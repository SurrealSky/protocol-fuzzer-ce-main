<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Peach.Core</name>
    </assembly>
    <members>
        <member name="T:Peach.Core.ActionException">
            <summary>
            Thrown when an error occurs in the action of a state model
            requiring the state model to exit.
            </summary>
            <remarks>
            This is not an error that will end fuzzing, instead we will exit
            the state model and continue to the next iteration.
            </remarks>
        </member>
        <member name="T:Peach.Core.Agent.AgentClient">
            <summary>
            Abstract base class for all Agent servers.
            </summary>
        </member>
        <member name="M:Peach.Core.Agent.AgentClient.#ctor(System.String,System.String,System.String)">
            <summary>
            Construct an agent client
            </summary>
            <param name="name">Name of agent</param>
            <param name="url">Agent URL</param>
            <param name="password">Agent Password</param>
        </member>
        <member name="P:Peach.Core.Agent.AgentClient.Name">
            <summary>
            Agent name
            </summary>
        </member>
        <member name="P:Peach.Core.Agent.AgentClient.Url">
            <summary>
            Agent URL
            </summary>
        </member>
        <member name="P:Peach.Core.Agent.AgentClient.Password">
            <summary>
            Agent password
            </summary>
        </member>
        <member name="M:Peach.Core.Agent.AgentClient.AgentConnect">
            <summary>
            Connect to agent
            </summary>
        </member>
        <member name="M:Peach.Core.Agent.AgentClient.AgentDisconnect">
            <summary>
            Disconnect from agent
            </summary>
        </member>
        <member name="M:Peach.Core.Agent.AgentClient.CreatePublisher(System.String,System.String,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Creates a publisher on the remote agent
            </summary>
            <param name="name">Name for publisher instance</param>
            <param name="cls">Class of publisher to create</param>
            <param name="args">Arguments for publisher</param>
            <returns>Instance of remote publisher</returns>
        </member>
        <member name="M:Peach.Core.Agent.AgentClient.StartMonitor(System.String,System.String,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Start a specific monitor
            </summary>
            <param name="name">Name for monitor instance</param>
            <param name="cls">Class of monitor to start</param>
            <param name="args">Arguments</param>
        </member>
        <member name="M:Peach.Core.Agent.AgentClient.StopAllMonitors">
            <summary>
            Stop all monitors currently running
            </summary>
        </member>
        <member name="M:Peach.Core.Agent.AgentClient.SessionStarting">
            <summary>
            Starting a fuzzing session.  A session includes a number of test iterations.
            </summary>
        </member>
        <member name="M:Peach.Core.Agent.AgentClient.SessionFinished">
            <summary>
            Finished a fuzzing session.
            </summary>
        </member>
        <member name="M:Peach.Core.Agent.AgentClient.IterationStarting(Peach.Core.Agent.IterationStartingArgs)">
            <summary>
            Starting a new iteration
            </summary>
            <param name="args">Metadata about the type of iteration</param>
        </member>
        <member name="M:Peach.Core.Agent.AgentClient.IterationFinished">
            <summary>
            Iteration has completed.
            </summary>
            <returns>Returns true to indicate iteration should be re-run, else false.</returns>
        </member>
        <member name="M:Peach.Core.Agent.AgentClient.DetectedFault">
            <summary>
            Was a fault detected during current iteration?
            </summary>
            <returns>True if a fault was detected, else false.</returns>
        </member>
        <member name="M:Peach.Core.Agent.AgentClient.GetMonitorData">
            <summary>
            Get the fault information
            </summary>
            <returns>Returns array of Fault instances</returns>
        </member>
        <member name="M:Peach.Core.Agent.AgentClient.Message(System.String)">
            <summary>
            Send a message to all monitors.
            </summary>
            <param name="msg">Message</param>
        </member>
        <member name="T:Peach.Core.Agent.AgentManager">
            <summary>
            Manages all agents.  This includes full lifetime.
            </summary>
        </member>
        <member name="T:Peach.Core.Agent.IAgentServer">
            <summary>
            Agent Servers are required to implement this interface
            </summary>
        </member>
        <member name="T:Peach.Core.Agent.AgentServerAttribute">
            <summary>
            Indicate class is an Agent Server.
            </summary>
        </member>
        <member name="T:Peach.Core.Agent.Channels.AgentLocal">
            <summary>
            This is an agent that runs in the local
            process, instead of a remote process.  This
            is much faster for things like file fuzzing.
            </summary>
        </member>
        <member name="T:Peach.Core.Agent.IterationStartingArgs">
            <summary>
            Information about the current iteration that is about to be run.
            </summary>
        </member>
        <member name="P:Peach.Core.Agent.IterationStartingArgs.IsReproduction">
            <summary>
            Is the current iteration a reproduction of a previously executed iteration.
            </summary>
        </member>
        <member name="P:Peach.Core.Agent.IterationStartingArgs.LastWasFault">
            <summary>
            Did a fault occur on the previous fuzzing iteration.
            </summary>
        </member>
        <member name="P:Peach.Core.Agent.Monitor.Agent">
            <summary>
            The agent that is running this monitor.
            </summary>
        </member>
        <member name="P:Peach.Core.Agent.Monitor.Name">
            <summary>
            The name of this monitor.
            </summary>
        </member>
        <member name="P:Peach.Core.Agent.Monitor.Class">
            <summary>
            The class of this monitor.
            </summary>
        </member>
        <member name="M:Peach.Core.Agent.Monitor.StopMonitor">
            <summary>
            Stop the monitor instance.
            </summary>
        </member>
        <member name="M:Peach.Core.Agent.Monitor.SessionStarting">
            <summary>
            Starting a fuzzing session.  A session includes a number of test iterations.
            </summary>
        </member>
        <member name="M:Peach.Core.Agent.Monitor.SessionFinished">
            <summary>
            Finished a fuzzing session.
            </summary>
        </member>
        <member name="M:Peach.Core.Agent.Monitor.IterationStarting(System.UInt32,System.Boolean)">
            <summary>
            Starting a new iteration
            </summary>
            <param name="iterationCount">Iteration count</param>
            <param name="isReproduction">Are we re-running an iteration</param>
        </member>
        <member name="M:Peach.Core.Agent.Monitor.IterationFinished">
            <summary>
            Iteration has completed.
            </summary>
            <returns>Returns true to indicate iteration should be re-run, else false.</returns>
        </member>
        <member name="M:Peach.Core.Agent.Monitor.DetectedFault">
            <summary>
            Was a fault detected during current iteration?
            </summary>
            <returns>True if a fault was detected, else false.</returns>
        </member>
        <member name="M:Peach.Core.Agent.Monitor.GetMonitorData">
            <summary>
            Return a Fault instance
            </summary>
            <returns></returns>
        </member>
        <member name="M:Peach.Core.Agent.Monitor.MustStop">
            <summary>
            Can the fuzzing session continue, or must we stop?
            </summary>
            <returns>True if session must stop, else false.</returns>
        </member>
        <member name="M:Peach.Core.Agent.Monitor.Message(System.String,Peach.Core.Variant)">
            <summary>
            Send a message to the monitor and possibly get data back.
            </summary>
            <param name="name">Message name</param>
            <param name="data">Message data</param>
            <returns>Returns data or null.</returns>
        </member>
        <member name="M:Peach.Core.Agent.Monitor.ProcessQueryMonitors(System.String)">
            <summary>
            Process query from another monitor.
            </summary>
            <remarks>
            This method is used to respond to an information request
            from another monitor.  Debugger monitors may expose specific
            queryies such as "QueryPid" to get the running processes PID.
            </remarks>
            <param name="query">Query</param>
            <returns>Non-null response indicates query was handled.</returns>
        </member>
        <member name="T:Peach.Core.Agent.Monitor2">
            <summary>
            Monitors are hosted by agent processes and are
            able to report detected faults and gather information
            that is usefull when a fualt is detected.
            </summary>
        </member>
        <member name="P:Peach.Core.Agent.Monitor2.Name">
            <summary>
            The name of this monitor.
            </summary>
        </member>
        <member name="P:Peach.Core.Agent.Monitor2.Class">
            <summary>
            The class of this monitor.
            </summary>
        </member>
        <member name="M:Peach.Core.Agent.Monitor2.StartMonitor(System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Start the monitor instance.
            If an exception is thrown, StopMonitor will not be called.
            </summary>
        </member>
        <member name="M:Peach.Core.Agent.Monitor2.StopMonitor">
            <summary>
            Stop the monitor instance.
            </summary>
        </member>
        <member name="M:Peach.Core.Agent.Monitor2.SessionStarting">
            <summary>
            Starting a fuzzing session.  A session includes a number of test iterations.
            </summary>
        </member>
        <member name="M:Peach.Core.Agent.Monitor2.SessionFinished">
            <summary>
            Finished a fuzzing session.
            </summary>
        </member>
        <member name="M:Peach.Core.Agent.Monitor2.IterationStarting(Peach.Core.Agent.IterationStartingArgs)">
            <summary>
            Starting a new iteration
            </summary>
            <param name="args">Information about the current iteration</param>
        </member>
        <member name="M:Peach.Core.Agent.Monitor2.IterationFinished">
            <summary>
            Iteration has completed.
            </summary>
        </member>
        <member name="M:Peach.Core.Agent.Monitor2.DetectedFault">
            <summary>
            Was a fault detected during current iteration?
            </summary>
            <returns>True if a fault was detected, else false.</returns>
        </member>
        <member name="M:Peach.Core.Agent.Monitor2.GetMonitorData">
            <summary>
            Return data from the monitor.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Peach.Core.Agent.Monitor2.Message(System.String)">
            <summary>
            Send a message to the monitor and possibly get data back.
            </summary>
            <param name="msg">Message name</param>
        </member>
        <member name="E:Peach.Core.Agent.Monitor2.InternalEvent">
            <summary>
            An event handler that can be used by monitor implementations
            to alert others about interesting events occuring.
            The peach core does not make use of this event.
            </summary>
            <remarks>
            This event handler is completly ignroed by the peach core.
            It can be useful for writing tests against monitors so the
            testing framework can get notified when interesting things happen.
            </remarks>
        </member>
        <member name="M:Peach.Core.Agent.Monitor2.OnInternalEvent(System.EventArgs)">
            <summary>
            Raises the InternalEvent event.
            </summary>
            <param name="args">Arbitrary arguments to pass to event subscribers.</param>
        </member>
        <member name="M:Peach.Core.Agent.Monitor2.Hash(System.String)">
            <summary>
            Compute the hash of a value for use as either
            the MajorHash or MinorHash of a MonitorData.Info object.
            </summary>
            <param name="value">String value to hash</param>
            <returns>The first 4 bytes of the md5 has as a hex string</returns>
        </member>
        <member name="T:Peach.Core.Agent.MonitorData">
            <summary>
            The information recorded by a monitor.
            This can be a fault or just an arbitrary collection of data.
            </summary>
        </member>
        <member name="T:Peach.Core.Agent.MonitorData.Info">
            <summary>
            The information about a fault detected by a monitor.
            </summary>
        </member>
        <member name="P:Peach.Core.Agent.MonitorData.Info.Description">
            <summary>
            A multi line description of the fault.
            </summary>
            <remarks>
            Saved as "AgentName.MonitorName.DetectionSource.Description.txt"
            </remarks>
        </member>
        <member name="P:Peach.Core.Agent.MonitorData.Info.MajorHash">
            <summary>
            The major hash bucket for this fault.
            </summary>
        </member>
        <member name="P:Peach.Core.Agent.MonitorData.Info.MinorHash">
            <summary>
            The minor hash bucket for this fault.
            </summary>
        </member>
        <member name="P:Peach.Core.Agent.MonitorData.Info.Risk">
            <summary>
            The risk assesment this fault.
            </summary>
        </member>
        <member name="P:Peach.Core.Agent.MonitorData.Info.MustStop">
            <summary>
            Does the engine need to stop all fuzzing in response to this fault.
            </summary>
        </member>
        <member name="P:Peach.Core.Agent.MonitorData.AgentName">
            <summary>
            The name of the agent that hosts the monitor
            that produced this data.
            </summary>
            <remarks>
            This field is automatically set by the agent client.
            </remarks>
        </member>
        <member name="P:Peach.Core.Agent.MonitorData.MonitorName">
            <summary>
            The name of the monitor that produced this data.
            </summary>
            <remarks>
            This field is automatically set by the agent server.
            </remarks>
        </member>
        <member name="P:Peach.Core.Agent.MonitorData.DetectionSource">
            <summary>
            The type of monitor that produced this data.
            </summary>
            <remarks>
            This field does not need to be set by the monitor.
            The agent server will set the detection source
            to the monitor's class name automatically.
            If a single monitor class has multiple internal
            detection sources, this field can be used to
            distinguish between them.
            </remarks>
        </member>
        <member name="P:Peach.Core.Agent.MonitorData.Title">
            <summary>
            A short title of the finding.
            </summary>
            <remarks>
            Saved as "AgentName.MonitorName.DetectionSource.txt"
            </remarks>
        </member>
        <member name="P:Peach.Core.Agent.MonitorData.Fault">
            <summary>
            If the monitor data is a fault, this field should
            be set with the appropriate information.
            </summary>
        </member>
        <member name="P:Peach.Core.Agent.MonitorData.Data">
            <summary>
            A collection of arbitrary data recorded by the monitor.
            </summary>
            <remarks>
            Extra data to keep with teh fault.
            For each Key,Value pair, Value will be saved as
            "AgentName.MonitorName.DetectionSource.Key"
            Ownership of the stream is the responsibility of the monitor.
            The stream needs to be returned from GetMonitorData and
            remain open until the next call to IterationStarting or
            a call to SessionFinished.
            </remarks>
        </member>
        <member name="T:Peach.Core.Analysis.Coverage">
            <summary>
            Abstract base class for performing code coverage via basic blocks
            for native binaries.  Each architecture implements this class.
            </summary>
            <remarks>
            So far only Windows has an implementation.
            </remarks>
        </member>
        <member name="M:Peach.Core.Analysis.Coverage.Run(System.String,System.String)">
            <summary>
            Runs code coverage of sample file and saves results in a trace file.
            Throws a PeachException on failure.
            </summary>
            <param name="sampleFile">Name of sample file to use for instrumentation.</param>
            <param name="traceFile">Name of result trace file to generate.</param>
        </member>
        <member name="T:Peach.Core.Analysis.Minset">
            <summary>
            Perform analysis on sample sets to identify the smallest sample set
            that provides the largest code coverage.
            </summary>
        </member>
        <member name="M:Peach.Core.Analysis.Minset.RunCoverage(System.String[],System.String[])">
            <summary>
            Perform coverage analysis of trace files.
            </summary>
            <remarks>
            Note: The sample and trace collections must have matching indexes.
            </remarks>
            <param name="sampleFiles">Collection of sample files</param>
            <param name="traceFiles">Collection of trace files for sample files</param>
            <returns>Returns the minimum set of smaple files.</returns>
        </member>
        <member name="M:Peach.Core.Analysis.Minset.RunTraces(System.String,System.String,System.String,System.String[],System.Boolean)">
            <summary>
            Collect traces for a collection of sample files.
            </summary>
            <remarks>
            This method will use the TraceStarting and TraceCompleted events
            to report progress.
            </remarks>
            <param name="executable">Executable to run.</param>
            <param name="arguments">Executable arguments.  Must contain a "%s" placeholder for the sampe filename.</param>
            <param name="tracesFolder">Where to write trace files</param>
            <param name="sampleFiles">Collection of sample files</param>
            <param name="needsKilling">Does this command requiring forcefull killing to exit?</param>
            <returns>Returns a collection of trace files</returns>
        </member>
        <member name="M:Peach.Core.Analyzer.asParser(System.Collections.Generic.Dictionary{System.String,System.Object},System.String)">
            <summary>
            Replaces the parser for fuzzer definition.
            </summary>
            <param name="args">Command line arguments</param>
            <param name="fileName">File to parse</param>
        </member>
        <member name="M:Peach.Core.Analyzer.asParser(System.Collections.Generic.Dictionary{System.String,System.Object},System.IO.Stream)">
            <summary>
            
            </summary>
            <param name="args"></param>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:Peach.Core.Analyzer.asParserValidation(System.Collections.Generic.Dictionary{System.String,System.Object},System.String)">
            <summary>
            Called to perform validation pass.
            </summary>
            <param name="args">Arguments</param>
            <param name="fileName">Filename to test</param>
            <returns>Throws PeachException on error.</returns>
        </member>
        <member name="T:Peach.Core.AnalyzerAttribute">
            <summary>
            Used to indicate a class is a valid Publisher and 
            provide it's invoking name used in the Pit XML file.
            </summary>
        </member>
        <member name="T:Peach.Core.Analyzers.PitParser">
            <summary>
            This is the default analyzer for Peach.  It will
            parse a Peach PIT file (XML document) into a Peach DOM.
            </summary>
        </member>
        <member name="F:Peach.Core.Analyzers.PitParser.DEFINED_VALUES">
            <summary>
            args key for passing a dictionary of defined values to replace.
            </summary>
        </member>
        <member name="F:Peach.Core.Analyzers.PitParser.dataElementDefaults">
            <summary>
            Contains default attributes for DataElements
            </summary>
        </member>
        <member name="F:Peach.Core.Analyzers.PitParser.dataElementPitParsable">
            <summary>
            Mapping of XML ELement names to type as provided by PitParsableAttribute
            </summary>
        </member>
        <member name="M:Peach.Core.Analyzers.PitParser.validatePit(System.String,System.String)">
            <summary>
            Validate PIT XML using Schema file.
            </summary>
            <param name="xmlData">Pit file to validate</param>
            <param name="sourceName">Name of pit file</param>
        </member>
        <member name="M:Peach.Core.Analyzers.PitParser.handlePeach(Peach.Core.Dom.Dom,System.Xml.XmlNode,System.Collections.Generic.Dictionary{System.String,System.Object})">
            <summary>
            Handle parsing the top level Peach node.
            </summary>
            <remarks>
            NOTE: This method is intended to be overriden (hence the virtual) and is 
            		currently in use by Godel to extend the Pit Parser.
            </remarks>
            <param name="dom">Dom object</param>
            <param name="node">XmlNode to parse</param>
            <param name="args">Parser arguments</param>
            <returns>Returns the parsed Dom object.</returns>
        </member>
        <member name="M:Peach.Core.Analyzers.PitParser.handleCommonDataElementAttributes(System.Xml.XmlNode,Peach.Core.Dom.DataElement)">
            <summary>
            Handle common attributes such as the following:
            
             * mutable
             * contraint
             * pointer
             * pointerDepth
             * token
             
            </summary>
            <param name="node">XmlNode to read attributes from</param>
            <param name="element">Element to set attributes on</param>
        </member>
        <member name="M:Peach.Core.Analyzers.PitParser.handleCommonDataElementChildren(System.Xml.XmlNode,Peach.Core.Dom.DataElement)">
            <summary>
            Handle parsing common dataelement children liek relation, fixupImpl and
            transformer.
            </summary>
            <param name="node">Node to read values from</param>
            <param name="element">Element to set values on</param>
        </member>
        <member name="M:Peach.Core.Analyzers.PitParser.handleDataElementContainer(System.Xml.XmlNode,Peach.Core.Dom.DataElementContainer)">
            <summary>
            Handle parsing child data types into containers.
            </summary>
            <param name="node">XmlNode tor read children elements from</param>
            <param name="element">Element to add items to</param>
        </member>
        <member name="M:Peach.Core.Analyzers.PitParser.handleCommonDataElementValue(System.Xml.XmlNode,Peach.Core.Dom.DataElement,Peach.Core.Dom.Dom)">
            <summary>
            Handle parsing value/valueType attributes on elements
            transformer.
            </summary>
            <param name="node">Node to read values from</param>
            <param name="element">Element to set values on</param>
            <param name="context">If element is detached (no parent) provide context Dom instance</param>
        </member>
        <member name="T:Peach.Core.ClassLoader">
            <summary>
            Methods for finding and creating instances of 
            classes.
            </summary>
        </member>
        <member name="M:Peach.Core.ClassLoader.GetDefaultAttr``1(System.Type)">
            <summary>
            Extension to the Type class. Return default plugin attribute
            matching the specified type or null if not found
            </summary>
            <typeparam name="TAttr">Attribute type to find.</typeparam>
            <param name="type">Type in which the search should run over.</param>
            <returns>A generator which yields the attributes specified.</returns>
        </member>
        <member name="M:Peach.Core.ClassLoader.GetAttributes``1(System.Type)">
            <summary>
            Extension to the Type class. Return all attributes matching the specified type.
            </summary>
            <typeparam name="TAttr">Attribute type to find.</typeparam>
            <param name="type">Type in which the search should run over.</param>
            <returns>A generator which yields the attributes specified.</returns>
        </member>
        <member name="M:Peach.Core.ClassLoader.GetAttributes``1(System.Type,System.Func{System.Type,``0,System.Boolean})">
            <summary>
            Extension to the Type class. Return all attributes matching the specified type and predicate.
            </summary>
            <typeparam name="TAttr">Attribute type to find.</typeparam>
            <param name="type">Type in which the search should run over.</param>
            <param name="predicate">Returns an attribute if the predicate returns true or the predicate itself is null.</param>
            <returns>A generator which yields the attributes specified.</returns>
        </member>
        <member name="M:Peach.Core.ClassLoader.GetAllByAttribute``1">
            <summary>
            Finds all types that are decorated with the specified Attribute type.
            </summary>
            <typeparam name="TAttr">Attribute type to find.</typeparam>
            <returns>A generator which yields KeyValuePair elements of custom attribute and type found.</returns>
        </member>
        <member name="M:Peach.Core.ClassLoader.GetAllByAttribute``1(System.Func{System.Type,``0,System.Boolean})">
            <summary>
            Finds all types that are decorated with the specified Attribute type and matches the specified predicate.
            </summary>
            <typeparam name="A">Attribute type to find.</typeparam>
            <param name="predicate">Returns a value if the predicate returns true or the predicate itself is null.</param>
            <returns>A generator which yields KeyValuePair elements of custom attribute and type found.</returns>
        </member>
        <member name="M:Peach.Core.ClassLoader.GetAllTypesByAttribute``1(System.Func{System.Type,``0,System.Boolean})">
            <summary>
            Finds all types that are decorated with the specified Attribute type and matches the specified predicate.
            </summary>
            <typeparam name="A">Attribute type to find.</typeparam>
            <param name="predicate">Returns a value if the predicate returns true or the predicate itself is null.</param>
            <returns>A generator which yields elements of the type found.</returns>
        </member>
        <member name="M:Peach.Core.ClassLoader.FindByAttribute``1(System.Func{System.Type,``0,System.Boolean})">
            <summary>
            Finds the first type that matches the specified query.
            </summary>
            <typeparam name="A">Attribute type to find.</typeparam>
            <param name="predicate">Returns a value if the predicate returns true or the predicate itself is null.</param>
            <returns>KeyValuePair of custom attribute and type found.</returns>
        </member>
        <member name="M:Peach.Core.ClassLoader.FindTypeByAttribute``1(System.Func{System.Type,``0,System.Boolean})">
            <summary>
            Finds the first type that matches the specified query.
            </summary>
            <typeparam name="A">Attribute type to find.</typeparam>
            <param name="predicate">Returns a value if the predicate returns true or the predicate itself is null.</param>
            <returns>Returns only the Type found.</returns>
        </member>
        <member name="M:Peach.Core.ClassLoader.FindPluginByName``1(System.String)">
            <summary>
            Finds the first type that matches the specified query.
            </summary>
            <typeparam name="TAttr">PluginAttribute type to find.</typeparam>
            <param name="name">The name of the plugin to search for.</param>
            <returns>Returns the Type found or null if not found.</returns>
        </member>
        <member name="M:Peach.Core.ParameterAttribute.#ctor(System.String,System.Type,System.String)">
            <summary>
            Constructs a REQUIRED parameter.
            </summary>
            <param name="name"></param>
            <param name="type"></param>
            <param name="description"></param>
        </member>
        <member name="M:Peach.Core.ParameterAttribute.#ctor(System.String,System.Type,System.String,System.String)">
            <summary>
            Constructs an OPTIONAL parameter.
            </summary>
            <param name="name"></param>
            <param name="type"></param>
            <param name="description"></param>
            <param name="defaultValue"></param>
        </member>
        <member name="P:Peach.Core.PluginAttribute.Internal">
            <summary>
            The scope of the plugin.
            Internal plugins are omitted from schema generation.
            </summary>
        </member>
        <member name="P:Peach.Core.PluginAttribute.Name">
            <summary>
            The name of the plugin.
            </summary>
        </member>
        <member name="P:Peach.Core.PluginAttribute.Type">
            <summary>
            The type of the plugin.
            </summary>
        </member>
        <member name="P:Peach.Core.PluginAttribute.IsDefault">
            <summary>
            Is this the default name for the plugin.
            For plugins with multiple names, the default name will be used in the schema.
            </summary>
        </member>
        <member name="P:Peach.Core.PluginAttribute.Scope">
            <summary>
            The scope of the plugin.
            Internal plugins are omitted from schema generation.
            Beta plugins are decorated as such in command line output.
            </summary>
        </member>
        <member name="P:Peach.Core.PluginAttribute.OS">
            <summary>
            The operating systems that support this plugin.
            </summary>
        </member>
        <member name="T:Peach.Core.Cracker.Position">
            <summary>
            Class for tracking the positions of elements.
            </summary>
        </member>
        <member name="T:Peach.Core.Cracker.DataCracker">
            <summary>
            Crack data into a DataModel.
            </summary>
        </member>
        <member name="T:Peach.Core.Cracker.DataCracker.SizedPosition">
            <summary>
            Helper class for tracking positions of cracked elements using
            optionally available sizing information.
            </summary>
        </member>
        <member name="F:Peach.Core.Cracker.DataCracker._sizedElements">
            <summary>
            Collection of all elements that have been cracked so far.
            </summary>
        </member>
        <member name="F:Peach.Core.Cracker.DataCracker._dataStack">
            <summary>
            Stack of all BitStream objects passed to CrackData().
            This is used for determining absolute locations from relative offsets.
            </summary>
        </member>
        <member name="F:Peach.Core.Cracker.DataCracker._elementsWithAnalyzer">
            <summary>
            Elements that have analyzers attached.  We run them all post-crack.
            </summary>
        </member>
        <member name="F:Peach.Core.Cracker.DataCracker._deferredPlacement">
            <summary>
            Placements to run after current cracking phase cracking complete
            </summary>
        </member>
        <member name="F:Peach.Core.Cracker.DataCracker._absolutePlacement">
            <summary>
            Absolute placements based on offset relations
            </summary>
        </member>
        <member name="F:Peach.Core.Cracker.DataCracker._root">
            <summary>
            The element we are cracking from
            </summary>
        </member>
        <member name="F:Peach.Core.Cracker.DataCracker._logPrefix">
            <summary>
            The string to prefix log messages with.
            </summary>
        </member>
        <member name="F:Peach.Core.Cracker.DataCracker._lastError">
            <summary>
            The last error we logged
            </summary>
        </member>
        <member name="M:Peach.Core.Cracker.DataCracker.#ctor">
            <summary>
            Constructs a DataCracker
            </summary>
        </member>
        <member name="M:Peach.Core.Cracker.DataCracker.Clone">
            <summary>
            Returns a new DataCracker with the log prefix maintained.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Peach.Core.Cracker.DataCracker.CrackData(Peach.Core.Dom.DataElement,Peach.Core.IO.BitStream)">
            <summary>
            Main entry method that will take a data stream and parse it into a data model.
            </summary>
            <remarks>
            Method will throw one of two exceptions on an error: CrackingFailure, or NotEnoughDataException.
            </remarks>
            <param name="element">DataElement to import data into</param>
            <param name="data">Data stream to read data from</param>
        </member>
        <member name="M:Peach.Core.Cracker.DataCracker.GetElementSize(Peach.Core.Dom.DataElement)">
            <summary>
            Get the size of an element that has already been cracked.
            The size only has a value if the element has a length attribute
            or the element has a size relation that has successfully resolved.
            </summary>
            <param name="elem">Element to query</param>
            <returns>size of the element</returns>
        </member>
        <member name="M:Peach.Core.Cracker.DataCracker.HasCracked(Peach.Core.Dom.Relation)">
            <summary>
            Determines if the From half of a relation has been cracked.
            </summary>
            <param name="rel">The Relation to test.</param>
            <returns>True if the From half has been cracked, false otherwise.</returns>
        </member>
        <member name="M:Peach.Core.Cracker.DataCracker.OptimizeDataModel(Peach.Core.Dom.DataModel)">
            <summary>
            Perform optimizations of data model for cracking
            </summary>
            <remarks>
            Optimization can be performed once on a data model and used
            for any clones made.  Optimizations will increase the speed
            of data cracking.
            </remarks>
            <param name="model">DataModel to optimize</param>
        </member>
        <member name="M:Peach.Core.Cracker.DataCracker.Log(System.String,System.Object[])">
            <summary>
            Elements can use this to log messages whe nthey are being cracked.
            </summary>
            <param name="msg"></param>
            <param name="fmt"></param>
        </member>
        <member name="P:Peach.Core.Cracker.DataCracker.IsLogEnabled">
            <summary>
            Returns true if the logger is enabled.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Peach.Core.Cracker.DataCracker.handleNode(Peach.Core.Dom.DataElement,Peach.Core.IO.BitStream)">
            <summary>
            Called to crack a DataElement based on an input stream.  This method
            will hand cracking off to a more specific method after performing
            some common tasks.
            </summary>
            <param name="elem">DataElement to crack</param>
            <param name="data">Input stream to use for data</param>
        </member>
        <member name="M:Peach.Core.Cracker.DataCracker.findToken(Peach.Core.IO.BitStream,Peach.Core.IO.BitwiseStream,System.Int64,System.Boolean)">
            <summary>
            Searches data for the first occurance of token starting at offset.
            </summary>
            <param name="data">BitStream to search in.</param>
            <param name="token">BitStream to search for.</param>
            <param name="offset">How many bits after the current position of data to start searching.</param>
            <param name="optional">Is the token optional.</param>
            <returns>The location of the token in data from the current position or null.</returns>
        </member>
        <member name="M:Peach.Core.Cracker.DataCracker.scan(Peach.Core.Dom.DataElement,System.Int64@,System.Collections.Generic.List{Peach.Core.Cracker.DataCracker.Mark},Peach.Core.Cracker.DataCracker.Mark,Peach.Core.Cracker.DataCracker.Until)">
            <summary>
            Scan elem and all children looking for a target element.
            The target can either be the first sized element or the first unsized element.
            If an unsized element is found, keep track of the determinism of the element.
            An element is determinstic if its size is unknown, but can be determined by calling
            crack(). Examples are a container with sized children or a null terminated string.
            </summary>
            <param name="elem">Element to start scanning at.</param>
            <param name="pos">The position of the scanner when 'until' occurs.</param>
            <param name="tokens">List of tokens found when scanning.</param>
            <param name="end">If non-null and an element with an offset relation is detected,
            record the element's absolute position and stop scanning.</param>
            <param name="until">When to stop scanning.
            Either first sized element or first unsized element.</param>
            <returns>Null if an unsized element was found.
            False if a deterministic element was found.
            True if all elements are sized.</returns>
        </member>
        <member name="T:Peach.Core.Cracker.DataCracker.ElementSize">
            <summary>
            Helper class for representing the size of an element.
            </summary>
        </member>
        <member name="P:Peach.Core.Cracker.DataCracker.ElementSize.Unknown">
            <summary>
            Is the size unknown.
            </summary>
        </member>
        <member name="P:Peach.Core.Cracker.DataCracker.ElementSize.Size">
            <summary>
            If the size is known, the size of the element in bits.
            </summary>
        </member>
        <member name="P:Peach.Core.Cracker.DataCracker.ElementSize.Reason">
            <summary>
            Why the element was determined to be of this size.
            Stored as a delegate so any styring formatting will
            not happen unless logging is enabled.
            </summary>
        </member>
        <member name="M:Peach.Core.Cracker.DataCracker.ElementSize.ToString">
            <summary>
            Format size for logging.
            </summary>
            <returns>String representation of size.</returns>
        </member>
        <member name="M:Peach.Core.Cracker.DataCracker.GetSize(Peach.Core.Dom.DataElement,Peach.Core.IO.BitStream)">
            <summary>
            Get the size of the data element.
            </summary>
            <param name="elem">Element to size</param>
            <param name="data">Bits to crack</param>
            <returns>Null if size is unknown or the size in bits.</returns>
        </member>
        <member name="M:Peach.Core.Cracker.DataCracker.lookahead(Peach.Core.Dom.DataElement,System.Int64@,System.Collections.Generic.List{Peach.Core.Cracker.DataCracker.Mark},Peach.Core.Cracker.DataCracker.Mark)">
            <summary>
            Scan all elements after elem looking for the first unsized element.
            If an unsized element is found, keep track of the determinism of the element.
            An element is determinstic if its size is unknown, but can be determined by calling
            crack(). Examples are a container with sized children or a null terminated string.
            </summary>
            <param name="elem">Start scanning at this element's next sibling.</param>
            <param name="pos">The position of the scanner when 'until' occurs.</param>
            <param name="tokens">List of tokens found when scanning.</param>
            <param name="end">If non-null and an element with an offset relation is detected,
            record the element's absolute position and stop scanning.
            Either first sized element or first unsized element.</param>
            <returns>Null if an unsized element was found.
            False if a deterministic element was found.
            True if all elements are sized.</returns>
        </member>
        <member name="T:Peach.Core.Dom.ActionAttribute">
            <summary>
            Used to indicate a class is a valid Action and 
            provide it's invoking name used in the Pit XML file.
            </summary>
        </member>
        <member name="T:Peach.Core.Dom.IActionDataXpath">
            <summary>
            Used by the xpath navigator to get all action data children.
            </summary>
        </member>
        <member name="T:Peach.Core.Dom.Action">
            <summary>
            Base class for state model actions such as sending output, calling a method, etc.
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.Action.schemaModel">
            <summary>
            Currently unused.  Exists for schema generation.
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.Action.schemaData">
            <summary>
            Currently unused.  Exists for schema generation.
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.Action.schemaGodel">
            <summary>
            Currently unused.  Exists for schema generation.
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.Action.started">
            <summary>
            Action was started
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.Action.finished">
            <summary>
            Action finished
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.Action.error">
            <summary>
            Action errored
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.Action.Name">
            <summary>
            Name of this action
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.Action.FieldId">
            <summary>
            The field id of this action.
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.Action.publisher">
            <summary>
            Name of publisher to use
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.Action.when">
            <summary>
            Only run action when expression is true
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.Action.onStart">
            <summary>
            Expression to run when action is starting
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.Action.onComplete">
            <summary>
            Expression to run when action is completed
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.Action.type">
            <summary>
            The type of this action
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.Action.parent">
            <summary>
            The state this action belongs to
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.Action.dataModel">
            <summary>
            Provides backwards compatibility to the unit tests.
            Will be removed in the future.
            </summary>
        </member>
        <member name="M:Peach.Core.Dom.Action.UpdateToOriginalDataModel">
            <summary>
            Update any DataModels we contain to new clones of
            origionalDataModel.
            </summary>
            <remarks>
            This should be performed in StateModel to every State/Action at
            start of the iteration.
            </remarks>
        </member>
        <member name="M:Peach.Core.Dom.Action.OnRun(Peach.Core.Publisher,Peach.Core.RunContext)">
            <summary>
            Run the action on the publisher
            </summary>
            <param name="publisher"></param>
            <param name="context"></param>
        </member>
        <member name="P:Peach.Core.Dom.Action.XpathData">
            <summary>
            All Data (DataModels &amp; DataSets) used by this action
            that should be nagivable via xpath
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.Action.allData">
            <summary>
            All Data (DataModels &amp; DataSets) used by this action.
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.Action.inputData">
            <summary>
            Raw data used for input (cracking) by this action.
            This can include data where cracking failed.
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.Action.outputData">
            <summary>
            All Data (DataModels &amp; DataSets) used for output (fuzzing) by this action.
            </summary>
        </member>
        <member name="M:Peach.Core.Dom.Action.WritePitBody(System.Xml.XmlWriter)">
            <summary>
            Base classes implement to add attributes and inner elements
            </summary>
            <param name="pit"></param>
        </member>
        <member name="P:Peach.Core.Dom.ActionData.schemaModel">
            <summary>
            Currently unused.  Exists for schema generation.
            </summary>
        </member>
        <member name="M:Peach.Core.Dom.ActionData.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.ActionData.action">
            <summary>
            The action that this belongs to
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.ActionData.dataModel">
            <summary>
            The data model we use for input/output when running the state model.
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.ActionData.dataSets">
            <summary>
            All of the data sets that correspond to the data model
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.ActionData.allData">
            <summary>
            Enumerable view of all Data that corresponds to the data model
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.ActionData.selectedData">
            <summary>
            The currently selected Data in use by the model
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.ActionData.sourceDataModel">
            <summary>
            A clean copy of the data model that has never had fields/data applied.
            Only set when using dataSets since applying data requires
            the clean model.
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.ActionData.originalDataModel">
            <summary>
            A cached copy of the clean data model.  Has fields/data applied
            when applicable.
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.ActionData.IsInput">
            <summary>
            Is this action data part of an input/getProperty/call-result action
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.ActionData.IsOutput">
            <summary>
            Is this action data part of an output/setProperty/call-param action
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.ActionData.Name">
            <summary>
            The name of this record.
            </summary>
            <remarks>
            Non-null when actions have multiple data models
            (Action.Call) and null otherwise (Input/Output/SetProperty/GetProperty).
            </remarks>
        </member>
        <member name="P:Peach.Core.Dom.ActionData.inputName">
            <summary>
            Full name of this record when viewed as input data
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.ActionData.outputName">
            <summary>
            Full name of this record when viewed as output data
            </summary>
        </member>
        <member name="M:Peach.Core.Dom.ActionData.UpdateToOriginalDataModel">
            <summary>
            Initialize dataModel to its original state.
            If this is the first time through and a dataSet exists,
            the data will be applied to the model.
            </summary>
        </member>
        <member name="M:Peach.Core.Dom.ActionData.Apply(Peach.Core.Dom.Data)">
            <summary>
            Apply data from the dataSet to the data model.
            </summary>
            <param name="option"></param>
        </member>
        <member name="M:Peach.Core.Dom.ActionData.Crack(Peach.Core.IO.BitStream)">
            <summary>
            Crack the BitStream into the data model.
            Will automatically update to the original model
            prior to cracking.  Used by InOut action parameters.
            </summary>
            <param name="bs"></param>
        </member>
        <member name="P:Peach.Core.Dom.ActionData.instanceName">
            <summary>
            The unique instance name for this action data.
            Includes the run count to disambiguate multiple
            runs of the action via a re-enterant state.
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.ActionData.modelName">
            <summary>
            The name of this action data.  Does not include the
            run count so the name will be the same across multiple
            runs of the action via a re-enterant state.
            </summary>
        </member>
        <member name="T:Peach.Core.Dom.ActionParameter.Type">
            <summary>
            Type of parameter used when calling a method.
            'In' means output the data on call
            'Out' means input the data after the call
            'InOut' means the data is output on call and input afterwards
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.ActionParameter.type">
            <summary>
            The type of this parameter.
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.ActionParameter.Data">
            <summary>
            Currently unused.  Exists for schema generation.
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.ActionParameter.inputName">
            <summary>
            Full input name of this parameter.
            'Out' parameters are input
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.ActionParameter.outputName">
            <summary>
            Full output name of this parameter.
            'In' parameters are input
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.Actions.Call.method">
            <summary>
            Method to call
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.Actions.Call.parameters">
            <summary>
            Array of parameters for a method call
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.Actions.Call.result">
            <summary>
            Action result for a method call
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.Actions.ChangeState.reference">
            <summary>
            Name of state to change to, type=ChangeState
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.Actions.GetProperty.property">
            <summary>
            Property to operate on
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.Actions.GetProperty.data">
            <summary>
            Data model to populate with property value
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.Actions.SetProperty.property">
            <summary>
            Property to operate on
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.Actions.SetProperty.data">
            <summary>
            Data model containing value of property
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.Actions.Slurp.setXpath">
            <summary>
            xpath for selecting set targets during slurp.
            </summary>
            <remarks>
            Can return multiple elements.  All returned elements
            will be updated with a new value.
            </remarks>
        </member>
        <member name="P:Peach.Core.Dom.Actions.Slurp.valueXpath">
            <summary>
            xpath for selecting value during slurp
            </summary>
            <remarks>
            Must return a single element.
            </remarks>
        </member>
        <member name="T:Peach.Core.Dom.Agent">
            <summary>
            Configure a local or remote agent. Agents can perform various tasks during
            a fuzzing run. This element must include at least one Monitor child.
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.Agent.Name">
            <summary>
            Name of agent. May not contain spaces or periods (.).
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.Agent.location">
            <summary>
            Specify location of agent. Value is "&lt;channel%gt;://&lt;hostname&gt;" where
            &lt;channel%gt; specifies the remoting channel (tcp or local) and
            &lt;hostname%gt; specifies the hostname/ipaddress of the agent.
            If this attribute is not set a local agent will be used.
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.Agent.password">
            <summary>
            Password to the remote agent if needed.
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.Agent.platform">
            <summary>
            Limit Agent to specific platform.
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.Agent.monitors">
            <summary>
            List of monitors Agent should spin up.
            </summary>
        </member>
        <member name="T:Peach.Core.Dom.Array">
            <summary>
            Array of zero or more DataElements. When a user marks an element with the attributes of
            occurs, minOcccurs, or maxOccurs, this element is used.
            </summary>
            <remarks>
            Array elements can be in one of two states, pre and post expansion. Initially an Array
            will have a single element called the OrigionalElement. This is the pre-expansion state. Once
            data is loaded into the Array, the array will have zero or more copies of OrigionalElement, each
            with different data. This is the post-expansion state.
            </remarks>
        </member>
        <member name="F:Peach.Core.Dom.Array.minOccurs">
            <summary>
            Minimum number of elements this Array can contain
            </summary>
        </member>
        <member name="F:Peach.Core.Dom.Array.maxOccurs">
            <summary>
            Maximum number of elements this Array can contain
            </summary>
        </member>
        <member name="F:Peach.Core.Dom.Array.occurs">
            <summary>
            Number of occurrence this array should have
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.Array.OriginalElement">
            <summary>
            The original elements that was marked with the occurs, minOccurs, or maxOccurs
            attributes.
            </summary>
        </member>
        <member name="M:Peach.Core.Dom.Array.XPathChildren">
            <summary>
            Returns a list of children for use in XPath navigation.
            Should not be called directly.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Peach.Core.Dom.Array.ExpandTo(System.Int32)">
            <summary>
            Expands the size of the array to be 'count' long.
            Does this by adding the same instance of the first
            item in the array until the Count is count.
            </summary>
            <param name="count">The total size the array should be.</param>
        </member>
        <member name="P:Peach.Core.Dom.Binding.From">
            <summary>
            The DataElement that owns the binding.
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.Binding.FromName">
            <summary>
            The name of the DataElement that owns the binding.
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.Binding.OfName">
            <summary>
            The name of the DataElement on the remote side of the binding.
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.Binding.Of">
            <summary>
            The DataElement on the remote side of the binding.
            </summary>
        </member>
        <member name="T:Peach.Core.Dom.Blob">
            <summary>
            Binary large object data element
            </summary>
        </member>
        <member name="T:Peach.Core.Dom.Block">
            <summary>
            Block element
            </summary>
        </member>
        <member name="T:Peach.Core.Dom.Choice">
            <summary>
            Choice allows the selection of a single
            data element based on the current data set.
            
            The other options in the choice are available
            for mutation by the mutators.
            </summary>
        </member>
        <member name="T:Peach.Core.Dom.Choice.ChoiceCache">
            <summary>
            Container for cache entries.
            </summary>
        </member>
        <member name="F:Peach.Core.Dom.Choice.ChoiceCache.Offset">
            <summary>
            Offset to Token in bits
            </summary>
        </member>
        <member name="F:Peach.Core.Dom.Choice.ChoiceCache.Token">
            <summary>
            Token
            </summary>
        </member>
        <member name="F:Peach.Core.Dom.Choice._choiceCache">
            <summary>
            Cache of tokens for fast choice cracking
            </summary>
        </member>
        <member name="M:Peach.Core.Dom.Choice.BuildCache">
            <summary>
            Build cache of tokens to speed up choice cracking
            </summary>
        </member>
        <member name="M:Peach.Core.Dom.Choice.TokenCheck(Peach.Core.IO.BitStream,Peach.Core.Dom.Choice.ChoiceCache,System.Int64)">
            <summary>
            Check of cached token is in our data stream.
            </summary>
            <param name="data"></param>
            <param name="tok"></param>
            <param name="startPosition"></param>
            <returns></returns>
        </member>
        <member name="M:Peach.Core.Dom.Choice.XPathChildren">
            <summary>
            Returns a list of children for use in XPath navigation.
            Should not be called directly.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Peach.Core.Dom.CountRelation">
            <summary>
            Array count relation
            </summary>
        </member>
        <member name="T:Peach.Core.Dom.Data">
            <summary>
            Interface for Data
            </summary>
        </member>
        <member name="M:Peach.Core.Dom.Data.Apply(Peach.Core.Dom.Action,Peach.Core.Dom.DataModel)">
            <summary>
            Applies the Data to the specified data model
            </summary>
            <param name="action"></param>
            <param name="model"></param>
        </member>
        <member name="P:Peach.Core.Dom.Data.Ignore">
            <summary>
            Will this data set be ignored by the engine when
            looking for a new data set to switch to.
            </summary>
        </member>
        <member name="T:Peach.Core.Dom.DataFile">
            <summary>
            Data that comes from a file
            </summary>
        </member>
        <member name="T:Peach.Core.Dom.DataField">
            <summary>
            Data that comes from fields
            </summary>
        </member>
        <member name="T:Peach.Core.Dom.LengthType">
            <summary>
            Length types
            </summary>
            <remarks>
            The "length" property defaults to Bytes.  Not all
            implementations of DataElement will support all LengthTypes.
            </remarks>
        </member>
        <member name="F:Peach.Core.Dom.LengthType.Bytes">
            <summary>
            Indicates the length is specified in units of bytes.
            </summary>
        </member>
        <member name="F:Peach.Core.Dom.LengthType.Bits">
            <summary>
            Indicates the length is specified in units of bits.
            </summary>
        </member>
        <member name="F:Peach.Core.Dom.LengthType.Chars">
            <summary>
            Indicates the length is specified in units of characters.
            </summary>
        </member>
        <member name="F:Peach.Core.Dom.ValueType.String">
            <summary>
            Regular string. C style "\" escaping can be used such as: \\r, \\n, \\t, and \\\\\.
            </summary>
        </member>
        <member name="F:Peach.Core.Dom.ValueType.Hex">
            <summary>
            Hex string. Allows specifying binary data.
            </summary>
        </member>
        <member name="F:Peach.Core.Dom.ValueType.Literal">
            <summary>
            Treated as a python literal string.
            An example is "[1,2,3,4]" which would evaluate to a python list.
            </summary>
        </member>
        <member name="F:Peach.Core.Dom.ValueType.IPv4">
            <summary>
            An IPv4 string address that is converted to an array of bytes.
            An example is "127.0.0.1" which would evaluate to the bytes: 0x7f, 0x00, 0x00, 0x01.
            </summary>
        </member>
        <member name="F:Peach.Core.Dom.ValueType.IPv6">
            <summary>
            An IPv6 string address that is converted to an array of bytes.
            </summary>
        </member>
        <member name="F:Peach.Core.Dom.EndianType.Big">
            <summary>
            Big endian encoding.
            </summary>
        </member>
        <member name="F:Peach.Core.Dom.EndianType.Little">
            <summary>
            Little endian encoding.
            </summary>
        </member>
        <member name="F:Peach.Core.Dom.EndianType.Network">
            <summary>
            Big endian encoding.
            </summary>
        </member>
        <member name="T:Peach.Core.Dom.MutateOverride">
             <summary>
             Mutated value override's fixupImpl
            
              - Default Value
              - Relation
              - Fixup
              - Type contraints
              - Transformer
             </summary>
        </member>
        <member name="F:Peach.Core.Dom.MutateOverride.None">
            <summary>
            No overrides have occured
            </summary>
        </member>
        <member name="F:Peach.Core.Dom.MutateOverride.Fixup">
            <summary>
            Mutated value overrides fixups
            </summary>
        </member>
        <member name="F:Peach.Core.Dom.MutateOverride.Transformer">
            <summary>
            Mutated value overrides transformers
            </summary>
        </member>
        <member name="F:Peach.Core.Dom.MutateOverride.TypeConstraints">
            <summary>
            Mutated value overrides type constraints (e.g. string length, null terminated, etc.)
            </summary>
        </member>
        <member name="F:Peach.Core.Dom.MutateOverride.Relations">
            <summary>
            Mutated value overrides relations.
            </summary>
        </member>
        <member name="F:Peach.Core.Dom.MutateOverride.TypeTransform">
            <summary>
            Mutated value overrides type transforms.
            </summary>
        </member>
        <member name="F:Peach.Core.Dom.MutateOverride.Default">
            <summary>
            Default mutate value
            </summary>
        </member>
        <member name="T:Peach.Core.Dom.DataElement">
            <summary>
            Base class for all data elements.
            </summary>
        </member>
        <member name="M:Peach.Core.Dom.DataElement.Parse(System.String)">
            <summary>
            This exists so the ParameterParser can parse 'ref' parameters.
            </summary>
        </member>
        <member name="M:Peach.Core.Dom.DataElement.Clone">
            <summary>
            Creates a deep copy of the DataElement, and updates the appropriate Relations.
            </summary>
            <returns>Returns a copy of the DataElement.</returns>
        </member>
        <member name="M:Peach.Core.Dom.DataElement.ShallowClone(Peach.Core.Dom.DataElementContainer)">
            <summary>
            Creates a deep copy of the DataElement, and updates the appropriate Relations.
            </summary>
            <param name="newParent">The new parent of the cloned element</param>
            <returns>Returns a copy of the DataElement.</returns>
        </member>
        <member name="M:Peach.Core.Dom.DataElement.Clone(System.String)">
            <summary>
            Creates a deep copy of the DataElement, and updates the appropriate Relations.
            </summary>
            <param name="newName">What name to set on the cloned DataElement</param>
            <returns>Returns a copy of the DataElement.</returns>
        </member>
        <member name="M:Peach.Core.Dom.DataElement.ShallowClone(Peach.Core.Dom.DataElementContainer,System.String)">
            <summary>
            Creates a deep copy of the DataElement, and updates the appropriate Relations.
            </summary>
            <param name="newParent">The new parent of the cloned element</param>
            <param name="newName">What name to set on the cloned DataElement</param>
            <returns>Returns a copy of the DataElement.</returns>
        </member>
        <member name="M:Peach.Core.Dom.DataElement.TuningTraverse(System.Boolean,System.Boolean)">
            <summary>
            Performs pre-order traversal starting with this node.
            If forDisplay is true, returns only children we want to display to the user.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Peach.Core.Dom.DataElement.PreOrderTraverse(System.Func{Peach.Core.Dom.DataElement,System.Boolean})">
            <summary>
            Performs pre-order traversal starting with this node.
            </summary>
            <param name="filter">Only traverse elements that pass the predacate</param>
            <returns></returns>
        </member>
        <member name="M:Peach.Core.Dom.DataElement.PreOrderTraverse">
            <summary>
            Performs pre-order traversal starting with this node.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Peach.Core.Dom.DataElement.BreadthFirstTraverse">
            <summary>
            Performs breadth-first traversal starting with this node.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Peach.Core.Dom.DataElement.Walk">
            <summary>
            Walk the DOM by performing pre-order traversal starting
            at this node.  Then perform pre-order traversal of our
            parent ignoring the branch containing ourselves. Keep
            iterating up the tree until we reach the root.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Peach.Core.Dom.DataElement.DisplayChildren">
            <summary>
            Returns an enumeration of children that are diplayed to the user.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Peach.Core.Dom.DataElement.XPathChildren">
            <summary>
            Returns a list of children for use in XPath navigation.
            Should not be called directly.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Peach.Core.Dom.DataElement.InScope">
            <summary>
            Is this element in scope in the data model.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Peach.Core.Dom.DataElement.InScope(Peach.Core.Dom.DataElement)">
            <summary>
            Is a child in the selected element scope for a given parent.
            Default behavior is true: all cchildren are in scope.
            </summary>
            <param name="child"></param>
            <returns></returns>
        </member>
        <member name="M:Peach.Core.Dom.DataElement.find(System.String)">
            <summary>
            Find data element with specific name.
            </summary>
            <remarks>
            We will search starting at our level in the tree, then moving
            to children from our level, then walk up node by node to the
            root of the tree.
            </remarks>
            <param name="name">Name to search for</param>
            <returns>Returns found data element or null.</returns>
        </member>
        <member name="M:Peach.Core.Dom.DataElement.EnumerateElementsUpTree">
            <summary>
            Enumerate all items in tree starting with our current position
            then moving up towards the root.
            </summary>
            <remarks>
            This method uses yields to allow for efficient use even if the
            quired node is found quickely.
            
            The method in which we return elements should match a human
            search pattern of a tree.  We start with our current position and
            return all children then start walking up the tree towards the root.
            At each parent node we return all children (excluding already returned
            nodes).
            
            This method is ideal for locating objects in the tree in a way indented
            a human user.
            </remarks>
            <returns></returns>
        </member>
        <member name="M:Peach.Core.Dom.DataElement.EnumerateAllElements">
            <summary>
            Enumerate all child elements recursevely.
            </summary>
            <remarks>
            This method will return this objects direct children
            and finally recursevely return children's children.
            </remarks>
            <returns></returns>
        </member>
        <member name="F:Peach.Core.Dom.DataElement._hasLength">
            <summary>
            Does this element have a defined length?
            </summary>
        </member>
        <member name="F:Peach.Core.Dom.DataElement._length">
            <summary>
            Length in bits
            </summary>
        </member>
        <member name="F:Peach.Core.Dom.DataElement._lengthType">
            <summary>
            Determines how the length property works.
            </summary>
        </member>
        <member name="M:Peach.Core.Dom.DataElement.WritePitCommonChildren(System.Xml.XmlWriter,System.Boolean)">
            <summary>
            Write out common data element children such as relations
            </summary>
            <param name="pit"></param>
            <param name="excludeTypeTransformHint"></param>
        </member>
        <member name="M:Peach.Core.Dom.DataElement.WritePitCommonAttributes(System.Xml.XmlWriter)">
            <summary>
            Write out common data element attributes.
            </summary>
            <param name="pit"></param>
        </member>
        <member name="P:Peach.Core.Dom.DataElement.Properties">
            <summary>
            Dynamic properties
            </summary>
            <remarks>
            Any objects added to properties must be serializable!
            </remarks>
        </member>
        <member name="P:Peach.Core.Dom.DataElement.fullName">
            <summary>
            Fully qualified name of DataElement to
            root DataElement.
            </summary>
        </member>
        <member name="M:Peach.Core.Dom.DataElement.evaulateAnalyzers">
            <summary>
            Recursively execute analyzers
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.DataElement.constraint">
            <summary>
            Constraint on value of data element.
            </summary>
            <remarks>
            This
            constraint is only enforced when loading data into
            the object.  It will not affect values that are
            produced during fuzzing.
            </remarks>
        </member>
        <member name="P:Peach.Core.Dom.DataElement.isReference">
            <summary>
            Is this DataElement created by a 
            reference to another DataElement?
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.DataElement.referenceName">
            <summary>
            If created by reference, has the reference name
            </summary>
        </member>
        <member name="M:Peach.Core.Dom.DataElement.nextSibling">
            <summary>
            Find our next sibling.
            </summary>
            <returns>Returns sibling or null.</returns>
        </member>
        <member name="M:Peach.Core.Dom.DataElement.previousSibling">
            <summary>
            Find our previous sibling.
            </summary>
            <returns>Returns sibling or null.</returns>
        </member>
        <member name="M:Peach.Core.Dom.DataElement.Invalidate">
            <summary>
            Call to invalidate current element and cause rebuilding
            of data elements dependent on this element.
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.DataElement.hasLength">
            <summary>
            Does element have a length?  This is
            separate from Relations.
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.DataElement.isDeterministic">
            <summary>
            Is the length of the element deterministic.
            This is the case if the element hasLength or
            if the element has a specific end. For example,
            a null terminated string.
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.DataElement.length">
            <summary>
            Length of element in lengthType units.
            </summary>
            <remarks>
            In the case that LengthType == "Calc" we will evaluate the
            expression.
            </remarks>
        </member>
        <member name="P:Peach.Core.Dom.DataElement.lengthAsBits">
            <summary>
            Returns length as bits.
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.DataElement.lengthType">
            <summary>
            Type of length.
            </summary>
            <remarks>
            Not all DataElement implementations support "Chars".
            </remarks>
        </member>
        <member name="P:Peach.Core.Dom.DataElement.DefaultValue">
            <summary>
            Default value for this data element.
            
            Changing the default value will invalidate
            the model.
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.DataElement.MutatedValue">
            <summary>
            Current mutated value (if any) for this data element.
            
            Changing the MutatedValue will invalidate the model.
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.DataElement.InternalValue">
            <summary>
            Get the Internal Value of this data element
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.DataElement.PreTransformedValue">
            <summary>
            Returns the final value without any transformers being applied
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.DataElement.Value">
            <summary>
            Get the final Value of this data element
            </summary>
        </member>
        <member name="M:Peach.Core.Dom.DataElement.GenerateInternalValue">
            <summary>
            Generate the internal value of this data element
            </summary>
            <returns>Internal value in .NET form</returns>
        </member>
        <member name="P:Peach.Core.Dom.DataElement.GenerateCount">
            <summary>
            How many times GenerateValue has been called on this element
            </summary>
            <returns></returns>
        </member>
        <member name="M:Peach.Core.Dom.DataElement.GenerateValue">
            <summary>
            Generate the final value of this data element
            </summary>
            <returns></returns>
        </member>
        <member name="P:Peach.Core.Dom.DataElement.fixup">
            <summary>
            Fixup for this data element.  Can be null.
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.DataElement.placement">
            <summary>
            Placement for this data element. Can be null.
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.DataElement.transformer">
            <summary>
            Transformer for this data element.  Can be null.
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.DataElement.relations">
            <summary>
            Relations for this data element.
            </summary>
        </member>
        <member name="M:Peach.Core.Dom.DataElement.ReadSizedData(Peach.Core.IO.BitStream,System.Nullable{System.Int64},System.Int64)">
            <summary>
            Helper fucntion to obtain a bitstream sized for this element
            </summary>
            <param name="data">Source BitStream</param>
            <param name="size">Length of this element</param>
            <param name="read">Length of bits already read of this element</param>
            <returns>BitStream of length 'size - read'</returns>
        </member>
        <member name="M:Peach.Core.Dom.DataElement.isChildOf(Peach.Core.Dom.DataElement)">
            <summary>
            Determines whether or not a DataElement is a child of this DataElement.
            </summary>
            <param name="dataElement">The DataElement to test for a child relationship.</param>
            <returns>Returns true if 'dataElement' is a child, false otherwise.</returns>
        </member>
        <member name="M:Peach.Core.Dom.DataElement.isParentOf(Peach.Core.Dom.DataElement)">
            <summary>
            Check if we are a parent of an element.  This is
            true even if we are not the direct parent, but several
            layers up.
            </summary>
            <param name="element">Element to check</param>
            <returns>Returns true if we are a parent of element.</returns>
        </member>
        <member name="M:Peach.Core.Dom.DataElement.CommonParent(Peach.Core.Dom.DataElement)">
            <summary>
            Finds the common parent between this elemet
            and the target element.
            </summary>
            <param name="elem">Element to check</param>
            <returns>The common parent or null of none exists.</returns>
        </member>
        <member name="T:Peach.Core.Dom.DataElementContainer">
            <summary>
            Abstract base class for DataElements that contain other
            data elements.  Such as Block, Choice, or Flags.
            </summary>
        </member>
        <member name="M:Peach.Core.Dom.DataElementContainer.OnInsertItem(Peach.Core.Dom.DataElement)">
            <summary>
            Called before the item is going to be added
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:Peach.Core.Dom.DataElementContainer.OnRemoveItem(Peach.Core.Dom.DataElement,System.Boolean)">
            <summary>
            Called after the item has been removed
            </summary>
            <param name="item"></param>
            <param name="cleanup">Remove any bindings that could prevent garbage collection</param>
        </member>
        <member name="M:Peach.Core.Dom.DataElementContainer.OnSetItem(Peach.Core.Dom.DataElement,Peach.Core.Dom.DataElement)">
            <summary>
            Called before oldItem is going to be replaced with newItem
            </summary>
            <param name="oldItem"></param>
            <param name="newItem"></param>
        </member>
        <member name="M:Peach.Core.Dom.DataElementContainer.XPathChildren">
            <summary>
            Returns a list of children for use in XPath navigation.
            Should not be called directly.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Peach.Core.Dom.DataElementContainer.prettyPrint(System.Text.StringBuilder,System.Int32)">
            <summary>
            Create a pretty string representation of model from here.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Peach.Core.Dom.DataElementContainer.TryGetValue(System.String,Peach.Core.Dom.DataElement@)">
            <summary>
            Does container contain child element with name key?
            </summary>
            <param name="key">Name of child element to check</param>
            <param name="value">Gets the element named 'key'.</param>
            <returns>Returns true if child exits</returns>
        </member>
        <member name="M:Peach.Core.Dom.DataElementContainer.MoveChild(System.Int32,System.Int32)">
            <summary>
            Takes the element at oldIndex and moves it to newIndex.
            </summary>
            <param name="oldIndex"></param>
            <param name="newIndex"></param>
        </member>
        <member name="M:Peach.Core.Dom.DataElementContainer.RemoveAt(System.Int32,System.Boolean)">
            <summary>
            Remove child element at specific index
            </summary>
            <remarks>
            Warning, once an item has been removed it is no longer in a useable state
            unless cleanup is set to false!  By default bindings that could prevent
            garbage collection such as relations are removed.
            </remarks>
            <param name="index"></param>
            <param name="cleanup">Remove any bindings that could prevent garbage collection</param>
        </member>
        <member name="M:Peach.Core.Dom.DataElementContainer.Remove(Peach.Core.Dom.DataElement,System.Boolean)">
            <summary>
            Remove child element
            </summary>
            <remarks>
            Warning, once an item has been removed it is no longer in a useable state
            unless cleanup is set to false!  By default bindings that could prevent
            garbage collection such as relations are removed.
            </remarks>
            <param name="item"></param>
            <param name="cleanup">Remove any bindings that could prevent garbage collection</param>
            <returns></returns>
        </member>
        <member name="T:Peach.Core.Dom.DataModel">
            <summary>
            DataModel is just a top level Block.
            </summary>
        </member>
        <member name="F:Peach.Core.Dom.DataModel.dom">
            <summary>
            Dom parent of data model if any
            </summary>
            <remarks>
            A data model can be the child of two (okay three) different types,
              1. Dom (dom.datamodel collection)
              2. Action (Action.dataModel)
              3. ActionParam (Action.parameters[0].dataModel)
              
            This variable is one of those parent holders.
            </remarks>
        </member>
        <member name="F:Peach.Core.Dom.DataModel.actionData">
            <summary>
            Action parent of data model if any
            </summary>
            <remarks>
            A data model can be the child of two (okay three) different types,
              1. Dom (dom.datamodel collection)
              2. Action (Action.dataModel)
              3. ActionParam (Action.parameters[0].dataModel)
              
            This variable is one of those parent holders.
            </remarks>
        </member>
        <member name="T:Peach.Core.Dom.DataSet">
            <summary>
            Specify a set of Data for a DataModel
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.Dom.Name">
            <summary>
            The namespace of this Dom.
            </summary>
        </member>
        <member name="M:Peach.Core.Dom.Dom.evaulateDataModelAnalyzers">
            <summary>
            Execute all analyzers on all data models in DOM.
            </summary>
        </member>
        <member name="M:Peach.Core.Dom.Dom.getRef``1(System.String,System.Func{Peach.Core.Dom.Dom,Peach.Core.ITryGetValue{System.String,``0}})">
            <summary>
            Find a referenced Dom element by name, taking into account namespace prefixes.
            </summary>
            <typeparam name="T">Type of Dom element.</typeparam>
            <param name="refName">Name of reference</param>
            <param name="predicate">Selector predicate that returns the element collection</param>
            <returns>The named Dom element or null if not found.</returns>
        </member>
        <member name="M:Peach.Core.Dom.Dom.getRef(System.String,Peach.Core.Dom.DataElementContainer)">
            <summary>
            Resolve a 'ref' attribute.  Will throw a PeachException if
            namespace is given, but not found.
            </summary>
            <param name="name">Ref name to resolve.</param>
            <param name="element">Container to start searching from.</param>
            <returns>DataElement for ref or null if not found.</returns>
        </member>
        <member name="T:Peach.Core.Dom.DataElementTypes">
            <summary>
            Flags to define what child elements are supported by
            a DataElement.  Flags can be combined or used individually.
            </summary>
            <remarks>
            Used primarily by the schema builder
            </remarks>
        </member>
        <member name="F:Peach.Core.Dom.DataElementTypes.None">
            <summary>
            No child elements
            </summary>
        </member>
        <member name="F:Peach.Core.Dom.DataElementTypes.DataElements">
            <summary>
            Can contain child data elements
            </summary>
        </member>
        <member name="F:Peach.Core.Dom.DataElementTypes.Parameter">
            <summary>
            Can contain Parameter elements
            </summary>
        </member>
        <member name="F:Peach.Core.Dom.DataElementTypes.Relation">
            <summary>
            Can contain Relation elements
            </summary>
        </member>
        <member name="F:Peach.Core.Dom.DataElementTypes.Transformer">
            <summary>
            Can contain Transformer element
            </summary>
        </member>
        <member name="F:Peach.Core.Dom.DataElementTypes.Fixup">
            <summary>
            Can contain Fixup element
            </summary>
        </member>
        <member name="F:Peach.Core.Dom.DataElementTypes.Hint">
            <summary>
            Can contain Hint elements
            </summary>
        </member>
        <member name="F:Peach.Core.Dom.DataElementTypes.Analyzer">
            <summary>
            Can contain Analyzer element
            </summary>
        </member>
        <member name="F:Peach.Core.Dom.DataElementTypes.NonDataElements">
            <summary>
            Any child element except DataElements
            </summary>
        </member>
        <member name="F:Peach.Core.Dom.DataElementTypes.All">
            <summary>
            All child elements
            </summary>
        </member>
        <member name="M:Peach.Core.Dom.Flag.Overlapps(System.Int32,System.Int32)">
            <summary>
            Determines if a flag at position 'position' with size 'size' overlapps this element
            </summary>
            <param name="position">Position to test</param>
            <param name="size">Size to test</param>
            <returns>True if overlapps, false otherwise</returns>
        </member>
        <member name="F:Peach.Core.Dom.Frag._payloadInvalidated">
            <summary>
            Set by Payload.Invalidated event handler
            </summary>
        </member>
        <member name="F:Peach.Core.Dom.Frag._generatedFragments">
            <summary>
            Set after we have generated fragements at least once
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.Frag.FragmentAlg">
            <summary>
            Instance of our fragement algorithm class. Can be null.
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.Frag.Template">
            <summary>
            Template to use for fragments
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.Frag.Ack">
            <summary>
            Acknowledgement to use for fragments
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.Frag.LastAck">
            <summary>
            Acknowledgement to use for final fragment.
            LastAck allows sending a different value for final fragments.
            If not provided the Ack model is used.
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.Frag.Nack">
            <summary>
            Negative acknowledgement to use for fragments.
            Recieving a nack will trigger retransmission of last fragment a max of 3 times.
            </summary>
        </member>
        <member name="T:Peach.Core.Dom.FragSequence">
            <summary>
            Specialized version of Sequence for Fragmentation support.
            </summary>
            <remarks>
            The main driving force for having a this class is the special
            handling of array expantion and contraction that is needed.
            
            The Outfrag action will iterate over the children of this sequence
            outputting each child in a separate output action. Our normal
            way of expanding/contracting sequences will not work. Instead
            we need to override how iteration of this sequence works.
            </remarks>
        </member>
        <member name="T:Peach.Core.Dom.Hint">
            <summary>
            Hints are attached to data elements providing information
            for mutators.
            </summary>
        </member>
        <member name="T:Peach.Core.Dom.HintAttribute">
            <summary>
            Used to indicate a mutator supports a type of Hint
            </summary>
        </member>
        <member name="T:Peach.Core.Dom.Monitor">
            <summary>
            Monitors are agent modules that can perform a number of tasks such as
            monitoring a target application to detect faults, restarting virtual machines,
            recording network traffic, etc. Custom monitors can easily be created and used along
            with the included monitors.
            </summary>
        </member>
        <member name="T:Peach.Core.Dom.Number">
            <summary>
            A numerical data element.
            </summary>
        </member>
        <member name="M:Peach.Core.Dom.Number.#ctor(System.Boolean)">
            <summary>
            In the case of Double the values set
            by Number will cause an exception. This
            contructor is added as a work arround.
            </summary>
            <param name="nullCtor"></param>
        </member>
        <member name="M:Peach.Core.Dom.Number.#ctor(System.Boolean,System.String)">
            <summary>
            In the case of Double the values set
            by Number will cause an exception. This
            contructor is added as a work arround.
            </summary>
            <param name="nullCtor"></param>
            <param name="name"></param>
        </member>
        <member name="T:Peach.Core.Dom.OffsetRelation">
            <summary>
            Byte offset relation
            </summary>
        </member>
        <member name="M:Peach.Core.Dom.OffsetRelation.calculateOffset">
            <summary>
            Caluclate the offset in bytes between two data elements.
            </summary>
            <returns>Returns the offset in bits between two elements.  Return can be negative.</returns>
        </member>
        <member name="T:Peach.Core.Dom.IOrderedDictionary`2">
            <summary>
            Represents a generic collection of key/value pairs that are ordered independently of the key and value.
            </summary>
            <typeparam name="TKey">The type of the keys in the dictionary</typeparam>
            <typeparam name="TValue">The type of the values in the dictionary</typeparam>
        </member>
        <member name="M:Peach.Core.Dom.IOrderedDictionary`2.Insert(System.Int32,`0,`1)">
            <summary>
            Inserts a new entry into the IOrderedDictionary&lt;TKey,TValue&gt; collection with the specified key and value at the specified index.
            </summary>
            <param name="index">The zero-based index at which the element should be inserted.</param>
            <param name="key">The key of the entry to add.</param>
            <param name="value">The value of the entry to add. The value can be null if the type of the values in the dictionary is a reference type.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index"/> is less than 0.<br/>
            -or-<br/>
            <paramref name="index"/> is greater than Count.</exception>
            <exception cref="T:System.ArgumentException">An element with the same key already exists in the IOrderedDictionary&lt;TKey,TValue&gt;.</exception>
            <exception cref="T:System.NotSupportedException">The IOrderedDictionary&lt;TKey,TValue&gt; is read-only.<br/>
            -or-<br/>
            The IOrderedDictionary&lt;TKey,TValue&gt; has a fized size.</exception>
        </member>
        <member name="P:Peach.Core.Dom.IOrderedDictionary`2.Item(System.Int32)">
            <summary>
            Gets or sets the value at the specified index.
            </summary>
            <param name="index">The zero-based index of the value to get or set.</param>
            <value>The value of the item at the specified index.</value>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index"/> is less than 0.<br/>
            -or-<br/>
            <paramref name="index"/> is equal to or greater than Count.</exception>
        </member>
        <member name="M:Peach.Core.Dom.IOrderedDictionary`2.IndexOfKey(`0)">
            <summary>
            Returns the zero-based index of the specified key in the OrderedDictionary&lt;TKey,TValue&gt;
            </summary>
            <param name="key">The key to locate in the OrderedDictionary&lt;TKey,TValue&gt;</param>
            <returns>The zero-based index of <paramref name="key"/>, if <paramref name="key"/> is found in the OrderedDictionary&lt;TKey,TValue&gt;; otherwise, -1</returns>
            <remarks>This method performs a linear search; therefore it has a cost of O(n) at worst.</remarks>
        </member>
        <member name="T:Peach.Core.Dom.OrderedDictionary`2">
            <summary>
            Represents a generic collection of key/value pairs that are ordered independently of the key and value.
            </summary>
            <typeparam name="TKey">The type of the keys in the dictionary</typeparam>
            <typeparam name="TValue">The type of the values in the dictionary</typeparam>
        </member>
        <member name="M:Peach.Core.Dom.OrderedDictionary`2.#ctor">
            <summary>
            Initializes a new instance of the OrderedDictionary&lt;TKey,TValue&gt; class.
            </summary>
        </member>
        <member name="M:Peach.Core.Dom.OrderedDictionary`2.IndexOfKey(`0)">
            <summary>
            Returns the zero-based index of the specified key in the OrderedDictionary&lt;TKey,TValue&gt;
            </summary>
            <param name="key">The key to locate in the OrderedDictionary&lt;TKey,TValue&gt;</param>
            <returns>The zero-based index of <paramref name="key"/>, if <paramref name="key"/> is found in the OrderedDictionary&lt;TKey,TValue&gt;; otherwise, -1</returns>
            <remarks>This method performs a linear search; therefore it has a cost of O(n) at worst.</remarks>
        </member>
        <member name="T:Peach.Core.Dom.Padding">
            <summary>
            Providing padding bytes to a DataElementContainer.
            </summary>
        </member>
        <member name="M:Peach.Core.Dom.Padding.#ctor">
            <summary>
            Create a padding element.
            </summary>
        </member>
        <member name="M:Peach.Core.Dom.Padding.#ctor(System.String)">
            <summary>
            Create a padding element.
            </summary>
            <param name="name">Name of padding element</param>
        </member>
        <member name="P:Peach.Core.Dom.Padding.alignment">
            <summary>
            Byte alignment (8, 16, etc).
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.Padding.alignedTo">
            <summary>
            Element to pull size to align.  If null use parent.
            </summary>
        </member>
        <member name="T:Peach.Core.Dom.Placement">
            <summary>
            Hints are attached to data elements providing information
            for mutators.
            </summary>
        </member>
        <member name="T:Peach.Core.Dom.Relation">
            <summary>
            Base class for all data element relations
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.Relation.ExpressionGet">
            <summary>
            Expression that is run when getting the value.
            </summary>
            <remarks>
            This expression is only run when the data cracker
            has identified a size relation exists and is getting
            the value from the "from" side of the relation.
            
            The expressionGet will only get executed when direcly calling
            the Relation.GetValue() method directly.  It is not called from
            DataElement by design.
            </remarks>
        </member>
        <member name="P:Peach.Core.Dom.Relation.ExpressionSet">
            <summary>
            Expression that is run when setting the value.
            </summary>
            <remarks>
            This expression can be called numerouse times.  It will be
            executed any time the attached data element re-generates it's
            value (internal or real).
            
            The ExpressionSet is executed typically from DataElement.GenerateInteralValue() via
            Relation.CalculateFromValue().  As such this expression should limit the amount of
            time intensive tasks it performs.
            </remarks>
        </member>
        <member name="M:Peach.Core.Dom.Relation.CalculateFromValue">
            <summary>
            Calculate the new From value based on Of
            </summary>
            <remarks>
            This method is called every time our attached DataElement re-generates it's
            value by calling DataElement.GenerateInteralValue().
            </remarks>
            <returns></returns>
        </member>
        <member name="M:Peach.Core.Dom.Relation.GetValue">
            <summary>
            Get value from our "from" side.
            </summary>
            <remarks>
            Gets the value from our "from" side and run it through expressionGet (if set).
            This method is only called by the DataCracker and never from DataElement.
            </remarks>
        </member>
        <member name="T:Peach.Core.Dom.RelationAttribute">
            <summary>
            Used to indicate a class is a valid Relation and 
            provide it's invoking name used in the Pit XML file.
            </summary>
        </member>
        <member name="T:Peach.Core.Dom.Sequence">
            <summary>
            Sequence element
            </summary>
        </member>
        <member name="F:Peach.Core.Dom.Sequence.ExpandedValue">
            <summary>
            Value to use in array expantion
            </summary>
        </member>
        <member name="F:Peach.Core.Dom.Sequence.ExpandedValueIndex">
            <summary>
            Index of value being expanded
            </summary>
        </member>
        <member name="M:Peach.Core.Dom.Sequence.SetCountOverride(System.Int32,Peach.Core.IO.BitwiseStream,System.Int32)">
            <summary>
            Set count override.
            </summary>
            <param name="count">New count for sequence</param>
            <param name="value">Value to use in expansion</param>
            <param name="valueIndex">Index to perform expantion at</param>
        </member>
        <member name="T:Peach.Core.Dom.SizeRelation">
            <summary>
            Byte size relation.
            </summary>
        </member>
        <member name="T:Peach.Core.Dom.State">
            <summary>
            The State element defines a sequence of Actions to perform.  Actions can cause a 
            change to another State.  Such changes can occur dynamically based on content received or sent
            by attaching python expressions to actions via the onStart/onComplete/when attributes.
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.State.schemaGodel">
            <summary>
            Currently unused.  Exists for schema generation.
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.State.Name">
            <summary>
            The name of this state.
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.State.FieldId">
            <summary>
            The field id of this state.
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.State.onStart">
            <summary>
            Expression to run when state is starting
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.State.onComplete">
            <summary>
            Expression to run when state is completed
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.State.actions">
            <summary>
            The actions contained in this state.
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.State.parent">
            <summary>
            The state model that owns this state.
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.State.started">
            <summary>
            Has the state started?
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.State.finished">
            <summary>
            Has the start completed?
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.State.error">
            <summary>
            Has an error occurred?
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.State.runCount">
            <summary>
            How many times has this state run
            </summary>
        </member>
        <member name="M:Peach.Core.Dom.State.MoveToNextAction">
            <summary>
            Will move forward one action in execution.
            </summary>
            <remarks>
            This method can be called by state model mutators.
            If this method is not called and a different action is returned by the
            mutator, the current action scheduled for execution will be tried again 
            on the next step through.
            </remarks>
        </member>
        <member name="T:Peach.Core.Dom.StateModel">
            <summary>
            Defines a state machine to use during a fuzzing test.  State machines in Peach are intended to be
            fairly simple and allow for only the basic modeling typically required for fuzzing state aware protocols or 
            call sequences.  State machines are made up of one or more States which are in them selves make up of
            one or more Action.  As Actions are executed the data can be moved between them as needed.
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.StateModel.schemaGodel">
            <summary>
            Currently unused.  Exists for schema generation.
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.StateModel.states">
            <summary>
            All states in state model.
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.StateModel.Name">
            <summary>
            The name of this state model.
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.StateModel.initialStateName">
            <summary>
            Name of the state to execute first.
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.StateModel.finalStateName">
            <summary>
            Name of the state to execute last.
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.StateModel.parent">
            <summary>
            The Dom that owns this state model.
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.StateModel.initialState">
            <summary>
            The initial state to run when state machine executes.
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.StateModel.finalState">
            <summary>
            The final state to run when state machine finishes.
            </summary>
        </member>
        <member name="M:Peach.Core.Dom.StateModel.SaveData(System.String,Peach.Core.IO.BitwiseStream,System.Boolean)">
            <summary>
            Saves the data produced/consumed by an action for future logging.
            </summary>
            <param name="dataName"></param>
            <param name="value"></param>
            <param name="isInput"></param>
        </member>
        <member name="M:Peach.Core.Dom.StateModel.Run(Peach.Core.RunContext)">
            <summary>
            Start running the State Machine
            </summary>
            <remarks>
            This will start the initial State.
            </remarks>
            <param name="context"></param>
        </member>
        <member name="M:Peach.Core.Dom.StateModel.CreateStateModelRef">
            <summary>
            Create a StateModelRef for this State Model
            </summary>
            <remarks>
            This allows different state model types to create
            specific StateModelRef instances for themselves.
            
            Example is WebProxyModel.
            </remarks>
            <returns></returns>
        </member>
        <member name="F:Peach.Core.Dom.StringType.ascii">
            <summary>
            Single byte characters.
            </summary>
        </member>
        <member name="F:Peach.Core.Dom.StringType.utf7">
            <summary>
            Multibyte unicode characters encoded in UTF-7.
            </summary>
        </member>
        <member name="F:Peach.Core.Dom.StringType.utf8">
            <summary>
            Multibyte unicode characters encoded in UTF-8.
            </summary>
        </member>
        <member name="F:Peach.Core.Dom.StringType.utf16">
            <summary>
            Double byte characters as commonly used with Windows applications.
            </summary>
        </member>
        <member name="F:Peach.Core.Dom.StringType.utf16be">
            <summary>
            Multibyte unicode characters encoded in UTF-16 big endian.
            </summary>
        </member>
        <member name="F:Peach.Core.Dom.StringType.utf32">
            <summary>
            Multibyte unicode characters encoded in UTF-32.
            </summary>
        </member>
        <member name="F:Peach.Core.Dom.StringType.utf32be">
            <summary>
            Multibyte unicode characters encoded in UTF-32 nig endian.
            </summary>
        </member>
        <member name="T:Peach.Core.Dom.String">
            <summary>
            String data element.  String elements support numerouse encodings
            such as straight ASCII through UTF-32.  Both little and big endian
            strings are supported.
            
            Strings also support standard attributes such as length, null termination,
            etc.
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.String.stringType">
            <summary>
            String type/encoding to be used.  Default is 
            ASCII.
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.String.nullTerminated">
            <summary>
            Is string null terminated?  For ASCII strings this
            is a single NULL characters, for WCHAR's, two NULL 
            characters are used.
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.String.padCharacter">
            <summary>
            Pad character for string.  Defaults to NULL.
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.String.length">
            <summary>
            Length of element in lengthType units.
            </summary>
            <remarks>
            In the case that LengthType == "Calc" we will evaluate the
            expression.
            </remarks>
        </member>
        <member name="P:Peach.Core.Dom.String.lengthAsBits">
            <summary>
            Returns length as bits.
            </summary>
        </member>
        <member name="T:Peach.Core.Dom.WeightMutable">
            <summary>
            Mark state model/data models as mutable at runtime.
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.WeightMutable.Weight">
            <summary>
            Name of element to mark as mutable/non-mutable.
            </summary>
        </member>
        <member name="T:Peach.Core.Dom.IncludeMutable">
            <summary>
            Mark state model/data models as mutable at runtime.
            </summary>
        </member>
        <member name="T:Peach.Core.Dom.ExcludeMutable">
            <summary>
            Mark state model/data models as non-mutable at runtime.
            </summary>
        </member>
        <member name="T:Peach.Core.Dom.MarkMutable">
            <summary>
            Mark state model/data models as mutable true/false at runtime.
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.MarkMutable.refName">
            <summary>
            Name of element to mark as mutable/non-mutable.
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.MarkMutable.xpath">
            <summary>
            Xpath to elements to mark as mutable/non-mutable.
            </summary>
        </member>
        <member name="T:Peach.Core.Dom.Test">
            <summary>
            Define a test to run. Currently a test is defined as a combination of a
            Template and optionally a Data set. In the future this will expand to include a state model,
            defaults for generation, etc.
            </summary>
        </member>
        <member name="T:Peach.Core.Dom.Test.Lifetime">
            <summary>
            Defines the lifetime of the fuzzing target.
            </summary>
        </member>
        <member name="F:Peach.Core.Dom.Test.Lifetime.Session">
            <summary>
            The fuzzing target is restarted once per fuzzing session.
            </summary>
        </member>
        <member name="F:Peach.Core.Dom.Test.Lifetime.Iteration">
            <summary>
            The fuzzing target is restarted once per fuzzing iteration.
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.Test.Name">
            <summary>
            Name of test case.
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.Test.description">
            <summary>
            Description of test case.
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.Test.waitTime">
            <summary>
            Time to wait in seconds between each test case. Value can be fractional
            (0.25). Defaults to zero (0).
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.Test.faultWaitTime">
            <summary>
            Time to wait in seconds between each iteration when in fault reproduction mode.
            This occurs when a fault has been detected and is being verified. Value can
            be fractional (0.25). Defaults to two (2) seconds.
            </summary>
            <remarks>
            This value should be large enough to make sure a fault is detected at the correct
            iteration.  We only wait this time when verifying a fault was detected.
            </remarks>
        </member>
        <member name="P:Peach.Core.Dom.Test.controlIteration">
            <summary>
            How often we should perform a control iteration.
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.Test.nonDeterministicActions">
            <summary>
            Are action run counts non-deterministic.
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.Test.maxOutputSize">
            <summary>
            The maximum data size to generate for output actions.
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.Test.TargetLifetime">
            <summary>
            Defines the lifetime of the fuzzing target.
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.Test.MaxBackSearch">
            <summary>
            Number of iteration to search backwards trying to reproduce a fault.
            </summary>
            <remarks>
            Many times, especially with network fuzzing, the iteration we detect a fault on is not the
            correct iteration, or the fault requires multiple iterations to reproduce.
            
            Peach will start reproducing at the current iteration count then start moving backwards
            until we locate the iteration causing the crash, or reach our max back search value.
            </remarks>
        </member>
        <member name="P:Peach.Core.Dom.Test.mutators">
            <summary>
            Currently unused.  Exists for schema generation.
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.Test.agentRef">
            <summary>
            Currently unused.  Exists for schema generation.
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.Test.stateModelRef">
            <summary>
            Currently unused.  Exists for schema generation.
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.Test.pubs">
            <summary>
            Currently unused.  Exists for schema generation.
            </summary>
        </member>
        <member name="F:Peach.Core.Dom.Test.includedMutators">
            <summary>
            List of mutators to include in run
            </summary>
            <remarks>
            If exclude is empty, and this collection contains values, then remove all mutators and only
            include these.
            </remarks>
        </member>
        <member name="F:Peach.Core.Dom.Test.excludedMutators">
            <summary>
            List of mutators to exclude from run
            </summary>
            <remarks>
            If include is empty then use all mutators excluding those in this list.
            </remarks>
        </member>
        <member name="P:Peach.Core.Dom.XmlAttribute.attributeName">
            <summary>
            XML attribute name
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.XmlAttribute.ns">
            <summary>
            XML Namespace for element
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.XmlElement.elementName">
            <summary>
            XML Element tag name
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.XmlElement.ns">
            <summary>
            XML Namespace for element
            </summary>
        </member>
        <member name="T:Peach.Core.Engine">
            <summary>
            The main Peach fuzzing engine!
            </summary>
        </member>
        <member name="E:Peach.Core.Engine.TestStarting">
            <summary>
            Fired when a Test is starting.  This could be fired
            multiple times after the RunStarting event if the Run
            contains multiple Tests.
            </summary>
        </member>
        <member name="E:Peach.Core.Engine.IterationStarting">
            <summary>
            Fired at the start of each iteration.  This event will
            be fired often.
            </summary>
        </member>
        <member name="E:Peach.Core.Engine.IterationFinished">
            <summary>
            Fired at end of each iteration.  This event will be fired often.
            </summary>
        </member>
        <member name="E:Peach.Core.Engine.ReproFault">
            <summary>
            Fired when a Fault is detected and the engine starts retrying to reproduce it.
            </summary>
        </member>
        <member name="E:Peach.Core.Engine.ReproFailed">
            <summary>
            Fired when a Fault is is unable to be reproduced
            </summary>
        </member>
        <member name="E:Peach.Core.Engine.Fault">
            <summary>
            Fired when a Fault is detected.
            </summary>
        </member>
        <member name="E:Peach.Core.Engine.TestFinished">
            <summary>
            Fired when a Test is finished.
            </summary>
        </member>
        <member name="E:Peach.Core.Engine.TestWarning">
            <summary>
            Fired when a recoverable warning occurs during a Test.
            </summary>
        </member>
        <member name="E:Peach.Core.Engine.TestError">
            <summary>
            Fired when we know the count of iterations the Test will take.
            </summary>
        </member>
        <member name="E:Peach.Core.Engine.HaveCount">
            <summary>
            Fired when we know the count of iterations the Test will take.
            </summary>
        </member>
        <member name="E:Peach.Core.Engine.HaveParallel">
            <summary>
            Fired when we know the range of iterations the parallel Test will take.
            </summary>
        </member>
        <member name="M:Peach.Core.Engine.startFuzzing(Peach.Core.Dom.Dom,Peach.Core.RunConfiguration)">
            <summary>
            Run the default fuzzing run in the specified dom.
            </summary>
            <param name="dom"></param>
            <param name="config"></param>
        </member>
        <member name="M:Peach.Core.Engine.RunTest">
            <summary>
            Run a test case.  Contains main fuzzing loop.
            </summary>
        </member>
        <member name="M:Peach.Core.Engine.StartAgents">
            <summary>
            Start up the agents required for the current test
            </summary>
        </member>
        <member name="M:Peach.Core.Engine.CollectControlFaults">
            <summary>
            If this was a control iteration, verify it againt our origional recording.
            </summary>
        </member>
        <member name="M:Peach.Core.XmlExtensions.AsEnumerable(System.Xml.XmlNodeList)">
            <summary>
            Presents an xml node list as an IEnumerable&lt;XmlNode&gt;
            </summary>
            <param name="list">Xml node list</param>
            <returns></returns>
        </member>
        <member name="M:Peach.Core.XmlExtensions.hasAttr(System.Xml.XmlNode,System.String)">
            <summary>
            Tests if an attribute exists on an XmlNode
            </summary>
            <param name="node">Node to test</param>
            <param name="name">Attribute name to check for</param>
            <returns>True if atribute exists, false otherwise</returns>
        </member>
        <member name="M:Peach.Core.XmlExtensions.getAttrString(System.Xml.XmlNode,System.String)">
            <summary>
            Gets the value of an xml attribute as a string.
            Throws an error if the attribute does not exist
            </summary>
            <param name="node">Xml node</param>
            <param name="name">Name of the attribute</param>
            <returns>Attribute value as a string</returns>
        </member>
        <member name="M:Peach.Core.XmlExtensions.getAttrInt(System.Xml.XmlNode,System.String)">
            <summary>
            Gets the value of an xml attribute as an int.
            Throws an error if the attribute does not exist or
            if the value can not be converted to an int.
            </summary>
            <param name="node">Xml node</param>
            <param name="name">Name of the attribute</param>
            <returns>Attribute value as an int</returns>
        </member>
        <member name="M:Peach.Core.XmlExtensions.getAttrUInt32(System.Xml.XmlNode,System.String)">
            <summary>
            Gets the value of an xml attribute as an unsigned int.
            Throws an error if the attribute does not exist or
            if the value can not be converted to an unsigned int.
            </summary>
            <param name="node">Xml node</param>
            <param name="name">Name of the attribute</param>
            <returns>Attribute value as an int</returns>
        </member>
        <member name="M:Peach.Core.XmlExtensions.getAttrUInt64(System.Xml.XmlNode,System.String)">
            <summary>
            Gets the value of an xml attribute as a ulong.
            Throws an error if the attribute does not exist or
            if the value can not be converted to a ulong.
            </summary>
            <param name="node">Xml node</param>
            <param name="name">Name of the attribute</param>
            <returns>Attribute value as an int</returns>
        </member>
        <member name="M:Peach.Core.XmlExtensions.getAttrBool(System.Xml.XmlNode,System.String)">
            <summary>
            Gets the value of an xml attribute as a bool.
            Throws an error if the attribute does not exist or
            if the value can not be converted to a bool.
            </summary>
            <param name="node">Xml node</param>
            <param name="name">Name of the attribute</param>
            <returns>Attribute value as a bool</returns>
        </member>
        <member name="M:Peach.Core.XmlExtensions.getAttrChar(System.Xml.XmlNode,System.String)">
            <summary>
            Gets the value of an xml attribute as a char.
            Throws an error if the attribute does not exist or
            if the value can not be converted to a char.
            </summary>
            <param name="node">Xml node</param>
            <param name="name">Name of the attribute</param>
            <returns>Attribute value as a char</returns>
        </member>
        <member name="M:Peach.Core.XmlExtensions.getAttr(System.Xml.XmlNode,System.String,System.String)">
            <summary>
            Gets the value of an xml attribute as a string.
            Throws an error if the attribute value can not be converted to a string.
            Returns the defaultValue if the attribute is not set.
            </summary>
            <param name="node">Xml node</param>
            <param name="name">Name of the attribute</param>
            <param name="defaultValue">Value to use when the attribute is not set</param>
            <returns>Attribute value as a string</returns>
        </member>
        <member name="M:Peach.Core.XmlExtensions.getAttr(System.Xml.XmlNode,System.String,System.Boolean)">
            <summary>
            Gets the value of an xml attribute as a bool.
            Throws an error if the attribute value can not be converted to a bool.
            Returns the defaultValue if the attribute is not set.
            </summary>
            <param name="node">Xml node</param>
            <param name="name">Name of the attribute</param>
            <param name="defaultValue">Value to use when the attribute is not set</param>
            <returns>Attribute value as a bool</returns>
        </member>
        <member name="M:Peach.Core.XmlExtensions.getAttr(System.Xml.XmlNode,System.String,System.Int32)">
            <summary>
            Gets the value of an xml attribute as an int.
            Throws an error if the attribute value can not be converted to an int.
            Returns the defaultValue if the attribute is not set.
            </summary>
            <param name="node">Xml node</param>
            <param name="name">Name of the attribute</param>
            <param name="defaultValue">Value to use when the attribute is not set</param>
            <returns>Attribute value as an int</returns>
        </member>
        <member name="M:Peach.Core.XmlExtensions.getAttr(System.Xml.XmlNode,System.String,System.UInt64)">
            <summary>
            Gets the value of an xml attribute as a ulong.
            Throws an error if the attribute value can not be converted to a ulong.
            Returns the defaultValue if the attribute is not set.
            </summary>
            <param name="node">Xml node</param>
            <param name="name">Name of the attribute</param>
            <param name="defaultValue">Value to use when the attribute is not set</param>
            <returns>Attribute value as an int</returns>
        </member>
        <member name="M:Peach.Core.XmlExtensions.getAttr(System.Xml.XmlNode,System.String,System.Char)">
            <summary>
            Gets the value of an xml attribute as a char.
            Throws an error if the attribute value can not be converted to a char.
            Returns the defaultValue if the attribute is not set.
            </summary>
            <param name="node">Xml node</param>
            <param name="name">Name of the attribute</param>
            <param name="defaultValue">Value to use when the attribute is not set</param>
            <returns>Attribute value as a char</returns>
        </member>
        <member name="M:Peach.Core.XmlExtensions.AppendAttribute(System.Xml.XmlNode,System.String,System.String)">
            <summary>
            Set attribute on XmlNode object.
            </summary>
            <param name="node">XmlNode to set attribute on</param>
            <param name="name">Name of attribute</param>
            <param name="value">Value of attribute</param>
        </member>
        <member name="T:Peach.Core.FaultType">
            <summary>
            Type of fault
            </summary>
        </member>
        <member name="M:Peach.Core.FaultSummary.Hash(System.String)">
            <summary>
            Compute the hash of a value for use as either
            the MajorHash or MinorHash.
            </summary>
            <param name="value">String value to hash</param>
            <returns>The first 4 bytes of the md5 has as a hex string</returns>
        </member>
        <member name="P:Peach.Core.FaultSummary.Title">
            <summary>
            One line title of fault
            </summary>
        </member>
        <member name="P:Peach.Core.FaultSummary.Description">
            <summary>
            Description field of fault
            </summary>
        </member>
        <member name="P:Peach.Core.FaultSummary.MajorHash">
            <summary>
            Major hash of fault.
            </summary>
        </member>
        <member name="P:Peach.Core.FaultSummary.MinorHash">
            <summary>
            Minor hash of fault
            </summary>
        </member>
        <member name="P:Peach.Core.FaultSummary.Exploitablity">
            <summary>
            Exploitability of fault
            </summary>
        </member>
        <member name="P:Peach.Core.FaultSummary.DetectionSource">
            <summary>
            Detection source for fault, typically the class name
            </summary>
            For the Rest publisher the detection name is the name attribute while
            detection source is the Publisher attribute.
        </member>
        <member name="P:Peach.Core.FaultSummary.DetectionName">
            <summary>
            Name of detection source
            </summary>
            <remarks>
            For the Rest publisher the detection name is the name attribute while
            detection source is the Publisher attribute.
            </remarks>
        </member>
        <member name="P:Peach.Core.FaultSummary.AgentName">
            <summary>
            Name of agent fault was reported by.
            </summary>
            <remarks>
            Only used when fault generated via agent, otherwise null.
            </remarks>
        </member>
        <member name="T:Peach.Core.Fault">
            <summary>
            Fault detected during fuzzing run
            </summary>
        </member>
        <member name="T:Peach.Core.Fault.Data">
            <summary>
            Data contained in fault.
            </summary>
        </member>
        <member name="P:Peach.Core.Fault.Data.Path">
            <summary>
            Set by FileLogger with the location on disk
            of this file.
            </summary>
        </member>
        <member name="F:Peach.Core.Fault.iteration">
            <summary>
            Iteration fault was detected on
            </summary>
        </member>
        <member name="F:Peach.Core.Fault.iterationStart">
            <summary>
            Start iteration of search when fault was detected
            </summary>
        </member>
        <member name="F:Peach.Core.Fault.iterationStop">
            <summary>
            End iteration of search when fault was detected
            </summary>
        </member>
        <member name="F:Peach.Core.Fault.controlIteration">
            <summary>
            Is this a control iteration.
            </summary>
        </member>
        <member name="F:Peach.Core.Fault.controlRecordingIteration">
            <summary>
            Is this control operation also a recording iteration?
            </summary>
        </member>
        <member name="F:Peach.Core.Fault.type">
            <summary>
            Type of fault
            </summary>
        </member>
        <member name="F:Peach.Core.Fault.detectionSource">
            <summary>
            Who detected this fault?
            </summary>
            <remarks>
            Example: "PageHeap Monitor"
            Example: "Name (PageHeap Monitor)"
            </remarks>
        </member>
        <member name="F:Peach.Core.Fault.monitorName">
            <summary>
            Name of monitor instance that created this fault
            </summary>
            <remarks>
            Set by the agent
            </remarks>
        </member>
        <member name="F:Peach.Core.Fault.agentName">
            <summary>
            Agent this fault came from
            </summary>
            <remarks>
            Set by the AgentManager
            </remarks>
        </member>
        <member name="F:Peach.Core.Fault.title">
            <summary>
            Title of finding
            </summary>
        </member>
        <member name="F:Peach.Core.Fault.description">
            <summary>
            Multiline description and collection of information.
            </summary>
        </member>
        <member name="F:Peach.Core.Fault.majorHash">
            <summary>
            Major hash of fault used for bucketting.
            </summary>
        </member>
        <member name="F:Peach.Core.Fault.minorHash">
            <summary>
            Minor hash of fault used for bucketting.
            </summary>
        </member>
        <member name="F:Peach.Core.Fault.exploitability">
            <summary>
            Exploitability of fault, used for bucketting.
            </summary>
        </member>
        <member name="F:Peach.Core.Fault.folderName">
            <summary>
            Folder for fault to be collected under.  Only used when
            major/minor hashes and exploitability are not defined.
            </summary>
        </member>
        <member name="F:Peach.Core.Fault.collectedData">
            <summary>
            Binary data collected about fault.  Key is filename, value is content.
            </summary>
        </member>
        <member name="F:Peach.Core.Fault.states">
            <summary>
            List of all states run when fault was detected.
            </summary>
        </member>
        <member name="M:Peach.Core.FileArch.GetWindows(System.String)">
            <summary>
            Returns the architecture of the specified PE file.
            </summary>
            <param name="fileName"></param>
            <returns></returns>
        </member>
        <member name="M:Peach.Core.FileArch.GetLinux(System.String)">
            <summary>
            Returns the architecture of the specified ELF file.
            </summary>
            <param name="fileName"></param>
            <returns></returns>
        </member>
        <member name="P:Peach.Core.Fixup.references">
            <summary>
            Returns mapping of ref key to ref value, eg: ("ref1", "DataModel.Emenent_0")
            </summary>
        </member>
        <member name="M:Peach.Core.Fixup.fixup(Peach.Core.Dom.DataElement)">
            <summary>
            Perform fixup operation
            </summary>
            <param name="obj">Parent data element</param>
            <returns></returns>
        </member>
        <member name="M:Peach.Core.Fixup.GetDefaultValue(Peach.Core.Dom.DataElement)">
            <summary>
            This is the value to use for the data element if the
            fixup has been recursivley called.  This can happen when
            the fixup references a parent of the element being fixed up.
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="T:Peach.Core.Fixups.VolatileFixup">
            <summary>
            A helper class for fixups that are volatile and need to
            be computed every time an action is run.
            Any fixup that requires per-iteration state stored in the
            RunContext should derive from this class and override OnActionRun.
            </summary>
        </member>
        <member name="M:Peach.Core.Fixups.VolatileFixup.OnActionRun(Peach.Core.RunContext)">
            <summary>
            Called before an output/call/setProperty action is run.
            Derivations can compute the result of the fixup
            from state stored on the run context.
            </summary>
            <param name="ctx"></param>
            <returns></returns>
        </member>
        <member name="M:Peach.Core.Fixups.VolatileFixup.OnCloned(Peach.Core.Fixup,System.Object)">
            <summary>
            This is needed for cloning with the object copier.
            </summary>
            <param name="original">The original the copy is made from</param>
            <param name="context">The clone context</param>
        </member>
        <member name="T:Peach.Core.FragmentAlgorithm">
            <summary>
            Base class for fragmentation algorithms.  Fragmentation algorithms are used
            in conjunction with the Frag element. They contain the logic for generating
            fragments on output and reassembling fragments on input.
            </summary>
            <remarks>
            To add a new fragmnetaiton algorithm, create a Class Library project in Visual
            Sudio or Mono Develop. Create a new class that extends from this base class
            and implment the required abstract methods.  Build and place output into 
            the Plugins folder.
            
            To debug simply change the debug settings of your project to run Peach.exe along
            with a sample pit. Such as: "peach.exe -1 --debug test.xml".
            </remarks>
        </member>
        <member name="F:Peach.Core.FragmentAlgorithm.Parent">
            <summary>
            Set to Frag element instance associated with current instance of class.
            </summary>
        </member>
        <member name="M:Peach.Core.FragmentAlgorithm.Fragment(Peach.Core.Dom.DataElement,Peach.Core.Dom.DataElement,Peach.Core.Dom.Sequence)">
            <summary>
            Perform fragmentation of payload
            </summary>
            <remarks>
            Perform fragmentation of payload, generating multiple copies of template, one per fragment.
            These fragments are added to the rendering sequence in the correct order.
            
            The template is a container with a child of 'FragData'. The 'FragData' element receives
            the fragments data.
            
            The template data element can be cloned using the 'template.Clone(name)' method.
            Example: <pre>var fragment = template.Clone("Frag_" + cnt);</pre> where cnt is the
            count of fragments.
            
            Method should check FragmentIndexField, FragementOffsetField, FragmentLengthField
            and TotalLengthField and make correct updates to the template clones as needed.
            </remarks>
            <param name="template"></param>
            <param name="payload"></param>
            <param name="rendering"></param>
        </member>
        <member name="M:Peach.Core.FragmentAlgorithm.NeedFragment">
            <summary>
            Check if all fragments are present in rendering sequence.
            </summary>
            <remarks>
            Used on infrag action to determine if all fragments have been received. Returning true will cause
            another input action to occur.
            </remarks>
            <returns>True if more fragments are needed. False if all fragments have been received.</returns>
        </member>
        <member name="M:Peach.Core.FragmentAlgorithm.Reassemble">
            <summary>
            Reassemble fragemnets into payload data
            </summary>
            <remarks>
            Prior to this method being called, NeedFragment must return False.
            
            Make sure to reassemble the fragments in the correct oder.
            
            The returned data stream will be used to crack the Payload.
            </remarks>
            <returns>BitStream instance containing reassembled payload data.</returns>
        </member>
        <member name="M:Peach.Core.IO.BitwiseStream.PadBits">
            <summary>
            Ensures that the data stream length is in full bytes
            by returning a new stream padded with up to 7 bits of '0'
            </summary>
            <returns>Stream of bits padded to a byte boundary</returns>
        </member>
        <member name="M:Peach.Core.IO.BitwiseStream.IndexOf(Peach.Core.IO.BitwiseStream,System.Int64)">
            <summary>
            Reports the position of the first occurrence of the specified BitStream in this
            instance. The search starts at a specified BitStream position.
            </summary>
            <param name="value">The BitStream to seek.</param>
            <param name="offsetBits">The search starting position.</param>
            <returns>
            The zero-based index position of value if that BitStream is found, or -1 if it is not.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offsetBits"/> specifies a position not within this instance.</exception>
        </member>
        <member name="M:Peach.Core.IO.BitwiseStream.GrowTo(System.Int64)">
            <summary>
            Create a new BitwiseSteam be replicating a source BitwiseStream over and over.
            </summary>
            <param name="len">How many bytes long the returned stream should be</param>
            <returns></returns>
        </member>
        <member name="M:Peach.Core.IO.BitwiseStream.GrowToBits(System.Int64)">
            <summary>
            Create a new BitwiseSteam be replicating a source BitwiseStream over and over.
            </summary>
            <param name="len">How many bits long the returned stream should be</param>
            <returns></returns>
        </member>
        <member name="T:Peach.Core.IO.NonClosingStreamWrapper">
            <summary>
            Wraps a stream for all operations except Close and Dispose, which
            merely flush the stream and prevent further operations from being
            carried out using this wrapper.
            </summary>
        </member>
        <member name="M:Peach.Core.IO.NonClosingStreamWrapper.#ctor(System.IO.Stream)">
            <summary>
            Creates a new instance of the class, wrapping the specified stream.
            </summary>
            <param name="stream">The stream to wrap. Must not be null.</param>
            <exception cref="T:System.ArgumentNullException">stream is null</exception>
        </member>
        <member name="P:Peach.Core.IO.NonClosingStreamWrapper.BaseStream">
            <summary>
            Stream wrapped by this wrapper
            </summary>
        </member>
        <member name="F:Peach.Core.IO.NonClosingStreamWrapper.closed">
            <summary>
            Whether this stream has been closed or not
            </summary>
        </member>
        <member name="M:Peach.Core.IO.NonClosingStreamWrapper.CheckClosed">
            <summary>
            Throws an InvalidOperationException if the wrapper is closed.
            </summary>
        </member>
        <member name="M:Peach.Core.IO.NonClosingStreamWrapper.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
            <summary>
            Begins an asynchronous read operation.
            </summary>
            <param name="buffer">The buffer to read the data into. </param>
            <param name="offset">
            The byte offset in buffer at which to begin writing data read from the stream.
            </param>
            <param name="count">The maximum number of bytes to read. </param>
            <param name="callback">
            An optional asynchronous callback, to be called when the read is complete.
            </param>
            <param name="state">
            A user-provided object that distinguishes this particular 
            asynchronous read request from other requests.
            </param>
            <returns>
            An IAsyncResult that represents the asynchronous read, 
            which could still be pending.
            </returns>
        </member>
        <member name="M:Peach.Core.IO.NonClosingStreamWrapper.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
            <summary>
            Begins an asynchronous write operation.
            </summary>
            <param name="buffer">The buffer to write data from.</param>
            <param name="offset">The byte offset in buffer from which to begin writing.</param>
            <param name="count">The maximum number of bytes to write.</param>
            <param name="callback">
            An optional asynchronous callback, to be called when the write is complete.
            </param>
            <param name="state">
            A user-provided object that distinguishes this particular asynchronous 
            write request from other requests.
            </param>
            <returns>
            An IAsyncResult that represents the asynchronous write, 
            which could still be pending.
            </returns>
        </member>
        <member name="P:Peach.Core.IO.NonClosingStreamWrapper.CanRead">
            <summary>
            Indicates whether or not the underlying stream can be read from.
            </summary>
        </member>
        <member name="P:Peach.Core.IO.NonClosingStreamWrapper.CanSeek">
            <summary>
            Indicates whether or not the underlying stream supports seeking.
            </summary>
        </member>
        <member name="P:Peach.Core.IO.NonClosingStreamWrapper.CanWrite">
            <summary>
            Indicates whether or not the underlying stream can be written to.
            </summary>
        </member>
        <member name="M:Peach.Core.IO.NonClosingStreamWrapper.Close">
            <summary>
            This method is not proxied to the underlying stream; instead, the wrapper
            is marked as unusable for other (non-close/Dispose) operations. The underlying
            stream is flushed if the wrapper wasn't closed before this call.
            </summary>
        </member>
        <member name="M:Peach.Core.IO.NonClosingStreamWrapper.CreateObjRef(System.Type)">
            <summary>
            Throws a NotSupportedException.
            </summary>
            <param name="requestedType">The Type of the object that the new ObjRef will reference.</param>
            <returns>n/a</returns>
        </member>
        <member name="M:Peach.Core.IO.NonClosingStreamWrapper.EndRead(System.IAsyncResult)">
            <summary>
            Waits for the pending asynchronous read to complete.
            </summary>
            <param name="asyncResult">
            The reference to the pending asynchronous request to finish.
            </param>
            <returns>
            The number of bytes read from the stream, between zero (0) 
            and the number of bytes you requested. Streams only return 
            zero (0) at the end of the stream, otherwise, they should 
            block until at least one byte is available.
            </returns>
        </member>
        <member name="M:Peach.Core.IO.NonClosingStreamWrapper.EndWrite(System.IAsyncResult)">
            <summary>
            Ends an asynchronous write operation.
            </summary>
            <param name="asyncResult">A reference to the outstanding asynchronous I/O request.</param>
        </member>
        <member name="M:Peach.Core.IO.NonClosingStreamWrapper.Flush">
            <summary>
            Flushes the underlying stream.
            </summary>
        </member>
        <member name="M:Peach.Core.IO.NonClosingStreamWrapper.InitializeLifetimeService">
            <summary>
            Throws a NotSupportedException.
            </summary>
            <returns>n/a</returns>
        </member>
        <member name="P:Peach.Core.IO.NonClosingStreamWrapper.Length">
            <summary>
            Returns the length of the underlying stream.
            </summary>
        </member>
        <member name="P:Peach.Core.IO.NonClosingStreamWrapper.Position">
            <summary>
            Gets or sets the current position in the underlying stream.
            </summary>
        </member>
        <member name="M:Peach.Core.IO.NonClosingStreamWrapper.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Reads a sequence of bytes from the underlying stream and advances the 
            position within the stream by the number of bytes read.
            </summary>
            <param name="buffer">
            An array of bytes. When this method returns, the buffer contains 
            the specified byte array with the values between offset and 
            (offset + count- 1) replaced by the bytes read from the underlying source.
            </param>
            <param name="offset">
            The zero-based byte offset in buffer at which to begin storing the data 
            read from the underlying stream.
            </param>
            <param name="count">
            The maximum number of bytes to be read from the 
            underlying stream.
            </param>
            <returns>The total number of bytes read into the buffer. 
            This can be less than the number of bytes requested if that many 
            bytes are not currently available, or zero (0) if the end of the 
            stream has been reached.
            </returns>
        </member>
        <member name="M:Peach.Core.IO.NonClosingStreamWrapper.ReadByte">
            <summary>
            Reads a byte from the stream and advances the position within the 
            stream by one byte, or returns -1 if at the end of the stream.
            </summary>
            <returns>The unsigned byte cast to an Int32, or -1 if at the end of the stream.</returns>
        </member>
        <member name="M:Peach.Core.IO.NonClosingStreamWrapper.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            Sets the position within the current stream.
            </summary>
            <param name="offset">A byte offset relative to the origin parameter.</param>
            <param name="origin">
            A value of type SeekOrigin indicating the reference 
            point used to obtain the new position.
            </param>
            <returns>The new position within the underlying stream.</returns>
        </member>
        <member name="M:Peach.Core.IO.NonClosingStreamWrapper.SetLength(System.Int64)">
            <summary>
            Sets the length of the underlying stream.
            </summary>
            <param name="value">The desired length of the underlying stream in bytes.</param>
        </member>
        <member name="M:Peach.Core.IO.NonClosingStreamWrapper.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Writes a sequence of bytes to the underlying stream and advances 
            the current position within the stream by the number of bytes written.
            </summary>
            <param name="buffer">
            An array of bytes. This method copies count bytes 
            from buffer to the underlying stream.
            </param>
            <param name="offset">
            The zero-based byte offset in buffer at 
            which to begin copying bytes to the underlying stream.
            </param>
            <param name="count">The number of bytes to be written to the underlying stream.</param>
        </member>
        <member name="M:Peach.Core.IO.NonClosingStreamWrapper.WriteByte(System.Byte)">
            <summary>
            Writes a byte to the current position in the stream and
            advances the position within the stream by one byte.
            </summary>
            <param name="value">The byte to write to the stream. </param>
        </member>
        <member name="T:Peach.Core.IPitSerializable">
            <summary>
            Implemented by items that can be serialized to a Peach Pit format.
            </summary>
        </member>
        <member name="M:Peach.Core.IPitSerializable.WritePit(System.Xml.XmlWriter)">
            <summary>
            Converts object into Pit XML
            </summary>
            <remarks>
            Objects that implement this interface must create their full
            xml representation. This includes calls to WriteElementString.
            </remarks>
            <param name="writer"></param>
        </member>
        <member name="T:Peach.Core.IWeighted">
            <summary>
            Weight to use on random selection.
            </summary>
        </member>
        <member name="P:Peach.Core.IWeighted.SelectionWeight">
            <summary>
            Selection weight used for weighted selection.
            </summary>
        </member>
        <member name="M:Peach.Core.IWeighted.TransformWeight(System.Func{System.Int32,System.Int32})">
            <summary>
            Return transformed weight based on function.
            </summary>
            <param name="how"></param>
            <returns></returns>
        </member>
        <member name="T:Peach.Core.LSFR">
            <summary>
            Linear Shift Feedback Register
            Produces a pseudo random sequence of numbers from 1 to (2^N)-1
            </summary>
        </member>
        <member name="T:Peach.Core.SequenceGenerator">
            <summary>
            Produces a pseudo random sequence of numbers from [1,max]
            </summary>
        </member>
        <member name="T:Peach.Core.Logger">
            <summary>
            A logging mechanism for fuzzing runs.
            </summary>
        </member>
        <member name="M:Peach.Core.Logger.GetLogPath(Peach.Core.RunContext,System.String)">
            <summary>
            Make the actual log path to use based on the run name,
            run time and path parameter.
            </summary>
            <param name="context"></param>
            <param name="path"></param>
            <returns></returns>
        </member>
        <member name="T:Peach.Core.LoggerAttribute">
            <summary>
            Used to indicate a class is a valid Publisher and 
            provide it's invoking name used in the Pit XML file.
            </summary>
        </member>
        <member name="T:Peach.Core.MutationStrategy">
            <summary>
            Mutation strategies drive the fuzzing
            that Peach performs.  Creating a fuzzing
            strategy allows one to fully control which elements
            are mutated, by which mutators, and when.
            </summary>
        </member>
        <member name="M:Peach.Core.MutationStrategy.MutateChangingState(Peach.Core.Dom.State)">
            <summary>
            Allows mutation strategy to affect state change.
            </summary>
            <param name="state"></param>
            <returns></returns>
        </member>
        <member name="M:Peach.Core.MutationStrategy.NextAction(Peach.Core.Dom.State,Peach.Core.Dom.Action,Peach.Core.Dom.Action)">
            <summary>
            Allows mutation strategy to affect state change.
            </summary>
            <param name="state"></param>
            <param name="lastAction"></param>
            <param name="nextAction"></param>
            <returns></returns>
        </member>
        <member name="M:Peach.Core.MutationStrategy.SupportedDataElement(System.Type,Peach.Core.Dom.DataElement)">
            <summary>
            Call supportedDataElement method on Mutator type.
            </summary>
            <param name="mutator"></param>
            <param name="elem"></param>
            <returns>Returns true or false</returns>
        </member>
        <member name="M:Peach.Core.MutationStrategy.SupportedState(System.Type,Peach.Core.Dom.State)">
            <summary>
            Call supportedDataElement method on Mutator type.
            </summary>
            <param name="mutator"></param>
            <param name="elem"></param>
            <returns>Returns true or false</returns>
        </member>
        <member name="M:Peach.Core.MutationStrategy.EnumerateValidMutators">
            <summary>
            Enumerate mutators valid to use in this test.
            </summary>
            <remarks>
            Function checks against included/exluded mutators list.
            </remarks>
            <returns></returns>
        </member>
        <member name="T:Peach.Core.Mutator">
            <summary>
            Base class for Mutators.
            </summary>
            <remarks>
            <para>There are two modes of operation for mutators, state model and data model. State model mutators
            will affect the flow of the state model and actions in the state model. Data model mutators will
            affect the data produced during the current test case.</para>
            
            <para>Your static constructor will correct set the <see cref="F:Peach.Core.Mutator.affectStateModel"/>
            and <see cref="F:Peach.Core.Mutator.affectDataModel"/> variables.
            These static variables determine in which modes your mutator will operate.</para>
            
            <para>The operation of <see cref="F:Peach.Core.Mutator.affectDataModel"/> is as follows:</para>
            
            <list type="number">
            <item>
            During record iterations your supportedDataElement static method
            will be called to check if your mutator supports a specific data element. If true 
            an instance of your mutator will be created with the original instance of the data element
            passed in. For every data element in the model you will be queried and asked and an
            instance created for that specific element.
            </item>
            <item>
            During mutation your sequentialMutation or randomMutation methods
            will get called with a cloned instance of the original data element. Each call to these
            methods will be passed a new cloned instance that can be modified in any way. In face the
            entire model could be modified in any way desired.
            </item>
            </list>
            
            <para>The operation of <see cref="F:Peach.Core.Mutator.affectStateModel"/> is as follows:</para>
            
            <list type="number">
            <item>
            A single instance of your mutator will be created and passed a 
            the original state model instance.
            </item>
            <item>
            During mutation your sequentialMutation or randomMutation methods
            will get called with a cloned instance of the original state model. Each call to these
            methods will be passed a new cloned instance that can be modified in any way.
            </item>
            <item>
            When a changeState action occurs the changeState method is called
            to provide an opportunity to modify the state that will be switched to.
            </item>
            </list>
            </remarks>
        </member>
        <member name="F:Peach.Core.Mutator.affectStateModel">
            <summary>
            Is this mutator able to affect the state model?
            </summary>
            <remarks>
            This static variable should be set through a static constructor in the sub-class.
            </remarks>
        </member>
        <member name="F:Peach.Core.Mutator.affectDataModel">
            <summary>
            Is this mutator able to affect the data model?
            </summary>
            <remarks>
            This static variable should be set through a static constructor in the sub-class.
            </remarks>
        </member>
        <member name="F:Peach.Core.Mutator.context">
            <summary>
            Instance of current mutation strategy
            </summary>
        </member>
        <member name="P:Peach.Core.Mutator.Name">
            <summary>
            The name of the mutator
            </summary>
            <remarks>
            The default implementation of this method returns the class name.
            </remarks>
        </member>
        <member name="M:Peach.Core.Mutator.supportedDataElement(Peach.Core.Dom.DataElement)">
            <summary>
            Check to see if DataElement is supported by this mutator.
            </summary>
            <remarks>
            Custom mutators that mutate data models must implement this method. The mutator
            will only be used to mutate a specific element when it returns true.
            </remarks>
            <param name="obj">DataElement to check</param>
            <returns>True if object is supported, else False</returns>
        </member>
        <member name="P:Peach.Core.Mutator.count">
            <summary>
            Returns the total number of mutations this mutator is able to perform.
            </summary>
            <returns>
            Returns number of mutations mutator can generate.
            </returns>
        </member>
        <member name="P:Peach.Core.Mutator.weight">
            <summary>
            Raw weight this mutator will get chosen in random mutation mode.
            The selection weight will also take into account if the element
            being mutated has a fixup or relation on it.
            </summary>
            <remarks>
            It is recommended that the base class implementation of this property be used.
            </remarks>
        </member>
        <member name="P:Peach.Core.Mutator.mutation">
            <summary>
            Called to set the mutation to return. Applies only to sequential mutation.
            </summary>
            <remarks>
            This value will range form 0 to count. The same mutation number must always
            produce the same mutation form sequencialMutation(). It does not apply to 
            randomMutation.
            </remarks>
        </member>
        <member name="M:Peach.Core.Mutator.sequentialMutation(Peach.Core.Dom.DataElement)">
            <summary>
            Perform a sequential mutation on a data element
            </summary>
            <param name="obj">Instance of DataElement for this specific iteration. Each iteration a new instance
            of the same object is passed in to be modified.</param>
            <remarks>
            This method performs mutation algorithm on a specific
            data element.
            </remarks>
        </member>
        <member name="M:Peach.Core.Mutator.randomMutation(Peach.Core.Dom.DataElement)">
            <summary>
            Perform a random mutation on a data element
            </summary>
            <param name="obj">Instance of DataElement for this specific iteration. Each iteration a new instance
            of the same object is passed in to be modified.</param>
        </member>
        <member name="M:Peach.Core.Mutator.sequentialMutation(Peach.Core.Dom.StateModel)">
            <summary>
            Perform a sequential mutation on state model
            </summary>
            <seealso cref="!:Peach.Core.Mutator.randomMutation(Peach.Core.Dom.StateModel)"/>
            <seealso cref="M:Peach.Core.Mutator.nextAction(Peach.Core.Dom.State,Peach.Core.Dom.Action,Peach.Core.Dom.Action)"/>
            <seealso cref="M:Peach.Core.Mutator.changeState(Peach.Core.Dom.State,Peach.Core.Dom.Action,Peach.Core.Dom.State)"/>
            <param name="model"></param>
        </member>
        <member name="M:Peach.Core.Mutator.randomMutation(Peach.Core.Dom.StateModel)">
            <summary>
            Perform a random mutation on state model.
            </summary>
            <remarks>
            The StateModel object is NOT duplicated. Changes made to the StateModel will
            persist across iterations and affect the entire fuzzing run.
            
            These methods are called to indicate the type of mutation type requested by
            the strategy. They should cause the mutator to produce this type of test case.
            The actual methods that perform the mutation are <c>changeState</c> and <c>changeAction</c>.
            </remarks>
            <seealso cref="!:Peach.Core.Mutator.sequentialMutation(Peach.Core.Dom.StateModel)"/>
            <seealso cref="M:Peach.Core.Mutator.nextAction(Peach.Core.Dom.State,Peach.Core.Dom.Action,Peach.Core.Dom.Action)"/>
            <seealso cref="M:Peach.Core.Mutator.changeState(Peach.Core.Dom.State,Peach.Core.Dom.Action,Peach.Core.Dom.State)"/>
            <param name="model"></param>
        </member>
        <member name="M:Peach.Core.Mutator.changeState(Peach.Core.Dom.State,Peach.Core.Dom.Action,Peach.Core.Dom.State)">
            <summary>
            Allow changing which state we change to.
            </summary>
            <param name="currentState">Currently executing state</param>
            <param name="currentAction">Currently executing action</param>
            <param name="nextState">State we are changing to</param>
            <seealso cref="M:Peach.Core.Mutator.nextAction(Peach.Core.Dom.State,Peach.Core.Dom.Action,Peach.Core.Dom.Action)"/>
            <returns>Returns state to start executing</returns>
        </member>
        <member name="M:Peach.Core.Mutator.nextAction(Peach.Core.Dom.State,Peach.Core.Dom.Action,Peach.Core.Dom.Action)">
            <summary>
            Return the next action to execute.
            </summary>
            <remarks>
            Called to find the next action to execute by the strategy.
            </remarks>
            <param name="state">Currently executing state</param>
            <param name="lastAction">The last action executed or null if first action in state.</param>
            <param name="nextAction"></param>
            <seealso cref="M:Peach.Core.Mutator.changeState(Peach.Core.Dom.State,Peach.Core.Dom.Action,Peach.Core.Dom.State)"/>
            <returns>Next action to execute or null if no more actions available.</returns>
        </member>
        <member name="T:Peach.Core.MutatorAttribute">
            <summary>
            Used to indicate a class is a valid Mutator and 
            provide it's invoking name used in the Pit XML file.
            </summary>
        </member>
        <member name="T:Peach.Core.ITryGetValue`2">
            <summary>
            Simple interface that exposes TryGetValue.
            Useful for generic functions that want to use
            NamedCollection and OrderedDictionary
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="T:Peach.Core.NamedCollection`1">
            <summary>
            A collection of T where order is well defined.
            Provides finding a record by using T.name
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Peach.Core.NamedCollection`1.#ctor">
            <summary>
            Uses typeof(T).Name as the base name when generating unique names.
            </summary>
        </member>
        <member name="M:Peach.Core.NamedCollection`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Uses typeof(T).Name as the base name when generating unique names.
            </summary>
        </member>
        <member name="M:Peach.Core.NamedCollection`1.#ctor(System.String)">
            <summary>
            Specifies the base name to use when generating unique names.
            </summary>
            <param name="baseName"></param>
        </member>
        <member name="M:Peach.Core.NamedCollection`1.UniqueName">
            <summary>
            Return the next unique name that is not in this container.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Peach.Core.NetworkAdapter">
            <summary>
            Helper class to control properties of a network adapter.
            </summary>
        </member>
        <member name="M:Peach.Core.ObjectCopier.Downcast(System.Type,System.Linq.Expressions.Expression,System.Collections.Generic.List{System.Linq.Expressions.ParameterExpression},System.Collections.Generic.List{System.Linq.Expressions.Expression})">
            <summary>
            Downcast obj to type and return typed instance
            </summary>
            <param name="type">Destination type</param>
            <param name="original">Variable to cast</param>
            <param name="vars">List of expression variables</param>
            <param name="exprs">List of expressions</param>
            <returns>Variable of <paramref name="type"/></returns>
        </member>
        <member name="M:Peach.Core.ObjectCopier.GetMethodsWithAttribute(System.Type,System.Type)">
            <summary>
            Returns all methods on type <paramref name="t"/> that are decorated
            with an attribute of type <paramref name="attribute"/>
            </summary>
            <param name="attribute">Type of attribute to match</param>
            <param name="t">Type to search</param>
            <returns>List of methods</returns>
        </member>
        <member name="M:Peach.Core.ObjectCopier.GetFields(System.Type)">
            <summary>
            Returns all serializable fields on type <paramref name="t"/> that
            need to be transferred when cloning.
            </summary>
            <param name="t">Type to search</param>
            <returns>List of fields</returns>
        </member>
        <member name="M:Peach.Core.ObjectCopier.#ctor(System.Type)">
            <summary>
            Construct object cloner expression tree
            </summary>
            <param name="type">Type to compute</param>
        </member>
        <member name="M:Peach.Core.ObjectCopier.CopyComplexType(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Collections.Generic.List{System.Linq.Expressions.Expression})">
            <summary>
            Generates expression list to copy all fields in a complex object.
            </summary>
            <param name="type">Object type</param>
            <param name="original">Source object of type <paramref name="type"/></param>
            <param name="clone">Destination object of type <paramref name="type"/></param>
            <param name="exprs">Expression list to populate</param>
        </member>
        <member name="M:Peach.Core.ObjectCopier.CopyRefType(System.Reflection.FieldInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Collections.Generic.List{System.Linq.Expressions.Expression})">
            <summary>
            Generates expression list to copy a single field in a complex object.
            </summary>
            <param name="fieldInfo">Field to copy</param>
            <param name="original">Source object</param>
            <param name="clone">Destination object</param>
            <param name="exprs">Expression list to populate</param>
        </member>
        <member name="T:Peach.Core.IOwned`1">
            <summary>
            Simple interface for objects that are owned by a parent
            </summary>
            <typeparam name="T">Type of the owner</typeparam>
        </member>
        <member name="P:Peach.Core.IOwned`1.parent">
            <summary>
            Returns the parent of the object
            </summary>
        </member>
        <member name="T:Peach.Core.OwnedCollection`2">
            <summary>
            Collection that contains both named and owned objects.
            Automatically synchronizes the parent property of all items
            to be the owner on insertion and null on removal.
            </summary>
            <typeparam name="TOwner">Thet type of the owner.</typeparam>
            <typeparam name="TObject">The type of the objects to collect.</typeparam>
        </member>
        <member name="M:Peach.Core.OwnedCollection`2.#ctor(`0)">
            <summary>
            Constructs a new OwnedCollection
            </summary>
            <param name="owner">The value to set to the parent property of inserted items.</param>
        </member>
        <member name="M:Peach.Core.OwnedCollection`2.#ctor(`0,System.String)">
            <summary>
            Constructs a new OwnedCollection.
            </summary>
            <param name="owner">The value to set to the parent property of inserted items.</param>
            <param name="baseName">Specifies the base name to use when generating unique names.</param>
        </member>
        <member name="M:Peach.Core.ParameterParser.Parse``1(``0,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Parses a dictionary of arguments, similiar to python kwargs.
            For each parameter attribute on 'T', the appropriate property
            on 'obj' will be set. Eg, given integer parameter 'option1':
            obj.option1 = int.Parse(args["option1"])
            </summary>
            <typeparam name="T">Class type</typeparam>
            <param name="obj">Instance of class T</param>
            <param name="args">Dictionary of arguments</param>
        </member>
        <member name="M:Peach.Core.ParameterParser.Parse``1(``0,System.Collections.Generic.Dictionary{System.String,Peach.Core.Variant})">
            <summary>
            Parses a dictionary of arguments, similiar to python kwargs.
            For each parameter attribute on 'T', the appropriate property
            on 'obj' will be set. Eg, given integer parameter 'option1':
            obj.option1 = int.Parse(args["option1"])
            </summary>
            <typeparam name="T">Class type</typeparam>
            <param name="obj">Instance of class T</param>
            <param name="args">Dictionary of arguments</param>
        </member>
        <member name="M:Peach.Core.ParameterParser.FromString(System.Type,Peach.Core.ParameterAttribute,System.String)">
            <summary>
            Will convert a string value to the type described in the ParameterAttribute.
            If an appropriate conversion function can not be found, this function will
            look for a static method on 'type' to perform the conversion.  For example,
            if the attribute type was class 'SomeClass', the function signature would be:
            static void Parse(string str, out SomeClass val)
            
            If the value is string.Empty and the destination type is nullable, the value
            null will be returned.
            </summary>
            <param name="type">Object type that is decorated with the Parameter attribute.</param>
            <param name="attr">Parameter attribute describing the destination type.</param>
            <param name="value">String value to convert.</param>
            <returns></returns>
        </member>
        <member name="T:Peach.Core.PeachException">
            <summary>
            Unrecoverable error.  Causes Peach to exit with an error
            message, but no stack trace.
            </summary>
        </member>
        <member name="T:Peach.Core.SoftException">
            <summary>
            Thrown to stop current test case and move to next.
            </summary>
            <remarks>
            Used to indicate an error that should stop the current test case, but not the fuzzing job.
            </remarks>
        </member>
        <member name="T:Peach.Core.AgentException">
            <summary>
            Thrown when peach catches an exception from an agent.
            </summary>
        </member>
        <member name="T:Peach.Core.FaultException">
            <summary>
            Thrown to indicate a fault has occured.
            </summary>
            <remarks>
            This exception can be thrown by Publishers or Scripting code to
            indicate a fault has occured.  The exception extends from
            SoftException, so normal cleanup code will run when this exception
            is thrown.
            </remarks>
        </member>
        <member name="T:Peach.Core.PitParsableAttribute">
            <summary>
            Indicate a class implements methods required
            to support PIT Parsing.
            </summary>
            <remarks>
            Any type that is marked with this attribute must implement
            the following methods:
            
            public static DataElement PitParser(PitParser context, XmlNode node, DataElementContainer parent)
            
            If unable to parse the current XML, just return null.
            </remarks>
        </member>
        <member name="P:Peach.Core.PitParsableAttribute.xmlElementName">
            <summary>
            XML element name that corresponds to this type.
            </summary>
        </member>
        <member name="P:Peach.Core.PitParsableAttribute.topLevel">
            <summary>
            Is this a top level XML element.
            </summary>
        </member>
        <member name="M:Peach.Core.PitParsableAttribute.#ctor(System.String)">
            <summary>
            Indicate a class implements methods required
            to support PIT Parsing.
            </summary>
            <param name="xmlElementName">XML element name that corresponds to this type.</param>
        </member>
        <member name="T:Peach.Core.Platform">
            <summary>
            Helper class to determine the OS/Platform we are on.  The built in 
            method returns incorrect results.
            </summary>
        </member>
        <member name="M:Peach.Core.Process.Stop(System.Int32)">
            <summary>
            Attempt to gracefully stop the process.
            If the process does not gracefully stop after timeout milliseconds,
            forcibly terminate the process.
            </summary>
            <param name="timeout"></param>
        </member>
        <member name="M:Peach.Core.Process.Dispose">
            <summary>
            Closes all open process resources.
            If the process was started by us, it will be killed.
            If the process was attached, it will continue to run.
            </summary>
        </member>
        <member name="T:Peach.Core.Publisher">
            <summary>
            Publishers are I/O interfaces called by actions in the state model. They
            perform stream or call based interactions with external entities.
            </summary>
            <remarks>
            Publishers are I/O interfaces for Peach.  They glue the actions
            in a state model to the target interface.  Publishers can be 
            stream based such as files or sockets, and also call based like
            COM and shared libraries.  They can also be hybrids using both
            stream and call based methods to make more complex publishers.
            
            Multiple publishers can be used in a single state model to allow
            for more complex operations such as writing to the registry and
            then calling an RPC method.
            
            Custom publishers should implement the methods prefixed with "On"
            such as OnStart, OnOpen and OnInput. Additionally they should
            the Stream interface as needed if they will support the
            input action.
            </remarks>
        </member>
        <member name="P:Peach.Core.Publisher.Name">
            <summary>
            The name of the publisher.
            </summary>
        </member>
        <member name="P:Peach.Core.Publisher.Iteration">
            <summary>
            Gets/sets the current fuzzing iteration.
            </summary>
        </member>
        <member name="P:Peach.Core.Publisher.IsControlIteration">
            <summary>
            Gets/sets if the current iteration is a control iteration.
            </summary>
        </member>
        <member name="P:Peach.Core.Publisher.IsIterationAfterFault">
            <summary>
            Is iteration after a fault has occured?
            </summary>
        </member>
        <member name="P:Peach.Core.Publisher.IsControlRecordingIteration">
            <summary>
            Is control record iteration?
            </summary>
        </member>
        <member name="M:Peach.Core.Publisher.OnStart">
            <summary>
            Called when the publisher is started.  This method will be called
            once per fuzzing "Session", not on every iteration.
            </summary>
            <remarks>
            This method can be overriden by custom Publishers.
            
            For Publishers that will listen for incoming connections, this is a good
            place to bind to a port, then perform the blocking accept in the OnAccept
            method.
            </remarks>
            <seealso cref="M:Peach.Core.Publisher.OnStop"/>
        </member>
        <member name="M:Peach.Core.Publisher.OnStop">
            <summary>
            Called when the publisher is stopped.  This method will be called
            once per fuzzing "Session", not on every iteration.
            </summary>
            <remarks>
            This method can be overriden by custom Publishers.
            </remarks>
            <seealso cref="M:Peach.Core.Publisher.OnStart"/>
        </member>
        <member name="M:Peach.Core.Publisher.OnOpen">
            <summary>
            Open or connect to a resource.  Will be called
            automatically if not called specifically.
            </summary>
            <remarks>
            This method can be overriden by custom Publishers.
            
            OnOpen will automatically get called if an input or output action
            is performed from the state model. In the case where only a call
            action is performed, there is no automatic open or close.
            </remarks>
            <seealso cref="M:Peach.Core.Publisher.OnClose"/>
        </member>
        <member name="M:Peach.Core.Publisher.OnClose">
            <summary>
            Close a resource.  Will be called automatically when
            state model exists.  Can also be called explicitly when
            needed.
            </summary>
            <remarks>
            This method can be overriden by custom Publishers.
            
            This method will not be called unless OnOpen has also been called.
            OnOpen will automatically get called if an input or output action
            is performed from the state model. In the case where only a call
            action is performed, there is no automatic open or close.
            </remarks>
            <seealso cref="M:Peach.Core.Publisher.OnOpen"/>
        </member>
        <member name="M:Peach.Core.Publisher.OnAccept">
            <summary>
            Accept an incoming connection.
            </summary>
            <remarks>
            This method can be overriden by custom Publishers.
            </remarks>
        </member>
        <member name="M:Peach.Core.Publisher.OnCall(System.String,System.Collections.Generic.List{Peach.Core.Dom.ActionParameter})">
            <summary>
            Call a method on the Publishers resource using data models.
            </summary>
            <remarks>
            This method can be overriden by custom Publishers.
            </remarks>
            <param name="method">Name of method to call</param>
            <param name="args">Arguments to pass</param>
            <returns>Returns resulting data</returns>
        </member>
        <member name="M:Peach.Core.Publisher.OnCall(System.String,System.Collections.Generic.List{Peach.Core.IO.BitwiseStream})">
            <summary>
            Call a method on the Publishers resource using data model values.
            </summary>
            <remarks>
            This method can be overriden by custom Publishers.
            </remarks>
            <param name="method">Name of method to call</param>
            <param name="args">Arguments to pass</param>
            <returns>Returns resulting data</returns>
        </member>
        <member name="M:Peach.Core.Publisher.OnSetProperty(System.String,Peach.Core.Variant)">
            <summary>
            Set a property on the Publishers resource.
            </summary>
            <remarks>
            This method can be overriden by custom Publishers.
            </remarks>
            <seealso cref="M:Peach.Core.Publisher.setProperty(System.String,Peach.Core.Variant)" />
            <seealso cref="M:Peach.Core.Publisher.OnGetProperty(System.String)" />
            <param name="property">Name of property to set</param>
            <param name="value">Value to set on property</param>
        </member>
        <member name="M:Peach.Core.Publisher.OnGetProperty(System.String)">
            <summary>
            Get value of a property exposed by Publishers resource
            </summary>
            <remarks>
            This method can be overriden by custom Publishers.
            </remarks>
            <seealso cref="M:Peach.Core.Publisher.getProperty(System.String)" />
            <seealso cref="M:Peach.Core.Publisher.OnSetProperty(System.String,Peach.Core.Variant)" />
            <param name="property">Name of property</param>
            <returns>Returns value of property</returns>
        </member>
        <member name="M:Peach.Core.Publisher.OnOutput(Peach.Core.Dom.DataModel)">
            <summary>
            Send data
            </summary>
            <remarks>
            This method can be overriden by custom Publishers.
            </remarks>
            <seealso cref="M:Peach.Core.Publisher.OnInput"/>
            <param name="dataModel">Data to send/write</param>
        </member>
        <member name="M:Peach.Core.Publisher.OnOutput(Peach.Core.IO.BitwiseStream)">
            <summary>
            Send data
            </summary>
            <remarks>
            This method can be overriden by custom Publishers.
            </remarks>
            <seealso cref="M:Peach.Core.Publisher.OnInput"/>
            <param name="data">Data to send/write</param>
        </member>
        <member name="M:Peach.Core.Publisher.OnInput">
            <summary>
            Read data
            </summary>
            <remarks>
            This method can be overriden by custom Publishers.
            
            The following chain of method calls will occour when an input action is performed:
            
            <list type="number">
            	<item>
            		OnInput() is called when an input action occurs. For publishers that can read a complete
            		peice of data with out any indication of how much data must be read can do so at this time.
            		An example of this is UDP based protocols in which an entire packet can be read. Typically
            		stream based publishers cannot read data at this time and should instead implement
            		WantBytes.
            	</item>
            	<item>
            		Cracking of input data model will commence resulting in the following method calls:
            		
            		<list type="number">
            			<item>WantBytes(count) is called when the cracker needs additional data. Custom publishers should perform blocking reads here.</item>
            			<item>read() is called on the stream interface as needed to read from buffered data.</item>
            			<item>These steps repeat until cracking has completed or no more data can be read.</item>
            		</list>
            	</item>
            	<item>Input action has completed.</item>
            </list>
            </remarks>
            <seealso cref="M:Peach.Core.Publisher.OnOutput(Peach.Core.IO.BitwiseStream)"/>
        </member>
        <member name="M:Peach.Core.Publisher.start">
            <summary>
            Called to Start publisher. To implement override the OnStart method.
            </summary>
            <remarks>
            This action is always performed
            even if not specifically called.  This method will be called
            once per fuzzing "Session", not on every iteration.
            
            This method is part of the base class. When implenting a custom Publisher 
            the OnStart method can be overriden to implement functionality that should
            occur when this method is called.
            </remarks>
            <seealso cref="M:Peach.Core.Publisher.OnStart"/>
        </member>
        <member name="M:Peach.Core.Publisher.stop">
            <summary>
            Called to Stop publisher.  This action is always performed
            even if not specifically called.  This method will be called
            once per fuzzing "Session", not on every iteration.
            </summary>
            <remarks>
            This method is part of the base class. When implenting a custom Publisher 
            the OnStop method can be overriden to implement functionality that should
            occur when this method is called.
            </remarks>
            <seealso cref="M:Peach.Core.Publisher.OnStop"/>
        </member>
        <member name="M:Peach.Core.Publisher.accept">
            <summary>
            Accept an incoming connection.
            </summary>
            <remarks>
            This method is part of the base class. When implenting a custom Publisher 
            the OnAccept method can be overriden to implement functionality that should
            occur when this method is called.
            </remarks>
            <seealso cref="M:Peach.Core.Publisher.OnAccept"/>
        </member>
        <member name="M:Peach.Core.Publisher.open">
            <summary>
            Open or connect to a resource.  Will be called
            automatically if not called specifically.
            </summary>
            <remarks>
            This method is part of the base class. When implenting a custom Publisher 
            the OnOpen method can be overriden to implement functionality that should
            occur when this method is called.
            </remarks>
            <seealso cref="M:Peach.Core.Publisher.OnOpen"/>
            <seealso cref="M:Peach.Core.Publisher.close"/>
        </member>
        <member name="M:Peach.Core.Publisher.close">
            <summary>
            Close a resource.  Will be called automatically when
            state model exists.  Can also be called explicitly when
            needed.
            </summary>
            <remarks>
            This method is part of the base class. When implenting a custom Publisher 
            the OnClose method can be overriden to implement functionality that should
            occur when this method is called.
            </remarks>
            <seealso cref="M:Peach.Core.Publisher.OnClose"/>
            <seealso cref="M:Peach.Core.Publisher.open"/>
        </member>
        <member name="M:Peach.Core.Publisher.call(System.String,System.Collections.Generic.List{Peach.Core.IO.BitwiseStream})">
            <summary>
            Call a method on the Publishers resource
            </summary>
            <remarks>
            This method is part of the base class. When implenting a custom Publisher 
            the OnCall method can be overriden to implement functionality that should
            occur when this method is called.
            </remarks>
            <seealso cref="!:Peach.Core.Publisher.OnCall(string, System.Collections.Generic.List`Peach.Core.IO.BitwiseStream)"/>
            <param name="method">Name of method to call</param>
            <param name="args">Arguments to pass</param>
            <returns>Returns resulting data</returns>
        </member>
        <member name="M:Peach.Core.Publisher.setProperty(System.String,Peach.Core.Variant)">
            <summary>
            Set a property on the Publishers resource.
            </summary>
            <remarks>
            This method is part of the base class. When implenting a custom Publisher 
            the OnSetProperty method can be overriden to implement functionality that should
            occur when this method is called.
            </remarks>
            <seealso cref="M:Peach.Core.Publisher.OnSetProperty(System.String,Peach.Core.Variant)"/>
            <seealso cref="M:Peach.Core.Publisher.getProperty(System.String)"/>
            <param name="property">Name of property to set</param>
            <param name="value">Value to set on property</param>
        </member>
        <member name="M:Peach.Core.Publisher.getProperty(System.String)">
            <summary>
            Get value of a property exposed by Publishers resource
            </summary>
            <remarks>
            This method is part of the base class. When implenting a custom Publisher 
            the OnGetProperty method can be overriden to implement functionality that should
            occur when this method is called.
            </remarks>
            <seealso cref="M:Peach.Core.Publisher.OnGetProperty(System.String)"/>
            <seealso cref="M:Peach.Core.Publisher.setProperty(System.String,Peach.Core.Variant)"/>
            <param name="property">Name of property</param>
            <returns>Returns value of property</returns>
        </member>
        <member name="M:Peach.Core.Publisher.output(Peach.Core.IO.BitwiseStream)">
            <summary>
            Send data
            </summary>
            <remarks>
            This method is part of the base class. When implenting a custom Publisher 
            the OnOutput method can be overriden to implement functionality that should
            occur when this method is called.
            </remarks>
            <seealso cref="M:Peach.Core.Publisher.OnOutput(Peach.Core.IO.BitwiseStream)"/>
            <seealso cref="M:Peach.Core.Publisher.input"/>
            <param name="data">Data to send/write</param>
        </member>
        <member name="M:Peach.Core.Publisher.input">
            <summary>
            Read data
            </summary>
            <remarks>
            This method is part of the base class. When implenting a custom Publisher 
            the OnInput method can be overriden to implement functionality that should
            occur when this method is called.
            </remarks>
            <seealso cref="M:Peach.Core.Publisher.OnInput"/>
            <seealso cref="!:Peach.Core.Publisher.output(Peach.Core.IO.BitwiseStream)"/>
        </member>
        <member name="M:Peach.Core.Publisher.WantBytes(System.Int64)">
            <summary>
            Blocking stream based publishers override this to wait
            for a certian amount of bytes to be available for reading.
            </summary>
            <remarks>
            This method can be overriden by custom Publishers.
            
            The following chain of method calls will occour when an input action is performed:
            
            <list type="number">
            	<item>
            		OnInput() is called when an input action occurs. For publishers that can read a complete
            		peice of data with out any indication of how much data must be read can do so at this time.
            		An example of this is UDP based protocols in which an entire packet can be read. Typically
            		stream based publishers cannot read data at this time and should instead implement
            		WantBytes.
            	</item>
            	<item>
            		Cracking of input data model will commence resulting in the following method calls:
            		
            		<list type="number">
            			<item>WantBytes(count) is called when the cracker needs additional data. Custom publishers should perform blocking reads here.</item>
            			<item>read() is called on the stream interface as needed to read from buffered data.</item>
            			<item>These steps repeat until cracking has completed or no more data can be read.</item>
            		</list>
            	</item>
            	<item>Input action has completed.</item>
            </list>
            </remarks>
            <param name="count">The requested byte count</param>
        </member>
        <member name="M:Peach.Core.Publisher.output(Peach.Core.Dom.DataModel)">
            <summary>
            Send data model
            </summary>
            <remarks>
            This method is part of the base class. When implenting a custom Publisher 
            the OnOutput method can be overriden to implement functionality that should
            occur when this method is called.
            </remarks>
            <seealso cref="M:Peach.Core.Publisher.OnOutput(Peach.Core.Dom.DataModel)"/>
            <param name="dataModel">DataModel to send/write</param>
        </member>
        <member name="M:Peach.Core.Publisher.call(System.String,System.Collections.Generic.List{Peach.Core.Dom.ActionParameter})">
            <summary>
            Call a method on the Publishers resource
            </summary>
            <remarks>
            This method is part of the base class. When implenting a custom Publisher 
            the OnCall method can be overriden to implement functionality that should
            occur when this method is called.
            </remarks>
            <seealso cref="!:Peach.Core.Publisher.OnCall(string, System.Collections.Generic.List`Peach.Core.Dom.ActionParameter)"/>
            <param name="method">Name of method to call</param>
            <param name="args">Arguments to pass</param>
            <returns>Returns resulting data</returns>
        </member>
        <member name="P:Peach.Core.Publisher.CanRead">
            <summary>
            Can stream be read from.
            </summary>
            <remarks>
            This method is part of the Stream interface that is implemented as part of the Publisher interface.
            Custom publishers should implement this property.
            
            Typically this property is implemented by exposing the internal buffer's own stream operations.
            
            <code>
            private MemoryStream _buffer;
            
            public override bool CanRead { get { lock(_buffer) { return _buffer.CanRead; } } }
            </code>
            </remarks>
        </member>
        <member name="P:Peach.Core.Publisher.CanSeek">
            <summary>
            Can seek in buffer.
            </summary>
            <remarks>
            This method is part of the Stream interface that is implemented as part of the Publisher interface.
            Custom publishers should implement this property.
            
            Typically this property is implemented by exposing the internal buffer's own stream operations.
            
            <code>
            private MemoryStream _buffer;
            
            public override bool CanSeek { get { lock(_buffer) { return _buffer.CanSeek; } } }
            </code>
            </remarks>
        </member>
        <member name="P:Peach.Core.Publisher.CanWrite">
            <summary>
            Can stream be written to.
            </summary>
            <remarks>
            This method is part of the Stream interface that is implemented as part of the Publisher interface.
            Custom publishers should implement this property.
            
            Typically this property is implemented by exposing the internal buffer's own stream operations.
            
            <code>
            private MemoryStream _buffer;
            
            public override bool CanWrite { get { lock(_buffer) { return _buffer.CanWrite; } } }
            </code>
            </remarks>
        </member>
        <member name="M:Peach.Core.Publisher.Flush">
            <summary>
            Flush stream
            </summary>
            <remarks>
            This method is part of the Stream interface that is implemented as part of the Publisher interface.
            Custom publishers should implement this method.
            
            Typically this property is implemented by exposing the internal buffer's own stream operations.
            
            <code>
            private MemoryStream _buffer;
            
            public override void Flush { lock(_buffer) { _buffer.Flush(); } }
            </code>
            </remarks>
        </member>
        <member name="P:Peach.Core.Publisher.Length">
            <summary>
            Length of stream in bytes.
            </summary>
            <remarks>
            This method is part of the Stream interface that is implemented as part of the Publisher interface.
            Custom publishers should implement this property.
            
            Typically this property is implemented by exposing the internal buffer's own stream operations.
            
            <code>
            private MemoryStream _buffer;
            
            public override long Length { get { lock(_buffer) { return _buffer.Length; } } }
            </code>
            </remarks>
        </member>
        <member name="P:Peach.Core.Publisher.Position">
            <summary>
            Current position in stream
            </summary>
            <remarks>
            This method is part of the Stream interface that is implemented as part of the Publisher interface.
            Custom publishers should implement this property.
            
            Typically this property is implemented by exposing the internal buffer's own stream operations.
            
            <code>
            private MemoryStream _buffer;
            
            public override long Position { get { lock(_buffer) { return _buffer.Position; } } }
            </code>
            </remarks>
        </member>
        <member name="M:Peach.Core.Publisher.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Read data from stream.
            </summary>
            <remarks>
            This method is part of the Stream interface that is implemented as part of the Publisher interface.
            Custom publishers must implement this method.
            
            Typically this property is implemented by exposing the internal buffer's own stream operations.
            
            <code>
            private MemoryStream _buffer;
            
            public override int Read(byte[] buffer, int offset, int count)
            {
            	lock(_buffer)
            	{
            		return _buffer.Read(buffer, offset, count);
            	}
            }
            </code>
            </remarks>
        </member>
        <member name="M:Peach.Core.Publisher.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            Seek to position in stream.
            </summary>
            <remarks>
            This method is part of the Stream interface that is implemented as part of the Publisher interface.
            Custom publishers must implement this method.
            
            Typically this property is implemented by exposing the internal buffer's own stream operations.
            
            <code>
            private MemoryStream _buffer;
            
            public override long Seek(long offset, SeekOrigin origin)
            {
            	lock(_buffer)
            	{
            		return _buffer.Seek(offset, origin);
            	}
            }
            </code>
            </remarks>
        </member>
        <member name="M:Peach.Core.Publisher.SetLength(System.Int64)">
            <summary>
            Set length of stream.
            </summary>
            <remarks>
            This method is part of the Stream interface that is implemented as part of the Publisher interface.
            Custom publishers can implement this method.
            
            Typically this property is implemented by exposing the internal buffer's own stream operations.
            
            <code>
            private MemoryStream _buffer;
            
            public override int SetLength(long value)
            {
            	lock(_buffer)
            	{
            		return _buffer.SetLength(value);
            	}
            }
            </code>
            </remarks>
        </member>
        <member name="M:Peach.Core.Publisher.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            This method is not currently used.
            </summary>
            <remarks>
            This method is part of the Stream interface that is implemented as part of the Publisher interface.
            Custom publishers should not implement this method.
            </remarks>
        </member>
        <member name="T:Peach.Core.PublisherAttribute">
            <summary>
            Used to indicate a class is a valid Publisher and 
            provide it's invoking name used in the Pit XML file.
            </summary>
        </member>
        <member name="T:Peach.Core.Publishers.BufferedStreamPublisher">
            <summary>
            Helper class for creating stream based publishers.
            This class is used when the publisher implementation
            has a non-seekable stream interface.
            
            Most derived classes should only need to override OnOpen()
            and in the implementation open _client and call StartClient()
            to begin async reads from _client to _buffer.
            </summary>
        </member>
        <member name="P:Peach.Core.Publishers.BufferedStreamPublisher.ReadAvailableMode">
            <summary>
            Special mode in which Input will wait for a single byte with Timeout timeout,
            but keep reading any available data after that till a timeout of 250 ms
            </summary>
        </member>
        <member name="M:Peach.Core.Publishers.BufferedStreamPublisher.HandleReadCompleted">
            <summary>
            Called by OnReadComplete after new data added to buffer.
            </summary>
            <remarks>
            Allows children to perform initial processing of data
            if needed.
            </remarks>
        </member>
        <member name="M:Peach.Core.Publishers.BufferedStreamPublisher.ReadAllAvailable">
            <summary>
            Continue reading data until no data is received for 150 ms
            </summary>
        </member>
        <member name="T:Peach.Core.Publishers.Can.BaseCanDriver">
            <summary>
            Base class for CAN Drivers.  Provides some skafolding for
            patterns same across all drivers.
            </summary>
        </member>
        <member name="F:Peach.Core.Publishers.Can.BaseCanDriver._canFrameReceivedHandlers">
            <summary>
            Store registered event handlers with a CAN ID filter
            </summary>
        </member>
        <member name="M:Peach.Core.Publishers.Can.BaseCanDriver.OpenImpl">
            <summary>
            Children must implement this method instead of Open()
            </summary>
        </member>
        <member name="M:Peach.Core.Publishers.Can.BaseCanDriver.CloseImpl">
            <summary>
            Children must implement this method instead of Close()
            </summary>
        </member>
        <member name="M:Peach.Core.Publishers.Can.BaseCanDriver.AddLogMessage(System.DateTime,System.String,System.Exception)">
            <summary>
            Add a log message to the log message queue
            </summary>
            <param name="when">When message occured</param>
            <param name="msg">Log message</param>
            <param name="e">Optional exception</param>
        </member>
        <member name="M:Peach.Core.Publishers.Can.BaseCanDriver.NotifyCanFrameReceivedHandlers(Peach.Core.Publishers.Can.CanFrame)">
            <summary>
            Notify any registered handlers for this specific CAN ID.
            Notifications occur in a Task to not block
            </summary>
            <param name="msg"></param>
        </member>
        <member name="M:Peach.Core.Publishers.Can.BaseCanDriver.RegisterCanFrameErrorReceiveHandler(Peach.Core.Publishers.Can.CanRxEventHandler)">
            <inheritdoc />
        </member>
        <member name="M:Peach.Core.Publishers.Can.BaseCanDriver.UnRegisterCanFrameErrorReceiveHandler(Peach.Core.Publishers.Can.CanRxEventHandler)">
            <inheritdoc />
        </member>
        <member name="M:Peach.Core.Publishers.Can.BaseCanDriver.RegisterCanFrameReceiveHandler(System.UInt32,Peach.Core.Publishers.Can.CanRxEventHandler)">
            <inheritdoc />
        </member>
        <member name="M:Peach.Core.Publishers.Can.BaseCanDriver.RegisterCanFrameReceiveHandler(System.UInt32[],Peach.Core.Publishers.Can.CanRxEventHandler)">
            <inheritdoc />
        </member>
        <member name="M:Peach.Core.Publishers.Can.BaseCanDriver.UnRegisterCanFrameReceiveHandler(System.UInt32,Peach.Core.Publishers.Can.CanRxEventHandler)">
            <inheritdoc />
        </member>
        <member name="M:Peach.Core.Publishers.Can.BaseCanDriver.UnRegisterCanFrameReceiveHandler(System.UInt32[],Peach.Core.Publishers.Can.CanRxEventHandler)">
            <inheritdoc />
        </member>
        <member name="M:Peach.Core.Publishers.Can.BaseCanDriver.UnixTimeStampToDateTime(System.Double)">
            <summary>
            Convert unix timestamp to DateTime
            </summary>
            <param name="unixTimeStamp"></param>
            <returns></returns>
        </member>
        <member name="M:Peach.Core.Publishers.Can.CanDriverAttribute.#ctor(System.String)">
            <summary>
            Mark CAN bus drivers
            </summary>
            <param name="name">Display name of driver</param>
        </member>
        <member name="T:Peach.Core.Publishers.Can.CanDrivers">
            <summary>
            Helper class for finding CAN drivers
            </summary>
        </member>
        <member name="T:Peach.Core.Publishers.Can.ICanDriver">
            <summary>
            Driver for a specific can interface.
            Implemented by drivers to support different vendors stuff.
            </summary>
        </member>
        <member name="P:Peach.Core.Publishers.Can.ICanDriver.Name">
            <summary>
            Name of driver. Must match CanDriver attribute.
            </summary>
        </member>
        <member name="P:Peach.Core.Publishers.Can.ICanDriver.Parameters">
            <summary>
            Parameters for this driver
            </summary>
        </member>
        <member name="M:Peach.Core.Publishers.Can.ICanDriver.CreateInterface(System.Collections.Generic.Dictionary{System.String,Peach.Core.Variant})">
            <summary>
            Create an interface using supplied arguments
            </summary>
            <remarks>
            Same format as publisher contructors.
            Must provide all required arguments as defined by Parameters property.
            </remarks>
            <param name="args">Arguments dictionary</param>
            <returns></returns>
        </member>
        <member name="T:Peach.Core.Publishers.Can.ICanChannel">
            <summary>
            CAN channel.  Interfaces have one or more channel.
            </summary>
        </member>
        <member name="P:Peach.Core.Publishers.Can.ICanChannel.Id">
            <summary>
            Integer identifier starting at 1 for channel.
            </summary>
        </member>
        <member name="P:Peach.Core.Publishers.Can.ICanChannel.Name">
            <summary>
            Human display name for channel.
            </summary>
        </member>
        <member name="P:Peach.Core.Publishers.Can.ICanChannel.IsEnabled">
            <summary>
            Enable or disable channel.
            </summary>
        </member>
        <member name="P:Peach.Core.Publishers.Can.ICanChannel.BaudRate">
            <summary>
            Baudrate for channel
            </summary>
        </member>
        <member name="P:Peach.Core.Publishers.Can.ICanChannel.Capturing">
            <summary>
            Capture all frames received on this channel.
            Used by CanCaptureMonitor
            </summary>
        </member>
        <member name="T:Peach.Core.Publishers.Can.CanRxEventHandler">
            <summary>
            Deligate for handling received CAN frames
            </summary>
            <param name="sender">Instance of ICanInterface receiving frame</param>
            <param name="frame">Frame received</param>
        </member>
        <member name="T:Peach.Core.Publishers.Can.ICanInterface">
            <summary>
            CAN interface
            </summary>
        </member>
        <member name="P:Peach.Core.Publishers.Can.ICanInterface.Channels">
            <summary>
            Channels available through interface
            </summary>
        </member>
        <member name="P:Peach.Core.Publishers.Can.ICanInterface.Capture">
            <summary>
            Return all captured frames
            </summary>
        </member>
        <member name="P:Peach.Core.Publishers.Can.ICanInterface.MonitorFrameIds">
            <summary>
            Monitors register frame id's being monitored.
            </summary>
            <remarks>
            This allows validation that we are not fuzzing the same id's
            causing the monitors themselves to be fuzzed.
            </remarks>
        </member>
        <member name="M:Peach.Core.Publishers.Can.ICanInterface.ValidateTxId(System.UInt32)">
            <summary>
            Validate a transmit frame id hasn't been registered by a monitor.
            Throws an exception if it has been.
            </summary>
            <param name="id">Frame ID to check</param>
        </member>
        <member name="P:Peach.Core.Publishers.Can.ICanInterface.IsOpen">
            <summary>
            Is interface in open state?  
            </summary>
        </member>
        <member name="M:Peach.Core.Publishers.Can.ICanInterface.Open">
            <summary>
            Open interface
            </summary>
        </member>
        <member name="M:Peach.Core.Publishers.Can.ICanInterface.Close">
            <summary>
            Close interface
            </summary>
        </member>
        <member name="M:Peach.Core.Publishers.Can.ICanInterface.RegisterCanFrameErrorReceiveHandler(Peach.Core.Publishers.Can.CanRxEventHandler)">
            <summary>
            Register a handler to receive CAN frame with error flag set
            </summary>
            <param name="handler">Handler method</param>
        </member>
        <member name="M:Peach.Core.Publishers.Can.ICanInterface.UnRegisterCanFrameErrorReceiveHandler(Peach.Core.Publishers.Can.CanRxEventHandler)">
            <summary>
            Un-register a CAN Frame Error Received handler
            </summary>
            <param name="handler">Handler method</param>
        </member>
        <member name="M:Peach.Core.Publishers.Can.ICanInterface.RegisterCanFrameReceiveHandler(System.UInt32,Peach.Core.Publishers.Can.CanRxEventHandler)">
            <summary>
            Register a CAN Frame Received handler with an CAN Frame ID filter.
            </summary>
            <param name="id">CAN Frame IDs</param>
            <param name="handler">Handler method</param>
        </member>
        <member name="M:Peach.Core.Publishers.Can.ICanInterface.RegisterCanFrameReceiveHandler(System.UInt32[],Peach.Core.Publishers.Can.CanRxEventHandler)">
            <summary>
            Register a CAN Frame Received handler with an CAN Frame ID filter.
            </summary>
            <param name="ids">One or more CAN Frame IDs</param>
            <param name="handler">Handler method</param>
        </member>
        <member name="M:Peach.Core.Publishers.Can.ICanInterface.UnRegisterCanFrameReceiveHandler(System.UInt32,Peach.Core.Publishers.Can.CanRxEventHandler)">
            <summary>
            Un-register a CAN Frame Received handler with an CAN Frame ID filter.
            </summary>
            <param name="id">CAN Frame IDs</param>
            <param name="handler">Handler method</param>
        </member>
        <member name="M:Peach.Core.Publishers.Can.ICanInterface.UnRegisterCanFrameReceiveHandler(System.UInt32[],Peach.Core.Publishers.Can.CanRxEventHandler)">
            <summary>
            Unregister a CAN Frame Received handler with an CAN Frame ID filter.
            </summary>
            <param name="ids">One or more CAN Frame IDs</param>
            <param name="handler">Handler method</param>
        </member>
        <member name="M:Peach.Core.Publishers.Can.ICanInterface.ReadMessage">
            <summary>
            Read single CAN frame
            </summary>
            <returns>Frame or null if no frames are available.</returns>
        </member>
        <member name="M:Peach.Core.Publishers.Can.ICanInterface.WriteMessage(Peach.Core.Publishers.Can.ICanChannel,Peach.Core.Publishers.Can.CanFrame)">
            <summary>
            Write CAN frame to bus
            </summary>
            <param name="txChannel">Channel to transmit frame on</param>
            <param name="frame">Frame instance to send</param>
        </member>
        <member name="M:Peach.Core.Publishers.Can.ICanInterface.GetLogMessage">
            <summary>
            Get a log frame (if supported).
            </summary>
            <remarks>
            This allows the driver to provide messages/errors
            </remarks>
            <returns></returns>
        </member>
        <member name="M:Peach.Core.Publishers.Can.ICanInterface.StartCapture">
            <summary>
            Start capturing can frames on channels marked for capture
            </summary>
        </member>
        <member name="M:Peach.Core.Publishers.Can.ICanInterface.StopCapture">
            <summary>
            Stop capturing can frame. (captured frames are kept)
            </summary>
        </member>
        <member name="M:Peach.Core.Publishers.Can.ICanInterface.ClearCapture">
            <summary>
            Clear all captured frames, does not stop capturing
            </summary>
        </member>
        <member name="T:Peach.Core.Publishers.Can.CanFrame">
            <summary>
            CAN frame that was read or can be sent by a driver
            </summary>
        </member>
        <member name="F:Peach.Core.Publishers.Can.CanFrame.Identifier">
            <summary>
            ID for can frame
            </summary>
        </member>
        <member name="F:Peach.Core.Publishers.Can.CanFrame.Timestamp">
            <summary>
            Timestamp frame was received
            </summary>
        </member>
        <member name="F:Peach.Core.Publishers.Can.CanFrame.Interface">
            <summary>
            Interface frame was received on
            </summary>
        </member>
        <member name="F:Peach.Core.Publishers.Can.CanFrame.Channel">
            <summary>
            Channel frame was received on
            </summary>
        </member>
        <member name="F:Peach.Core.Publishers.Can.CanFrame.IsRemote">
            <summary>
            Is Remote
            </summary>
        </member>
        <member name="F:Peach.Core.Publishers.Can.CanFrame.IsError">
            <summary>
            Is Error
            </summary>
        </member>
        <member name="P:Peach.Core.Publishers.Can.CanFrame.IsExtended">
            <summary>
            Is extended frame
            </summary>
        </member>
        <member name="P:Peach.Core.Publishers.Can.CanFrame.IsFd">
            <summary>
            Is frame FD
            </summary>
        </member>
        <member name="F:Peach.Core.Publishers.Can.CanFrame.Data">
            <summary>
            Data portion of can frame.  Excludes ID, flags, etc.
            </summary>
        </member>
        <member name="M:Peach.Core.Publishers.Can.CanFrame.ToPcapBitwiseStream">
            <summary>
            Convert to binary frame format
            </summary>
            <returns></returns>
        </member>
        <member name="T:Peach.Core.Publishers.StreamPublisher">
            <summary>
            Helper class for creating stream based publishers.
            Derived classes should only need to override OnOpen and OnClose
            </summary>
        </member>
        <member name="M:Peach.Core.Random.Shuffle``1(``0[])">
            <summary>
            Fisher-Yates array shuffling algorithm.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="items"></param>
            <returns></returns>
        </member>
        <member name="M:Peach.Core.Random.ElementAt``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>
            Work around for missing method in Mono
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="T:Peach.Core.RunConfiguration">
            <summary>
            Configure the current run
            </summary>
        </member>
        <member name="P:Peach.Core.RunConfiguration.id">
            <summary>
            A unique identifier for this run
            </summary>
        </member>
        <member name="F:Peach.Core.RunConfiguration.countOnly">
            <summary>
            Just get the count of mutations
            </summary>
        </member>
        <member name="F:Peach.Core.RunConfiguration.singleIteration">
            <summary>
            Perform a single iteration
            </summary>
        </member>
        <member name="F:Peach.Core.RunConfiguration.range">
            <summary>
            Specify the test range to perform
            </summary>
        </member>
        <member name="F:Peach.Core.RunConfiguration.parallel">
            <summary>
            Controls parallel fuzzing
            </summary>
        </member>
        <member name="F:Peach.Core.RunConfiguration.skipToIteration">
            <summary>
            Skip to a specific iteration
            </summary>
        </member>
        <member name="P:Peach.Core.RunConfiguration.debug">
            <summary>
            Enable or disable debugging output
            </summary>
        </member>
        <member name="F:Peach.Core.RunConfiguration.runName">
            <summary>
            Name of run to perform
            </summary>
        </member>
        <member name="F:Peach.Core.RunConfiguration.pitFile">
            <summary>
            Name of PIT file (used by logger)
            </summary>
        </member>
        <member name="F:Peach.Core.RunConfiguration.commandLine">
            <summary>
            Command line if any (used by logger)
            </summary>
        </member>
        <member name="F:Peach.Core.RunConfiguration.runDateTime">
            <summary>
            Date and time of run (used by logger)
            </summary>
        </member>
        <member name="F:Peach.Core.RunConfiguration.Duration">
            <summary>
            How long to run the fuzzer for.
            </summary>
        </member>
        <member name="F:Peach.Core.RunConfiguration.AbortTimeout">
            <summary>
            How long to wait for the engine to stop before giving up and aborting.
            </summary>
        </member>
        <member name="P:Peach.Core.RunConfiguration.randomSeed">
            <summary>
            Random number generator SEED
            </summary>
            <remarks>
            If the same SEED value is specified the same
            iterations will be performed with same values.
            </remarks>
        </member>
        <member name="P:Peach.Core.RunConfiguration.userDefinedSeed">
            <summary>
            Was randomSeed set by the user.
            </summary>
        </member>
        <member name="P:Peach.Core.RunConfiguration.version">
            <summary>
            Peach version currently running (used by logger)
            </summary>
        </member>
        <member name="T:Peach.Core.RunConfiguration.StopHandler">
            <summary>
            Function that returns true if the engine should stop
            </summary>
        </member>
        <member name="F:Peach.Core.RunConfiguration.shouldStop">
            <summary>
            Called every iteration by the engine to check if it should stop
            </summary>
        </member>
        <member name="T:Peach.Core.RunContext">
            <summary>
            Contains state information regarding the current fuzzing run.
            </summary>
        </member>
        <member name="M:Peach.Core.RunContext.Fault(System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String)">
            <summary>
            Triggers a fault for the currently executing test case.
            </summary>
            <param name="title">Title of fault</param>
            <param name="description">Description of fault</param>
            <param name="majorHash">Major hash for fault. Set to null or empty string to skip bucketing.</param>
            <param name="minorHash">Minor hash for fault. Set to null or empty string to skip bucketing.</param>
            <param name="exploitability">Exploitability for fault</param>
            <param name="detectionSource">Detection source, such as Monitor class attribute.</param>
            <param name="detectionName">Detection name, such as name attribute</param>
            <param name="agentName">Name of agent fault was reported by</param>
        </member>
        <member name="F:Peach.Core.RunContext.config">
            <summary>
            Configuration settings for this run
            </summary>
        </member>
        <member name="P:Peach.Core.RunContext.dom">
            <summary>
            Dom to use for this run
            </summary>
        </member>
        <member name="F:Peach.Core.RunContext.engine">
            <summary>
            Engine instance for this run
            </summary>
        </member>
        <member name="F:Peach.Core.RunContext.test">
            <summary>
            Current test being run
            </summary>
            <remarks>
            Currently the Engine code sets this.
            </remarks>
        </member>
        <member name="F:Peach.Core.RunContext.agentManager">
            <summary>
            Current agent manager for this run.
            </summary>
            <remarks>
            Currently the Engine code sets this.
            </remarks>
        </member>
        <member name="F:Peach.Core.RunContext.stateStore">
            <summary>
            An object store that will last entire run.  For use
            by Peach code to store some state.
            </summary>
        </member>
        <member name="F:Peach.Core.RunContext.iterationStateStore">
            <summary>
            An object store that will last current iteration.
            </summary>
        </member>
        <member name="F:Peach.Core.RunContext.currentIteration">
            <summary>
            The current iteration of fuzzing.
            </summary>
        </member>
        <member name="F:Peach.Core.RunContext.controlIteration">
            <summary>
            Is this a control iteration.  Control iterations are used
            to verify the system can still reliably fuzz and are performed
            with out any mutations applied.
            </summary>
            <remarks>
            The first iteration is a special control iteration.  We also
            perform control iterations after we have collected a fault.
            
            In later version we will likely inject control iterations every 
            N iterations where N is >= 100.
            </remarks>
        </member>
        <member name="F:Peach.Core.RunContext.controlRecordingIteration">
            <summary>
            Is this control operation also a recording iteration?
            </summary>
            <remarks>
            Recording iterations set our controlActionsExecuted and 
            controlStatesExecuted arrays.
            </remarks>
        </member>
        <member name="F:Peach.Core.RunContext.controlRecordingActionsExecuted">
            <summary>
            Actions performed during first control iteration.  Used to validate
            control iterations that come later have same action coverage.
            </summary>
        </member>
        <member name="F:Peach.Core.RunContext.controlRecordingStatesExecuted">
            <summary>
            States performed during first control iteration.  Used to validate
            control iterations that come later have same state coverage.
            </summary>
            <remarks>
            This may not be required with action coverage.
            </remarks>
        </member>
        <member name="F:Peach.Core.RunContext.controlActionsExecuted">
            <summary>
            Actions performed during later control iterations.  Used to validate
            control iterations that come later have same action coverage.
            </summary>
        </member>
        <member name="F:Peach.Core.RunContext.controlStatesExecuted">
            <summary>
            States performed during later control iterations.  Used to validate
            control iterations that come later have same state coverage.
            </summary>
            <remarks>
            This may not be required with action coverage.
            </remarks>
        </member>
        <member name="P:Peach.Core.RunContext.FaultOnPreviousIteration">
            <summary>
            Was there a fault detected on the previous iteration.
            </summary>
        </member>
        <member name="F:Peach.Core.RunContext.faults">
            <summary>
            Faults for current iteration of fuzzing.  This collection
            is cleared after each iteration.
            </summary>
            <remarks>
            This collection should only be added to from the CollectFaults event.
            </remarks>
        </member>
        <member name="F:Peach.Core.RunContext._continueFuzzing">
            <summary>
            Controls if we continue fuzzing or exit
            after current iteration.  This can be used
            by UI code to stop Peach.
            </summary>
        </member>
        <member name="F:Peach.Core.RunContext.reproducingFault">
            <summary>
            True when we have found a fault and are in the process
            of reproducing it.
            </summary>
            <remarks>
            Many times, especially with network fuzzing, the iteration we detect a fault on is not the
            correct iteration, or the fault requires multiple iterations to reproduce.
            
            Peach will start reproducing at the current iteration count then start moving backwards
            until we locate the iteration causing the crash, or reach our max back search value.
            </remarks>
        </member>
        <member name="F:Peach.Core.RunContext.reproducingInitialIteration">
            <summary>
            The initial iteration we detected fault on
            </summary>
        </member>
        <member name="F:Peach.Core.RunContext.reproducingControlIteration">
            <summary>
            Did the fault we are trying to reproduce occur on a control iteration.
            </summary>
        </member>
        <member name="F:Peach.Core.RunContext.reproducingControlRecordingIteration">
            <summary>
            Did the fault we are trying to reproduce occur on a control iteration.
            </summary>
        </member>
        <member name="F:Peach.Core.RunContext.reproducingIterationJumpCount">
            <summary>
            Number of iterations to jump.
            </summary>
            <remarks>
            Initializes to 1, then multiply against reproducingSkipMultiple
            </remarks>
        </member>
        <member name="T:Peach.Core.Scripting">
            <summary>
            Scripting class provides easy to use
            methods for using Python with Peach.
            </summary>
        </member>
        <member name="F:Peach.Core.Scripting._scope">
            <summary>
            Global scope for this instance of scripting
            </summary>
        </member>
        <member name="M:Peach.Core.Scripting.CreateScope">
            <summary>
            Create the global scope, or return existing one
            </summary>
            <returns></returns>
        </member>
        <member name="M:Peach.Core.Scripting.Exec(System.String,System.Collections.Generic.Dictionary{System.String,System.Object})">
            <summary>
            Execute a scripting program. Not cached.
            </summary>
            <param name="code"></param>
            <param name="localScope"></param>
        </member>
        <member name="M:Peach.Core.Scripting.Eval(System.String,System.Collections.Generic.Dictionary{System.String,System.Object},System.Boolean)">
            <summary>
            Evaluate an expression. Pre-compiled expressions are cached by default.
            </summary>
            <param name="code">Expression to evaluate</param>
            <param name="localScope">Local scope for expression</param>
            <param name="cache">Cache compiled script for re-use (defaults to true)</param>
            <returns>Result from expression</returns>
        </member>
        <member name="M:Peach.Core.Scripting.CreateScope(System.Collections.Generic.Dictionary{System.String,System.Object})">
            <summary>
            Returns the global scope with localScope added in.
            </summary>
            <param name="localScope"></param>
            <returns></returns>
        </member>
        <member name="M:Peach.Core.Scripting.CleanupScope(Microsoft.Scripting.Hosting.ScriptScope,System.Collections.Generic.Dictionary{System.String,System.Object})">
            <summary>
            Remove local scope items from global scope. This is quick.
            </summary>
            <param name="scope"></param>
            <param name="localScope"></param>
        </member>
        <member name="T:Peach.Core.Transformer">
            <summary>
            Transformers perform static transforms of data.
            </summary>
        </member>
        <member name="M:Peach.Core.Transformer.encode(Peach.Core.IO.BitwiseStream)">
            <summary>
            Encode data, will properly call any chained transformers.
            </summary>
            <param name="data">Data to encode</param>
            <returns>Returns encoded value or null if encoding is not supported.</returns>
        </member>
        <member name="M:Peach.Core.Transformer.decode(Peach.Core.IO.BitStream)">
            <summary>
            Decode data, will properly call any chained transformers.
            </summary>
            <param name="data">Data to decode</param>
            <returns>Returns decoded value or null if decoding is not supported.</returns>
        </member>
        <member name="M:Peach.Core.Transformer.internalEncode(Peach.Core.IO.BitwiseStream)">
            <summary>
            Implement to perform actual encoding of 
            data.
            </summary>
            <param name="data">Data to encode</param>
            <returns>Returns encoded data</returns>
        </member>
        <member name="M:Peach.Core.Transformer.internalDecode(Peach.Core.IO.BitStream)">
            <summary>
            Implement to perform actual decoding of
            data.
            </summary>
            <param name="data">Data to decode</param>
            <returns>Returns decoded data</returns>
        </member>
        <member name="M:Peach.Core.Transformer.CryptoStream(Peach.Core.IO.BitwiseStream,System.Security.Cryptography.ICryptoTransform,System.Security.Cryptography.CryptoStreamMode)">
            <summary>
            
            </summary>
            <param name="stream"></param>
            <param name="transform"></param>
            <param name="mode"></param>
            <returns></returns>
        </member>
        <member name="T:Peach.Core.TransformerAttribute">
            <summary>
            Use this attribute to identify Transformers
            </summary>
        </member>
        <member name="T:Peach.Core.AssertWriter">
            <summary>
            Helper class to add a debug listener so asserts get written to the console.
            </summary>
        </member>
        <member name="T:Peach.Core.NumberGenerator">
            <summary>
            A simple number generation class.
            </summary>
        </member>
        <member name="M:Peach.Core.NumberGenerator.GenerateBadNumbers(System.Int32,System.Int32)">
            <summary>
            Generate a list of numbers around size edge cases.
            </summary>
            <param name="size">The size (in bits) of the data</param>
            <param name="n">The +/- range number</param>
            <returns>Returns a list of all sizes to be used</returns>
        </member>
        <member name="T:Peach.Core.Utilities">
            <summary>
            Some utility methods that can be useful
            </summary>
        </member>
        <member name="M:Peach.Core.Utilities.ConfigureLogging(System.Int32)">
            <summary>
            Configure NLog.
            </summary>
            <remarks>
            Level = 0 --&gt; Info
            Level = 1 --&gt; Debug
            Level &gt; 1 --&gt; Trace
            </remarks>
            <param name="level"></param>
        </member>
        <member name="P:Peach.Core.Utilities.ExecutionDirectory">
            <summary>
            The location on disk where peach is executing from.
            Does not include the trailing slash in the directory name.
            </summary>
        </member>
        <member name="P:Peach.Core.Utilities.ExecutableName">
            <summary>
            Returns the name of the currently running executable.
            Equivalent to argv[0] in C/C++.
            </summary>
        </member>
        <member name="M:Peach.Core.Utilities.SliceRange(System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Compute the subrange resulting from diving a range into equal parts
            </summary>
            <param name="begin">Inclusive range begin</param>
            <param name="end">Inclusive range end</param>
            <param name="curSlice">The 1 based index of the current slice</param>
            <param name="numSlices">The total number of slices</param>
            <returns>Range of the current slice</returns>
        </member>
        <member name="T:Peach.Core.Variant">
            <summary>
            Variant class emulates untyped scripting languages
            variables were typing can change as needed.  This class
            solves the problem of boxing internal types.  Instead
            explicit casts are used to access the value as needed.
            
            TODO: Investigate implicit casting as well.
            TODO: Investigate deligates for type -> byte[] conversion.
            </summary>
        </member>
        <member name="M:Peach.Core.Variant.op_Explicit(Peach.Core.Variant)~System.Int32">
            <summary>
            Access variant as an int value.
            </summary>
            <param name="v">Variant to cast</param>
            <returns>int representation of value</returns>
        </member>
        <member name="M:Peach.Core.Variant.op_Explicit(Peach.Core.Variant)~System.UInt32">
            <summary>
            Access variant as an int value.
            </summary>
            <param name="v">Variant to cast</param>
            <returns>int representation of value</returns>
        </member>
        <member name="M:Peach.Core.Variant.op_Explicit(Peach.Core.Variant)~System.Double">
            <summary>
            Access variant as an double value.
            </summary>
            <param name="v">Variant to cast</param>
            <returns>int representation of value</returns>
        </member>
        <member name="M:Peach.Core.Variant.op_Explicit(Peach.Core.Variant)~System.String">
            <summary>
            Access variant as string value.
            </summary>
            <param name="v">Variant to cast</param>
            <returns>string representation of value</returns>
        </member>
        <member name="M:Peach.Core.Variant.op_Explicit(Peach.Core.Variant)~System.Byte[]">
            <summary>
            Access variant as byte[] value.  This type is currently limited
            as neather int or string's are properly cast to byte[] since 
            additional information is needed.
            
            TODO: Investigate using deligates to handle conversion.
            </summary>
            <param name="v">Variant to cast</param>
            <returns>byte[] representation of value</returns>
        </member>
        <member name="T:Peach.Core.Watcher">
            <summary>
            Watches the Peach Engine events.  This is how to 
            add a UI or logging.
            </summary>
        </member>
        <member name="T:Peach.Core.Xsd.Dom">
            <summary>
            Root element of a Peach XML DDL document.
            </summary>
        </member>
        <member name="F:Peach.Core.Xsd.Dom.TargetNamespace">
            <summary>
            Namespace used by peach.
            </summary>
        </member>
        <member name="P:Peach.Core.Xsd.Dom.version">
            <summary>
            Version of this XML file.
            </summary>
        </member>
        <member name="P:Peach.Core.Xsd.Dom.author">
            <summary>
            Author of this XML file.
            </summary>
        </member>
        <member name="P:Peach.Core.Xsd.Dom.description">
            <summary>
            Description of this XML file.
            </summary>
        </member>
        <member name="T:Peach.Core.Xsd.Include">
            <summary>
            Imports other Peach XML files into a namespace.
            This allows reusing existing templates from other Peach XML files.
            </summary>
        </member>
        <member name="P:Peach.Core.Xsd.Include.ns">
            <summary>
            The namespace prefix. One or more alphanumeric characters. Must not include a period.
            </summary>
        </member>
        <member name="P:Peach.Core.Xsd.Include.src">
            <summary>
            URL of file to include. For files say "file:path/to/file".
            </summary>
        </member>
        <member name="T:Peach.Core.Xsd.Import">
            <summary>
            Import a python file into the current context.
            This allows referencing generators and methods in external python files.
            Synonymous with saying "import xyz".
            </summary>
        </member>
        <member name="P:Peach.Core.Xsd.Import.import">
            <summary>
            Just like the python "import xyz" syntax.
            </summary>
        </member>
        <member name="T:Peach.Core.Xsd.Require">
            <summary>
            Import a ruby file into the current context.
            This allows referencing generators and methods in external ruby files.
            Synonymous with saying "require xyz".
            </summary>
        </member>
        <member name="P:Peach.Core.Xsd.Require.require">
            <summary>
            Just like the ruby "require xyz" syntax.
            </summary>
        </member>
        <member name="T:Peach.Core.Xsd.PythonPath">
            <summary>
            Includes an additional path for python module resolution.
            </summary>
        </member>
        <member name="P:Peach.Core.Xsd.PythonPath.path">
            <summary>
            Include this path when resolving python modules.
            </summary>
        </member>
        <member name="T:Peach.Core.Xsd.RubyPath">
            <summary>
            Includes an additional path for ruby module resolution.
            </summary>
        </member>
        <member name="P:Peach.Core.Xsd.RubyPath.path">
            <summary>
            Include this path when resolving ruby modules.
            </summary>
        </member>
        <member name="T:Peach.Core.Xsd.Python">
            <summary>
            This element allows for running Python code.
            This is useful to call any initialization methods for code that is later used.
            This is an advanced element.
            </summary>
        </member>
        <member name="P:Peach.Core.Xsd.Python.code">
            <summary>
            Python code to run.
            </summary>
        </member>
        <member name="T:Peach.Core.Xsd.Ruby">
            <summary>
            This element allows for running Ruby code.
            This is useful to call any initialization methods for code that is later used.
            This is an advanced element.
            </summary>
        </member>
        <member name="P:Peach.Core.Xsd.Ruby.code">
            <summary>
            Ruby code to run.
            </summary>
        </member>
        <member name="T:Peach.Core.Xsd.NumberDefaults">
            <summary>
            Controls the default values of attributes for number elements.
            </summary>
        </member>
        <member name="P:Peach.Core.Xsd.NumberDefaults.endian">
            <summary>
            Specifies the byte order of the number.
            </summary>
        </member>
        <member name="P:Peach.Core.Xsd.NumberDefaults.signed">
            <summary>
            Specifies if the the number signed.
            </summary>
        </member>
        <member name="P:Peach.Core.Xsd.NumberDefaults.valueType">
            <summary>
            Specifies the format of the value attribute.
            </summary>
        </member>
        <member name="T:Peach.Core.Xsd.StringDefaults">
            <summary>
            Controls the default values of attributes for string elements.
            </summary>
        </member>
        <member name="P:Peach.Core.Xsd.StringDefaults.type">
            <summary>
            Specifies the character encoding of the string.
            </summary>
        </member>
        <member name="P:Peach.Core.Xsd.StringDefaults.nullTerminated">
            <summary>
            Specifies if the string is null terminated.
            </summary>
        </member>
        <member name="P:Peach.Core.Xsd.StringDefaults.padCharacter">
            <summary>
            Specify the character to bad the string with if it's length if less then
            specified in the length attribute. Only valid when the length attribute is also
            specified.  This field will accept python escape sequences
            such as \\xNN, \\r, \\n, etc.
            </summary>
        </member>
        <member name="P:Peach.Core.Xsd.StringDefaults.lengthType">
            <summary>
            Specifies the units of the length attribute.
            </summary>
        </member>
        <member name="P:Peach.Core.Xsd.StringDefaults.valueType">
            <summary>
            Specify the format of the value attribute.
            </summary>
        </member>
        <member name="T:Peach.Core.Xsd.FlagsDefaults">
            <summary>
            Controls the default values of attributes for flags elements.
            </summary>
        </member>
        <member name="P:Peach.Core.Xsd.FlagsDefaults.endian">
            <summary>
            Specifies the byte order of the flag set.
            </summary>
        </member>
        <member name="P:Peach.Core.Xsd.FlagsDefaults.size">
            <summary>
            Specifies the length in bits of the flag set.
            </summary>
        </member>
        <member name="T:Peach.Core.Xsd.BlobDefaults">
            <summary>
            Controls the default values of attributes for blob elements.
            </summary>
        </member>
        <member name="P:Peach.Core.Xsd.BlobDefaults.lengthType">
            <summary>
            Specifies the units of the length attribute.
            </summary>
        </member>
        <member name="P:Peach.Core.Xsd.BlobDefaults.valueType">
            <summary>
            Specifies the format of the value attribute.
            </summary>
        </member>
        <member name="T:Peach.Core.Xsd.Defaults">
            <summary>
            This element allow setting default values for data elements.
            </summary>
        </member>
        <member name="T:Peach.Core.Xsd.PluginParam">
            <summary>
            Param elements provide parameters for the parent element.
            </summary>
        </member>
        <member name="P:Peach.Core.Xsd.PluginParam.name">
            <summary>
            Name of the parameter.
            </summary>
        </member>
        <member name="P:Peach.Core.Xsd.PluginParam.value">
            <summary>
            Value of the parameter.
            </summary>
        </member>
        <member name="T:Peach.Core.Xsd.Data">
            <summary>
            Specifies a set of default data values for a template.
            </summary>
        </member>
        <member name="T:Peach.Core.Xsd.Data.Field">
            <summary>
            Specifies a value for a field in a template.
            </summary>
        </member>
        <member name="P:Peach.Core.Xsd.Data.Field.name">
            <summary>
            Name of field to specify a default value for.
            Format of name is: "Element" or "Block.Block.Element".
            </summary>
        </member>
        <member name="P:Peach.Core.Xsd.Data.Field.xpath">
            <summary>
            Name of field to specify a default value for.
            Format of name is: "Element" or "Block.Block.Element".
            </summary>
        </member>
        <member name="P:Peach.Core.Xsd.Data.Field.value">
            <summary>
            Default value for template field.
            </summary>
        </member>
        <member name="P:Peach.Core.Xsd.Data.Field.valueType">
            <summary>
            Format of value attribute.
            </summary>
        </member>
        <member name="T:Peach.Core.Xsd.Data.FieldMask">
            <summary>
            Constrains field enumeration to specified choices.
            </summary>
        </member>
        <member name="P:Peach.Core.Xsd.Data.FieldMask.select">
            <summary>
            Specify selection of choices
            </summary>
        </member>
        <member name="P:Peach.Core.Xsd.Data.refData">
            <summary>
            Name of other data template to reference.
            </summary>
        </member>
        <member name="P:Peach.Core.Xsd.Data.name">
            <summary>
            Name of the data template.
            </summary>
        </member>
        <member name="P:Peach.Core.Xsd.Data.fieldId">
            <summary>
            Field ID of the data template.
            </summary>
        </member>
        <member name="P:Peach.Core.Xsd.Data.fileName">
            <summary>
            Use contents of file to populate data model.
            Peach will try and crack the file  based on the data model.
            </summary>
        </member>
        <member name="M:Peach.Core.Xsd.Extensions.GetAttributes``1(System.Reflection.MemberInfo)">
            <summary>
            Extension to the MemberInfo class. Return all attributes matching the specified type.
            </summary>
            <typeparam name="A">Attribute type to find.</typeparam>
            <param name="mi">MemberInfo in which the search should run over.</param>
            <returns>A generator which yields the attributes specified.</returns>
        </member>
    </members>
</doc>
