<?xml version="1.0" encoding="UTF-8"?>
<?asciidoc-toc maxdepth="2"?>
<?asciidoc-numbered?>
<article xmlns="http://docbook.org/ns/docbook" xmlns:xl="http://www.w3.org/1999/xlink" version="5.0" xml:lang="en">
<info>
<title>Peach Fuzzer Professional</title>
<subtitle>User Guide</subtitle>
<date>2021-09-28</date>
<author>
<personname>
<firstname>Peach Fuzzer, LLC</firstname>
</personname>
</author>
<authorinitials>P</authorinitials>
</info>
<simpara><?asciidoc-pagebreak?></simpara>
<section xml:id="Preface">
<title>Preface</title>
<simpara>This document is one of two books that together form the official documentation of
Peach Fuzzer Professional v0.0. This documentation set is written by the Peach Fuzzer Professional team, and
represents a concerted effort to fully document all of the Peach Fuzzer Professional features.</simpara>
<simpara>This book, Peach Fuzzer Professional User Guide, focuses on activities encountered in
day-to-day usage of Peach. The organization of this book is predominantly task-driven.
The second book, Peach Fuzzer Professional Developer Guide, focuses on developer needs
such as advanced configurations, building custom fuzzing definitions, and extending
the various areas of Peach.</simpara>
<simpara>As a User Guide, this book provides support for the user in daily issues that can otherwise
impede tasks associated with fuzzing. It is not theoretical in nature. Nor is it designed
to tackle advanced configurations, such as those used to fuzz embedded hardware or
kernel drivers.</simpara>
<simpara>The primary audience for this guide is a daily user who is not a developer.
The user is also not knowledgeable about XML.</simpara>
<simpara>Peach Fuzzer has been in active development through three major revisions since 2004. Until 2014,
no complete documentation existed. This is the first edition of the User Guide, bearing witness
that documenting Peach is an on-going effort. The majority of effort focuses on documenting the
most common uses of Peach Fuzzer Professional.</simpara>
<section xml:id="_what_is_peach_fuzzer_professional">
<title>What is Peach Fuzzer Professional?</title>
<simpara>Peach Fuzzer Professional (Peach) is a fuzzer for data consumers. Fuzzing is a software testing technique that
introduces malformed data to parts of a computer system. How the tested item reacts to unexpected
data becomes the source of security bugs.</simpara>
<simpara>Peach is a smart fuzzer that operates by performing the following actions:</simpara>
<itemizedlist>
<listitem>
<simpara>Understands the data structure and the flows of the test target</simpara>
</listitem>
<listitem>
<simpara>Creates and feeds malformed data to the test target</simpara>
</listitem>
<listitem>
<simpara>Monitors the test target to record interesting information when unintended or undesirable behavior
occurs (monitors include debuggers and network packet sniffers)</simpara>
</listitem>
</itemizedlist>
<simpara>Peach is a versatile product and has been used to fuzz a wide range of products and devices:</simpara>
<itemizedlist>
<listitem>
<simpara>web browsers (file consumers)</simpara>
</listitem>
<listitem>
<simpara>web servers (network servers)</simpara>
</listitem>
<listitem>
<simpara>mobile devices (such as Android iOS)</simpara>
</listitem>
<listitem>
<simpara>robots</simpara>
</listitem>
<listitem>
<simpara>SCADA systems</simpara>
</listitem>
<listitem>
<simpara>Semiconductor chips</simpara>
</listitem>
</itemizedlist>
<simpara>Because Peach can easily extend its interfacing and monitoring, it is the most adaptable fuzzer that exists.</simpara>
</section>
<section xml:id="_additional_resources">
<title>Additional Resources</title>
<simpara>More information about Peach is available on the Web:</simpara>
<itemizedlist>
<listitem>
<simpara><link xl:href="http://peachfuzzer.com">Peach Fuzzer website</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="http://www.peachfuzzer.com/products/peach-pits/">Current Pits and Pit Packs</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://forums.peachfuzzer.com">Peach User Forums</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://vimeo.com/148176046">Installing Peach Fuzzer Software video</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="_bug_reporting_guidelines">
<title>Bug Reporting Guidelines</title>
<simpara>Support for Peach Fuzzer is available in two ways:</simpara>
<itemizedlist>
<listitem>
<simpara>The Peach Forums site</simpara>
</listitem>
<listitem>
<simpara>Using the Peach ticketing system to open a support ticket</simpara>
</listitem>
</itemizedlist>
<section xml:id="Peach_Forums">
<title>Peach Forums</title>
<simpara>There are two sets of forums for Peach, the community forums and the professional forums. Both forums are hosted at <link xl:href="https://forums.peachfuzzer.com">https://forums.peachfuzzer.com</link>.</simpara>
<simpara>Peach Fuzzer Professional users should access the private forums to receive support for the commercial versions of Peach. Responses on the commercial forums are prioritized over the public community forums.</simpara>
<simpara>To access the Peach Fuzzer Professional forums, follow these steps:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Register an account on the forums site.</simpara>
</listitem>
<listitem>
<simpara>Send an email to <link xl:href="mailto:support@peachfuzzer.com">support@peachfuzzer.com</link> with your license email and forum username.</simpara>
</listitem>
<listitem>
<simpara>Your account will be granted access to the commercial forums within 24 business hours.</simpara>
</listitem>
</orderedlist>
<simpara>Forums are monitored by the team at Peach Fuzzer, LLC; however, there is no guarantee of response time.</simpara>
</section>
<section xml:id="_support_tickets">
<title>Support Tickets</title>
<simpara>You can open a support ticket by sending an email to <emphasis>support@peachfuzzer.com</emphasis>. You will receive an initial response within 24 business hours of opening the ticket. Peach support is available Monday through Friday. Peach support is not currently available on weekends or holidays.</simpara>
<simpara>When opening a ticket, please provide the following information in your email:</simpara>
<itemizedlist>
<listitem>
<simpara>Operating system(s) in use by Peach and any agents</simpara>
</listitem>
<listitem>
<simpara>Exact version of Peach being used. This is available from the console output and in the <emphasis>status.txt</emphasis> log file</simpara>
</listitem>
<listitem>
<simpara>Detailed description of the issue and expected behavior</simpara>
</listitem>
<listitem>
<simpara>Console output using the <emphasis>--trace</emphasis> argument</simpara>
</listitem>
<listitem>
<simpara>(if possible) the full Pit file and configuration files</simpara>
</listitem>
</itemizedlist>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
</section>
<section xml:id="JumpStart">
<title>Getting Started with the Peach Fuzzer Platform</title>
<simpara>This section provides a workflow that identifies the steps involved in setting up and running a fuzzing session.
Stepping through the Peach fuzzing workflow is the quickest way to begin fuzzing.</simpara>
<simpara>The workflow in this section is conceptual.
It tells you what needs to be done;
not how to do it.
Yet,
when we can,
we refer to the appropriate section of the Peach User Guide to perform that part of the workflow.</simpara>
<note>
<simpara>If you&#8217;re new to fuzzing or want to learn how fuzzing works,
read the section <link linkend="Intro_to_FuzzingBrand_new_items">Introduction to Fuzzing</link>.</simpara>
<simpara>This approach applies to any step of the workflow that you are unfamiliar with or that you are curious about.
Read the section.
Then, come back to the workflow for the next task.</simpara>
</note>
<simpara>The workflow includes the following steps. The first item in the workflow is your test target.
You should have this item locked down,
as it makes the other steps of the workflow easier to get through.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara><link linkend="WF1_PickTarget">Picking Your Fuzzing Target</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="WF2_InstallPeach">Installing Peach</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="WF3_LaunchPeach">Launching Peach</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="WF4_SelectPit">Selecting a Peach Pit (fuzzing definition for your test target)</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="WF5_SpecifyTestConfiguration">Specifying a Test Configuration</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="WF6_RunFuzzJob">Running the Fuzzing Job</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="WF7_InterpretResults">Interpreting Results</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="WF8_FixIssuesAndRerun">Fixing Issues and Re-running the Faulting Test Cases</link></simpara>
</listitem>
</orderedlist>
<simpara>The following is a restatement of the workflow that includes descriptions and appropriate references.
After you&#8217;ve been through the workflow once or twice, you shouldn&#8217;t need to access the details again.</simpara>
<section xml:id="WF1_PickTarget">
<title>Picking your fuzzing target</title>
<simpara>A fuzzing target can be just about anything;
typically,
the target accepts and dispenses data through security boundaries.
Fuzzing target examples include:</simpara>
<itemizedlist>
<listitem>
<simpara>An application that consumes files</simpara>
</listitem>
<listitem>
<simpara>A protocol service</simpara>
</listitem>
<listitem>
<simpara>A protocol client</simpara>
</listitem>
<listitem>
<simpara>A device</simpara>
</listitem>
<listitem>
<simpara>Other</simpara>
</listitem>
</itemizedlist>
<simpara>Get a good idea of what you intend to fuzz.</simpara>
</section>
<section xml:id="WF2_InstallPeach">
<title>Installing Peach</title>
<simpara>The <link linkend="Installation">Installation</link> section includes instructions for installing Peach Fuzzer on Windows,
three Linux distributions,
and OS X.
The scope of material includes downloading distribution images with your Peach license through
launching the platform to ensure a correct installation.</simpara>
<simpara>The installation also identifies other applications that Peach uses and where needed,
provides installation on these items.</simpara>
<simpara>A video of the installation titled
<link xl:href="https://vimeo.com/148176046">Installing Your Peach Fuzzer Professional or Enterprise Software</link>
is available at <link xl:href="http://www.vimeo.com">vimeo.com</link>.</simpara>
</section>
<section xml:id="WF3_LaunchPeach">
<title>Launching Peach</title>
<simpara>The <link linkend="Start_Peach_Web">Starting the Peach Web Interface</link> section describes how to launch Peach and the Peach Web UI.</simpara>
<note>
<orderedlist numeration="arabic">
<listitem>
<simpara>A command processor or command shell at a heightened/administrative level is used to launch Peach.</simpara>
</listitem>
<listitem>
<simpara>In the Windows environment, Peach automatically starts a browser and loads the Web UI.</simpara>
<simpara>For other environments,
you need to copy the URL generated by Peach,
launch a browser,
and connect to Peach by pasting the URL into the browser address bar.</simpara>
</listitem>
</orderedlist>
</note>
</section>
<section xml:id="WF4_SelectPit">
<title>Selecting a Peach Pit</title>
<simpara>From the Peach Web Home page,
click the “Library” icon in the group of icons on the left side of the page that are above the menu entries.
This action lets you start with a pit installed on your system.</simpara>
<simpara>If you need a Pit that is not in your library,
please contact the Peach Fuzzer Sales team at <link xl:href="mailto:sales@peachfuzzer.com">sales@peachfuzzer.com</link>.
For a list of available Pits,
visit the <link xl:href="http://peachfuzzer.com">Peach Fuzzer</link> web site.
From the Peach Fuzzer homepage,
click on  "Products" in the banner at the top of the page,
then click the "Peach Pits" menu entry.</simpara>
</section>
<section xml:id="WF5_SpecifyTestConfiguration">
<title>Specifying a Test Configuration</title>
<simpara>Specifying a configuration consists of setting variables specific to the selected Pit and defining how to monitor the test subject.</simpara>
<simpara>Variables are used to configure and target a Pit.
This includes information such as IP addresses and port numbers for network Pits and any configuration required a specific Pit.
Many of the variables you already know or can obtain quickly.
Sometimes,
the value of a variable depends on the monitoring setup,
so some tweaking might be appropriate once you select the monitors to use.</simpara>
<simpara>Several monitoring recipes are included to provide base monitor configurations for the different fuzzing targets.
Monitors focus on detecting faults,
collecting data,
and automating the test environment.
The monitoring recipes also are great starting points for developing your own configurations that precisely monitor the test target for your needs.
The recipes in this release consist of the following:</simpara>
<itemizedlist>
<listitem>
<simpara><link linkend="Recipe_FileFuzzing">Monitoring a File Consumer (File Fomat)</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="Recipe_LinuxNetServer">Monitoring a Linux Network Service</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="Recipe_LinuxNetClient">Monitoring a Linux Network Client</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="Recipe_NetDevice">Monitoring a Network Device</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="Recipe_WindowsNetServer">Monitoring a Windows Network Service</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="Recipe_WindowsNetClient">Monitoring a Windows Network Client</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="WF6_RunFuzzJob">
<title>Running the Fuzzing Job</title>
<simpara>Peach Fuzzer typically runs hundreds of thousands of test cases.
The Peach Fuzzer engine will generate an unlimited number of test cases,
though this is not typically the most efficient use of resources.
For more information, see <link linkend="Fuzzing_ExitCriteria">When to Stop Fuzzing</link>.
In each fuzzing job,
Peach generates test cases randomly with fresh data values.
The Peach platform weights the mutations used to generate the most faults.</simpara>
<simpara>Once your configuration is complete,
or if you selected an existing configuration,
you can start a fuzzing job by clicking Start at the bottom of the configuration page.
For more information on starting and re-running fuzzing jobs,
see the <link linkend="Start_Fuzzing">Fuzzing Session</link> section for more information.</simpara>
<note>
<simpara>A fuzzing job runs indefinitely.
It will stop running if you specify a value for Stop Test Case or if you manually click Stop on the Peach dashboard.</simpara>
</note>
</section>
<section xml:id="WF7_InterpretResults">
<title>Interpreting Results</title>
<simpara>When the fuzzing job completes, Peach provides two sets of results:</simpara>
<itemizedlist>
<listitem>
<simpara>A report of the fuzzing job in a <literal>.pdf</literal> file.</simpara>
</listitem>
<listitem>
<simpara>Online information that buckets the results, and provides drill-down capability</simpara>
</listitem>
</itemizedlist>
<simpara>The report provides an overall status of the job and provides many views of the fuzzing job by focusing on the metrics used in fuzzing.
The report is available by locating the appropriate fuzzing job entry,
then clicking on the document in the Action column at the right side of the entry.</simpara>
<simpara>Review the overall metrics and the buckets/categories of faults that occur.
You should be able to see what worked well and where the issues were.
After that,
you&#8217;ll need to investigate the faults,
find the root cause of the fault,
and then deal with it accordingly.</simpara>
<simpara>The online results focus on the faults that occurred during the fuzzing job.
The faults are where you need to focus,
and where Peach Fuzzer adds value to the SDL.
You can access faults from the Dashboard page or from the home page,
where you can access all of the stored fuzzing job results.</simpara>
<simpara>See the <link linkend="Report_Faults">Faults</link> section for a description of the information that Peach captures when a fault occurs;
visit the <link linkend="Report_Metrics">Metrics</link> section for a description of how Peach Fuzzer provides meaningful views into the fuzzing job by rolling up test case results.</simpara>
</section>
<section xml:id="WF8_FixIssuesAndRerun">
<title>Fixing Issues and Re-running Test Cases</title>
<simpara>The last step is to address the faults/issues uncovered during fuzzing, and to verify the fixes.</simpara>
<itemizedlist>
<listitem>
<simpara>Address the faults<?asciidoc-br?>
This item is for the developer, who needs to edit the code where the fault occurred.
Use your normal debugging practices here.</simpara>
</listitem>
<listitem>
<simpara>Verifying fixes of issues<?asciidoc-br?>
When the fixes are in place,
you can re-run a fuzzing job in whole or in part by selecting the Pit Configuration,
and then specifying the Seed value of the fuzzing job that you found the fault,
the Start Test Case (optional),
and the End Test Case (optional).
For more information,
see <link linkend="Re-Fuzzing">Re-running a Fuzzing Job</link>.</simpara>
</listitem>
</itemizedlist>
<tip>
<simpara>Specifying the same the seed value as in the original fuzzing job ensures that the same test cases are run,
in the same sequence and with the same data as in the original fuzzing job.</simpara>
</tip>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Intro_to_FuzzingBrand_new_items">
<title>Introduction to Fuzzing</title>
<simpara>Welcome to the world of fuzzing!</simpara>
<simpara><emphasis>What is fuzzing?</emphasis></simpara>
<simpara>Fuzzing is the art of performing unexpected actions that result in target misbehavior.</simpara>
<simpara><emphasis>What is our goal when we fuzz?</emphasis></simpara>
<simpara>Our goal is to find new, previously unknown security vulnerabilities. Finding vulnerabilities is limited only by our ability to detect them automatically.</simpara>
<simpara>The most common target for fuzzing is a data consumer such a network service or a web browser. For a data consumer, the unexpected actions consist of sending data to the consumer that is malformed in some way. When the target consumes the fuzzed data, the malformed data could trigger a target vulnerability. The likelihood that a single change causes a vulnerability might not be high, but when the act of sending fuzzed data repeats over and over, a very good chance exists that the target will misbehave in some interesting manner.</simpara>
<simpara>Fuzzers submit hundreds, thousands, even millions of data samples malformed in some way; fuzzers call the malformed data mutations. Once written, fuzzers typically run for long periods of time finding more and more vulnerabilities, called faults.</simpara>
<simpara>Consider the following C structure and corresponding data shown in hex:</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/DevGuide/FuzzingIntro/struct_with_hex.png"/>
</imageobject>
<textobject><phrase>struct with hex</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>The data is parsed by the data consumer into the structure. The data and structure are color coded to show which parts of the data are loaded into each member of the structure <emphasis>Header</emphasis>. Following the structure, two lines of code occur that use the <emphasis>Header</emphasis> structure. Looking at that code, we can identify several issues that could likely lead to crashing our program that we could trigger by changing our input data.</simpara>
<simpara>The first thing we could do is change the <emphasis>len</emphasis> in our data from <literal>0x0021</literal> to <literal>0x0001</literal>. This would cause the memory allocation to return a smaller amount of memory than what is needed for copying data using the <emphasis>strcpy</emphasis> function. Once <emphasis>strcpy</emphasis> executes, we will have written past the end of <emphasis>msg_data</emphasis>, possibly causing the target process to crash.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/DevGuide/FuzzingIntro/struct_with_hex_len.png"/>
</imageobject>
<textobject><phrase>struct with hex len</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Another change we could make to the data is to remove or change the null byte that terminates the string <emphasis>data</emphasis>. In C, string functions operate on data up to the null character. If the null byte is changed, the <emphasis>strcpy</emphasis> function  copies more than 33 bytes into <emphasis>msg_data</emphasis>. This could cause the target process to crash.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/DevGuide/FuzzingIntro/struct_with_hex_data.png"/>
</imageobject>
<textobject><phrase>struct with hex data</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>The two changes we made to trigger two similar but different bugs in the code is something we look to automate with fuzzing. Taking this input data and randomly changing a byte to a random value, would, over the course of many attempts, eventually find both of these issues.</simpara>
<simpara>One of the goals with fuzzing is to find as many faults in targets with the least amount of human time.</simpara>
<section xml:id="_dumb_fuzzing">
<title>Dumb Fuzzing</title>
<simpara>Several types of fuzzing technology exist; one of the most common technologies is dumb fuzzing. Dumb fuzzers are a class of fuzzers that operate with limited or no information or understanding of the target or data being consumed.</simpara>
<simpara>Dumb fuzzers are popular because they take very little effort to get running and can produce good results with certain targets. Since they lack any knowledge of the data being consumed, they have limited practical use.</simpara>
<simpara>The most common mutation performed by dumb fuzzers is bit flipping. Bit flipping selects a part of data to change and modifies it in a simple manner. One might make a single change, or multiple changes depending on the fuzzer. The resulting data is then sent to the data consumer to see if it causes the data consumer to misbehave (such as crash).</simpara>
<simpara>Dumb fuzzing makes a great starting point when first fuzzing as it is the easiest method to use. However, in many cases, dumb fuzzing does not work. One example is the use of checksums in the data format. Checksums validate integrity of the data during transmission or storage. Any change to the data will result in a checksum that does not match. This is shown in the following image:</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/DevGuide/FuzzingIntro/crc_missmatch.png"/>
</imageobject>
<textobject><phrase>crc missmatch</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>The highlighted FF in the data stream is a byte that was changed during fuzzing. The new checksum value does not match the one that already exists in the file. If the checksum is validated by the data consumer, it could be rejected early on, limiting the number of faults that can be found.</simpara>
<simpara>Smart fuzzers allow updating the data to correct for things like checksums, encryption, encoding, and compression so that the data passes through the initial system checks and is process by the data consumer.</simpara>
<simpara>Peach makes it easy to shift from dumb fuzzing into smart fuzzing.</simpara>
</section>
<section xml:id="_smart_fuzzing">
<title>Smart Fuzzing</title>
<simpara>Smart fuzzers are a class of fuzzers that operate with some knowledge and understanding of the target, and of the data being consumed. The amount of knowledge depends on the fuzzer being used.</simpara>
<simpara>A typical smart fuzzer does the following things:</simpara>
<itemizedlist>
<listitem>
<simpara>Understand the data format being consumed by the target application</simpara>
</listitem>
<listitem>
<simpara>Monitor the target for fault conditions</simpara>
</listitem>
<listitem>
<simpara>Modify the data to gain better coverage or to increase the ability to detect certain types of issues</simpara>
</listitem>
</itemizedlist>
<simpara>Data understanding includes:</simpara>
<itemizedlist>
<listitem>
<simpara>Type information (string, integer, byte array)</simpara>
</listitem>
<listitem>
<simpara>Relationships between fields in the data (length, offset, count)</simpara>
</listitem>
<listitem>
<simpara>Ability integrity fields such as a checksum or a CRC</simpara>
</listitem>
</itemizedlist>
<simpara>At this level, understanding the data structures and data types allows the fuzzer to make more informed changes (mutations) to the data. Smart fuzzers use this understanding level to find more bugs.</simpara>
<simpara>Smart fuzzers can control and monitor the fuzzing environment. Environment and instrumentation controls start all the components of the system so they are ready to fuzz. On a faulting condition, they reset the environment to a known, good state. Smart fuzzers can detect a faulting condition and collect any interesting data in the system at the time of the fault (including output from a debugger, a network capture, or files on the file system), and log the data for later review. High-quality smart fuzzers can run unattended for long periods of time and capture enough information to allow a resource to reasonably reproduce and investigate the faults that occurred.</simpara>
<simpara>Smart fuzzers also perform bug bucketing and basic risk analysis. Fuzzing commonly finds the same
issue multiple times during a long test session. Bucketing is an industry term for cataloging similar, and
possible duplicate, issues into a "bucket". Bucketing is typically done at a major and minor level.</simpara>
<itemizedlist>
<listitem>
<simpara>Major differences are generally distinct issues. The bucket for a major issue might associate
with a specific processor family, operating system, or monitor name.</simpara>
</listitem>
<listitem>
<simpara>Minor differences that generate faults mean that the issues might be identical, or are
probably similar; yet, issues in minor buckets are worth reviewing to ensure the issues
have the same root cause.</simpara>
</listitem>
</itemizedlist>
<simpara>Along with buckets, initial risk analysis allows you to direct your attention first on higher risk faults before spending time on lower risk issues. Risk analysis is not always possible, but is useful when it can be performed.</simpara>
</section>
<section xml:id="Fuzzing_ExitCriteria">
<title>When to Stop Fuzzing</title>
<simpara>A fuzzing bar sets requirements for a fuzzing job and answers the question, “How long do we fuzz?”</simpara>
<simpara>Here is one set of exiting criteria that consists of two requirements:</simpara>
<itemizedlist>
<listitem>
<simpara>The fuzzer must run a set number of test cases.<?asciidoc-br?>
The number of test cases performed must meet or exceed the specified threshold.</simpara>
</listitem>
<listitem>
<simpara>The fuzzer must have at least Y consecutive clean test cases.<?asciidoc-br?>
A clean test case generates zero new faults.</simpara>
</listitem>
</itemizedlist>
<simpara>As soon as both requirements occur, fuzzing can stop.</simpara>
<simpara>For example, when fuzzing a new product, the release criteria might be set to 250,000 total fuzzing test cases on the product and yield 150,000 consecutive clean test cases.</simpara>
<simpara>The following diagram shows one way of meeting this criteria and focuses on the number of test cases performed, test case failures, and the number of consecutive clean test cases.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/Fuzzing_Exit_Criteria_Case1_3_8.png"/>
</imageobject>
<textobject><phrase>Fuzzing Exit Criteria Case1 3 8</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>A few items are worth noting:</simpara>
<itemizedlist>
<listitem>
<simpara>The total number of test cases performed is 250K.</simpara>
</listitem>
<listitem>
<simpara>The number of consecutive clean test cases is 200K, surpassing the requirement of
150K clean test cases. The last 50K test cases were needed to meet the first requirement.</simpara>
</listitem>
<listitem>
<simpara>The count of consecutive clean test cases reset to zero when a new fault was found at the 50,000th test case.</simpara>
</listitem>
</itemizedlist>
<simpara>The next diagram shows another way of meeting this criteria.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/Fuzzing_Exit_Criteria_Case2_3_8.png"/>
</imageobject>
<textobject><phrase>Fuzzing Exit Criteria Case2 3 8</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Again, a few of items are worth noting:</simpara>
<itemizedlist>
<listitem>
<simpara>The total number of test cases performed is 450K.</simpara>
</listitem>
<listitem>
<simpara>The number of consecutive clean test cases is 150K.</simpara>
</listitem>
<listitem>
<simpara>The count of the consecutive clean test cases restarted three times due to
new faults occurring in test cases: after 76K, 200K, and 300K.</simpara>
</listitem>
</itemizedlist>
<simpara>The requirements used in the previous example are reasonable for a first release of a product. However, each successive version of a product should become more and more stable. This can be realized by increasing the total number of test cases performed by the fuzzer, and the number of consecutive clean test cases that result from fuzzing. The following table provides increasing requirements as a product matures.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="14.2857*"/>
<colspec colname="col_2" colwidth="42.8571*"/>
<colspec colname="col_3" colwidth="42.8572*"/>
<thead>
<row>
<entry align="left" valign="top">Year</entry>
<entry align="left" valign="top">Required Iterations</entry>
<entry align="left" valign="top">Clean Iterations</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Year 1</simpara></entry>
<entry align="left" valign="top"><simpara>250,000</simpara></entry>
<entry align="left" valign="top"><simpara>150,000</simpara></entry>
</row>
<row>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Year 2</simpara></entry>
<entry align="left" valign="top"><simpara>500,000</simpara></entry>
<entry align="left" valign="top"><simpara>250,000</simpara></entry>
</row>
<row>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Year 4</simpara></entry>
<entry align="left" valign="top"><simpara>High      750,000</simpara></entry>
<entry align="left" valign="top"><simpara>High    500,000</simpara></entry>
</row>
<row>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>Medium    500,000</simpara></entry>
<entry align="left" valign="top"><simpara>Medium  250,000</simpara></entry>
</row>
<row>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>Low       500,000</simpara></entry>
<entry align="left" valign="top"><simpara>Low     250,000</simpara></entry>
</row>
<row>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Year 5</simpara></entry>
<entry align="left" valign="top"><simpara>High    1,000,000</simpara></entry>
<entry align="left" valign="top"><simpara>High    750,000</simpara></entry>
</row>
<row>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>Medium    750,000</simpara></entry>
<entry align="left" valign="top"><simpara>Medium  500,000</simpara></entry>
</row>
<row>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>Low       500,000</simpara></entry>
<entry align="left" valign="top"><simpara>Low     250,000</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<note>
<simpara>What was once the Software Development Life Cycle (SDLC) has evolved into
the Secure Development Lifecycle (SDL) to protect corporate assets from zero-day
attacks. Fuzzing is part of the SDL, specifically in the security push and the
Verification Phase. Peach Fuzzer can operate on non-executable file formats,
protocol stacks, and data that originates from a lesser-privileged trust boundary.</simpara>
</note>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Installation">
<title>Installation</title>
<simpara>The following list contains links to the sections that describe in detail how to download, install and activate Peach Fuzzer.</simpara>
<variablelist>
<varlistentry>
<term><link linkend="Installation_Hardware">Recommended Hardware</link></term>
<listitem>
<simpara>This section describes the minimum and recommended hardware requirements for common fuzzing scenarios.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Installation_Download">Product Download</link></term>
<listitem>
<simpara>This section contains the steps required to download the product for your desired platform.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Product Installation</term>
<listitem>
<simpara>This section lists the software prerequisites, OS specific configuration, and steps for installing the product on each of the three supported platforms:</simpara>
<itemizedlist>
<listitem>
<simpara><link linkend="InstallOnWindows">Windows</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="InstallOnLinux">Linux</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="InstallOnOSX">OSX</link></simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term>Product Activation</term>
<listitem>
<simpara>The list below contains links to the steps for activating the different types of Peach Fuzzer licenses.</simpara>
<itemizedlist>
<listitem>
<simpara><link linkend="ActivateOnline">Usage Based (Online Synchronization)</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="ActivateOffline">Usage Based (Offline Synchronization)</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="ActivateNodeLock">Node Locked</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="ActivateEnterprise">Enterprise</link></simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term>Optional Configuration</term>
<listitem>
<simpara>The list below contains links to optional post-install configurations.</simpara>
<itemizedlist>
<listitem>
<simpara><link linkend="InstallSecureInstall">Enabling HTTPS And Authentication</link></simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>
<section xml:id="Installation_Hardware">
<title>Hardware Requirements</title>
<simpara>The following are generic hardware recommendations. Adjust based on your needs.</simpara>
<section xml:id="_local_target">
<title>Local Target</title>
<simpara>When fuzzing a local target (software running on the same machine as Peach),
additional resources are required for the target process.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="5">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="20*"/>
<colspec colname="col_3" colwidth="20*"/>
<colspec colname="col_4" colwidth="20*"/>
<colspec colname="col_5" colwidth="20*"/>
<thead>
<row>
<entry align="left" valign="top">Target Type</entry>
<entry align="left" valign="top">Architecture</entry>
<entry align="left" valign="top">Cores</entry>
<entry align="left" valign="top">Ram</entry>
<entry align="left" valign="top">Disk</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Network</simpara></entry>
<entry align="left" valign="top"><simpara>64-bit</simpara></entry>
<entry align="left" valign="top"><simpara>4</simpara></entry>
<entry align="left" valign="top"><simpara>8GB</simpara></entry>
<entry align="left" valign="top"><simpara>60GB SSD</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>File</simpara></entry>
<entry align="left" valign="top"><simpara>64-bit</simpara></entry>
<entry align="left" valign="top"><simpara>4</simpara></entry>
<entry align="left" valign="top"><simpara>16GB</simpara></entry>
<entry align="left" valign="top"><simpara>60GB SSD</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Other</simpara></entry>
<entry align="left" valign="top"><simpara>64-bit</simpara></entry>
<entry align="left" valign="top"><simpara>4</simpara></entry>
<entry align="left" valign="top"><simpara>8GB</simpara></entry>
<entry align="left" valign="top"><simpara>60GB SSD</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
<section xml:id="_remote_target">
<title>Remote Target</title>
<simpara>Remote target fuzzing occurs when the target is not located on the machine running Peach.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="5">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="20*"/>
<colspec colname="col_3" colwidth="20*"/>
<colspec colname="col_4" colwidth="20*"/>
<colspec colname="col_5" colwidth="20*"/>
<thead>
<row>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top">Architecture</entry>
<entry align="left" valign="top">Cores</entry>
<entry align="left" valign="top">Ram</entry>
<entry align="left" valign="top">Disk</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Minimum</simpara></entry>
<entry align="left" valign="top"><simpara>64-bit</simpara></entry>
<entry align="left" valign="top"><simpara>2</simpara></entry>
<entry align="left" valign="top"><simpara>4GB</simpara></entry>
<entry align="left" valign="top"><simpara>60GB Any</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Recommended</simpara></entry>
<entry align="left" valign="top"><simpara>64-bit</simpara></entry>
<entry align="left" valign="top"><simpara>2</simpara></entry>
<entry align="left" valign="top"><simpara>8GB</simpara></entry>
<entry align="left" valign="top"><simpara>60GB SSD</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<tip>
<simpara>It&#8217;s possible to run Peach on 32-bit systems,
but it&#8217;s not recommended as it places severe limits on memory usage (max 2GB).</simpara>
</tip>
</section>
</section>
<section xml:id="Installation_Download">
<title>Downloading</title>
<simpara>The first step of the installation is to download the Peach Fuzzer distribution files from the Peach download site.
Once the appropriate files have been downloaded,
follow the instructions for your specific operating system found in the next section.</simpara>
<variablelist>
<varlistentry>
<term><link linkend="Installation_UserAccount">User Account Download</link></term>
<listitem>
<simpara>If you were assigned an account with a username/password, follow these instructions to sign in and download Peach Fuzzer.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Installation_UserAccount">Enterprise Download</link></term>
<listitem>
<simpara>If you were provided an enterprise license file, follow the instructions to sign in and download Peach Fuzzer.</simpara>
</listitem>
</varlistentry>
</variablelist>
<section xml:id="Installation_UserAccount">
<title>User Account Download</title>
<orderedlist numeration="arabic">
<listitem>
<simpara>When your Peach Fuzzer welcome email arrives, click the link to reset your initial password.</simpara>
</listitem>
<listitem>
<simpara>Navigate to <link xl:href="https://portal.peachfuzzer.com">https://portal.peachfuzzer.com</link> with your preferred web browser.</simpara>
</listitem>
<listitem>
<simpara>At the login prompt under the Portal Login section,
enter the new username/password that was recently reset and click <literal>Sign In</literal>.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/Installation/Portal_Home.png"/>
</imageobject>
<textobject><phrase>Portal Home</phrase></textobject>
</mediaobject>
</informalfigure>
<note>
<simpara>Contact <link xl:href="mailto:support@peach.tech">support@peach.tech</link> if you need your account password reset.</simpara>
</note>
</listitem>
<listitem>
<simpara>On the <literal>Downloads</literal> page, select the Peach Fuzzer release version and operating system to install.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Choose a release version from the items on the left side.</simpara>
</listitem>
<listitem>
<simpara>Click the download icon on the right side after deciding which OS and architecture is needed.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/Installation/Portal_Downloads.png"/>
</imageobject>
<textobject><phrase>Portal Downloads</phrase></textobject>
</mediaobject>
</informalfigure>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>If your organization has multiple entitlements,
you may need to select an Activation ID that corresponds to the license the download should be tied to.
This selection page will not be displayed if there is only one entitlement for your organization.
Contact <link xl:href="mailto:licensing@peach.tech">licensing@peach.tech</link> for more information if you are unsure which Activation ID to select.</simpara>
</listitem>
<listitem>
<simpara>After a few moments, an End User License Agreement acceptance page appears.
Click <literal>I ACCEPT</literal> to continue.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/Installation/EULA_Acceptance.png"/>
</imageobject>
<textobject><phrase>EULA Acceptance</phrase></textobject>
</mediaobject>
</informalfigure>
</listitem>
<listitem>
<simpara>The download will begin.
Depending on your network connection,
this could take a few minutes.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="Installation_LicenseFile">
<title>Enterprise Download</title>
<note>
<simpara>You need a copy of your Peach Fuzzer license on your system to perform the download.</simpara>
</note>
<orderedlist numeration="arabic">
<listitem>
<simpara>Using a web browser, navigate to <link xl:href="https://portal.peachfuzzer.com">https://portal.peachfuzzer.com</link></simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/Installation/Portal_Home_Enterprise.png"/>
</imageobject>
<textobject><phrase>Portal Home Enterprise</phrase></textobject>
</mediaobject>
</informalfigure>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Click the <literal>Choose File</literal> button. The upload dialog display allows you to select the <literal>Peach.license</literal> file.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/Installation/LicenseUpload.png"/>
</imageobject>
<textobject><phrase>LicenseUpload</phrase></textobject>
</mediaobject>
</informalfigure>
</listitem>
<listitem>
<simpara>Navigate to the location of the license</simpara>
</listitem>
<listitem>
<simpara>Select the license (<literal>Peach.license</literal>)</simpara>
</listitem>
<listitem>
<simpara>Click <literal>Open</literal> to return to the download home page.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Upon returning to the Peach download home page, click <literal>Sign In with License</literal>.</simpara>
</listitem>
<listitem>
<simpara>On the <literal>Downloads</literal> page, select the Peach Fuzzer release version and operating system to install.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Choose a release version from the items on the left side.</simpara>
</listitem>
<listitem>
<simpara>Click the download icon on the right side after deciding which OS and architecture is needed.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/Installation/Portal_Downloads.png"/>
</imageobject>
<textobject><phrase>Portal Downloads</phrase></textobject>
</mediaobject>
</informalfigure>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>After a few moments, an End User License Agreement acceptance page appears.
Click <literal>I ACCEPT</literal> to continue.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/Installation/EULA_Acceptance.png"/>
</imageobject>
<textobject><phrase>EULA Acceptance</phrase></textobject>
</mediaobject>
</informalfigure>
</listitem>
<listitem>
<simpara>The download will begin.
Depending on your network connection,
this could take a few minutes.</simpara>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="InstallOnWindows">
<title>Windows</title>
<simpara>Peach is officially supported on the following Windows&#174; Operating Systems:</simpara>
<itemizedlist>
<listitem>
<simpara>Windows 7 SP1 (x86 and x64)</simpara>
</listitem>
<listitem>
<simpara>Windows 8 (x86 and x64)</simpara>
</listitem>
<listitem>
<simpara>Windows 8.1 (x86 and x64)</simpara>
</listitem>
<listitem>
<simpara>Windows 10 (x64)</simpara>
</listitem>
<listitem>
<simpara>Windows Server 2008 SP2 (x86 and x64)</simpara>
</listitem>
<listitem>
<simpara>Windows Server 2008 R2 SP1 (x64)</simpara>
</listitem>
<listitem>
<simpara>Windows Server 2012 (x64)</simpara>
</listitem>
<listitem>
<simpara>Windows Server 2012 R2 (x64)</simpara>
</listitem>
</itemizedlist>
<simpara>The only required software is the Microsoft .NET Framework v4.5.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Download and install the <link xl:href="https://dotnet.microsoft.com/download/dotnet-framework-runtime/net452">Microsoft .NET Framework v4.5.2 (Installer)</link>.</simpara>
</listitem>
<listitem>
<simpara>Install the <link xl:href="https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/debugger-download-tools">Microsoft Debugging Tools for Windows</link> (optional).</simpara>
<note>
<simpara>This is only required if you want to use a debugger to detect crashes in fuzzed programs.</simpara>
</note>
</listitem>
<listitem>
<simpara>Install <link xl:href="https://www.wireshark.org/#download">Wireshark</link> (optional).</simpara>
<note>
<simpara>This is only required if you want to collect network captures during fuzzing runs.</simpara>
</note>
</listitem>
<listitem>
<simpara>Unzip the Peach distribution to the appropriate folder.
The file is a zip file with the extension <literal>.zip</literal>.
Use the filename that begins with <literal>peach-pro</literal> and contains the appropriate architecture for your system,
such as <literal>peach-pro-0.0.0-win_x64_release.zip</literal>.</simpara>
</listitem>
<listitem>
<simpara>When fuzzing, many security products (such as anti-virus programs) can interfere or slowdown fuzzing.
For network fuzzing,
make sure none of the network or host-based network intrusion detection systems (IDS) are running.
For file fuzzing,
disable anti-virus software;
or mark Peach,
the target application,
and any directories that might have files used in fuzzing,
as out of scope for real time monitoring.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="InstallOnLinux">
<title>Linux</title>
<simpara>Peach is supported on three distributions of Linux;
Peach may run on other Linux distributions,
but are not officially supported.
This section provides instructions for installing Peach on the following supported Linux systems,
and includes a checklist for installing Peach on other Linux systems:</simpara>
<itemizedlist>
<listitem>
<simpara>Ubuntu/Debian Linux</simpara>
</listitem>
<listitem>
<simpara>Redhat Enterprise Linux (RHEL and CentOS)</simpara>
</listitem>
<listitem>
<simpara>SUSE Enterprise Linux (SLES)</simpara>
</listitem>
</itemizedlist>
<section xml:id="_ubuntudebian_linux">
<title>Ubuntu/Debian Linux</title>
<simpara>When installing Peach on an Ubuntu or Debian Linux system,
the operating system is ready for Peach without modification.
The installation starts with the Mono .NET runtime, then Peach.
If you want to attach a debugger to a target process,
install GDB when the Mono installation completes.</simpara>
<note>
<simpara>Peach Fuzzer, LLC,
recommends using Ubuntu Linux version 16.04 LTS,
and Mono .NET runtime version 4.8.1 from the mono project.
The mono project has <literal>apt</literal> packages for Ubuntu.</simpara>
<simpara>Peach will not run with Mono version 5.0 or newer due to incompatibilities with IronPython.
If you have Mono 5.0 installed, you must downgrade to 4.8.1.</simpara>
<simpara>Peach will not run with version 4.4 of the Mono runtime as there are known
handle leaks which can cause Peach to run out of memory during long fuzzing runs.
If you have Mono 4.4 installed,
you can either upgrade to 4.6+ or downgrade to 4.2.</simpara>
<simpara>Some Linux kernel versions have known issues with the Mono runtime.
When using Ubuntu 14.04 LTS,
avoid using kernel versions 3.13.0-48 through 3.13.0-54 inclusive.
Version 14.04 LTS might require that you update the Linux kernel.
If so, perform the following to update the kernel: <literal>sudo apt-get install linux-image-generic</literal>.</simpara>
<simpara>The Peach installer checks for compatibility and alerts the user if an incompatibility has been detected.</simpara>
</note>
<simpara>The following steps will prepare Peach to run properly:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Install the latest <literal>mono-complete</literal> package.</simpara>
<screen>sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys  3FA7E0328081BFF6A14DA29AA6A19B38D3D831EF

echo "deb http://download.mono-project.com/repo/debian wheezy/snapshots/4.8.1.0 main" | sudo tee /etc/apt/sources.list.d/mono-xamarin.list

sudo apt-get update

sudo apt-get install mono-complete</screen>
</listitem>
<listitem>
<simpara>Install libpcap using the following command:</simpara>
<screen>sudo apt-get install libpcap</screen>
</listitem>
<listitem>
<simpara>Optionally, install the GNU Debugger (GDB) to enable debugging of local processes.</simpara>
<screen>sudo apt-get install gdb</screen>
</listitem>
<listitem>
<simpara>Unzip the Peach distribution to the appropriate folder.
The file is a zip file with the extension <literal>.zip</literal>.
Use the filename that begins with <literal>peach-pro</literal> and contains the appropriate architecture for your system,
such as <literal>peach-pro-0.0.0-linux_x86_64_release.zip</literal>.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="_redhat_enterprise_linux_rhel_and_centos">
<title>Redhat Enterprise Linux (RHEL and CentOS)</title>
<simpara>Installing Peach on a RHEL CentOS platform requires additional steps.
Begin by installing Extra Packages for Enterprise Linux (EPEL),
followed by the Mono package and Peach.</simpara>
<note>
<simpara>Peach Fuzzer, LLC, recommends using Mono .NET runtime version 4.8.1 from the mono project.
The mono project has <literal>yum</literal> packages for RHEL and CentOS distributions.</simpara>
<simpara>Peach will not run with Mono version 5.0 or newer due to incompatibilities with IronPython.
If you have Mono 5.0 installed, you must downgrade to 4.8.1.</simpara>
<simpara>Peach will not run with version 4.4 of the Mono runtime as there are known
handle leaks which can cause Peach to run out of memory during long fuzzing runs.
If you have Mono 4.4 installed,
you can either upgrade to 4.6+ or downgrade to 4.2.</simpara>
</note>
<note>
<simpara>The following Mono installation steps are taken from the
<link xl:href="http://www.mono-project.com/docs/getting-started/install/linux/#centos-7-fedora-19-and-later-and-derivatives">Mono Project</link>.</simpara>
</note>
<simpara>The following steps provide the needed details:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Install <literal>yum-utils</literal> using the following command:</simpara>
<screen>sudo yum install yum-utils</screen>
</listitem>
<listitem>
<simpara>Install Extra Packages for Enterprise Linux (EPEL) using the following command:</simpara>
<screen>sudo yum install epel-release</screen>
</listitem>
<listitem>
<simpara>Import the GPG signing key for the mono package using the following command. Note the long search key:</simpara>
<screen>sudo rpm --import "http://keyserver.ubuntu.com/pks/lookup?op=get&amp;search=0x3FA7E0328081BFF6A14DA29AA6A19B38D3D831EF"</screen>
</listitem>
<listitem>
<simpara>Add and enable the mono project repository for CentOS using the yum configuration manager:</simpara>
<screen>sudo yum-config-manager --add-repo http://download.mono-project.com/repo/centos/</screen>
</listitem>
<listitem>
<simpara>Install the latest version of Mono using the following command:</simpara>
<screen>sudo yum install mono-complete-4.8.1.0-0.xamarin.1</screen>
</listitem>
<listitem>
<simpara>Install libpcap using the following command:</simpara>
<screen>sudo yum install libpcap</screen>
</listitem>
<listitem>
<simpara>Unzip the Peach distribution to the appropriate folder.
The file is a zip file with the extension <literal>.zip</literal>.
Use the filename that begins with <literal>peach-pro</literal> and contains the appropriate architecture for your system,
such as <literal>peach-pro-0.0.0-linux_x86_64_release.zip</literal>.</simpara>
</listitem>
</orderedlist>
<tip>
<simpara>If you receive and error regarding libMonoPosixHelper the <literal>/etc/mono/config</literal> file may need to be edited.
To edit locate a line that looks like the following (the path may be different):</simpara>
<screen>&lt;dllmap dll="MonoPosixHelper" target="/usr/lib/libMonoPosixHelper.so" os="!windows" /&gt;</screen>
<simpara>Once found use the Linux <emphasis>find</emphasis> command to locate the shared library:</simpara>
<screen>find /usr -name "*libMonoPosixHelper.so"</screen>
<simpara>And finally, update the <literal>/etc/mono/config</literal> entry to the correct path.</simpara>
</tip>
<note>
<simpara>For more information, see the following resources:
* <link xl:href="http://www.mono-project.com/docs/getting-started/install/linux#centos-fedora-and-derivatives">http://www.mono-project.com/docs/getting-started/install/linux#centos-fedora-and-derivatives</link>
* <link xl:href="https://fedoraproject.org/wiki/EPEL#How_can_I_use_these_extra_packages.3F">https://fedoraproject.org/wiki/EPEL#How_can_I_use_these_extra_packages.3F</link></simpara>
</note>
</section>
<section xml:id="_suse_enterprise_linux_sles">
<title>SUSE Enterprise Linux (SLES)</title>
<simpara>To install Peach on a SUSE Enterprise Linux platform,
use the 1-click SUSE mono-complete installation file.
If you want to attach a debugger to a target process,
install GDB when the Mono installation completes.</simpara>
<note>
<simpara>Peach Fuzzer, LLC, recommends using Mono .NET runtime version 4.8.1 from the mono project.
The mono project has packages for SLES distributions.</simpara>
<simpara>Peach will not run with Mono version 5.0 or newer due to incompatibilities with IronPython.
If you have Mono 5.0 installed, you must downgrade to 4.8.1.</simpara>
<simpara>Peach will not run with version 4.4 of the Mono runtime as there are known
handle leaks which can cause Peach to run out of memory during long fuzzing runs.
If you have Mono 4.4 installed,
you can either upgrade to 4.6+ or downgrade to 4.2.</simpara>
</note>
<simpara>The following steps provide the needed details:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Import the GPG signing key for the mono package using the following command. Note the long search key:</simpara>
<screen>sudo rpm --import "http://keyserver.ubuntu.com/pks/lookup?op=get&amp;search=0x3FA7E0328081BFF6A14DA29AA6A19B38D3D831EF"</screen>
</listitem>
<listitem>
<simpara>Add and enable the mono project repository using the zypper configuration manager:</simpara>
<screen>sudo zypper ar -f http://download.mono-project.com/repo/centos/ mono</screen>
</listitem>
<listitem>
<simpara>Install the latest supported version of Mono using the following command:</simpara>
<screen>sudo zypper in mono-complete=4.8.1.0-0.xamarin.1</screen>
</listitem>
<listitem>
<simpara>Install libpcap using the following command:</simpara>
<screen>sudo zypper in libpcap</screen>
</listitem>
<listitem>
<simpara>Optionally, install the GNU Debugger (GDB) for debugging local processes.</simpara>
<screen>sudo yum install gdb</screen>
</listitem>
<listitem>
<simpara>Unzip the Peach binary distribution to the appropriate folder.
The file is a zip file with the extension <literal>.zip</literal>.
Use the filename that begins with <literal>peach-pro</literal> and contains the appropriate architecture for your system,
such as <literal>peach-pro-0.0.0-linux_x86_64_release.zip</literal>.</simpara>
</listitem>
</orderedlist>
<tip>
<simpara>If you receive and error regarding libMonoPosixHelper the <literal>/etc/mono/config</literal> file may need to be edited.
To edit locate a line that looks like the following (the path may be different):</simpara>
<screen>&lt;dllmap dll="MonoPosixHelper" target="/usr/lib/libMonoPosixHelper.so" os="!windows" /&gt;</screen>
<simpara>Once found use the Linux <emphasis>find</emphasis> command to locate the shared library:</simpara>
<screen>find /usr -name "*libMonoPosixHelper.so"</screen>
<simpara>And finally, update the <literal>/etc/mono/config</literal> entry to the correct path.</simpara>
</tip>
</section>
<section xml:id="_other_linux_distributions">
<title>Other Linux Distributions</title>
<simpara>For other Linux versions,
the installation steps are a checklist,
not specific commands.
The checklist follows:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Install the Mono runtime. Version 4.8.1 is recommended.</simpara>
</listitem>
<listitem>
<simpara>Unzip the Peach distribution to an appropriate folder.
The file is a zip file with the extension <literal>.zip</literal>.
Use the filename that begins with <literal>peach-pro</literal> and contains the appropriate architecture for your system,
such as <literal>peach-pro-0.0.0-linux_x86_64_release.zip</literal>.</simpara>
</listitem>
</orderedlist>
<note>
<simpara>Peach Fuzzer, LLC, recommends using Mono .NET runtime version 4.8.1 from the mono project.</simpara>
<simpara>Peach will not run with Mono version 5.0 or newer due to incompatibilities with IronPython.
If you have Mono 5.0 installed, you must downgrade to 4.8.1.</simpara>
<simpara>Peach will not run with version 4.4 of the Mono runtime as there are known
handle leaks which can cause Peach to run out of memory during long fuzzing runs.
If you have Mono 4.4 installed,
you can either upgrade to 4.6+ or downgrade to 4.2.</simpara>
</note>
</section>
</section>
<section xml:id="InstallOnOSX">
<title>macOS</title>
<simpara>To install on macOS, follow the installation steps provided below.  Installation will require installing the Mono .NET runtime, then Peach.
To enable support for the <link linkend="Monitors_CrashWrangler">CrashWrangler</link> monitor,
install CrashWrangler and Xcode.
Note that installing CrashWrangler is optional;
it is only needed when running the target locally.</simpara>
<note>
<simpara>Peach Fuzzer, LLC,
recommends using Mono .NET runtime version 4.8.1 from the mono project.</simpara>
<simpara>Peach will not run with Mono version 5.0 or newer due to incompatibilities with our Python runtime.
If you have Mono 5.0 installed, you must downgrade to 4.8.1.</simpara>
<simpara>Peach will not run with version 4.4 of the Mono runtime as there are known
handle leaks which can cause Peach to run out of memory during long fuzzing runs.
If you have Mono 4.4 installed, you can either upgrade to 4.6+ or downgrade to 4.2.</simpara>
</note>
<orderedlist numeration="arabic">
<listitem>
<simpara>Install the <link xl:href="https://download.mono-project.com/archive/4.8.1/macos-10-universal/">Mono package</link>.</simpara>
</listitem>
<listitem>
<simpara>Unzip the Peach distribution to an appropriate folder.
The file is a zip file with the extension <literal>.zip</literal>.
Use the filename that begins with <literal>peach-pro</literal> and contains the appropriate architecture for your system,
such as <literal>peach-pro-0.0.0-osx_release.zip</literal>.</simpara>
</listitem>
<listitem>
<simpara>Install CrashWrangler.</simpara>
<simpara>CrashWrangler <emphasis role="strong">MUST</emphasis> be compiled on each macOS machine.
Peach includes the CrashWrangler source files in the peach distribution.
Here are instructions to install and compile CrashWrangler from the peach zip.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Ensure XCode is installed.</simpara>
</listitem>
<listitem>
<simpara>Open <literal>Terminal.app</literal>.</simpara>
</listitem>
<listitem>
<simpara>Navigate to the folder where you extracted <literal>peach-pro-0.0.0-osx_release.zip</literal>.</simpara>
</listitem>
<listitem>
<simpara>Finish installing CrashWrangler using the following commands.</simpara>
<screen># Navigate to the folder containing CrashWrangler distribution
cd CrashWrangler

# Extract CrashWrangler sources
unzip 52607_crashwrangler.zip

# Navigate to the folder containing the extracted CrashWrangler sources
cd crashwrangler

# Compile CrashWrangler
$ make

# Ensure installation directory exists
sudo mkdir -p /usr/local/bin

# Install CrashWrangler
sudo cp exc_handler /usr/local/bin

# Navigate to the folder containing peach
cd ../../

# Verify CrashWrangler can run
exc_handler</screen>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
</section>
<section xml:id="License_Activation">
<title>License Activation</title>
<simpara>The list below contains links to the steps for activating the different types of Peach Fuzzer licenses.</simpara>
<variablelist>
<varlistentry>
<term>Usage Based (Online Synchronization)</term>
<listitem>
<simpara>The most common method for activating a usage based license.
A Cloud License Server will be automatically provisioned and managed for you.
However, Peach Fuzzer will require a persistent connection to the Internet.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Usage Based (Offline Synchronization)</term>
<listitem>
<simpara>Users who wish to use Peach Fuzzer in an offline without having access to the Internet can deploy a
Local License Server onsite to provide offline activation and synchronization of licensing information.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Node Locked</term>
<listitem>
<simpara>The license is tied to the physical machine running Peach Fuzzer.
No license server is required and internet connectivity is only needed for activation.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Enterprise</term>
<listitem>
<simpara>No activation is required for enterprise customers.</simpara>
</listitem>
</varlistentry>
</variablelist>
<section xml:id="ActivateOnline">
<title>Usage Based (Online Synchronization)</title>
<simpara>A Cloud License Server provides functionality for serving and monitoring a counted pool of licenses for Peach Fuzzer.
A persistent connection to the Internet is required so that usage data can be uploaded to the Cloud License Server while a Peach Fuzzer job is running.
Peach Fuzzer will automatically activate the first time it is run.</simpara>
<note>
<simpara>If a proxy server is required to connect to the Internet, it must be configured as described below.</simpara>
</note>
<section xml:id="_windows_proxy_configuration">
<title>Windows Proxy configuration</title>
<simpara>On Windows, the system proxy setting is the correct way to configure the proxy peach will use to connect to the licensing server.</simpara>
<variablelist>
<varlistentry>
<term>Windows 10</term>
<listitem>
<simpara>The system proxy settings are configured at Settings &gt; Network &amp; Internet &gt; Proxy.
From there you will be able to enter the IP and Port of the proxy server.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Windows 8</term>
<listitem>
<simpara>The system proxy settings are configured at PC Settings &gt; Network Proxy.
From there you will be able to enter the IP and Port of the proxy server.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Windows 7</term>
<listitem>
<simpara>The system proxy settings are configured through the Internet Settings dialog.
Open the Internet Options window located at Control Panel &gt; Network and Internet &gt; Internet Options.<?asciidoc-br?></simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Click the "Connections" tab at the top of the Internet Options window.<?asciidoc-br?></simpara>
</listitem>
<listitem>
<simpara>Click the "LAN Settings" button at the bottom of the window.<?asciidoc-br?></simpara>
</listitem>
<listitem>
<simpara>Click the "Advanced" button under Proxy Server will allow you to change advanced settings and enable a manual proxy server.</simpara>
</listitem>
</orderedlist>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_linux_proxy_configuration">
<title>Linux Proxy Configuration</title>
<simpara>The proxy configuration on Linux is controlled via two environment variables <literal>http_proxy</literal> and <literal>https_proxy</literal>.
Ensure both variables are set prior to starting Peach Fuzzer.</simpara>
<screen>export http_proxy=http://xxxxx
export https_proxy=https://xxxxx</screen>
</section>
</section>
<section xml:id="ActivateOffline">
<title>Usage Based (Offline Synchronization)</title>
<simpara>The Local License Server provides functionality for serving and monitoring a counted pool of licenses for Peach Fuzzer.
Users who wish to use Peach Fuzzer without having access to the Internet can deploy a
Local License Server onsite to provide offline activation and synchronization of licensing
information.</simpara>
<simpara>The instructions for installing and activating a Local License Server can be found on the <link xl:href="https://portal.peachfuzzer.com">Peach Portal</link> by navigating to the "Licensing" tab and clicking the "Local License Server" button for the desired license.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/Installation/Portal_LLS_Button.png"/>
</imageobject>
<textobject><phrase>Portal LLS Button</phrase></textobject>
</mediaobject>
</informalfigure>
</section>
<section xml:id="ActivateNodeLock">
<title>Node Locked</title>
<simpara>No license server is required, as node locked licenses are tied to an individual machine.
Peach Fuzzer will automatically activate the first time it is run.</simpara>
<simpara>If your license has changed and you want Peach Fuzzer refresh its license, run the following command:</simpara>
<screen>peach --activate</screen>
<simpara>If you wish to move your license to a new machine, you must first deactivate the existing instance by running the following command:</simpara>
<screen>peach --deactivate</screen>
<note>
<simpara>Peach Fuzzer requires an internet connection in order to perform activation and deactivation.  Once activated, no further internet connectivity is required.</simpara>
</note>
</section>
<section xml:id="ActivateEnterprise">
<title>Enterprise</title>
<simpara>No activation is required for enterprise customers.
The enterprise license is automatically embedded in the Peach Fuzzer download.</simpara>
</section>
</section>
<section xml:id="InstallSecureInstall">
<title>Enabling HTTPS And Authentication</title>
<simpara>Peach Fuzzer Professional uses a web interface for configuration and control of the fuzzing engine.
By default, the web interface is accessible with no encryption (SSL/TLS) and no authentication.
If the use of HTTPS or authentication is required, a reverse proxy (apache/nginx/traefik) can be used to provide both SSL/TLS and authentication.</simpara>
<section xml:id="_reverse_proxy_with_nginx">
<title>Reverse Proxy with NGINX</title>
<simpara>The following steps will configure NGINX as a reverse proxy for Peach adding TLS and authentication:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Install nginx using your Linux package manager</simpara>
</listitem>
<listitem>
<simpara>Create required key.  For self signed keys this
<link xl:href="http://www.selfsignedcertificate.com/">online self-signed certificate generator</link> can be used.</simpara>
</listitem>
<listitem>
<simpara>Install the included NGINX configuration file to /etc/nginx/sites-available/peach</simpara>
</listitem>
<listitem>
<simpara>Install certificate and key and update configuration file if needed</simpara>
</listitem>
<listitem>
<simpara>Create .htpasswd with username/passwords replacing <literal>USERNAME</literal> with your username</simpara>
<screen>sudo sh -c "echo -n 'USERNAME:' &gt;&gt; /etc/nginx/.htpasswd"
sudo sh -c "openssl passwd -apr1 &gt;&gt; /etc/nginx/.htpasswd"</screen>
</listitem>
<listitem>
<simpara>Add a firewall rule to block external access to Peach&#8217;s port 8888.  Make sure this rule is enabled on bootup.</simpara>
</listitem>
<listitem>
<simpara>Link /etc/nginx/sites-available/peach to /etc/nginx/sites-enabled/peach</simpara>
</listitem>
<listitem>
<simpara>Restart NGINX and verify configuration is working</simpara>
</listitem>
</orderedlist>
<section xml:id="_nginx_configuration_file">
<title>NGINX Configuration File</title>
<screen># HTTPS server
#
server {
        listen 443;
        server_name localhost;

        root html;
        index index.html index.htm;

        ssl on;
        ssl_certificate /etc/ssl/certs/ssl.crt;
        ssl_certificate_key /etc/ssl/private/ssl.key;

        ssl_session_timeout 5m;

        ssl_protocols TLSv1.1 TLSv1.2;
        ssl_ciphers "HIGH:!aNULL:!MD5 or HIGH:!aNULL:!MD5:!3DES";
        ssl_prefer_server_ciphers on;

        location / {
                # First attempt to serve request as file, then
                # as directory, then fall back to displaying a 404.
                #try_files $uri $uri/ =404;
                # Uncomment to enable naxsi on this location
                # include /etc/nginx/naxsi.rules


                auth_basic "Restricted";
                auth_basic_user_file /etc/nginx/.htpasswd;
                proxy_pass http://127.0.0.1:8888/;
        }
}</screen>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
</section>
</section>
<section xml:id="Brand_new_items">
<title>What&#8217;s new in Peach Fuzzer Professional v0.0</title>
<simpara>This section provides a high-level view of the changes introduced this
release of Peach Fuzzer Professional.</simpara>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
<section xml:id="RunningPeach">
<title>Running Peach</title>
<simpara>Peach Fuzzer Professional includes a number of executable files.
In most instances,
using the web interface will meet your needs.
Peach can also be used from the command line.
This includes using the Peach Web Interface,
which launches by running Peach from the command line without any parameters or switches.</simpara>
<simpara>The following list identifies the support applications included with Peach Fuzzer Professional.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="33.3333*"/>
<colspec colname="col_3" colwidth="33.3334*"/>
<thead>
<row>
<entry align="left" valign="top">Program</entry>
<entry align="left" valign="top">Executable</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><link linkend="Program_PeachWebIF">Peach Web Interface</link></simpara></entry>
<entry align="left" valign="top"><simpara><literal>Peach.exe</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The Peach Web Interface for Peach Fuzzer.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="Program_Peach">Peach Command Line</link></simpara></entry>
<entry align="left" valign="top"><simpara><literal>Peach.exe</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The Peach Command Line Interface for Peach Fuzzer.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="Program_PeachAgent">Peach Agent</link></simpara></entry>
<entry align="left" valign="top"><simpara><literal>PeachAgent.exe</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The Agent process for Peach Fuzzer.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="Program_PeachMinset">Minset</link></simpara></entry>
<entry align="left" valign="top"><simpara><literal>PeachMinset.exe</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Find the minimal set of sample files for use during fuzzing with the greatest code coverage for a given target.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="PitTool_Ninja">PitTool - Sample Ninja</link></simpara></entry>
<entry align="left" valign="top"><simpara><literal>PitTool.exe</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Create a sample ninja database.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="Program_PeachMultiNodeCli">Peach Multi-Node CLI Tool</link></simpara></entry>
<entry align="left" valign="top"><simpara><literal>sdk\tools\peachcli</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Control and coordinate multiple Peach instances.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><?asciidoc-pagebreak?></simpara>
<section xml:id="Program_PeachWebIF">
<title>The Peach Web Interface</title>
<simpara>The Peach Web Interface is an interactive interface to Peach Fuzzer Professional that simplifies monitoring of local and remote fuzzing jobs. Using Peach Web Interface, you can select, configure, and run fuzzing definitions (Pits). The Peach Web Interface is operating system agnostic. This means that you can use the same interface to run Peach, whether on Windows, Linux, or OS X. When a Pit is running, you can view the state of the fuzzing job and see faults that result.</simpara>
<simpara>The Peach Web Interface works with Pits from the included Pit Library. With a little configuration, the Pits will be ready to run. Once you settle on a Pit that you want to use, you can configure the Pit to detect faults, to collect data, or to automate the fuzzing session.</simpara>
<section xml:id="_peach_web_interface_installation_requirements">
<title>Peach Web Interface Installation Requirements</title>
<simpara>The Peach Web Interface uses modern web technologies, such as HTML 5. Yet,  Peach Web Interface requires two things to run:</simpara>
<itemizedlist>
<listitem>
<simpara>JavaScript, enabled in your web browser</simpara>
</listitem>
<listitem>
<simpara>A supported browser</simpara>
<itemizedlist>
<listitem>
<simpara>Internet Explorer: version 9 and newer</simpara>
</listitem>
<listitem>
<simpara>Safari: version 6 and newer</simpara>
</listitem>
<listitem>
<simpara>Firefox: version 4 and newer</simpara>
</listitem>
<listitem>
<simpara>Chrome: version 12 and newer</simpara>
</listitem>
<listitem>
<simpara>Opera: version 12 and newer</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
<note>
<simpara>Other browsers might work; however, they are not officially supported</simpara>
</note>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
<section xml:id="Start_Peach_Web">
<title>Starting the Peach Web Interface</title>
<simpara>You can start the Peach Web Interface using the GUI File Manager or from the command line. Both methods include the same functionality, use the method you prefer.</simpara>
<simpara>We recommend running Peach with heightened or administrative privileges. Some applications that provide monitoring functions, such as debuggers, need heightened access to run.</simpara>
<simpara>You can start Peach from a command line with two actions:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Open a command shell with administrative privileges.</simpara>
</listitem>
<listitem>
<simpara>On the command line, type Peach and press RETURN. The following illustration shows starting Peach in Windows.</simpara>
</listitem>
</orderedlist>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/WebUI/P1_Starting_Peach.png"/>
</imageobject>
<textobject><phrase>P1 Starting Peach</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>The Peach Web Interface is the default mode of operation for the command line. Launching the Peach Web Interface performs the following tasks:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Starts Peach Fuzzer Professional</simpara>
</listitem>
<listitem>
<simpara>Loads your default web browser with the Peach Web Interface URL</simpara>
<simpara>On the first launch of Peach, a licensing page displays.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/WebUI/P2_EULA_Details.png"/>
</imageobject>
<textobject><phrase>P2 EULA Details</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>When you have read and understood the End User License Agreement, click <emphasis>Accept</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Displays the Peach Home Page</simpara>
</listitem>
</orderedlist>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/WebUI/H1_Home.png"/>
</imageobject>
<textobject><phrase>H1 Home</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>From Home, you can use click entries and buttons on the left side of the page to work with your licensed Pits, view reports and details of previous fuzzing sessions, and to interact with the Peach forums.</simpara>
<section xml:id="_parts_of_the_user_interface">
<title>Parts of the User Interface</title>
<simpara>The Web User Interface includes many useful components, the most prominent are called out in the following illustration:</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/WebUI/H1_Annotated.png"/>
</imageobject>
<textobject><phrase>H1 Annotated</phrase></textobject>
</mediaobject>
</informalfigure>
<section xml:id="_1_page_title">
<title>1. Page Title</title>
<simpara>The Page title identifies the page you are on and establishes the context of your current task.</simpara>
</section>
<section xml:id="_2_menu_entries">
<title>2. Menu Entries</title>
<simpara>Menu entries are located along the left edge of the browser window. These buttons identify the functionality immediately at your disposal. Whether you want to explore your Pit Library, investigate a completed fuzzing job, or get some assistance from Help or the Forums, the menu is there for you.</simpara>
<simpara>The entries in the menu change according to the work context. For example, when you start working with a Pit, the menu entries change to accommodate editing a Pit definition. Click an entry in the menu to start working on that item. There is also an option to collapse the menu.</simpara>
</section>
<section xml:id="_3_menu_icons">
<title>3. Menu Icons</title>
<simpara>Located above the menu entries, the menu icons are always present and do not change. The icons are always:</simpara>
<itemizedlist>
<listitem>
<simpara>Home Page</simpara>
</listitem>
<listitem>
<simpara>Your Pit Library</simpara>
</listitem>
<listitem>
<simpara>Your Fuzzing Job Historical Results</simpara>
</listitem>
<listitem>
<simpara>Peach User&#8217;s Guide (HTML Help)</simpara>
</listitem>
</itemizedlist>
<simpara>Click a menu icon to move there.</simpara>
</section>
<section xml:id="_4_breadcrumb_menu">
<title>4. Breadcrumb menu</title>
<simpara>The breadcrumb is located above the Page Title and identifies your position within the Peach Web UI.
Portions of the breadcrumb are links and marked appropriately by color.</simpara>
</section>
</section>
<section xml:id="_a_quick_tour_of_the_peach_web_interface">
<title>A Quick Tour of the Peach Web Interface</title>
<simpara>This section provides a brief glimpse of the main areas of Peach that are accessible from the menu and buttons on the left edge of the page. The tour is quick: about a slide per menu item.</simpara>
<section xml:id="_library">
<title>Library</title>
<simpara>The <emphasis>Library</emphasis> menu is where you select and configure Pits (fuzzing definitions), and run fuzzing jobs. The page lists the licensed Peach Pits first, then follows with the defined configurations that you create.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/WebUI/H2_Library.png"/>
</imageobject>
<textobject><phrase>H2 Library</phrase></textobject>
</mediaobject>
</informalfigure>
</section>
<section xml:id="_jobs">
<title>Jobs</title>
<simpara>The <emphasis>Jobs</emphasis> menu provides access to your fuzzing job results. Click on an entry to see the report status, summary, metrics, and drill down detail of individual findings.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/WebUI/H3_Jobs.png"/>
</imageobject>
<textobject><phrase>H3 Jobs</phrase></textobject>
</mediaobject>
</informalfigure>
</section>
<section xml:id="_help">
<title>Help</title>
<simpara>The <emphasis>Help</emphasis> Menu provides access to the online Peach User Guide. This instructional piece provides workflows for installing Peach, recipes for setting up and running various configurations, and descriptions of the Peach monitors for detecting faults (issues), collecting data, and automating the test environment.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/WebUI/H4_HTMLHelp.png"/>
</imageobject>
<textobject><phrase>H4 HTMLHelp</phrase></textobject>
</mediaobject>
</informalfigure>
<note>
<simpara>Additionally, the <emphasis>User Guide</emphasis> is available in PDF format.</simpara>
</note>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/WebUI/H5_PdfHelp.png"/>
</imageobject>
<textobject><phrase>H5 PdfHelp</phrase></textobject>
</mediaobject>
</informalfigure>
</section>
<section xml:id="_forums">
<title>Forums</title>
<simpara>Peach has user forums that serve as a knowledge base of user questions, and as an active platform to raise questions of current need or interest. Feel free to explore the forums. Note that the professional forum provides a service venue to licensed users of Peach Professional and Peach Enterprise solutions.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/WebUI/H6_PeachForums.png"/>
</imageobject>
<textobject><phrase>H6 PeachForums</phrase></textobject>
</mediaobject>
</informalfigure>
</section>
</section>
</section>
<section xml:id="Program_PeachWebAdvanceConfig">
<title>Configuration Menu</title>
<simpara>You can configure a Pit by using the Configuration menu.
This menu consists of four parts: variables, monitoring, tuning, and test.
Only the Variable and Monitoring parts need to be completed to pass a test of the configuration.</simpara>
<simpara>To begin from the Home Page,</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Click the Library menu entry.</simpara>
</listitem>
<listitem>
<simpara>From the Pit Library, select a Pit or an existing configuration.</simpara>
<itemizedlist>
<listitem>
<simpara>Selecting a configuration means that you are revising the settings of an existing configuration. Peach displays the start screen for the configuration.</simpara>
</listitem>
<listitem>
<simpara>Selecting a Pit means that you are creating a new configuration. You will need to
name the configuration, optionally provide a description, and click "Submit" to reach the start screen for the configuration.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/WebUI/NP2_Config_Start.png"/>
</imageobject>
<textobject><phrase>NP2 Config Start</phrase></textobject>
</mediaobject>
</informalfigure>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Click the "Configure Variables" button to define or edit the variables and their values.</simpara>
</listitem>
</orderedlist>
<note>
<simpara><emphasis role="strong">Switching Pit Configurations</emphasis></simpara>
<simpara>The active Peach Pit configuration can be changed in the Peach Web Interface by clicking on the Home menu icon above the menu along the left side of the screen. Then, click on the Library menu item to choose a Pit or Pit configuration in your library.</simpara>
</note>
<section xml:id="_variables">
<title>Variables</title>
<simpara>The variables data entry screen lists the information needed by the selected pit, as in the following illustration. Some information is pit-specific, such as file names used to fuzz file formats and port addresses used to fuzz network protocols. Other information applies to the Peach environment; two examples are the Peach Installation Directory and the Pit Library Path.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/WebUI/AC01_Variables_Init.png"/>
</imageobject>
<textobject><phrase>AC01 Variables Init</phrase></textobject>
</mediaobject>
</informalfigure>
</section>
<section xml:id="_pit_specific_variables">
<title>Pit-specific Variables</title>
<simpara>In the illustration, three variables are specific to the <literal>BMP</literal> Pit. Because the variables have default values, you can use the supplied values during the fuzzing job.</simpara>
<itemizedlist>
<listitem>
<simpara>If a variable lacks a default value and is not marked optional, you need to supply a value for the variable before you can fuzz the target.</simpara>
</listitem>
<listitem>
<simpara>If a variable is labeled optional or has a default value, you need not supply a value to enable the configuration to run.</simpara>
</listitem>
</itemizedlist>
<simpara>When entering a data value, type the value into the appropriate text box of the form.
If you&#8217;d like to use the value of another variable, type <literal>##</literal>, the name of the
variable that contains the value you want to use, and <literal>##</literal> to end the variable name.</simpara>
<simpara>The default value of the <literal>Sample Path</literal> variable in the previous illustration uses another variable (<literal>PitLibraryPath</literal>) as part of its value.</simpara>
</section>
<section xml:id="_system_defined_variables">
<title>System-defined Variables</title>
<simpara>The Peach environment variables includes the following entries:</simpara>
<variablelist>
<varlistentry>
<term>Peach OS</term>
<listitem>
<simpara>The Peach OS identifies the operating system that the Peach Fuzzer is using. The value is selected when downloading the Peach distribution image.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Peach Installation Directory</term>
<listitem>
<simpara>The Peach Installation Directory is the directory that contains the peach executable file. This directory was created when Peach was installed on the computer system.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Peach Working Directory</term>
<listitem>
<simpara>The Peach working directory is the current working directory for fuzzing. While this directory is usually the directory containing Peach, the directory can be another location on your system. The Peach Working Directory is set by launching Peach from the shell command line. The value is the current working directory of the command shell when you start Peach.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Root Log Directory</term>
<listitem>
<simpara>The default name of this directory is Logs. The default location is a subdirectory of the Peach Installation Directory. You can specify another location for it, such as a subdirectory of the Peach Working Directory.<?asciidoc-br?></simpara>
<tip>
<simpara>Each pit has its own logs that appear as subdirectories of the logger Path.</simpara>
</tip>
</listitem>
</varlistentry>
<varlistentry>
<term>Pit Library Path</term>
<listitem>
<simpara>The Pit library path is the full path of the folder in the Peach installation directory that contains your licensed Peach Pits and Pit Packs. The folder name is "pits", and contains subdirectories that hold your licensed Pits, Pit configurations, and Peach-supplied sample files.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>For descriptions on the pit-specific variables, see the documentation for the individual pit.</simpara>
<section xml:id="_custom_variables">
<title>Custom Variables</title>
<simpara>You can create your own set variables for Peach. Perhaps you want to identify
where the image repository is located. Or, perhaps you want to identify the
MAC addresses, interface names, and IP addresses for the network interfaces on
your system.</simpara>
<simpara>Whatever the resource you&#8217;d like to specify, once you&#8217;ve created a variable and
given it a value, you can use the variable wherever appropriate when supplying
values for Pit variables and monitor variables.</simpara>
<simpara>Additionally, once defined, the custom variable is added to the dropdown variable list. The list of variables displays during data entry when a <literal>#</literal> is typed as the sole character in a data field, as shown in the following illustration.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/WebUI/AC02_Variable_DropList.png"/>
</imageobject>
<textobject><phrase>AC02 Variable DropList</phrase></textobject>
</mediaobject>
</informalfigure>
<section xml:id="_creating_a_custom_variable">
<title>Creating a custom variable</title>
<simpara>Here are the steps to add a custom variable to Peach:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Begin on the Variables page.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/WebUI/AC03_Vars_AddVar.png"/>
</imageobject>
<textobject><phrase>AC03 Vars AddVar</phrase></textobject>
</mediaobject>
</informalfigure>
</listitem>
<listitem>
<simpara>Click the "Add Variable" button immediately above and to the right of list of variables.</simpara>
<simpara>The "Add Variable" pop-up dialog displays.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/WebUI/AC04_AddVar_Popup.png"/>
</imageobject>
<textobject><phrase>AC04 AddVar Popup</phrase></textobject>
</mediaobject>
</informalfigure>
</listitem>
<listitem>
<simpara>Fill in values for the name, key, and value fields. The following illustration shows a variable locating a JPEG repository.</simpara>
<itemizedlist>
<listitem>
<simpara>The <emphasis role="strong">Name</emphasis> parameter is the name of the custom variable, and allows spaces and
punctuation. This is the name to search on if you want to edit the value of the variable.</simpara>
</listitem>
<listitem>
<simpara>The <emphasis role="strong">Key</emphasis> parameter is the value, such as <literal>JPEGs</literal>, that you plug into values in the Peach Web UI. When Peach processes the pit, the fuzzer replaces the key parameter with the value of the <emphasis role="strong">Value</emphasis> parameter.</simpara>
</listitem>
<listitem>
<simpara>The <emphasis role="strong">Value</emphasis> parameter stores the value that Peach uses when processing the pit.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/WebUI/AC05_AddVar_FilledIn.png"/>
</imageobject>
<textobject><phrase>AC05 AddVar FilledIn</phrase></textobject>
</mediaobject>
</informalfigure>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Click OK.</simpara>
</listitem>
<listitem>
<simpara>Click save.<?asciidoc-br?>
The new value is now part of the list, and has been saved for future use.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/WebUI/AC06_Vars_Page_Saved.png"/>
</imageobject>
<textobject><phrase>AC06 Vars Page Saved</phrase></textobject>
</mediaobject>
</informalfigure>
</listitem>
</orderedlist>
</section>
<section xml:id="_using_a_custom_variable">
<title>Using a custom variable</title>
<simpara>Using a custom variable consists of typing <literal>##</literal>, the variable name, and <literal>##</literal> in the value of another variable. In the following illustration, the "Sample Path" variable refers to the "JPEG Sample Pictures". When parsing the configuration information, Peach inserts the value <literal>C:\Samples\JPEG</literal> for the value of the "Sample Path".</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/WebUI/AC07_Vars_Page_Using.png"/>
</imageobject>
<textobject><phrase>AC07 Vars Page Using</phrase></textobject>
</mediaobject>
</informalfigure>
</section>
</section>
</section>
<section xml:id="_monitoring">
<title>Monitoring</title>
<simpara>The Monitoring data entry screen defines one or more Agents and one or more Monitors for the Pit.</simpara>
<simpara>Agents are host processes for monitors and publishers. Local agents can reside on the same machine as Peach, and can control the test environment through monitors and publishers. Remote agents reside on the test target, and can provide remote monitors and publishers.</simpara>
<simpara>Monitors are components that perform one or more of the following functions: detect faults (issues), collect data associated with faults, and help manage the fuzzing job to reduce the level of human interaction throughout the job.</simpara>
<section xml:id="_from_the_home_page">
<title>From the Home Page</title>
<simpara>To begin configuring from the Home Page:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Click the Library menu entry.</simpara>
</listitem>
<listitem>
<simpara>From the Pit Library, select a Pit or an existing configuration.</simpara>
<itemizedlist>
<listitem>
<simpara>Selecting a configuration means that you are revising the settings of an existing configuration. Peach displays the start screen for the configuration.</simpara>
</listitem>
<listitem>
<simpara>Selecting a Pit means that you are creating a new configuration. You will need to name the configuration, optionally provide a description, and click "Submit" to reach the start screen for the configuration.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/WebUI/NP2_Config_Start.png"/>
</imageobject>
<textobject><phrase>NP2 Config Start</phrase></textobject>
</mediaobject>
</informalfigure>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Click the "Configure Monitoring" button to define or edit agents, monitors, and the data values associated with them. The Monitoring data entry screen displays and is initially empty.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/WebUI/AC08_Monitors_Page_Empty.png"/>
</imageobject>
<textobject><phrase>AC08 Monitors Page Empty</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>The workflow for this data entry screen has you declare an Agent. Then, you can branch out and do the following in any order:</simpara>
<itemizedlist>
<listitem>
<simpara>Declare one or more monitors for the agent</simpara>
</listitem>
<listitem>
<simpara>Fill in details for a monitor</simpara>
</listitem>
<listitem>
<simpara>Switch focus from one monitor to another</simpara>
</listitem>
<listitem>
<simpara>Declare additional agents, as needed</simpara>
</listitem>
<listitem>
<simpara>Switch focus from one agent to another</simpara>
</listitem>
</itemizedlist>
</listitem>
</orderedlist>
<simpara>In this instance, we&#8217;re going to complete the agent, then add a monitor and fill in the monitor settings.</simpara>
</section>
<section xml:id="_specifying_an_agent">
<title>Specifying an Agent</title>
<simpara>Here are the steps to add an agent to a configuration:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Click the "Add Agent" button. Peach adds a new agent to the Monitors page, as in the following illustration.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/WebUI/AC09_Mon_Pg_NewAgent.png"/>
</imageobject>
<textobject><phrase>AC09 Mon Pg NewAgent</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>An agent has a name and location. The location can be local or remote.</simpara>
<itemizedlist>
<listitem>
<simpara>Local agents run in the same process space as the Peach fuzzing engine.</simpara>
</listitem>
<listitem>
<simpara>Remote agents are separate processes that can reside on the same hardware as the test target. Remote agents act as intermediaries between Peach and test targets, sending test cases to the test target and replying with test case results and data back to Peach.</simpara>
<simpara>If you use a remote agent, you need to supply location information that conforms to a URL with the following parts: <literal>channel://host:port</literal></simpara>
<variablelist>
<varlistentry>
<term>channel</term>
<listitem>
<simpara>Specify one of the following for the channel type: <emphasis>local</emphasis>, <emphasis>tcp</emphasis>, or <emphasis>http</emphasis>. Typical remote agent configurations should use the <emphasis>tcp</emphasis> channel.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>host</term>
<listitem>
<simpara>Specify the hostname of the agent to be used. This value is not required for the <emphasis>local</emphasis> channel.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>port</term>
<listitem>
<simpara>Specify the port number of the agent to be used. This value is not required for the <emphasis>local</emphasis> channel.</simpara>
</listitem>
</varlistentry>
</variablelist>
</listitem>
<listitem>
<simpara>Example agent using the <literal>tcp</literal> channel: <literal>tcp://192.168.127.128:9001</literal></simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Give the agent a name, such as <literal>LocalAgent</literal> and click "Save".</simpara>
<simpara>Peach saves the Agent information, provides a visual cue with a "Saved successfully." message in a banner near the top of the page.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="_adding_a_monitor">
<title>Adding a Monitor</title>
<orderedlist numeration="arabic">
<listitem>
<simpara>click the "Add a monitor&#8230;&#8203;" button.<?asciidoc-br?>
Peach displays a list of monitors that you can use in your configuration. The monitors are categorized by usage. Fault detection monitors appear first, then data collection, automation, android, and lastly, other monitors.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/WebUI/AC10_Mon_Pg_Monitor_DropList.png"/>
</imageobject>
<textobject><phrase>AC10 Mon Pg Monitor DropList</phrase></textobject>
</mediaobject>
</informalfigure>
</listitem>
<listitem>
<simpara>Select the <literal>WindowsDebugger</literal> entry, located under the <literal>Fault Detection</literal> section, and click "OK".</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/WebUI/AC11_Mon_Pg_Added_WinDbg.png"/>
</imageobject>
<textobject><phrase>AC11 Mon Pg Added WinDbg</phrase></textobject>
</mediaobject>
</informalfigure>
</listitem>
<listitem>
<simpara>Fill in the details of monitor.<?asciidoc-br?>
Configuration information for each monitor is available in the <link linkend="Monitors">Monitors</link> reference section. A list of monitors appears at the start of the section that links to the individual entries.</simpara>
<simpara>The monitor parameters divide into three groups: "Core", "When To Trigger", and "Advanced".</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/WebUI/AC12_Mon_Windbg_Detail.png"/>
</imageobject>
<textobject><phrase>AC12 Mon Windbg Detail</phrase></textobject>
</mediaobject>
</informalfigure>
<itemizedlist>
<listitem>
<simpara>The "Core" parameters consist of parameters that you should check when creating or editing a configuration. This monitor provides a choice of what to monitor: an executable file, a running process, or a service.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/WebUI/AC12A_Mon_WinDbg_Core.png"/>
</imageobject>
<textobject><phrase>AC12A Mon WinDbg Core</phrase></textobject>
</mediaobject>
</informalfigure>
</listitem>
<listitem>
<simpara>The "When To Trigger" addresses timing-related issues, such as restarting the test target at the end of an iteration. This is common for file fuzzing, where Peach creates a fuzzed data file, then starts the target with the fuzzed file as input.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/WebUI/AC12B_Mon_WinDbg_Trigger.png"/>
</imageobject>
<textobject><phrase>AC12B Mon WinDbg Trigger</phrase></textobject>
</mediaobject>
</informalfigure>
</listitem>
<listitem>
<simpara>The "Advanced" parameters are items that seldom need to be specified; the default values of these parameters are usually sufficient as is. Yet, once in a while you might need to access one of these parameters. When fuzzing a network client, the "No Cpu Kill" parameter needs to be set to true to give the client an opportunity to close cleanly.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/WebUI/AC12C_Mon_WinDbg_Advanced.png"/>
</imageobject>
<textobject><phrase>AC12C Mon WinDbg Advanced</phrase></textobject>
</mediaobject>
</informalfigure>
</listitem>
</itemizedlist>
</listitem>
</orderedlist>
</section>
<section xml:id="_sample_agent_with_multiple_monitors">
<title>Sample Agent with Multiple Monitors</title>
<simpara>The following illustration is of an agent with multiple monitors. Note that you can show or hide the details for a monitor by clicking the chevron preceding the monitor name. In fact, this is true for agents, too.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/WebUI/AC13_LocAgnt_n_Mtrs.png"/>
</imageobject>
<textobject><phrase>AC13 LocAgnt n Mtrs</phrase></textobject>
</mediaobject>
</informalfigure>
</section>
<section xml:id="_sample_remote_agent">
<title>Sample Remote Agent</title>
<simpara>The following illustration is of a remote agent. The location of the agent is the IP address of the remote machine, and that the address is stored in a custom variable. The agent manages multiple monitors.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/WebUI/AC14_RemAgnt_n_Mtrs.png"/>
</imageobject>
<textobject><phrase>AC14 RemAgnt n Mtrs</phrase></textobject>
</mediaobject>
</informalfigure>
</section>
</section>
<section xml:id="WebUI_Config_Tuning">
<title>Tuning</title>
<simpara>Tuning allows control of how testing is performed on a field-by-field basis.</simpara>
<simpara>Fields are shown hierarchically below. A search feature is provided to quickly find fields of interest. Each field, or set of fields, can be excluded from testing or have its testing focus turned up or down. As a field&#8217;s focus is turned up (High or Highest), test cases will be generated more often for that field. If a field is turned down (Low, Lowest), fewer test cases will be generated for that field. Fields that are excluded will not have any test cases generated.</simpara>
<simpara>Excluding fields from testing should be used judiciously as it can lead to undiscovered faults.</simpara>
<note>
<simpara>Tuning is not required. In fact it&#8217;s recommended to use the defaults and let Peach decide how often to test fields.</simpara>
</note>
<section xml:id="_from_the_home_page_2">
<title>From the Home Page</title>
<simpara>To begin configuring from the Home Page:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Click the Library menu entry.</simpara>
</listitem>
<listitem>
<simpara>From the Pit Library, select a Pit or an existing configuration.</simpara>
<itemizedlist>
<listitem>
<simpara>Selecting a configuration means that you are revising the settings of an existing configuration. Peach displays the start screen for the configuration.</simpara>
</listitem>
<listitem>
<simpara>Selecting a Pit means that you are creating a new configuration. You will need to name the configuration, optionally provide a description, and click "Submit" to reach the start screen for the configuration.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/WebUI/NP2_Config_Start.png"/>
</imageobject>
<textobject><phrase>NP2 Config Start</phrase></textobject>
</mediaobject>
</informalfigure>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Click the "Configure" menu item on the left of the screen. It will expand to show several configuration options.</simpara>
</listitem>
<listitem>
<simpara>Click the "Tuning" sub-menu item to access the Tuning page.
The Monitoring data entry screen displays and is initially empty.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/WebUI/AC_Tuning.png"/>
</imageobject>
<textobject><phrase>AC Tuning</phrase></textobject>
</mediaobject>
</informalfigure>
</listitem>
</orderedlist>
</section>
<section xml:id="_tuning_fields">
<title>Tuning Fields</title>
<simpara>The Tuning page shows fields in a hierarchy. For file pits such as media formats or application formats, this will be the format of the file being generated.  For network pits, the hierarchy will show different packets or messages being transmitted, assuming the protocol has this concept.  When modifying a field that contains children, by default all of the children will also be changed.  This allows quickly tuning entire messages or sections of a message.</simpara>
<simpara>For each field there are several tuning options:</simpara>
<variablelist>
<varlistentry>
<term>Exclude</term>
<listitem>
<simpara>Don&#8217;t perform any testing of this field.</simpara>
<caution>
<simpara>Excluding fields from testing should be used judiciously, as it may lead to missed faults. It&#8217;s our recommendation that all fields get tested.
Instead of excluding fields, consider tuning them to lower or lowest.</simpara>
</caution>
</listitem>
</varlistentry>
<varlistentry>
<term>Lowest</term>
<listitem>
<simpara>Produce the least number of test cases for this field.
When selected, the field will still receive some testing, but much less than fields marked as normal.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Low</term>
<listitem>
<simpara>Produce fewer test cases for this field.
Fields tuned to low will still be tested, but fewer test cases will be generated compared to fields marked as normal.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Normal</term>
<listitem>
<simpara>No changes to how this field is tested.
Peach will decide how often to generate test cases for fields marked as normal.
This is the recommended setting for all fields.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>High</term>
<listitem>
<simpara>Produce more test cases for this field.
Fields tuned to high will receive more testing than those marked as normal.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Highest</term>
<listitem>
<simpara>Produce even more test cases for this field.
Fields tuned to highest will receive more testing than those marked as high.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>Once you have completed tuning the fields, click the Save button in the upper right of the screen.</simpara>
</section>
</section>
<section xml:id="Test_PitConfiguration">
<title>Test</title>
<simpara>In the Test section, Peach performs a test on the selected Pit configuration using settings provided for variables, agents, and monitors. Peach identifies the readiness of the Pit configuration for testing by tracking and reporting the progress of completing settings for the variables, agents, and monitors.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/WebUI/AC_Test.png"/>
</imageobject>
<textobject><phrase>AC Test</phrase></textobject>
</mediaobject>
</informalfigure>
<note>
<simpara>The Test section runs a single test case without any fuzzing.<?asciidoc-br?>
The test requires that the target device, service, or application be available for use.</simpara>
</note>
<tip>
<simpara>This screen issues a warning if the pit is not configured, but lets the user run the test.</simpara>
</tip>
<itemizedlist>
<listitem>
<simpara>Click the Begin Test button to run the test.<?asciidoc-br?>
When the test completes, Peach reports whether the Pit configuration passes the test. If the configuration passes the test, the following message displays:</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/WebUI/AC_Test_Pass.png"/>
</imageobject>
<textobject><phrase>AC Test Pass</phrase></textobject>
</mediaobject>
</informalfigure>
</listitem>
</itemizedlist>
<simpara>You can start a fuzzing job with your pit.</simpara>
</section>
</section>
<section xml:id="Start_Fuzzing">
<title>Fuzzing Session</title>
<simpara>With your Pit configured and tested, you&#8217;re ready to start fuzzing!</simpara>
<section xml:id="_from_the_home_page_3">
<title>From the Home Page</title>
<orderedlist numeration="arabic">
<listitem>
<simpara>From the Home screen, click the Library menu.</simpara>
</listitem>
<listitem>
<simpara>From your Pits Library screen, select a configuration.<?asciidoc-br?>
The configurations are listed in the section that follows the Pits.</simpara>
<simpara>Once selected, the configured Pit displays, as in the following illustration.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/WebUI/config_selected.png"/>
</imageobject>
<textobject><phrase>config selected</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>If needed, you can change configuration settings or set some other parameters at the button of the page (typically used in replaying a fuzzing session).</simpara>
</listitem>
<listitem>
<simpara>Click Start to begin the fuzzing session. The Peach Dashboard displays.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/WebUI/dashboard_oct2015.png"/>
</imageobject>
<textobject><phrase>dashboard oct2015</phrase></textobject>
</mediaobject>
</informalfigure>
</listitem>
</orderedlist>
<simpara>The dashboard allows you to monitor progress as your fuzzing job runs and from it, you can pause, stop, resume, and replay your fuzzing session. The Peach Dashboard provides the following information:</simpara>
<itemizedlist>
<listitem>
<simpara>The Configuration name, above the colored status bar</simpara>
</listitem>
<listitem>
<simpara>The time the job started</simpara>
</listitem>
<listitem>
<simpara>The duration that the job has been running</simpara>
</listitem>
<listitem>
<simpara>The number of fuzzing test cases per hour</simpara>
</listitem>
<listitem>
<simpara>The seed ID for random number generation, so you can replicate the test, if needed</simpara>
</listitem>
<listitem>
<simpara>Number of test cases completed</simpara>
</listitem>
<listitem>
<simpara>Total number of faults found in this run</simpara>
</listitem>
<listitem>
<simpara>A summary of the most recent faults.</simpara>
</listitem>
</itemizedlist>
<note>
<simpara><emphasis role="strong">NOTES</emphasis></simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>The seed ID influences the fuzzing that occurs during a fuzzing job. If you want to replicate a test, the seed value is required to reproduce the exact sequence of values from the random-number generator used in fuzzing.</simpara>
</listitem>
<listitem>
<simpara>The STOP button does NOT close Peach. The STOP button only allows you to stop the currently running job.</simpara>
</listitem>
<listitem>
<simpara>If you have stopped a job and wish to start a new job using a different pit, choose one of the Pits or Pit configurations in your Pit Library. You&#8217;ll need to re-visit the Home page, and then choose the appropriate entry from the library.</simpara>
</listitem>
<listitem>
<simpara>The fault summary lists the most recent faults. For information about the faults generated during this fuzzing session, click the Metrics menu, then Faults on the left side of the screen.</simpara>
</listitem>
</orderedlist>
</note>
</section>
<section xml:id="PassTest_and_Fuzz">
<title>From a Configuration Test</title>
<simpara>When your Pit configuration passes the validation test, the following screen displays
with the green banner and the message "Testing Passed, click Continue."</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/WebUI/AC_Test_Pass.png"/>
</imageobject>
<textobject><phrase>AC Test Pass</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>From here, you can start a fuzzing session with two clicks of the mouse.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Click Continue. Peach displays the Pit configuration page.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/WebUI/config_selected.png"/>
</imageobject>
<textobject><phrase>config selected</phrase></textobject>
</mediaobject>
</informalfigure>
</listitem>
<listitem>
<simpara>Click Start in the "Start Options" section at the bottom of the page to start a fuzzing job.</simpara>
<simpara>The Peach dashboard displays and the fuzzing job starts.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/WebUI/dashboard_oct2015.png"/>
</imageobject>
<textobject><phrase>dashboard oct2015</phrase></textobject>
</mediaobject>
</informalfigure>
</listitem>
</orderedlist>
</section>
<section xml:id="Re-Fuzzing">
<title>Re-running a Fuzzing Job</title>
<simpara>Peach allows you to re-run fuzzing sessions in whole or in part, meaning that exactly the same tests run using exactly the same data values. If you run an entire fuzzing job, all of the test cases are performed.</simpara>
<simpara>If you run a partial job, the test cases you specify run, again in exactly the same order as in the original fuzzing job using exactly the same data values.</simpara>
<simpara>What is needed to re-run a fuzzing job?</simpara>
<itemizedlist>
<listitem>
<simpara>Seed value</simpara>
</listitem>
<listitem>
<simpara>Start test case number</simpara>
</listitem>
<listitem>
<simpara>Stop test case number</simpara>
</listitem>
</itemizedlist>
<simpara>Supply the seed value and appropriate Start and Stop Test Case values in the "Start Options" on the Pit Configuration page that follows, and click Start to begin a repeat of the fuzzing session.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/WebUI/config_selected.png"/>
</imageobject>
<textobject><phrase>config selected</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>The next two sections provide information about the Seed Value and the Test Case number used in recreating a fuzzing job.</simpara>
<section xml:id="About_SeedValue">
<title>Seed Value</title>
<simpara>The seed value of a fuzzing job is located in the following places:</simpara>
<itemizedlist>
<listitem>
<simpara>For a running job, the seed is part of the dashboard display when a fuzzing job is running. See entry 2 of the right column of the dashboard.</simpara>
</listitem>
<listitem>
<simpara>For a completed job, click on the Jobs menu and again on the entry in the Jobs list. This brings up the dashboard for the fuzzing job, where the seed is entry 2 of the right column.</simpara>
</listitem>
<listitem>
<simpara>For a completed job, view the generated report, a <literal>.pdf</literal> file. The seed is the last table entry in the Summary section (section 1) of the report.</simpara>
</listitem>
</itemizedlist>
<simpara>A seed is a common technique used in scientific and computer experiments to provide reproducible results when a random set of data values is needed. The seed feeds into a random-number generator that produces a sequence of "random numbers". Each time the seed is used, the same sequence of "random numbers" is generated.</simpara>
<simpara>Peach uses the "random numbers" in determining the mutators to use in a test case, the sequence of mutators, the data elements to fuzz, and the fuzzed data values. Having the seed value guarantees that the same sequence of numbers is generated and used throughout a fuzzing job.</simpara>
</section>
<section xml:id="About_TestCaseNumbers">
<title>Start/Stop Test Case</title>
<simpara>The Start Test Case number identifies the first test case to perform in a fuzzing job.
The Stop Test Case number identifies the last test case to perform in a fuzzing job.
Together, the Start and Stop Test Case numbers identify a range or a sequence of fuzzing test cases to run, whether the fuzzing job is new or is a re-run.</simpara>
<simpara>The number of a specific test case is present in the detail or drill-down report for a specific fault. In this report, the value is at the top of the report and is labeled "Iteration". The value represents the iteration number (or test case number) in a fuzzing job.</simpara>
<simpara>Main uses of specifying start and/or stop test case numbers in a fuzzing job are
to confirm that an issue reliably occurs, to assist in tracking down an issue, or
to verify that an issue is fixed.</simpara>
<simpara>If the issue does not reproduce, the issue will be more difficult to solve and might be a HEAP-related memory issue in which the addressable memory layout can have a large impact on the bug occurrence. In short, tracking down the root cause and verifying a fix for an issue will require running Peach for a long time to see whether the issue recurs.
There is no easy way to guarantee an effective fix in this case.</simpara>
<tip>
<simpara>Once a fix is in place, run a new fuzzing job to regress around the fix and to determine whether any residual faults surface.</simpara>
</tip>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
</section>
<section xml:id="Report_Faults">
<title>Faults</title>
<simpara>While Peach Fuzzer Professional is running, you can view all the faults generated during the session by clicking the Faults menu option on the left.</simpara>
<simpara>Faults displays the total number of generated faults. There are two Faults views: the Summary view and the Detail view:</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/WebUI/Fault_summary.png"/>
</imageobject>
<textobject><phrase>Fault summary</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>For each session, the Faults Summary view lists a summary of information about the fault such as:</simpara>
<itemizedlist>
<listitem>
<simpara>Identified fault iteration count</simpara>
</listitem>
<listitem>
<simpara>Time and date</simpara>
</listitem>
<listitem>
<simpara>Monitor that detected the fault</simpara>
</listitem>
<listitem>
<simpara>Risk (if known)</simpara>
</listitem>
<listitem>
<simpara>Unique identifiers of the fault (major and minor hashes), if available</simpara>
</listitem>
</itemizedlist>
<simpara>Clicking on one of the listed faults from the Summary view opens the Details view for the selected fault.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/WebUI/Fault_detail.png"/>
</imageobject>
<textobject><phrase>Fault detail</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Here&#8217;s where you can find details about the selected fault. Additional information (such as any files collected during the data collection phase) are located in the disk log folder.</simpara>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
<section xml:id="Report_Metrics">
<title>Metrics</title>
<simpara>A number of metrics are available for viewing while Peach Fuzzer Professional is running.</simpara>
<tip>
<simpara>The data grids used on many of the metrics displays support multi-column sorting using the <emphasis>shift</emphasis> key and clicking on the different columns to sort.</simpara>
</tip>
<section xml:id="_bucket_timeline">
<title>Bucket Timeline</title>
<simpara>This metric display shows a timeline with new fault buckets listed, and total number of times the bucket was found during the fuzzing session.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/WebUI/metrics_timeline.png"/>
</imageobject>
<textobject><phrase>metrics timeline</phrase></textobject>
</mediaobject>
</informalfigure>
</section>
<section xml:id="_faults_over_time">
<title>Faults Over Time</title>
<simpara>This metric display shows the count of faults found by hour over the course of the fuzzing run. This is the count of all faults found, not just unique buckets.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/WebUI/metrics_faultsovertime.png"/>
</imageobject>
<textobject><phrase>metrics faultsovertime</phrase></textobject>
</mediaobject>
</informalfigure>
</section>
<section xml:id="_mutators">
<title>Mutators</title>
<simpara>This metric display shows statistics for each mutator by arranging the information into columns:</simpara>
<informaltable tabstyle="horizontal" frame="none" colsep="0" rowsep="0">
<tgroup cols="2">
<colspec colwidth="15*"/>
<colspec colwidth="85*"/>
<tbody valign="top">
<row>
<entry>
<simpara>Element Count</simpara>
</entry>
<entry>
<simpara>The number of elements this mutator touched with mutated data.</simpara>
</entry>
</row>
<row>
<entry>
<simpara>Iteration Count</simpara>
</entry>
<entry>
<simpara>The number of iterations this mutator was used during the fuzzing job.</simpara>
</entry>
</row>
<row>
<entry>
<simpara>Bucket Count</simpara>
</entry>
<entry>
<simpara>The number of unique buckets found while this mutator was in use.</simpara>
</entry>
</row>
<row>
<entry>
<simpara>Fault Count</simpara>
</entry>
<entry>
<simpara>The number of faults found while this mutator was in use.</simpara>
</entry>
</row>
</tbody>
</tgroup>
</informaltable>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/WebUI/metrics_mutators.png"/>
</imageobject>
<textobject><phrase>metrics mutators</phrase></textobject>
</mediaobject>
</informalfigure>
</section>
<section xml:id="_elements">
<title>Elements</title>
<simpara>This metric display shows statistics for all of the elements in your Pit.</simpara>
<simpara>This display shows several columns of information:</simpara>
<informaltable tabstyle="horizontal" frame="none" colsep="0" rowsep="0">
<tgroup cols="2">
<colspec colwidth="15*"/>
<colspec colwidth="85*"/>
<tbody valign="top">
<row>
<entry>
<simpara>State</simpara>
</entry>
<entry>
<simpara>The state this element belongs to</simpara>
</entry>
</row>
<row>
<entry>
<simpara>Action</simpara>
</entry>
<entry>
<simpara>The action this element belongs to</simpara>
</entry>
</row>
<row>
<entry>
<simpara>Parameter</simpara>
</entry>
<entry>
<simpara>The parameter this action belongs to (if any). Parameters are used only with actions of type <emphasis>call</emphasis>.</simpara>
</entry>
</row>
<row>
<entry>
<simpara>Element</simpara>
</entry>
<entry>
<simpara>The full name of the element and its associated DataModel.</simpara>
</entry>
</row>
<row>
<entry>
<simpara>Mutations</simpara>
</entry>
<entry>
<simpara>The number of mutations generated from this element.</simpara>
</entry>
</row>
<row>
<entry>
<simpara>Buckets</simpara>
</entry>
<entry>
<simpara>The number of unique buckets found by sending mutating data to this element.</simpara>
</entry>
</row>
<row>
<entry>
<simpara>Faults</simpara>
</entry>
<entry>
<simpara>The number of faults found from the mutated data sent to this element.</simpara>
</entry>
</row>
</tbody>
</tgroup>
</informaltable>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/WebUI/metrics_elements.png"/>
</imageobject>
<textobject><phrase>metrics elements</phrase></textobject>
</mediaobject>
</informalfigure>
</section>
<section xml:id="_states">
<title>States</title>
<simpara>This metric display presents statistics that are relevant for pits that have state models with more than two or more states. This display shows the number of times a specific state occurred during the fuzzing session. Seldom-used states might hide issues or indicate a problem.</simpara>
<simpara>For example, not all states always execute. If an early-occurring state is fuzzed, the outcome of the fuzzing could prevent states that are used late in the state flow from occurring.</simpara>
<note>
<simpara>Over time, the number of occurrences for most states should trend towards equality.</simpara>
</note>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/WebUI/metrics_states.png"/>
</imageobject>
<textobject><phrase>metrics states</phrase></textobject>
</mediaobject>
</informalfigure>
</section>
<section xml:id="_data_sets">
<title>Data Sets</title>
<simpara>This metric display shows statistics related to the use of two or more data sets in the fuzzing session. This is useful to determine the origin of unique buckets and also faults in terms of the data sources used in mutating.</simpara>
<simpara>This display shows several columns of information:</simpara>
<informaltable tabstyle="horizontal" frame="none" colsep="0" rowsep="0">
<tgroup cols="2">
<colspec colwidth="15*"/>
<colspec colwidth="85*"/>
<tbody valign="top">
<row>
<entry>
<simpara>Data Set</simpara>
</entry>
<entry>
<simpara>Name of the data set</simpara>
</entry>
</row>
<row>
<entry>
<simpara>Iterations</simpara>
</entry>
<entry>
<simpara>Number of fuzzing iterations performed using this data set</simpara>
</entry>
</row>
<row>
<entry>
<simpara>Buckets</simpara>
</entry>
<entry>
<simpara>Number of unique buckets found with this data set</simpara>
</entry>
</row>
<row>
<entry>
<simpara>Faults</simpara>
</entry>
<entry>
<simpara>Number of faults found with this data set</simpara>
</entry>
</row>
</tbody>
</tgroup>
</informaltable>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/WebUI/metrics_datasets.png"/>
</imageobject>
<textobject><phrase>metrics datasets</phrase></textobject>
</mediaobject>
</informalfigure>
</section>
<section xml:id="_buckets">
<title>Buckets</title>
<simpara>This metric display shows the buckets encountered during the fuzzing job. Several columns of information show:</simpara>
<informaltable tabstyle="horizontal" frame="none" colsep="0" rowsep="0">
<tgroup cols="2">
<colspec colwidth="15*"/>
<colspec colwidth="85*"/>
<tbody valign="top">
<row>
<entry>
<simpara>Fault bucket</simpara>
</entry>
<entry>
<simpara>Identifier of the fault that occurred</simpara>
</entry>
</row>
<row>
<entry>
<simpara>Mutator</simpara>
</entry>
<entry>
<simpara>The mutator that generated the fault</simpara>
</entry>
</row>
<row>
<entry>
<simpara>Iteration count</simpara>
</entry>
<entry>
<simpara>The number of iterations that used the mutator</simpara>
</entry>
</row>
<row>
<entry>
<simpara>Faults count</simpara>
</entry>
<entry>
<simpara>The number of faults that occurred while using the mutator</simpara>
</entry>
</row>
</tbody>
</tgroup>
</informaltable>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/WebUI/metrics_buckets.png"/>
</imageobject>
<textobject><phrase>metrics buckets</phrase></textobject>
</mediaobject>
</informalfigure>
</section>
<section xml:id="_accessing_raw_metrics_data">
<title>Accessing Raw Metrics Data</title>
<simpara>Each job has its own SQLite database that contains metrics and other information about the job.
The database is stored with other log assets under the logs folder in the peach application folder.
Each job will have its own folder of assets.
While we don&#8217;t document the database schema,
advanced users are welcome to mine the database to utilize the metrics data in different ways.
The database format may change between versions, though typically changes are small.</simpara>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
</section>
<section xml:id="Program_Peach">
<title>The Peach Command Line Interface</title>
<simpara>This is the core Peach application which provides the core fuzzing capabilities and
also some utility functions for the custom pit developer.
This application can be used to start the Peach Web Application and
also to launch fuzzing jobs from the command line.</simpara>
<simpara>Some options may be disabled depending on your Peach License options.</simpara>
<simpara>Please submit any bugs to <link xl:href="mailto:support@peachfuzzer.com">support@peachfuzzer.com</link>.</simpara>
<section xml:id="_peach_web_application">
<title>Peach Web Application</title>
<simpara>Starts Peach and provides a web application for configuring, running, and
viewing results of a fuzzing job.</simpara>
<section xml:id="_syntax">
<title>Syntax</title>
<screen>peach [options]</screen>
<variablelist>
<varlistentry>
<term>--nobrowser</term>
<listitem>
<simpara>Disable launching browser on start.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>--webport=PORT</term>
<listitem>
<simpara>Specified port the web application runs on.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>--plugins=PATH</term>
<listitem>
<simpara>Change the plugins folder location.
Defaults to the <emphasis>Plugins</emphasis> folder relative to the Peach installation.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
</section>
<section xml:id="_fuzzing_from_command_line">
<title>Fuzzing from Command Line</title>
<simpara>A fuzzing run is started by specifying the Peach Pit Configuration or
Peach XML file and the name of a test to perform.</simpara>
<simpara>If a run is interrupted,
it can be restarted by providing the last successful test case and the seed of the test session.
Use the --skipto and --seed parameters to provide this information.</simpara>
<section xml:id="_syntax_2">
<title>Syntax</title>
<screen>peach [options] &lt;PEACH_PIT.xml | PEACH_CONFIG.peach&gt; [test_name]</screen>
<variablelist>
<varlistentry>
<term>PEACH_CONFIG.peach</term>
<listitem>
<simpara>Peach Pit Configuration generated by Peach Application.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>PEACH_PIT.xml</term>
<listitem>
<simpara>The Peach Pit XML file.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>test_name</term>
<listitem>
<simpara>Name of test to run (defaults to <emphasis>Default</emphasis>).</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>-1</term>
<listitem>
<simpara>Perform a single test case</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>--debug</term>
<listitem>
<simpara>Enable debug messages.
Useful when debugging Peach Pit Files.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>-DKEY=VALUE</term>
<listitem>
<simpara>Define a configuration variable via the command line.
Multiple defines can be provided as needed.
Example: -DTargetIPv4=127.0.0.1 -DTargetPort=80</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>--duration=DUR</term>
<listitem>
<simpara>Duration of fuzzing run. Peach will run for DUR length of time.
Commonly integrating Peach into an automated test cycle or continuous integration environment.
Argument format is DD.HH:MM:SS.</simpara>
<variablelist>
<varlistentry>
<term>Examples</term>
<listitem>
<itemizedlist>
<listitem>
<simpara><literal>--duration=12</literal>     Duration of 12 days</simpara>
</listitem>
<listitem>
<simpara><literal>--duration=0:20</literal>   Duration of 20 min</simpara>
</listitem>
<listitem>
<simpara><literal>--duration=5:00</literal>   Duration of 5 hours</simpara>
</listitem>
<listitem>
<simpara><literal>--duration=1.5:00</literal> Duration of 1 day, 5 hrs</simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>
</listitem>
</varlistentry>
<varlistentry>
<term>--noweb</term>
<listitem>
<simpara>Disable the Peach Web Application</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>--plugins=PATH</term>
<listitem>
<simpara>Change the plugins folder location.
Defaults to the <emphasis>Plugins</emphasis> folder relative to the Peach installation.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>--polite</term>
<listitem>
<simpara>Disable interactive console mode</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>--range=S,F</term>
<listitem>
<simpara>Perform a range of test cases starting at test case S and ending with test case F.
Typically combined with the --seed argument.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>--seed=SEED</term>
<listitem>
<simpara>Set the fuzzing jobs seed.
The same seed will always produce the same test case sequence.
Should only be set when reproducing a historical fuzzing job.
Default is a random seed.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>--skipto=NUM</term>
<listitem>
<simpara>Skip to NUM test case and start fuzzing.
Normally combined with --seed to reproduce a specific sequence of test cases.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>--trace</term>
<listitem>
<simpara>Enable even more verbose debug messages.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>--webport=PORT</term>
<listitem>
<simpara>Specified port the web application runs on</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
</section>
<section xml:id="_debug_peach_xml_file">
<title>Debug Peach XML File</title>
<simpara>This will perform a single iteration (-1) of your pit file while
displaying a lot of debugging information (--debug).
The debugging information is intended for custom pit developers.</simpara>
<section xml:id="_syntax_3">
<title>Syntax</title>
<screen>peach -1 --debug &lt;PEACH_PIT.xml | PEACH_CONFIG.peach&gt; [test_name]</screen>
</section>
</section>
<section xml:id="_display_list_of_network_capture_devices">
<title>Display List of Network Capture Devices</title>
<simpara>Display a list of all known devices Peach can perform network capture on.</simpara>
<section xml:id="_syntax_4">
<title>Syntax</title>
<screen>peach --showdevices</screen>
</section>
</section>
<section xml:id="_display_known_elements">
<title>Display Known Elements</title>
<simpara>Print a list of all known:</simpara>
<itemizedlist>
<listitem>
<simpara>Actions</simpara>
</listitem>
<listitem>
<simpara>Agent Channels</simpara>
</listitem>
<listitem>
<simpara>Analyzers</simpara>
</listitem>
<listitem>
<simpara>DataElements</simpara>
</listitem>
<listitem>
<simpara>Fixups</simpara>
</listitem>
<listitem>
<simpara>Loggers</simpara>
</listitem>
<listitem>
<simpara>Monitors</simpara>
</listitem>
<listitem>
<simpara>Mutation Strategies</simpara>
</listitem>
<listitem>
<simpara>Mutators</simpara>
</listitem>
<listitem>
<simpara>Publishers</simpara>
</listitem>
<listitem>
<simpara>Relations</simpara>
</listitem>
<listitem>
<simpara>Transformers</simpara>
</listitem>
</itemizedlist>
<simpara>The list includes any associated parameters along with a description and default values.
This can be used to verify that custom extensions are found.</simpara>
<section xml:id="_syntax_5">
<title>Syntax</title>
<screen>peach --showenv</screen>
</section>
</section>
<section xml:id="_peach_agent">
<title>Peach Agent</title>
<simpara>The Peach Agent functionality has been moved to a separate executable.
See <link linkend="Program_PeachAgent">PeachAgent</link> for more information.</simpara>
</section>
<section xml:id="_examples">
<title>Examples</title>
<example>
<title>Running a Pit Configuration (.peach)</title>
<simpara>This example shows how to run a fuzzing job from a configuration file (.peach).
The following command line launches Peach and fuzzes using <literal>pit_config.peach</literal> as the configuration file.</simpara>
<screen>&gt; peach pit_config.peach</screen>
</example>
<example>
<title>Running a Pit</title>
<simpara>This example shows how to run a fuzzing definition.
The following command line launches Peach and fuzzes using <literal>pit.xml</literal> (and if it exists, <literal>pit.xml.config</literal>) as the configuration file.</simpara>
<screen>&gt; peach pit.xml</screen>
</example>
<example>
<title>Single Iteration with Debug Output</title>
<simpara>When testing a definition, we recommend running a single non-mutating iteration with debug output.</simpara>
<simpara>The following command line launches Peach and fuzzes using <literal>pit.xml</literal> (and if it exists, <literal>pit.xml.config</literal>) as the configuration file.
The command line combines the <literal>-1</literal> and <literal>--debug</literal> arguments to run a single iteration;
the debugging information is included in the output.
Even more verbose output can be enabled by using <literal>--trace</literal> instead of <literal>--debug</literal>.</simpara>
<screen>&gt; peach -1 --debug samples\DebuggerWindows.xml

[*] Test 'Default' starting with random seed 27886.
Peach.Core.Agent.Agent StartMonitor: Monitor WindowsDebugger
Peach.Core.Agent.Agent StartMonitor: Monitor_1 PageHeap
Peach.Core.Agent.Agent StartMonitor: Monitor_2 NetworkCapture
Peach.Core.Agent.Agent SessionStarting: Monitor
Peach.Core.Agent.Monitors.WindowsDebuggerHybrid SessionStarting
Peach.Core.Agent.Agent SessionStarting: Monitor_1
Establishing the listener...
Waiting for a connection...
Peach.Core.Agent.Agent SessionStarting: Monitor_2

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.TcpClientPublisher start()
Peach.Core.Publishers.TcpClientPublisher open()
Accepted connection from 127.0.0.1:51466.
Peach.Core.Publishers.TcpClientPublisher output(12 bytes)
Peach.Core.Publishers.TcpClientPublisher

00000000   48 65 6C 6C 6F 20 57 6F  72 6C 64 21               Hello World!

Received 12 bytes from client.
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.TcpClientPublisher output(12 bytes)
Peach.Core.Publishers.TcpClientPublisher

00000000   48 65 6C 6C 6F 20 57 6F  72 6C 64 21               Hello World!

Received 12 bytes from client.
Peach.Core.Publishers.TcpClientPublisher close()
Peach.Core.Publishers.TcpClientPublisher Shutting down connection to 127.0.0.1:4
244
Connection closed by peer.
Shutting connection down...
Connection is down.
Peach.Core.Publishers.TcpClientPublisher Read 0 bytes from 127.0.0.1:4244, closing client connection.
Waiting for a connection...
Peach.Core.Publishers.TcpClientPublisher Closing connection to 127.0.0.1:4244
Peach.Core.Agent.Monitors.WindowsDebuggerHybrid DetectedFault()
Peach.Core.Agent.Monitors.WindowsDebuggerHybrid DetectedFault() - No fault detected
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.TcpClientPublisher stop()
Peach.Core.Agent.Agent SessionFinished: Monitor_2
Peach.Core.Agent.Agent SessionFinished: Monitor_1
Peach.Core.Agent.Agent SessionFinished: Monitor
Peach.Core.Agent.Monitors.WindowsDebuggerHybrid SessionFinished
Peach.Core.Agent.Monitors.WindowsDebuggerHybrid _StopDebugger
Peach.Core.Agent.Monitors.WindowsDebuggerHybrid _FinishDebugger
Peach.Core.Agent.Monitors.WindowsDebuggerHybrid _StopDebugger
Peach.Core.Agent.Monitors.WindowsDebuggerHybrid _StopDebugger
Peach.Core.Agent.Monitors.WindowsDebuggerHybrid _FinishDebugger
Peach.Core.Agent.Monitors.WindowsDebuggerHybrid _StopDebugger

[*] Test 'Default' finished.</screen>
</example>
<example xml:id="Replay_Existing_Test_Sequence">
<title>Replay Existing Test Sequence</title>
<simpara>Once you find a faulting condition,
you may want to replicate the exact test (or sequence of tests) to recreate the issue.
Peach can reproduce exact test sequences given the following information:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Exact version of Peach. This is found in the log file <literal>status.txt</literal>.</simpara>
</listitem>
<listitem>
<simpara>Seed number used. This is also found in the log file <literal>status.txt</literal>.</simpara>
</listitem>
<listitem>
<simpara>Same/similar pit file. Data and state models must be the same.</simpara>
</listitem>
<listitem>
<simpara>If datasets are used, they must be the same set and have the same contents.</simpara>
</listitem>
</orderedlist>
<formalpara>
<title>status.txt</title>
<para>
<screen>Peach Fuzzing Run
=================

Date of run: 3/20/2014 1:58:58 PM
Peach Version: 3.1.40.1              <co xml:id="CO1-1"/>
Seed: 51816                          <co xml:id="CO1-2"/>
Command line: samples\DebuggerWindows.xml
Pit File: samples\DebuggerWindows.xml
. Test starting: Default</screen>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO1-1">
<para>Version of Peach used. Must match when reproducing.</para>
</callout>
<callout arearefs="CO1-2">
<para>Seed used. Must match when reproducing.</para>
</callout>
</calloutlist>
<simpara>We can use the first command line to skip directly to a specific iteration and start fuzzing. This lets you run a series of iterations starting from a certain point.</simpara>
<tip>
<simpara>The <literal>--seed</literal> argument matches the value from the <literal>status.txt</literal> file.</simpara>
</tip>
<screen>&gt; peach --seed 51816 --skipto 37566</screen>
<simpara>We can use the second command line to perform either a specific iteration or a small number of iterations.</simpara>
<screen>&gt; peach --seed 51816 --range 37566,37566</screen>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Program_PeachAgent">
<title>PeachAgent</title>
<simpara>Starts a Peach Agent server process.</simpara>
<simpara>A Peach Agent can be started on a remote machine (remote to Peach) to accept connections from a Peach instance.
Agents run various utility modules called Monitors and also host remote Publishers.
Peach Agents do not need any specific configuration outside of which port to listen on.
All configuration is provided by a Peach instance.</simpara>
<section xml:id="_licensing">
<title>Licensing</title>
<simpara>The Peach Agent server process does not require a license.
In a typical deployment, only the machine running the core Peach process (Peach.exe) requires a license.</simpara>
</section>
<section xml:id="_syntax_6">
<title>Syntax</title>
<screen>peachagent [--port=9001]</screen>
<variablelist>
<varlistentry>
<term>-h, --help</term>
<listitem>
<simpara>Display this help and exit</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>-V, --version</term>
<listitem>
<simpara>Display version information and exit</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>-v, --verbose</term>
<listitem>
<simpara>Increase verbosity, can use multiple times</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>--plugins=VALUE</term>
<listitem>
<simpara>Specify the plugins path</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>--port=VALUE</term>
<listitem>
<simpara>Port to listen for incoming connections on (defaults to 9001).</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>--debug</term>
<listitem>
<simpara>Enable debug messages. Useful when debugging your Peach Pit file. Warning: Messages are very
cryptic sometimes.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>--trace</term>
<listitem>
<simpara>Enable even more verbose debug messages.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Program_PeachMinset">
<title>Minset</title>
<simpara>This tool is used when adding additional samples to an existing Pit or creating a custom file fuzzing Pit.</simpara>
<simpara>Peach Minset is used to identify the minimum number of sample files required to provide the greatest code coverage for a given target.
This process can be distributed across multiple machines to decrease the run time.</simpara>
<simpara>There are two steps to the process:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Collect traces</simpara>
</listitem>
<listitem>
<simpara>Compute minimum set coverage</simpara>
</listitem>
</orderedlist>
<simpara>The first step can be distributed and the results collected for analysis by the second step.</simpara>
<section xml:id="_collect_traces">
<title>Collect Traces</title>
<simpara>Performs code coverage using all files in the <emphasis>samples</emphasis> folder.
Collects the .trace files for later analysis.
This process can be run in parallel across multiple machines or CPU cores.</simpara>
<section xml:id="_syntax_7">
<title>Syntax</title>
<screen>PeachMinset [-k] -s samples -t traces command.exe args %s</screen>
<variablelist>
<varlistentry>
<term>-k</term>
<listitem>
<simpara>Kill target when CPU usage drops to near zero.
This is used when taking traces of GUI programs.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>-s samples</term>
<listitem>
<simpara>Folder to load sample files from</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>-t traces</term>
<listitem>
<simpara>Folder to write traces to</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>command.exe args %s</term>
<listitem>
<simpara>Executable and arguments.
<literal>%s</literal> is replaced with the path and file name of a file from the samples folder.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
</section>
<section xml:id="_compute_minimum_set_coverage">
<title>Compute Minimum Set Coverage</title>
<simpara>Analyzes all .trace files to determine the minimum set of samples to use during fuzzing.
This process cannot be parallelized.</simpara>
<section xml:id="_syntax_8">
<title>Syntax</title>
<screen>PeachMinset -s samples -t traces -m minset</screen>
<variablelist>
<varlistentry>
<term>-s samples</term>
<listitem>
<simpara>Folder to load sample files from</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>-t traces</term>
<listitem>
<simpara>Folder to write traces to</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>-m minset</term>
<listitem>
<simpara>Folder to write minimum set of files to</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
</section>
<section xml:id="_all_in_one">
<title>All-In-One</title>
<simpara>Both tracing and computing can be performed in a single step.</simpara>
<section xml:id="_syntax_9">
<title>Syntax</title>
<screen>PeachMinset [-k] -s samples -m minset -t traces command.exe args %s</screen>
<variablelist>
<varlistentry>
<term>-k</term>
<listitem>
<simpara>Kill target when CPU usage drops to near zero.
This is used when taking traces of GUI programs.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>-s samples</term>
<listitem>
<simpara>Folder to load sample files from</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>-m minset</term>
<listitem>
<simpara>Folder to write minimum set of files to</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>-t traces</term>
<listitem>
<simpara>Folder to write traces to</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>command.exe args %s</term>
<listitem>
<simpara>Executable and arguments.
<literal>%s</literal> is replaced with the path and file name of a file from the samples folder.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
</section>
<section xml:id="_distributing_minset">
<title>Distributing Minset</title>
<simpara>Minset can be distributed by splitting up the sample files and distributing the collecting of traces to multiple machines.
The final compute minimum set coverage cannot be distributed.</simpara>
</section>
<section xml:id="_examples_2">
<title>Examples</title>
<example>
<title>Example Run</title>
<screen>&gt; PeachMinset.exe -s pinsamples -m minset -t traces bin\pngcheck.exe %%s

[*] Running both trace and coverage analysis
[*] Running trace analysis on 15 samples...
[1:15]   Coverage trace of pinsamples\basn0g01.png...done.
[2:15]   Coverage trace of pinsamples\basn0g02.png...done.
[3:15]   Coverage trace of pinsamples\basn0g04.png...done.
[4:15]   Coverage trace of pinsamples\basn0g08.png...done.
[5:15]   Coverage trace of pinsamples\basn0g16.png...done.
[6:15]   Coverage trace of pinsamples\basn2c08.png...done.
[7:15]   Coverage trace of pinsamples\basn2c16.png...done.
[8:15]   Coverage trace of pinsamples\basn3p01.png...done.
[9:15]   Coverage trace of pinsamples\basn3p02.png...done.
[10:15]   Coverage trace of pinsamples\basn3p04.png...done.
[11:15]   Coverage trace of pinsamples\basn3p08.png...done.
[12:15]   Coverage trace of pinsamples\basn4a08.png...done.
[13:15]   Coverage trace of pinsamples\basn4a16.png...done.
[14:15]   Coverage trace of pinsamples\basn6a08.png...done.
[15:15]   Coverage trace of pinsamples\basn6a16.png...done.

[*] Finished
[*] Running coverage analysis...
[-]   3 files were selected from a total of 15.
[*] Copying over selected files...
[-]   pinsamples\basn3p08.png -&gt; minset\basn3p08.png
[-]   pinsamples\basn3p04.png -&gt; minset\basn3p04.png
[-]   pinsamples\basn2c16.png -&gt; minset\basn2c16.png

[*] Finished</screen>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Program_PeachMultiNodeCli">
<title>Peach Multi-Node CLI Tool</title>
<simpara>This tool is used to control multiple Peach instances at once.
The tool can be used via the command line or as an interactive
tool.</simpara>
<simpara>The tool utilizes the Peach REST API to perform all actions.</simpara>
<section xml:id="_installation">
<title>Installation</title>
<simpara>Installation of this tool has two steps.</simpara>
<section xml:id="_install_python_2_7">
<title>Install Python 2.7</title>
<simpara>Python v2.7 is recommended. Other versions may also work.</simpara>
</section>
<section xml:id="_install_dependencies">
<title>Install dependencies</title>
<screen>easy_install requests
easy_install cmd2</screen>
</section>
<section xml:id="_populate_instances_py">
<title>Populate instances.py</title>
<simpara>The instances.py file contains a list of all Peach instances
that will be controlled from this tool.  Instances can be
placed into groups. An instance can be part of more than one
group.</simpara>
<simpara>Configurations are pulled from a master instance configured in instances.py.
Typically the master instance is running locally, but it can
also be one of the fuzzing instances.</simpara>
<warning>
<simpara>Only one master instance can be configured!</simpara>
</warning>
</section>
</section>
<section xml:id="_syntax_10">
<title>Syntax</title>
<screen>peachcli

peachcli "jobs all" quit</screen>
</section>
<section xml:id="_commands">
<title>Commands</title>
<section xml:id="_jobs_view_all_jobs">
<title>jobs: View all jobs</title>
<screen>jobs &lt;group&gt;

jobs all</screen>
<simpara>Show basic job information from each instance in a group.</simpara>
<example>
<title>Example</title>
<screen># peachcli.py

| Peach CLI v0.1
| Copyright (c) Peach Fuzzer, LLC


&gt;&gt; jobs all

-- http://192.168.48.128:8888 --
Name                 Status     Start                Stop                 Count      Faults
-------------------------------------------------------------------------------------------
HTTP Server-Test     stopped    2016-01-12T23:13:11Z 2016-01-12T23:13:30Z 200        -
HTTP Server-Test     stopped    2016-01-13T00:27:02Z 2016-01-13T00:54:05Z 781        -

-- http://192.168.48.129:8888 --
Name                 Status     Start                Stop                 Count      Faults
-------------------------------------------------------------------------------------------
HTTP Server-Test     stopped    2016-01-12T23:13:14Z 2016-01-12T23:13:25Z -          -
HTTP Server-Test     stopped    2016-01-13T00:27:04Z 2016-01-13T00:48:35Z 13400      112

&gt;&gt;</screen>
</example>
</section>
<section xml:id="_pause_pause_a_set_of_jobs">
<title>pause: Pause a set of jobs</title>
<screen>pause &lt;pit-config&gt; &lt;group&gt;

pause HTTP_Server-Test all</screen>
<simpara>Pause pit configuration jobs running on a specified group.</simpara>
</section>
<section xml:id="_pull_pull_fault_details">
<title>pull: Pull fault details</title>
<screen>pull faults &lt;pit-config&gt; &lt;group&gt;

pull faults HTTP_Server-Test all</screen>
<simpara>Pull fault details for a specific pit configuration. Faults from all jobs in group will be
collected.  The resulting faults are placed into a <literal>faults</literal> folder, organized by risk, bucket,
and node/test case number.</simpara>
<example>
<title>Example</title>
<screen># peachcli.py

| Peach CLI v0.1
| Copyright (c) Peach Fuzzer, LLC


&gt;&gt; pull faults HTTP_Server-Test all
Pulling faults of HTTP_Server-Test for group all:

  Pulling 112 faults from http://192.168.48.129:8888...

&gt;&gt; quit

# ls faults\HTTP_Server-Test\EXPLOITABLE\F0FF8D9D\1395E24B\
192.168.48.129_13290  192.168.48.129_13309  192.168.48.129_13328  192.168.48.129_13347  192.168.48.129_13366  192.168.48.129_13385
192.168.48.129_13291  192.168.48.129_13310  192.168.48.129_13329  192.168.48.129_13348  192.168.48.129_13367  192.168.48.129_13386
192.168.48.129_13292  192.168.48.129_13311  192.168.48.129_13330  192.168.48.129_13349  192.168.48.129_13368  192.168.48.129_13387
192.168.48.129_13293  192.168.48.129_13312  192.168.48.129_13331  192.168.48.129_13350  192.168.48.129_13369  192.168.48.129_13388
192.168.48.129_13294  192.168.48.129_13313  192.168.48.129_13332  192.168.48.129_13351  192.168.48.129_13370  192.168.48.129_13389
192.168.48.129_13295  192.168.48.129_13314  192.168.48.129_13333  192.168.48.129_13352  192.168.48.129_13371  192.168.48.129_13390
192.168.48.129_13296  192.168.48.129_13315  192.168.48.129_13334  192.168.48.129_13353  192.168.48.129_13372  192.168.48.129_13391
192.168.48.129_13297  192.168.48.129_13316  192.168.48.129_13335  192.168.48.129_13354  192.168.48.129_13373  192.168.48.129_13392
192.168.48.129_13298  192.168.48.129_13317  192.168.48.129_13336  192.168.48.129_13355  192.168.48.129_13374  192.168.48.129_13393
192.168.48.129_13299  192.168.48.129_13318  192.168.48.129_13337  192.168.48.129_13356  192.168.48.129_13375  192.168.48.129_13394
192.168.48.129_13300  192.168.48.129_13319  192.168.48.129_13338  192.168.48.129_13357  192.168.48.129_13376  192.168.48.129_13395
192.168.48.129_13301  192.168.48.129_13320  192.168.48.129_13339  192.168.48.129_13358  192.168.48.129_13377  192.168.48.129_13396
192.168.48.129_13302  192.168.48.129_13321  192.168.48.129_13340  192.168.48.129_13359  192.168.48.129_13378  192.168.48.129_13397
192.168.48.129_13303  192.168.48.129_13322  192.168.48.129_13341  192.168.48.129_13360  192.168.48.129_13379  192.168.48.129_13398
192.168.48.129_13304  192.168.48.129_13323  192.168.48.129_13342  192.168.48.129_13361  192.168.48.129_13380  192.168.48.129_13399
192.168.48.129_13305  192.168.48.129_13324  192.168.48.129_13343  192.168.48.129_13362  192.168.48.129_13381  192.168.48.129_13400
192.168.48.129_13306  192.168.48.129_13325  192.168.48.129_13344  192.168.48.129_13363  192.168.48.129_13382  192.168.48.129_13401
192.168.48.129_13307  192.168.48.129_13326  192.168.48.129_13345  192.168.48.129_13364  192.168.48.129_13383
192.168.48.129_13308  192.168.48.129_13327  192.168.48.129_13346  192.168.48.129_13365  192.168.48.129_13384</screen>
</example>
</section>
<section xml:id="_push_push_pit_configuration">
<title>push: Push pit configuration</title>
<screen>push &lt;pit-config&gt; &lt;group&gt;

push HTTP_Server-Test all</screen>
<simpara>The push command will copy a configuration from the master instance to a group of remote instances.
The pit configuration name must follow a specific naming convention to use this command. The name
has two parts. The first part is the source pit name, for example "HTTP_Server". The second part
is the configuration name, for example "Test". They are joined with a hyphen (-). The resulting
name would be "HTTP_Server-Test".</simpara>
</section>
<section xml:id="_status_status_of_all_related_jobs">
<title>status: Status of all related jobs</title>
<screen>status &lt;pit-config&gt; &lt;group&gt;

status HTTP_Server-Test all</screen>
<simpara>Collect information about all jobs for a specific pit configuration.</simpara>
<example>
<title>Example</title>
<screen># peachcli.py

| Peach CLI v0.1
| Copyright (c) Peach Fuzzer, LLC


&gt;&gt; status HTTP_Server-Test all
Status of HTTP_Server-Test for group all:

 Nodes    Running  Stopped  Paused   Count    Faults
-----------------------------------------------------
 2        0        4        0        14381    112

&gt;&gt;</screen>
</example>
</section>
<section xml:id="_start_start_a_new_set_of_jobs">
<title>start: Start a new set of jobs</title>
<screen>start &lt;pit-config&gt; &lt;group&gt;

start HTTP_Server-Test all</screen>
<simpara>Start a new job using the specified pit configuration on all instances in the specified group.</simpara>
</section>
<section xml:id="_stop_stop_a_set_of_jobs">
<title>stop: Stop a set of jobs</title>
<screen>stop &lt;pit-config&gt; &lt;group&gt;

stop HTTP_Server-Test all</screen>
<simpara>Stop pit configuration jobs running on a specified group.</simpara>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
</section>
<section xml:id="PitTool_Ninja">
<title>Pit Tool - Ninja</title>
<simpara>This tool is used when adding samples to an existing Pit or creating a custom file fuzzing Pit.</simpara>
<simpara>Sample Ninja reads sample files used in fuzzing,
runs them through the Peach data crackers
(which applies sample files to the data models),
and places them into a database.
During fuzzing,
a sample ninja mutator mixes-and-matches file sections to create a new file.</simpara>
<important>
<simpara>Sample Ninja is not available in the Peach Community version.</simpara>
</important>
<simpara>The <literal>pittool ninja</literal> command produces and maintains the Sample Ninja database used by the
Sample Ninja mutator.</simpara>
<simpara>To fuzz using Sample Ninja:</simpara>
<itemizedlist>
<listitem>
<simpara>Generate a Sample Ninja database using <literal>pittool ninja</literal>.</simpara>
</listitem>
<listitem>
<simpara>The Sample Ninja mutator automatically uses the database the next time Peach is run.</simpara>
</listitem>
<listitem>
<simpara>When new or modified sample files are needed, re-run <literal>pittool ninja</literal> to update the database.</simpara>
</listitem>
</itemizedlist>
<simpara>The generated database has a name like <literal>PIT.ninja</literal>.
This means that if your pit file is <literal>png.xml</literal>,
the generated database file is <literal>png.ninja</literal>.</simpara>
<section xml:id="_syntax_11">
<title>Syntax</title>
<screen>Usage:
  PitTool.exe ninja &lt;PitPath&gt; &lt;DataModel&gt; &lt;SamplesPath&gt;

Description:
  Create a sample ninja database.

General Options:
  -h, --help                 Display this help and exit
  -V, --version              Display version information and exit
  -v, --verbose              Increase verbosity, can use multiple times
      --plugins=VALUE        Specify the plugins path
      --pits=VALUE           Specify the PitLibraryPath.</screen>
</section>
<section xml:id="_parameters">
<title>Parameters</title>
<variablelist>
<varlistentry>
<term>PitPath</term>
<listitem>
<simpara>Fuzzing definition that refers to sample files.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>DataModel</term>
<listitem>
<simpara>The DataModel used to crack each sample.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>SamplesPath</term>
<listitem>
<simpara>The path to a folder containing the sample files to be used during fuzzing.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_3">
<title>Examples</title>
<example>
<title>Creating a Sample Ninja database</title>
<orderedlist numeration="arabic">
<listitem>
<simpara>Open a new terminal window.</simpara>
</listitem>
<listitem>
<simpara>Run <literal>pittool &lt;PitPath&gt; &lt;DataModel&gt; &lt;SamplesPath&gt;</literal>.</simpara>
</listitem>
<listitem>
<simpara>The Sample Ninja database will be generated.</simpara>
</listitem>
</orderedlist>
<screen>&gt; pittool ninja pits\Image\PNG.xml PNG:PNG:File samples_png
Processing: samples_png\ajou_logo.png
Processing: samples_png\apollonian_gasket.png
Processing: samples_png\aquarium.png
Processing: samples_png\baboon.png
...
Processing: samples_png\z00n2c08.png
Processing: samples_png\z03n2c08.png
Processing: samples_png\z06n2c08.png
Processing: samples_png\z09n2c08.png</screen>
<simpara>Generated database:</simpara>
<screen>03/17/2014  08:39 PM             9,035 PNG.xml
03/20/2014  03:52 PM         9,651,200 PNG.ninja</screen>
</example>
<example>
<title>Adding new samples to an existing Samples Ninja database</title>
<orderedlist numeration="arabic">
<listitem>
<simpara>Put new samples into your samples folder.</simpara>
</listitem>
<listitem>
<simpara>Open a terminal window.</simpara>
</listitem>
<listitem>
<simpara>Run <literal>pittool &lt;PitPath&gt; &lt;DataModel&gt; &lt;SamplesPath&gt;</literal>.</simpara>
</listitem>
<listitem>
<simpara>The new and modified files will be added to the database.</simpara>
</listitem>
</orderedlist>
<screen>&gt; pittool ninja pits\Image\PNG.xml PNG:PNG:File samples_png
Skipping: samples_png\ajou_logo.png
Skipping: samples_png\apollonian_gasket.png
Skipping: samples_png\aquarium.png
Skipping: samples_png\baboon.png
...
Skipping: samples_png\z00n2c08.png
Skipping: samples_png\z03n2c08.png
Skipping: samples_png\z06n2c08.png
Skipping: samples_png\z09n2c08.png
Processing: samples_png\zzzz.png</screen>
<simpara>Generated database:</simpara>
<screen>03/17/2014  08:39 PM             9,035 PNG.xml
03/20/2014  03:52 PM         9,651,200 PNG.ninja</screen>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
</section>
<section xml:id="Configuration_Recipes">
<title>Monitoring Recipes</title>
<simpara>Peach Fuzzer has very powerful monitoring capabilities that detect faults that occur in the test
target, collect data surrounding each fault, and automate the test
environment. This section provides some suggested monitoring configurations for
different types of targets. These recipes can be used as-is or as
starting points for a custom configurations.</simpara>
<simpara>All of the recipes here follow a common process:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Define the workflow for the fuzzing session.</simpara>
</listitem>
<listitem>
<simpara>Define the Peach components to use in configuring the fuzzing setup.
This step focuses on the monitoring needs and the agents that house the monitors.</simpara>
</listitem>
<listitem>
<simpara>Provide configuration settings used to fuzz a sample test target using the recipe.</simpara>
</listitem>
</orderedlist>
<note>
<simpara><emphasis role="strong">NOTE</emphasis>: Assumptions/Givens in each recipe include the following:</simpara>
<itemizedlist>
<listitem>
<simpara>A Pit, pre-defined or custom, is ready to use.</simpara>
</listitem>
<listitem>
<simpara>Peach is installed and ready to run.</simpara>
</listitem>
<listitem>
<simpara>All software modules needed to perform the fuzzing job are available for use.</simpara>
</listitem>
</itemizedlist>
</note>
<simpara><emphasis role="strong">What&#8217;s left to do?</emphasis><?asciidoc-br?>
When you finish developing a recipe, it&#8217;s time to fill out and test the
configuration, then run the fuzzing job.</simpara>
<itemizedlist>
<listitem>
<simpara>See the <link linkend="JumpStart">Getting Started with the Peach Fuzzer Platform</link> for the workflow to run a fuzzing job.</simpara>
</listitem>
</itemizedlist>
<simpara>The remainder of this section provides the following monitor recipes:</simpara>
<itemizedlist>
<listitem>
<simpara><link linkend="Recipe_FileFuzzing">Monitoring a File Consumer (File Fomat)</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="Recipe_LinuxNetServer">Monitoring a Linux Network Service</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="Recipe_LinuxNetClient">Monitoring a Linux Network Client</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="Recipe_NetDevice">Monitoring a Network Device</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="Recipe_WindowsNetServer">Monitoring a Windows Network Service</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="Recipe_WindowsNetClient">Monitoring a Windows Network Client</link></simpara>
</listitem>
</itemizedlist>
<section xml:id="Recipe_FileFuzzing">
<title>Recipe: Monitoring a File Consumer (File Fuzzing)</title>
<simpara>This recipe identifies the monitors and associated settings suitable for testing a
file consumer. When fuzzing a file consumer, Peach creates malformed data files,
and then has the file consumer open and access the data from the malformed files.</simpara>
<tip>
<simpara>Using one common approach, Peach can fuzz file consumers of all types, whether
the file types are multimedia&#8212;&#8203;sound, images, or video; documents&#8212;&#8203;word processing,
text, or presentation; or other types of files, such as archive or compressed data
files.</simpara>
</tip>
<section xml:id="_what_is_the_fuzzing_session_workflow">
<title>What is the fuzzing session workflow?</title>
<simpara>The workflow that we want to follow in the test consists of the following steps:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Perform Fuzzing.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Write a file to disk that contains fuzzed data.</simpara>
</listitem>
<listitem>
<simpara>Run the target application.</simpara>
</listitem>
<listitem>
<simpara>Wait for the target to consume the data file.</simpara>
</listitem>
<listitem>
<simpara>Check for faults.</simpara>
</listitem>
<listitem>
<simpara>If a fault occurs, collect data.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Repeat step 1.</simpara>
</listitem>
</orderedlist>
<simpara>The monitoring setup for this recipe is simple because a single monitor, the Windows
Debugger monitor, provides most of the functionality needed, including: fault detection,
data collection, and automation.</simpara>
<simpara>A second monitor, the PageHeap monitor, enables debug memory allocation settings for
the target process. PageHeap can improve the likelihood that certain types of issues,
such as buffer overflow, will cause the the target to crash. Using the debug memory
allocation settings normally leads to finding more faults during testing.</simpara>
<simpara>Here&#8217;s a diagram of connections for the test configuration.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/UserGuide/Recipes/FileFuzzing.png" scale="60"/>
</imageobject>
<textobject><phrase>FileFuzzing</phrase></textobject>
</mediaobject>
</informalfigure>
</section>
<section xml:id="_setting_up_monitors_using_the_peach_web_ui">
<title>Setting up Monitors Using the Peach Web UI</title>
<section xml:id="_starting_peach">
<title>Starting Peach</title>
<orderedlist numeration="arabic">
<listitem>
<simpara>Start a Windows command line session with administrative privileges.<?asciidoc-br?>
Right-click on the command  prompt on the Windows menu to find the "As Administrator"
setting. PageHeap requires administrative (heightened) privileges.</simpara>
</listitem>
<listitem>
<simpara>Launch Peach from the command line (type <literal>peach</literal> and press the Return key) to start the UI.</simpara>
</listitem>
<listitem>
<simpara>Select a pit (test definition) of a protocol supported by the network device, such as BMP, so that Peach can communicate with device protocol during fuzzing.</simpara>
<itemizedlist>
<listitem>
<simpara>Give the pit a name and a description. Peach makes a configuration file of the selections you make, so that you can re-use the setup again.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>From the configuration menu along the left edge of the window, select Monitoring.</simpara>
</listitem>
<listitem>
<simpara>Fill in a name for the agent. Since this agent resides within Peach, the default
location <literal>local</literal> is appropriate.</simpara>
</listitem>
</orderedlist>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/UserGuide/Recipes/FileFuzzing_Monitoring.png" scale="50"/>
</imageobject>
<textobject><phrase>FileFuzzing Monitoring</phrase></textobject>
</mediaobject>
</informalfigure>
</section>
<section xml:id="_supplying_monitor_details">
<title>Supplying Monitor Details</title>
<simpara>Begin each monitor with a name or descriptive text. This helps identify one monitor from
another.</simpara>
<simpara>Next, fill in the critical parameters for each monitor. These parameters have callouts in
the settings diagram of each monitor. Details for these parameters are given in the text
that follows.</simpara>
<note>
<simpara>The order of the monitors listed in the agent is significant. Peach processes
the monitors in the order listed (from top to bottom). For example, a blocking
situation or incorrect test results might occur if the sequencing is incorrect. In fact,
PageHeap sets some settings for the Windows Debugger, so you you need to declare the PageHeap monitor first.</simpara>
</note>
<simpara>For this recipe, use the monitors in the order they are presented:</simpara>
<itemizedlist>
<listitem>
<simpara>PageHeap (Fault Assist)</simpara>
</listitem>
<listitem>
<simpara>WinDebugger (WaitforBootOnStartAndFault)</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="_pageheap_monitor_faultassist">
<title>PageHeap Monitor (FaultAssist)</title>
<simpara>The <link linkend="Monitors_PageHeap">PageHeap Monitor</link> enables heap allocation monitoring for
an executable through the Windows debugger. Peach sets and clears the parameters used for monitoring heap allocation at the beginning and end of the fuzzing session.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/UserGuide/Recipes/FileFuzzing_PageHeap.png" scale="50"/>
</imageobject>
<textobject><phrase>FileFuzzing PageHeap</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>The <emphasis role="strong">Executable</emphasis> parameter identifies the application or executable file that is the fuzzing target. Specify the file name, with the file extension. The path is not needed nor wanted.</simpara>
</section>
<section xml:id="_windows_debugger_monitor_faultdataandautomation">
<title>Windows Debugger Monitor (FaultDataAndAutomation)</title>
<simpara>The <link linkend="Monitors_WindowsDebugger">Windows Debugger Monitor</link> controls a Windows
debugger instance. This monitor launches an executable file, a process, a service, or
a kernel driver with the debugger attached; or, this monitor can attach the debugger
to a running executable, process, or service. This monitor can also attach the
debugger to kernel-mode drivers, although that lies outside the scope of this documentation.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/UserGuide/Recipes/FileFuzzing_WinDebugger.png" scale="50"/>
</imageobject>
<textobject><phrase>FileFuzzing WinDebugger</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>The <emphasis role="strong">Arguments</emphasis> parameter identifies command-line arguments for the executable file. The value of this parameter provides command-line switches and data file names needed to launch the executable file.</simpara>
<simpara>The <emphasis role="strong">Executable</emphasis> parameter identifies the application or executable file to launch
via the debugger. If the executable has command-line arguments, specify these using
the "Arguments" parameter.</simpara>
<simpara>The <emphasis role="strong">StartOnCall</emphasis> parameter defers launching the target until the state model issues a
call to the monitor to begin. Upon receiving the call, the debugger starts the process.</simpara>
</section>
</section>
<section xml:id="_summary">
<title>Summary</title>
<simpara>When fuzzing files on Windows, you need two monitors: PageHeap for heap allocation and the Windows Debugger that performs the vast majority of work. You also need to launch Peach
from an administrative console. A snapshot of the agent setup follows:</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/UserGuide/Recipes/FileFuzzing_AgentSummary.png" scale="50"/>
</imageobject>
<textobject><phrase>FileFuzzing AgentSummary</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>When ready, test the configuration. See <link linkend="Test_PitConfiguration">Text Pit Configuration</link> for more information.</simpara>
<simpara>Also, see <link linkend="Start_Fuzzing">Fuzzing Session</link> for information on running a fuzzing job.</simpara>
</section>
</section>
<section xml:id="Recipe_LinuxNetClient">
<title>Recipe: Monitoring a Linux Network Service Client</title>
<simpara>This recipe describes the base setup needed to fuzz a client of a Linux network service.
When fuzzing a network client, Peach impersonates the network service, the other endpoint of the network connection.</simpara>
<simpara>The recipe is a model that you can follow closely. Or, use the model as
a starting point and augment the model for your specific situation. This recipe
consists of the following parts:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>The workflow for the fuzzing session</simpara>
</listitem>
<listitem>
<simpara>The Peach components to use in configuring the fuzzing setup
This section focuses on the monitoring needs and the agents that house the monitors.</simpara>
</listitem>
<listitem>
<simpara>Configuration settings used to fuzz a service client (<literal>snmpget</literal>) running this workflow</simpara>
</listitem>
</orderedlist>
<important>
<simpara>Assumptions/Givens in this recipe are that a Pit is ready to use, Peach is ready to run, and any software module needed to perform the fuzzing job is installed.</simpara>
</important>
<section xml:id="_workflow_for_the_fuzzing_session">
<title>Workflow for the Fuzzing Session</title>
<simpara>The workflow lists the task sequence that occurs when running the fuzzing session.
The setup needed to implement the workflow follows in the next section. Start with
defining the workflow, especially if you plan to embellish the recipe.</simpara>
<simpara>Here is the workflow that Peach performs in fuzzing a Linux network service client:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Revert to a virtual machine snapshot.</simpara>
</listitem>
<listitem>
<simpara>Wait for the machine to boot up.</simpara>
</listitem>
<listitem>
<simpara>Perform fuzzing. Create and run test cases.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Peach launches the network client. The client initiates contact with the server and sends requests to the server.</simpara>
</listitem>
<listitem>
<simpara>Peach impersonates the server and replies to client queries. Query responses contain fuzzed data.</simpara>
</listitem>
<listitem>
<simpara>Perform fault detection on the client.</simpara>
</listitem>
<listitem>
<simpara>If a fault occurs, collect data surrounding the test case.</simpara>
</listitem>
<listitem>
<simpara>Revert to the VM snapshot.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Loop to step three (resume fuzzing).</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="_peach_components_needed_in_the_fuzzing_configuration">
<title>Peach Components Needed in the Fuzzing Configuration</title>
<simpara>Defining the Peach components divides in two parts: identifying the monitors to use in the configuration and identifying where to locate the specified monitors.</simpara>
<section xml:id="_identifying_monitors">
<title>Identifying Monitors</title>
<simpara>This part of the recipe revisits each step of the workflow to identify the monitors needed to implement the configuration:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Revert to a snapshot of a virtual machine.</simpara>
<simpara>Peach needs to automate the test environment and remove human interaction during the fuzzing job. We place the service in a virtual machine (VM) because Peach can use a VM monitor to automatically start and reset the test environment when needed.</simpara>
<simpara>The VM snapshot is taken while the guest OS and the Peach agent are running. Using such a snapshot avoids the wait time associated with booting up the virtual machine. Also, the same snapshot is used when Peach refreshes the test environment after a fault occurs.</simpara>
<simpara>The monitor for the VM environment, <link linkend="Monitors_Vmware">VMware</link> monitor, resides on the host machine.</simpara>
</listitem>
<listitem>
<simpara>Wait for the machine to boot up.</simpara>
<simpara>Peach waits for the VM snapshot to resume.</simpara>
</listitem>
<listitem>
<simpara>Perform fuzzing, checking for faults.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Launch the network client.</simpara>
<simpara>The Peach agent launches the client service through GDB. The client submits requests from the remote machine. The debugger and the client both reside on the remote machine.</simpara>
</listitem>
<listitem>
<simpara>Reply to the client request with fuzzed data.</simpara>
<simpara>Peach impersonates the network server and sends fuzzed replies in response to client queries.</simpara>
</listitem>
<listitem>
<simpara>Perform fault detection in the VM.</simpara>
<simpara>The GDB monitor watches the internals of the services and detects faults such as access violations and exceptions. Again, the debug monitor is located on the same machine as the service.</simpara>
</listitem>
<listitem>
<simpara>Collect data surrounding each fault as it happens.</simpara>
<simpara>When a fault occurs, the packets involved with the fault are interesting. Peach captures the packets using a network capture monitor. This monitor resides on the local machine with Peach Fuzzer.</simpara>
<simpara>Peach collects log files generated by the debugger located on the remote machine where the service resides. A monitor that saves files sends files from a specified folder on the remote system to the Peach logging repository on the local machine. The monitor to save the log files is located on the remote machine.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Revert to the VM snapshot.</simpara>
<simpara>This step uses the VM monitor and VM snapshot from step 1 to refresh the test environment, and the debug monitor from step 3 to start the network service in the refreshed environment. No additional monitors are needed for this step.</simpara>
</listitem>
<listitem>
<simpara>Resume fuzzing.</simpara>
<simpara>Loop to step 3.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="_identifying_agents">
<title>Identifying Agents</title>
<simpara>Peach offers two types of agents to manage monitors and I/O publishers: local and remote.</simpara>
<itemizedlist>
<listitem>
<simpara>Local agents reside inside Peach.<?asciidoc-br?>
The local agent in this recipe addresses automation involving the VM and data collection
that captures network packets. The local agent houses the <link linkend="Monitors_Vmware">VMware</link>
 and the <link linkend="Monitors_NetworkCapture">NetworkCapture</link> monitors.</simpara>
<simpara>The VMware monitor starts a snapshot VM environment at the beginning of the fuzzing job,
as well as restarting the same VM snapshot after a fault occurs.</simpara>
</listitem>
<listitem>
<simpara>Remote agents reside in separate processes on remote machines with the test targets.<?asciidoc-br?>
In this case, the remote agent and the Linux service reside on the same machine.</simpara>
<simpara>The remote agent houses the <link linkend="Monitors_Gdb">Gdb</link> debug monitor that starts the
Linux service client at the beginning of the fuzzing job and restarts the service in the
refreshed environment after a fault. The Gdb debug monitor detects faults that occur in
the client.</simpara>
<simpara>In addition, a data collection monitor collects log files after a fault occurs in the network client. The <link linkend="Monitors_SaveFile">Save File</link> monitor forwards the log files to the logging repository.</simpara>
</listitem>
</itemizedlist>
<simpara>The result is that we end up with the following configuration:</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/UserGuide/Recipes/VM_Remote_Agent.png" scale="50"/>
</imageobject>
<textobject><phrase>VM Remote Agent</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Peach is located on one machine with a local agent that houses the VM monitor and the Network capture monitor. A second agent resides on the remote machine with the service. The remote agent houses the Gdb debug monitor and the SaveFile monitor.</simpara>
<simpara>The local agent is simple to implement. All that&#8217;s needed is to define the agent, then specify the appropriate monitors and monitor settings used with the local agent.</simpara>
<simpara>The remote monitor is a little more involved. Like the local agent, the remote agent needs to be defined, then specify the appropriate monitors and monitor settings used with the remote agent. Second, the remote agent needs to run on the same OS as the test target. This step can be done separately from specifying the configuration details. In this recipe, a VM snapshot is used. See <link linkend="VM_Setup">Using Virtual Machines</link>, for information on setting up the VM snapshot.</simpara>
</section>
</section>
<section xml:id="_sample_network_client_configuration">
<title>Sample Network Client Configuration</title>
<simpara>This section shows the recipe implemented for a network service client and consists of the following items:</simpara>
<itemizedlist>
<listitem>
<simpara>Setup on the Target VM Image</simpara>
</listitem>
<listitem>
<simpara>Pit variables</simpara>
</listitem>
<listitem>
<simpara>Peach agents</simpara>
</listitem>
<listitem>
<simpara>Peach monitors</simpara>
</listitem>
<listitem>
<simpara>Debug monitor "No Cpu Kill" parameter</simpara>
</listitem>
<listitem>
<simpara>Configuration test</simpara>
</listitem>
</itemizedlist>
<note>
<simpara>The configurations for the network client and the network service are very similar. Two significant differences exist:</simpara>
<itemizedlist>
<listitem>
<simpara>The network client configuration uses a client application instead of the network service.</simpara>
</listitem>
<listitem>
<simpara>In the network client configuration, the test target initiates the action instead of
responding to a request. The client contacts Peach, acting as the network service, then waits for Peach to provide a response to the query. The debug monitor has additional configuration options that are set to drive this configuration.</simpara>
</listitem>
</itemizedlist>
</note>
<section xml:id="_setup_on_the_target_vm_image">
<title>Setup on the Target VM Image</title>
<simpara>Perform the following task on the VM before taking a snapshot of the VM.</simpara>
<itemizedlist>
<listitem>
<simpara>Run the Peach agent from a shell with root access.<?asciidoc-br?>
Within the shell, navigate to the peach folder and execute the following command:<?asciidoc-br?>
<literal>./peach -a tcp</literal><?asciidoc-br?>
When Peach starts the VM, the Peach agent is running in a root shell.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="_pit_variables">
<title>Pit Variables</title>
<simpara>The following UI display identifies data values typically needed by a network
protocol Pit. The variables and values are independent of the monitors used in
the configuration. Pit variables are unique to the Pit and might differ with those
in the example illustration.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/UserGuide/Recipes/LinuxNetClient_PitVariables.png" scale="50"/>
</imageobject>
<textobject><phrase>LinuxNetClient PitVariables</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>The Pit User Guides describe the Pit-specific variables.</simpara>
<variablelist>
<varlistentry>
<term>Community String (Authentication)</term>
<listitem>
<simpara>Community string used for authentication. Peach and the network client must use the same community string. Check the server documentation for consistency of this value. If needed, change the value here to coincide with the value expected by the test target.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Source Port</term>
<listitem>
<simpara>Port number of the local machine that sends packets to the server. Several services use well-known ports that usually can be left unedited.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Target IPv4 Address</term>
<listitem>
<simpara>IPv4 address of the target machine (client). For information on obtaining the IPv4 address, see Retrieving Machine Information section of the Pit User Guide.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Target Port</term>
<listitem>
<simpara>SNMP port number of the remote machine that sends and receives packets. Several services use well-known ports that usually can be left unedited.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Timeout</term>
<listitem>
<simpara>Duration, in milliseconds, to wait for incoming data. During fuzzing, a timeout failure causes the fuzzer to skip to the next test case.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_agents">
<title>Agents</title>
<simpara>The following UI diagram acts as an overview, showing the Peach agents and the monitors within each agent. Peach uses the ordering within the agent to determine the order in which to load and run monitors.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/UserGuide/Recipes/LinuxNetClient_Agents.png" scale="50"/>
</imageobject>
<textobject><phrase>LinuxNetClient Agents</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>The local agent is defined first and lists the default information for both name and location. This definition for a local agent is typical and, otherwise, unremarkable. The NetworkCapture and Vmware monitors are independent of one another, allowing either monitor to top the list.</simpara>
<simpara>The remote agent, named "Remote Client Manager", has quite a different location specification. The location consists of concatenated pieces of information:</simpara>
<itemizedlist>
<listitem>
<simpara>Channel. The channel for a remote agent is <literal>tcp</literal>. A colon and two forward slashes separate the channel from the IPv4 address of the hardware interface.</simpara>
</listitem>
<listitem>
<simpara>Target IPv4 address of the remote machine. The IPv4 address of the agent is the second component of the location.  For more information, see the Retrieving Machine Information section of the Peach Pit User Guide.</simpara>
</listitem>
</itemizedlist>
<simpara>The monitor list within each agent is significant, as the monitors are launched in order from top to bottom within an agent.</simpara>
</section>
<section xml:id="_monitors">
<title>Monitors</title>
<simpara>This recipe uses four monitors, two on the machine with Peach and two on the remote machine. The recipe shows each monitor and describes its roles: fault detection, data collection, and automation.</simpara>
<section xml:id="_vmware_remote_client_manager">
<title>Vmware (Remote Client Manager)</title>
<simpara>The <link linkend="Monitors_Vmware">Vmware</link> monitor controls setting up and starting the virtual machine.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/UserGuide/Recipes/LinuxNetClient_Vmware.png" scale="50"/>
</imageobject>
<textobject><phrase>LinuxNetClient Vmware</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>The most significant parameters for the VMware monitor follow:</simpara>
<variablelist>
<varlistentry>
<term>Vmx</term>
<listitem>
<simpara>Identifies the full path of the virtual machine image. Peach loads the
snapshot of the VM image at the start of the fuzzing job and after a fault occurs.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Headless</term>
<listitem>
<simpara>Identifies whether the VM has a window associated with it. When
developing a configuration, set this parameter to false. When the configuration is
complete, change Headless to true.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Host Type</term>
<listitem>
<simpara>Specifies the VMware product used in the configuration.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Snapshot Name</term>
<listitem>
<simpara>Identifies the snapshot to use for the specific image.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
</section>
<section xml:id="_network_capture_interestingpackets">
<title>Network Capture (InterestingPackets)</title>
<simpara>The <link linkend="Monitors_NetworkCapture">Network Capture Monitor</link> captures
network packets sent and received from the test target. When a fault occurs,
Peach stores the packets immediately surrounding the fault in the log of the test case.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/UserGuide/Recipes/LinuxNetClient_NetworkCapture.png" scale="50"/>
</imageobject>
<textobject><phrase>LinuxNetClient NetworkCapture</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>The most significant parameters for the network capture monitor follow:</simpara>
<variablelist>
<varlistentry>
<term>Device</term>
<listitem>
<simpara>Specifies the name of the interface on the local machine (the machine
with Peach) used to communicate with the test target. Use <literal>ifconfig</literal> to identify
the interface(s) available for use.</simpara>
</listitem>
</varlistentry>
</variablelist>
<note>
<simpara>You can find the appropriate host interface that communicates with the VM using the following steps:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Collect a list of interfaces (and their IPv4 addresses) by running <literal>ipconfig</literal> or <literal>ifconfig</literal>.</simpara>
</listitem>
<listitem>
<simpara>Test each interface in the list. Manually run a capture session with Wireshark using an interface from the list.</simpara>
</listitem>
<listitem>
<simpara>On the host machine, Ping the target IPv4 (of the VM).</simpara>
</listitem>
<listitem>
<simpara>If the correct interface of the host is used, you&#8217;ll see the Ping request and reply packet exchanges through Wireshark,</simpara>
</listitem>
<listitem>
<simpara>Loop to step 2 and repeat, using another interface.</simpara>
</listitem>
</orderedlist>
</note>
<variablelist>
<varlistentry>
<term>Filter</term>
<listitem>
<simpara>Helps capture only those packets associated with the fuzzing session.
The filter adheres to the syntax and requirements of the Pcap filter specification.</simpara>
</listitem>
</varlistentry>
</variablelist>
<tip>
<simpara>WireShark refers to the Libpcap filters as capture filters. Use the capture
filters. Wireshark also defines its own display filters that it uses to filter entries in its session files. The display filters are not compatible with Libpcap.</simpara>
</tip>
</section>
<section xml:id="_gdb_debugger">
<title>GDB (Debugger)</title>
<simpara>The <link linkend="Monitors_Gdb">GDB</link> debugger monitor performs two main functions in this recipe:</simpara>
<itemizedlist>
<listitem>
<simpara>Starts the network client at the start of a fuzzing job and restarts the client when the VM snapshot refreshes.</simpara>
</listitem>
<listitem>
<simpara>Detects faults internal to the client.</simpara>
</listitem>
</itemizedlist>
<simpara>The Gdb monitor uses the settings in the following illustration:</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/UserGuide/Recipes/LinuxNetClient_Gdb.png" scale="50"/>
</imageobject>
<textobject><phrase>LinuxNetClient Gdb</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>The most significant parameters follow:</simpara>
<variablelist>
<varlistentry>
<term>Executable</term>
<listitem>
<simpara>Identifies the full path to the Linux service client. The client
resides on the remote machine; so, the full path is for the Linux file system.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Arguments</term>
<listitem>
<simpara>Arguments for the executable.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>No Cpu Kill</term>
<listitem>
<simpara>Controls whether the process stays alive if its CPU usage drops to zero. Specify <literal>true</literal> to keep the process running and to allow the process to release or close its resources before exiting. For more information, see the following section <emphasis>Closing the Client Process</emphasis>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Start On Call</term>
<listitem>
<simpara>Controls when the test target launches, and in turn, initiates contact with the service (Peach). Specify <literal>StartIterationEvent</literal> to launch the client at the start of the test case.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_savefile_collectlogs">
<title>SaveFile (CollectLogs)</title>
<simpara>The <link linkend="Monitors_SaveFile">SaveFile</link> monitor collects log files from the remote
test target and copies them to the Peach Logging folder. The monitor is housed by
the remote agent.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/UserGuide/Recipes/LinuxNetClient_SaveFile.png" scale="50"/>
</imageobject>
<textobject><phrase>LinuxNetClient SaveFile</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>The most significant parameter follows:</simpara>
<variablelist>
<varlistentry>
<term>Filename</term>
<listitem>
<simpara>Specifies the full path to the Linux logging system used by GDB.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
</section>
<section xml:id="_closing_the_client_process">
<title>Closing the Client Process</title>
<simpara>In this recipe, the Peach debug monitor launches the network service client using the "Start On Call" parameter so that the client initiates contact with the server. Then, at the end of the test case after execution complete, the "No Cpu Kill" parameter provides control of how the client closes:</simpara>
<itemizedlist>
<listitem>
<simpara>If "No Cpu Kill" is <literal>true</literal>, Peach waits for the process to exit OR for a time to elapse specified by the "Wait For Exit Timeout" parameter.</simpara>
</listitem>
<listitem>
<simpara>If "No Cpu Kill" is <literal>false</literal>, Peach waits for the CPU usage of the process to reach zero percent OR for the process to exit OR for a time to elapse specified by the "Wait For Exit Timeout" parameter. The "No Cpu Kill" parameter default setting is <literal>false</literal>.</simpara>
</listitem>
</itemizedlist>
<note>
<simpara>If the waiting period ends, peach kills the target process if it is still running and starts the next iteration.</simpara>
</note>
<simpara>So, when do you need to let a process with zero CPU activity continue to execute?</simpara>
<simpara>Set “No Cpu Kill” to <literal>true</literal> when you&#8217;re fuzzing a network service client. In this scenario, Peach Fuzzer starts the network client using the “Start on Call” parameter to initiate contact with the service. When the client receives and processes the reply, Peach waits for the client to run to completion and watches for any faults that occur before the client exits.</simpara>
<simpara>Scenarios exempt from the "No Cpu Kill" option include the following:</simpara>
<itemizedlist>
<listitem>
<simpara>Fuzzing network service servers typically do not use the “Start On Call” option, so the “No Cpu Kill” option isn&#8217;t needed.</simpara>
</listitem>
<listitem>
<simpara>Fuzzing file formats require “Start on Call” to start the fuzzing target once the fuzzed data file is generated. The “No Cpu Kill” parameter can be used here; however, Peach can save time that will be replicated in each test case by letting the process terminate if the CPU usage falls to zero. In this case, not using “No Cpu Kill” is a performance optimization.</simpara>
</listitem>
<listitem>
<simpara>Embedded devices. Fuzzing configurations for these devices do not use the Peach debugging monitors: GDB, WindowsDebugger, or CrashWrangler. So, the “No Cpu Kill” option isn&#8217;t needed.</simpara>
</listitem>
<listitem>
<simpara>Kernel-mode debugging. Kernel-mode debugging has its own set of requirements. “No Cpu Kill” is not used here.</simpara>
</listitem>
</itemizedlist>
<section xml:id="_configuration_test">
<title>Configuration Test</title>
<simpara>Once the monitors and associated parameters are part of the configuration, you can test the configuration. From the Configuration menu along the left edge of the window, click on <literal>Test</literal> to run a single iteration (test case) on the configuration. Note that the test checks the connections and communications. It does NOT do any fuzzing.</simpara>
<simpara>For more information on testing a configuration, see <link linkend="Test_PitConfiguration">Test Pit Configuration</link>.</simpara>
</section>
</section>
</section>
<section xml:id="Recipe_LinuxNetServer">
<title>Recipe: Monitoring a Linux Network Service</title>
<simpara>This recipe describes the base setup needed to fuzz a Linux network service.
When fuzzing a network server, Peach impersonates the client, the other endpoint of the
network connection.</simpara>
<simpara>The recipe is a model that you can follow closely. Or, you can use the model as
a starting point and augment the model for your specific situation. This recipe
consists of the following parts:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>The workflow for the fuzzing session</simpara>
</listitem>
<listitem>
<simpara>The Peach components to use in configuring the fuzzing setup
This section focuses on the monitoring needs and the agents that house the monitors.</simpara>
</listitem>
<listitem>
<simpara>Configuration settings used to fuzz a sample service (SNMP) running this workflow</simpara>
</listitem>
</orderedlist>
<important>
<simpara>Assumptions/Givens in this recipe are that a Pit is ready to use, Peach is ready to run, and any software module needed to perform the fuzzing job is installed.</simpara>
</important>
<simpara>In this scenario, Peach runs on a host computer; the network server runs in a
Virtual Machine (VM) on the host. With Peach running on the host, it controls the
environment. If the network server crashes, the worst thing that happens is that
the virtual machine has to restart. Peach recover the data if the network
server crashes.</simpara>
<section xml:id="_workflow_for_the_fuzzing_session_2">
<title>Workflow for the Fuzzing Session</title>
<simpara>The workflow lists the task sequence that occurs when running the fuzzing session.
The setup needed to implement the workflow follows in the next section. Start with
defining the workflow, especially if you plan to embellish the recipe.</simpara>
<simpara>Here is the workflow that Peach performs in fuzzing a Linux network service:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Revert to a virtual machine snapshot.</simpara>
</listitem>
<listitem>
<simpara>Wait for the machine to boot up.</simpara>
</listitem>
<listitem>
<simpara>Launch the network service.</simpara>
</listitem>
<listitem>
<simpara>Perform fuzzing. Create and run test cases.</simpara>
<itemizedlist>
<listitem>
<simpara>Peach initiates contact with the server and sends packets of fuzzed data to the server.</simpara>
</listitem>
<listitem>
<simpara>Check for faults, such as crashes and access violations.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>When a fault occurs, do the following:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Collect data surrounding the test case.</simpara>
</listitem>
<listitem>
<simpara>Revert to the VM snapshot.</simpara>
</listitem>
<listitem>
<simpara>Launch the network service.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Loop to step 4 (resume fuzzing).</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="_peach_components_needed_in_the_fuzzing_configuration_2">
<title>Peach Components Needed in the Fuzzing Configuration</title>
<simpara>Defining the Peach components divides in two parts: identifying the monitors to use in the configuration and identifying where to locate the specified monitors.</simpara>
<section xml:id="_identifying_monitors_2">
<title>Identifying Monitors</title>
<simpara>This part of the recipe revisits each step of the workflow to identify the monitors needed to implement the configuration:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Revert to a snapshot of a virtual machine.</simpara>
<simpara>Peach needs to automate the test environment and remove human interaction during the fuzzing job. We place the service in a virtual machine (VM) because Peach can use a VM monitor to automatically start and reset the test environment when needed.</simpara>
<simpara>The VM snapshot is taken while the guest OS and the Peach agent are running. Using such a snapshot avoids the wait time associated with booting up the virtual machine. Also, the same snapshot is used when Peach refreshes the test environment after a fault occurs.</simpara>
<simpara>The monitor for the VM environment, <link linkend="Monitors_Vmware">VMware</link> monitor, resides on the host machine.</simpara>
</listitem>
<listitem>
<simpara>Wait for the machine to boot up.</simpara>
<simpara>Peach waits for the VM snapshot to resume.</simpara>
</listitem>
<listitem>
<simpara>Launch the network service.</simpara>
<simpara>The Peach agent in the VM starts the network service via the <link linkend="Monitors_Gdb">Gdb</link> debugging monitor and the GDB system debugger.</simpara>
</listitem>
<listitem>
<simpara>Perform fuzzing, checking for faults.</simpara>
<simpara>Perform fault detection in the VM. The Gdb monitor watches the internals of the services and detects faults such as access violations and exceptions. Again, the debug monitor is located on the same machine as the service.</simpara>
</listitem>
<listitem>
<simpara>Collect data surrounding each fault as it happens.</simpara>
<simpara>Peach sends and receives network packets to the service. When a fault occurs, the packets involved with the fault are interesting. Peach captures the packets using the <link linkend="Monitors_NetworkCapture">NetworkCapture</link> monitor.</simpara>
<simpara>Peach collects log files generated by the debugger located on the remote machine where the service resides. A <link linkend="Monitors_SaveFile">Save File</link> monitor sends files from a specified folder on the remote system to the Peach logging repository on the local machine.</simpara>
</listitem>
<listitem>
<simpara>Resume fuzzing.</simpara>
<simpara>This step uses the VM monitor and VM snapshot from step 1 to refresh the test environment, and the debug monitor from step 3 to start the network service in the refreshed environment. No additional monitors are needed for this step.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="_identifying_agents_2">
<title>Identifying Agents</title>
<simpara>Peach offers two types of agents to manage monitors and I/O publishers: local and remote.</simpara>
<itemizedlist>
<listitem>
<simpara>Local agents reside inside Peach.<?asciidoc-br?>
The local agent in this recipe addresses automation involving the VM and data collection
that captures network packets. The local agent houses the <link linkend="Monitors_Vmware">VMware</link>
 and the <link linkend="Monitors_NetworkCapture">NetworkCapture</link> monitors.</simpara>
<simpara>The VMware monitor starts a snapshot VM environment at the beginning of the fuzzing job,
as well as restarting the same VM snapshot after a fault occurs.</simpara>
</listitem>
<listitem>
<simpara>Remote agents reside in separate processes on remote machines with the test targets.<?asciidoc-br?>
In this case, the remote agent and the Linux service reside on the same machine.</simpara>
<simpara>The remote agent houses the <link linkend="Monitors_Gdb">Gdb</link> debug monitor that starts the
network service at the beginning of the fuzzing job and restarts the service in the
refreshed environment after a fault. The Gdb debug monitor detects faults that occur in
the service.</simpara>
<simpara>In addition, a data collection monitor collects log files after a fault occurs in the network service. The <link linkend="Monitors_SaveFile">Save File</link> monitor forwards the log files to the logging repository.</simpara>
</listitem>
</itemizedlist>
<simpara>The result is that we end up with the following configuration:</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/UserGuide/Recipes/VM_Remote_Agent.png" scale="50"/>
</imageobject>
<textobject><phrase>VM Remote Agent</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Peach is located on one machine with a local agent that houses the VM monitor and the Network capture monitor. A second agent resides on the remote machine with the service. The remote agent houses the Gdb debug monitor and the SaveFile monitor.</simpara>
<simpara>The local agent is simple to implement. All that&#8217;s needed is to define the agent, then specify the appropriate monitors and monitor settings used with the local agent.</simpara>
<simpara>The remote monitor is a little more involved. Like the local agent, the remote agent needs to be defined, then specify the appropriate monitors and monitor settings used with the remote agent. Second, the remote agent needs to run on the same OS as the test target. This step can be done separately from specifying the configuration details. In this recipe, a VM snapshot is used. See the previous section, Using Virtual Machines, for information on setting up the VM snapshot.</simpara>
</section>
</section>
<section xml:id="_sample_configuration">
<title>Sample configuration</title>
<simpara>This section shows the recipe implemented for a network service and consists of the following items:</simpara>
<itemizedlist>
<listitem>
<simpara>Setup on the Target VM Image</simpara>
</listitem>
<listitem>
<simpara>Pit variables</simpara>
</listitem>
<listitem>
<simpara>Peach agents</simpara>
</listitem>
<listitem>
<simpara>Peach monitors</simpara>
</listitem>
<listitem>
<simpara>Configuration test</simpara>
</listitem>
</itemizedlist>
<section xml:id="_setup_on_the_target_vm_image_2">
<title>Setup on the Target VM Image</title>
<simpara>Perform the following items on the VM before taking a snapshot of the VM.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Run the Peach agent from a shell with root access.<?asciidoc-br?>
Within the shell, navigate to the peach folder and execute the following command:<?asciidoc-br?>
<literal>./peach -a tcp</literal><?asciidoc-br?>
When Peach starts the VM, the Peach agent is running in a root shell.<?asciidoc-br?></simpara>
</listitem>
<listitem>
<simpara>In the VM, edit the configuration file to have the service listen for
connections on all IPv4 interfaces.</simpara>
</listitem>
<listitem>
<simpara>Stop the service.<?asciidoc-br?>
During fuzzing, the debugger (GDB) will start the service.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="_pit_variables_2">
<title>Pit Variables</title>
<simpara>The following UI display identifies data values typically needed by a network
protocol Pit. The variables and values are independent of the monitors used in
the configuration. Pit variables are unique to the Pit and might differ with those
in the example illustration.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/UserGuide/Recipes/LinuxNetService_PitVariables.png" scale="50"/>
</imageobject>
<textobject><phrase>LinuxNetService PitVariables</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>The Pit User Guides describe the Pit-specific variables.</simpara>
<variablelist>
<varlistentry>
<term>Community String (Authentication)</term>
<listitem>
<simpara>Community string used for authentication by the network server. Check the network service documentation for consistency of this value. If needed, change the value here to coincide with the value expected by the test target.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Source Port</term>
<listitem>
<simpara>Port number of the local machine that sends packets to the server. Several services use well-known ports that usually can be left unedited.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Target IPv4 Address</term>
<listitem>
<simpara>IPv4 address of the target machine (server). For information on obtaining the IPv4 address, see Retrieving Machine Information in the Pit documentation.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Target Port</term>
<listitem>
<simpara>Port number of the server that receives packets. Several services use well-known ports that usually can be left unedited.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Timeout</term>
<listitem>
<simpara>Duration, in milliseconds, to wait for incoming data.During fuzzing, a timeout failure causes the fuzzer to skip to the next test case.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_agents_2">
<title>Agents</title>
<simpara>The following UI diagram acts as an overview, showing the Peach agents and the monitors within each agent. Peach uses the ordering within the agent to determine the order in which to load and run monitors.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/UserGuide/Recipes/LinuxNetService_Agents.png" scale="50"/>
</imageobject>
<textobject><phrase>LinuxNetService Agents</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>The local agent is defined first and lists the default information for both name and location. This definition for a local agent is typical and, otherwise, unremarkable. The Vmware monitor, that starts the virtual machine, is the first monitor listed, as that action is not dependent on actions from another monitor.</simpara>
<simpara>The remote agent, named "Remote", has quite a different location specification. The location consists of concatenated pieces of information:</simpara>
<itemizedlist>
<listitem>
<simpara>Channel. The channel for a remote agent is <literal>tcp</literal>. A colon and two forward slashes separate the channel from the IPv4 address of the hardware interface.</simpara>
</listitem>
<listitem>
<simpara>IPv4 address. The IPv4 address of the agent is the second component of the location. Use <literal>ifconfig</literal> to  find this address of the remote machine.</simpara>
</listitem>
</itemizedlist>
<simpara>The monitor list within each agent is significant, as the monitors are launched in order from top to bottom within an agent.</simpara>
</section>
<section xml:id="_monitors_2">
<title>Monitors</title>
<simpara>This recipe uses four monitors, two on the machine with Peach and two on the remote machine. The recipe shows each monitor and describes its roles: fault detection, data collection, and automation.</simpara>
<section xml:id="_vmware_linux_virtual_machine_automation">
<title>Vmware (Linux virtual machine Automation)</title>
<simpara>The <link linkend="Monitors_Vmware">Vmware</link> monitor controls setting up and starting the virtual machine.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/UserGuide/Recipes/LinuxNetService_Vmware.png" scale="50"/>
</imageobject>
<textobject><phrase>LinuxNetService Vmware</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>The most significant parameters for the VMware monitor follow:</simpara>
<variablelist>
<varlistentry>
<term>Vmx</term>
<listitem>
<simpara>Identifies the full path of the virtual machine image. Peach loads the snapshot of the VM image at the start of the fuzzing job and after a fault occurs.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Headless</term>
<listitem>
<simpara>Identifies whether the VM has a window associated with it. When
developing a configuration, set this parameter to false. When the configuration
is complete, change Headless to true.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Host Type</term>
<listitem>
<simpara>Specifies the VMware product used in the configuration.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Snapshot Name</term>
<listitem>
<simpara>Identifies the snapshot to use for the specific image.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
</section>
<section xml:id="_network_capture_interestingpackets_2">
<title>Network Capture (InterestingPackets)</title>
<simpara>The <link linkend="Monitors_NetworkCapture">Netowrk Capture Monitor (InterestingPackets)</link> captures
network packets sent and received from the test target. When a fault occurs,
Peach stores the packets immediately surrounding the fault in the log of the
test case.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/UserGuide/Recipes/LinuxNetService_NetworkCapture.png" scale="50"/>
</imageobject>
<textobject><phrase>LinuxNetService NetworkCapture</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>The most significant parameters for the network capture monitor follow:</simpara>
<variablelist>
<varlistentry>
<term>Device</term>
<listitem>
<simpara>Specifies the name of the interface on the local machine (the machine
with Peach) used to communicate with the test target. Use <literal>ifconfig</literal> to identify
the interface(s) available for use.</simpara>
</listitem>
</varlistentry>
</variablelist>
<note>
<simpara>You can find the appropriate host interface that communicates with the VM using the following steps:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Collect a list of interfaces (and their IPv4 addresses) by running <literal>ipconfig</literal> or <literal>ifconfig</literal>.</simpara>
</listitem>
<listitem>
<simpara>Test each interface in the list. Manually run a capture session with Wireshark using an interface from the list.</simpara>
</listitem>
<listitem>
<simpara>On the host machine, Ping the target IPv4 (of the VM).</simpara>
</listitem>
<listitem>
<simpara>If the correct interface of the host is used, you&#8217;ll see the Ping request and reply packet exchanges through Wireshark,</simpara>
</listitem>
<listitem>
<simpara>Loop to step 2 and repeat, using another interface.</simpara>
</listitem>
</orderedlist>
</note>
<variablelist>
<varlistentry>
<term>Filter</term>
<listitem>
<simpara>Helps capture only those packets associated with the fuzzing session.
The filter adheres to the syntax and requirements of the Pcap filter specification.</simpara>
</listitem>
</varlistentry>
</variablelist>
<tip>
<simpara>WireShark refers to the Libpcap filters as capture filters. Use the capture
filters. Wireshark also defines its own display filters that it uses to filter entries in its session files. The display filters are not compatible with Libpcap.</simpara>
</tip>
</section>
<section xml:id="_gdb_debugger_2">
<title>Gdb (Debugger)</title>
<simpara>The <link linkend="Monitors_Gdb">Gdb</link> debugger monitor performs two main functions in this recipe:</simpara>
<itemizedlist>
<listitem>
<simpara>Starts the network service at the start of a fuzzing job and restarts the service
when the VM snapshot refreshes.</simpara>
</listitem>
<listitem>
<simpara>Detects faults internal to the service.</simpara>
</listitem>
</itemizedlist>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/UserGuide/Recipes/LinuxNetService_Gdb.png" scale="50"/>
</imageobject>
<textobject><phrase>LinuxNetService Gdb</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>The most significant parameters follow:</simpara>
<variablelist>
<varlistentry>
<term>Executable</term>
<listitem>
<simpara>Identifies the full path to the Linux service executable.
This monitor, managed by the remote agent, resides on the remote machine, so the
full path is for the Linux file system.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Arguments</term>
<listitem>
<simpara>Arguments for the executable.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_savefile_collectlogs_2">
<title>SaveFile (CollectLogs)</title>
<simpara>The <link linkend="Monitors_SaveFile">SaveFile</link> monitor collects log files from the remote test target and copies them to the Peach Logging folder. The monitor is housed by the remote agent.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/UserGuide/Recipes/LinuxNetService_SaveFile.png" scale="50"/>
</imageobject>
<textobject><phrase>LinuxNetService SaveFile</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>The most significant parameter follows:</simpara>
<variablelist>
<varlistentry>
<term>Filename</term>
<listitem>
<simpara>Specifies the full path to the Linux logging system used by GDB.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_configuration_test_2">
<title>Configuration Test</title>
<simpara>Once the monitors and associated parameters are part of the configuration, you can test the configuration. From the Configuration menu along the left edge of the window, click on <literal>Test</literal> to run a single iteration (test case) on the configuration. Note that the test checks the connections and communications. It does NOT do any fuzzing.</simpara>
<simpara>For more information on testing a configuration, see <link linkend="Test_PitConfiguration">Test Pit Configuration</link>.</simpara>
</section>
</section>
</section>
<section xml:id="Recipe_NetDevice">
<title>Recipe: Monitoring a Network Device</title>
<simpara>This recipe identifies the monitors and associated settings suitable for testing a
network device, such as a router or a switch. The network device connects to the
computer running Peach via a network interface. Peach tests the connection using
a specific protocol or service. The network device&#8217;s serial console connects
to the computer running Peach. Peach uses the serial console to capture and inspect
device messages.</simpara>
<simpara>This recipe uses a router to demonstrate the procedure.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/UserGuide/Recipes/NetworkDevice_Router.png" scale="40"/>
</imageobject>
<textobject><phrase>NetworkDevice Router</phrase></textobject>
</mediaobject>
</informalfigure>
<note>
<simpara>When testing protocols in layers 2 through 4 of the ISO network model,
consider using a private test network so that the testing doesn&#8217;t affect other
systems on the network.</simpara>
</note>
<section xml:id="_what_is_the_fuzzing_session_workflow_2">
<title>What is the fuzzing session workflow?</title>
<simpara>The workflow that we want to follow in the test consists of the following steps:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Power on the device.</simpara>
</listitem>
<listitem>
<simpara>Wait for the device to complete its boot process.</simpara>
</listitem>
<listitem>
<simpara>Fuzz the device and look for faults.</simpara>
</listitem>
<listitem>
<simpara>When a fault occurs, do the following:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Reset the device by cycling the power off and then on.</simpara>
</listitem>
<listitem>
<simpara>Wait for the device to complete its boot process.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Loop to step 3 and continue fuzzing.</simpara>
</listitem>
</orderedlist>
<simpara>Given this, here&#8217;s a diagram of connections for the test configuration.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/UserGuide/Recipes/NetworkDevice_Overview.png" scale="50"/>
</imageobject>
<textobject><phrase>NetworkDevice Overview</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Peach handles communications with the device using a single, local agent. Peach also
connects to a programmable power supply, the IpPower 9258, that can be powered down
and up on command. In step 4a of the workflow, Peach sends the power cycling command
to the IpPower 9258 to perform this task.</simpara>
<simpara>Now for setting up the monitors, consisting of detecting faults, collecting data, and
automating the test environment.</simpara>
<simpara>The first item in detecting faults is to ensure the service is still listening
for incoming connections. With more sophisticated devices, a service can stop,
but the device still responds. Use the TCP port monitor for detecting when the service
stops. As a backup, the Ping monitor can be used.</simpara>
<simpara>The second item in detecting faults is watching the device console for error messages.
The Serial monitor with a regular expression specified, such as “Error”,
can perform this task. You will need to construct the regular expression to watch
for key word(s) in the error message text because the messages vary among manufacturers. Consult the device documentation or an
expert on the test device for the message content.</simpara>
<simpara>When a fault occurs, we want to collect data relevant to the fault. The
NetworkCapture monitor (InterestingPackets) provides the mechanism to capture network packets around the
time that the fault occurs. The Serial monitor provides console logs with messages
leading up to the fault.</simpara>
<simpara>Finally, we want to automatically reset the device after a fault occurs by cycling
the power off, then on again. The IpPower9258 monitor provides control over outlets.
A second aspect of automation is that the system must wait for the device reboot
to complete before resuming fuzzing activities. The Serial monitor performs this
task by watching logging messages for a message that indicates the boot process
completed.</simpara>
</section>
<section xml:id="_setting_up_monitors_using_the_peach_web_ui_2">
<title>Setting up Monitors Using the Peach Web UI</title>
<section xml:id="_starting_peach_2">
<title>Starting Peach</title>
<orderedlist numeration="arabic">
<listitem>
<simpara>Launch Peach from the command line (type <literal>peach</literal> and press the Return key) to start the UI.</simpara>
</listitem>
<listitem>
<simpara>Select a pit (test definition) of a protocol supported by the network device, so that Peach can communicate with the device during fuzzing.</simpara>
<itemizedlist>
<listitem>
<simpara>Give the pit a name and a description. Peach makes a configuration file of the selections you make, so that you can re-use the setup again.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>From the configuration menu along the left edge of the window, select Monitoring.</simpara>
</listitem>
<listitem>
<simpara>Fill in a name for the agent. Since this agent resides within Peach, the default
location <literal>local</literal> is appropriate. Then, click the`Save` button.</simpara>
</listitem>
</orderedlist>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/UserGuide/Recipes/NetworkDevice_LocalAgent.png" scale="50"/>
</imageobject>
<textobject><phrase>NetworkDevice LocalAgent</phrase></textobject>
</mediaobject>
</informalfigure>
</section>
<section xml:id="_supplying_monitor_details_2">
<title>Supplying Monitor Details</title>
<simpara>Begin each monitor with a name or descriptive text. This helps identify one monitor from
another, and is especially evident with the two serial monitors.</simpara>
<simpara>Next, fill in the critical parameters for each monitor. These parameters have callouts in
the settings diagram of each monitor. Details for these parameters are given in the text
that follows.</simpara>
<note>
<simpara>The order of the monitors listed in the agent is significant. Peach processes
the monitors in the order listed (from top to bottom). For example, if the IpPower
monitor were last on the list, a blocking situation might arise because one of the
Serial monitors would be waiting for the device boot process to finish before the power
is recycled to initiate the device boot process.</simpara>
</note>
<simpara>For this recipe, use the monitors in the order they are presented:</simpara>
<itemizedlist>
<listitem>
<simpara>IpPower9258 (BootDevice)</simpara>
</listitem>
<listitem>
<simpara>IpPower9258 (RebootDevice)</simpara>
</listitem>
<listitem>
<simpara>SerialPort (WaitforBootOnStartAndFault)</simpara>
</listitem>
<listitem>
<simpara>SerialPort (WaitForBootAfterFault)</simpara>
</listitem>
<listitem>
<simpara>TcpPort (VerifyDeviceAlive)</simpara>
</listitem>
<listitem>
<simpara>NetworkCapture (InterestingPackets)</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="_ippower9258_bootdevice">
<title>IpPower9258 (BootDevice)</title>
<simpara>The <link linkend="Monitors_IpPower9258">IpPower 9258 Monitor</link> controls the IpPower 9258 device to start the network device at the beginning of the fuzzing session.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/UserGuide/Recipes/NetworkDevice_IpPower9258_Boot.png" scale="50"/>
</imageobject>
<textobject><phrase>NetworkDevice IpPower9258 Boot</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>h
The <emphasis role="strong">Port</emphasis> parameter identifies the receptacle of the IpPower9258 device. Numbers range
from 1 to 4. Receptacle 1 is the leftmost receptacle.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/UserGuide/Recipes/NetworkDevice_IpPower9258_RearPanel.png" scale="50"/>
</imageobject>
<textobject><phrase>NetworkDevice IpPower9258 RearPanel</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>The <emphasis role="strong">When</emphasis> parameter "OnStart" identifies that the power cycle occurs at the start of
the fuzzing session.</simpara>
</section>
<section xml:id="_ippower9258_rebootdevice">
<title>IpPower9258 (RebootDevice)</title>
<simpara>The second <link linkend="Monitors_IpPower9258">IpPower 9258 Monitor</link> controls the IpPower 9258 device to recycle power, ensuring that the network device starts in a clean state following a fault.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/UserGuide/Recipes/NetworkDevice_IpPower9258_Reboot.png" scale="50"/>
</imageobject>
<textobject><phrase>NetworkDevice IpPower9258 Reboot</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>The <emphasis role="strong">Port</emphasis> parameter identifies the receptacle of the IpPower9258 device. Numbers range from 1 to 4. Receptacle 1 is the leftmost receptacle.</simpara>
<simpara>The <emphasis role="strong">When</emphasis> parameter "OnIterationStartAfterFault" identifies that the the power cycle occurs at the start of the test case that immediately follows a fault.</simpara>
</section>
<section xml:id="_serial_port_waitforbootonstartandfault">
<title>Serial Port (WaitforBootOnStartAndFault)</title>
<simpara>This <link linkend="Monitors_Serial">Serial Port Monitor</link> addresses two configuration settings:
one automation setting and one fault detection setting. The automation setting causes
Peach to wait for the device to complete its boot processing before starting the
fuzzing session. The fault detection setting causes peach to monitor the console
for messages that indicate a fault occurred on the device.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/UserGuide/Recipes/NetworkDevice_Serial_OnStart.png" scale="50"/>
</imageobject>
<textobject><phrase>NetworkDevice Serial OnStart</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>The <emphasis role="strong">Port</emphasis> parameter identifies the serial port on the computer that receives monitoring.</simpara>
<itemizedlist>
<listitem>
<simpara>In Windows, the port map is accessible from the Device Manager located in the
Control Panel\System applet. In the illustration, the value is <literal>COM1</literal>.</simpara>
</listitem>
<listitem>
<simpara>In Linux and OS X systems the port map is accessible with the following command:
<literal>dmesg | grep tty</literal>. Specify the value of the appropriate port, such as <literal>tty0</literal>.</simpara>
</listitem>
</itemizedlist>
<simpara>The <emphasis role="strong">Fault Regex</emphasis> <literal>(CRITICAL | ERROR | ASSERT | CRASH)</literal> identifies words that indicate
a fault occurred. When the monitor encounters any word of a message that matches any word
in the regular expression, Peach issues a fault.</simpara>
<simpara>The <emphasis role="strong">Wait When</emphasis> and <emphasis role="strong">Wait Regex</emphasis> parameters are automation oriented. <emphasis role="strong">Wait When</emphasis> identifies
when peach should enter a waiting state. The value <literal>OnStart</literal> identifies that the waiting
period is when the test target goes through the boot process at the beginning of
the fuzzing session. The <emphasis role="strong">Wait Regex</emphasis> identifies the message text that the monitor looks
to match. Here, the value is <literal>Bootup Completed</literal>. Peach waits until this message appears
to begin fuzzing the target.</simpara>
<note>
<simpara>The regular expressions used with this monitor are used to identify faults
that have occurred in the device. You will need to construct the regular expression
to watch for key word(s) in the error message text. Consult the device documentation
or an expert of the test device for the message content.</simpara>
</note>
</section>
<section xml:id="_serial_port_monitor_waitforbootafterfault">
<title>Serial Port Monitor (WaitForBootAfterFault)</title>
<simpara>This second instance of the <link linkend="Monitors_Serial">Serial Port Monitor</link> addresses
resumption of a fuzzing session after a fault.</simpara>
<simpara>When a fault occurs, the IpPower9258 recycles the power causing the network device to
reboot. Then, this monitor causes Peach to wait until the network device completes its
boot process and becomes available for use before resuming the current fuzzing session.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/UserGuide/Recipes/NetworkDevice_Serial_AfterFault.png" scale="50"/>
</imageobject>
<textobject><phrase>NetworkDevice Serial AfterFault</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>The <emphasis role="strong">Port</emphasis> parameter identifies the serial port on the computer that receives monitoring.
Since only one serial port is in this fuzzing setup, the value should be identical with
the value for the WaitforBootOnStartAndFault monitor.</simpara>
<simpara>The <emphasis role="strong">Wait When</emphasis> and <emphasis role="strong">Wait Regex</emphasis> parameters identify when Peach should enter a waiting
state. The <emphasis role="strong">Wait When</emphasis> value <literal>OnIterationStartAfterFault</literal> identifies that the waiting
period follows each fault occurrence. The <emphasis role="strong">Wait Regex</emphasis> identifies the message text that
the monitor looks to match. Here, the value is <literal>Bootup Completed</literal>. Peach waits until
this message appears to resume the fuzzing session in progress.</simpara>
<note>
<simpara>The regular expressions used with this monitor are used to identify conditions
that have occurred in the device. You will need to construct the regular expression
to watch for key word(s) in the error message text. Consult the device documentation
or an expert of the test device for the message content.</simpara>
</note>
</section>
<section xml:id="_tcpport_verifydevicealive">
<title>TcpPort (VerifyDeviceAlive)</title>
<simpara>The <link linkend="Monitors_TcpPort">TcpPort Monitor</link> periodically checks two things when the
State Model issues a <literal>Call</literal> event during a test case:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>The state of a TCP port on the target.</simpara>
</listitem>
<listitem>
<simpara>The state of the service or protocol on the target, that uses the same TCP port
on the target.</simpara>
</listitem>
</orderedlist>
<simpara>If the status of the port is <literal>Closed</literal>, Peach reports an error.</simpara>
<tip>
<simpara>The TcpPort monitor can be used when the target runs TCP. When testing other
protocols,  use the Ping monitor instead to see whether the device as a whole
is responding.</simpara>
</tip>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/UserGuide/Recipes/NetworkDevice_TcpPort.png" scale="50"/>
</imageobject>
<textobject><phrase>NetworkDevice TcpPort</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>The <emphasis role="strong">Host</emphasis> parameter specifies the hostname of the target or the IPv4 address of the
target. The <literal>##TargetIPv4##</literal> value is a configuration variable that you set to identify
the target. Its operation is similar to operating system environment variables.
For more information, see Variables.</simpara>
<simpara>The <emphasis role="strong">Port</emphasis> value should be set to the appropriate port number of the target device
used by the service under test. In this example, the service is using TCP on port 80
of the network device.</simpara>
<simpara>For example, some common port values follow: HTTP uses port 80; SSH uses port 22; and,
FTP uses port 21.</simpara>
<simpara>The <emphasis role="strong">Action</emphasis> parameter specifies the type of action that the monitor performs. Here,
the value used is <literal>Fault</literal>;  and causes the monitor to report a fault when the TCP
port is closed and unresponsive.</simpara>
<simpara>The <emphasis role="strong">State</emphasis> parameter specifies the fault condition. The value <literal>Closed</literal> indicates a
fault occurs when the communication channel changes to <literal>Closed</literal>.</simpara>
</section>
<section xml:id="_networkcapture_interestingpackets">
<title>NetworkCapture (InterestingPackets)</title>
<simpara>The <link linkend="Monitors_NetworkCapture">NetworkCapture Monitor</link> captures network traffic (packets) sent and
received from the test target.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/UserGuide/Recipes/NetworkDevice_NetworkCapture.png" scale="50"/>
</imageobject>
<textobject><phrase>NetworkDevice NetworkCapture</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>The <emphasis role="strong">Device</emphasis> parameter specifies the hostname of the target or the IPv4 address of the
target. The value given is <literal>eth0</literal>.</simpara>
<simpara>The <emphasis role="strong">Filter</emphasis> parameter is a capture filter (Berkeley Packet Syntax filter used by
Libpcap) that limits the network packets under consideration to those packets that
match the specified filter. The packets that match the filter are captured from the
wire as they arrive or leave the test target.</simpara>
<simpara>Here, the the filter consists of the hostname combined with the TCP port number of
the test target. As previously mentioned, <literal>port 80</literal> is the test target TCP port number.</simpara>
<tip>
<simpara>WireShark refers to the Libpcap filters as capture filters. Use the capture
filters. Wireshark also defines its own display filters that it uses to filter
entries in its session files. The display filters are not compatible with Libpcap.</simpara>
</tip>
</section>
</section>
</section>
<section xml:id="Recipe_WindowsNetClient">
<title>Recipe: Monitoring a Windows Network Service Client</title>
<simpara>This recipe describes the base setup needed to fuzz a client of a Windows network service.
When fuzzing a network client, Peach impersonates the network service, the other endpoint of the network connection.</simpara>
<simpara>The recipe is a model that you can follow closely. Or, use the model as
a starting point and augment the model for your specific situation. This recipe
consists of the following parts:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>The workflow for the fuzzing session</simpara>
</listitem>
<listitem>
<simpara>The Peach components to use in configuring the fuzzing setup
This section focuses on the monitoring needs and the agents that house the monitors.</simpara>
</listitem>
<listitem>
<simpara>Configuration settings used to fuzz a service client running this workflow</simpara>
</listitem>
</orderedlist>
<important>
<simpara>Assumptions/Givens in this recipe are that a Pit is ready to use, Peach is ready to run, and any software module needed to perform the fuzzing job is installed.</simpara>
</important>
<section xml:id="_workflow_for_the_fuzzing_session_3">
<title>Workflow for the Fuzzing Session</title>
<simpara>The workflow lists the task sequence that occurs when running the fuzzing session.
The setup needed to implement the workflow follows in the next section. Start with
defining the workflow, especially if you plan to embellish the recipe.</simpara>
<simpara>Here is the workflow that Peach performs in fuzzing a Windows network service client:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Revert to a virtual machine snapshot.</simpara>
</listitem>
<listitem>
<simpara>Wait for the machine to boot up.</simpara>
</listitem>
<listitem>
<simpara>Perform fuzzing. Create and run test cases.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Peach launches the network client. The client initiates contact with the server and sends requests to the server.</simpara>
</listitem>
<listitem>
<simpara>Peach impersonates the server and replies to client queries. Query responses contain fuzzed data.</simpara>
</listitem>
<listitem>
<simpara>Perform fault detection on the client.</simpara>
</listitem>
<listitem>
<simpara>If a fault occurs, collect data surrounding the test case.</simpara>
</listitem>
<listitem>
<simpara>Revert to the VM snapshot.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Loop to step three (resume fuzzing).</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="_peach_components_needed_in_the_fuzzing_configuration_3">
<title>Peach Components Needed in the Fuzzing Configuration</title>
<simpara>Defining the Peach components divides in two parts: identifying the monitors to use in the configuration and identifying where to locate the specified monitors.</simpara>
<section xml:id="_identifying_monitors_3">
<title>Identifying Monitors</title>
<simpara>This part of the recipe revisits each step of the workflow to identify the monitors needed to implement the configuration:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Revert to a snapshot of a virtual machine.</simpara>
<simpara>Peach needs to automate the test environment and remove human interaction during the fuzzing job. We place the service in a virtual machine (VM) because Peach can use a VM monitor to automatically start and reset the test environment when needed.</simpara>
<simpara>The VM snapshot is taken while the guest OS and the Peach agent are running. Using such a snapshot avoids the wait time associated with booting up the virtual machine. Also, the same snapshot is used when Peach refreshes the test environment after a fault occurs.</simpara>
<simpara>The monitor for the VM environment, <link linkend="Monitors_Vmware">VMware</link> monitor, resides on the host machine.</simpara>
</listitem>
<listitem>
<simpara>Wait for the machine to boot up.</simpara>
<simpara>Peach waits for the VM snapshot to resume.</simpara>
</listitem>
<listitem>
<simpara>Perform fuzzing, checking for faults.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Launch the network client.</simpara>
<simpara>The Peach agent launches the client service through the Windows debugger. The client submits requests from the remote machine. The debugger and the client both reside on the remote machine.</simpara>
<literallayout class="monospaced">NOTE: The PageHeap monitor complements the WindowsDebugger monitor by allowing in-depth heap analysis.</literallayout>
</listitem>
<listitem>
<simpara>Reply to the client request with fuzzed data.</simpara>
<simpara>Peach impersonates the network server and sends fuzzed replies in response to client queries.</simpara>
</listitem>
<listitem>
<simpara>Perform fault detection in the VM.</simpara>
<simpara>The WindowsDebugger monitor watches the internals of the services and detects faults such as access violations and exceptions. Again, the debug monitor is located on the same machine as the service.</simpara>
</listitem>
<listitem>
<simpara>Collect data surrounding each fault as it happens.</simpara>
<simpara>When a fault occurs, the packets involved with the fault are interesting. Peach captures the packets using a network capture monitor. This monitor resides on the local machine with Peach Fuzzer.</simpara>
</listitem>
<listitem>
<simpara>Revert to the VM snapshot.</simpara>
<simpara>This step uses the VM monitor and VM snapshot from step one to refresh the test
environment, and the debug monitor from step three to start the network service in
the refreshed environment. No additional monitors are needed for this step.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Resume fuzzing.</simpara>
<simpara>Loop to step three, perform fuzzing.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="_identifying_agents_3">
<title>Identifying Agents</title>
<simpara>Peach offers two types of agents to manage monitors and I/O publishers: local and remote.</simpara>
<itemizedlist>
<listitem>
<simpara>Local agents reside inside Peach.<?asciidoc-br?>
The local agent in this recipe addresses automation involving the VM and
data collection that captures network packets. The local agent houses the
<link linkend="Monitors_Vmware">VMware</link> and the <link linkend="Monitors_NetworkCapture">NetworkCapture</link> monitors.</simpara>
<simpara>The VMware monitor starts a snapshot VM environment at the beginning of the
fuzzing job, as well as restarting the same VM snapshot after a fault occurs.</simpara>
</listitem>
<listitem>
<simpara>Remote agents reside in separate processes on remote machines with the test targets.<?asciidoc-br?>
In this case, the remote agent and the Windows service client reside on the same machine.</simpara>
<simpara>The remote agent houses the <link linkend="Monitors_PageHeap">PageHeap</link> and the  <link linkend="Monitors_WindowsDebugger">WindowsDebugger</link> monitors
that start the Windows service client at the beginning of the fuzzing job and
restart the service in the refreshed environment after a fault. The WindowsDebugger monitor detects faults that occur in the client.</simpara>
</listitem>
</itemizedlist>
<simpara>The result is that we end up with the following configuration:</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/UserGuide/Recipes/VM_Remote_Agent.png" scale="50"/>
</imageobject>
<textobject><phrase>VM Remote Agent</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Peach is located on one machine with a local agent that houses the VM monitor and the Network capture monitor. A second agent resides on the remote machine with the service. The remote agent houses the PageHeap and WindowsDebugger monitors.</simpara>
<simpara>The local agent is simple to implement. All that&#8217;s needed is to define the agent, then specify the appropriate monitors and monitor settings used with the local agent.</simpara>
<simpara>The remote monitor is a little more involved. Like the local agent, the remote agent needs to be defined, then specify the appropriate monitors and monitor settings used with the remote agent. Second, the remote agent needs to run on the same OS as the test target. This step can be done separately from specifying the configuration details. In this recipe, a VM snapshot is used. See <link linkend="VM_Setup">Using Virtual Machines</link>, for information on setting up the VM snapshot.</simpara>
</section>
</section>
<section xml:id="_sample_network_client_configuration_2">
<title>Sample Network Client Configuration</title>
<simpara>This section shows the recipe implemented for a Windows network service client and consists of the following items:</simpara>
<itemizedlist>
<listitem>
<simpara>Setup on the Target VM Image</simpara>
</listitem>
<listitem>
<simpara>Pit variables</simpara>
</listitem>
<listitem>
<simpara>Peach agents</simpara>
</listitem>
<listitem>
<simpara>Peach monitors</simpara>
</listitem>
<listitem>
<simpara>Debug monitor "No Cpu Kill" parameter</simpara>
</listitem>
<listitem>
<simpara>Configuration test</simpara>
</listitem>
</itemizedlist>
<note>
<simpara>The configurations for the network client and the network service are very similar. Two significant differences exist:</simpara>
<itemizedlist>
<listitem>
<simpara>The network client configuration uses a client application instead of the network service.</simpara>
</listitem>
<listitem>
<simpara>In the network client configuration, the test target initiates the action instead of
responding to a request. The client contacts Peach, a surrogate network service, then waits for Peach to provide a response to the query. The debug monitor has additional configuration options that are set to drive this configuration.</simpara>
</listitem>
</itemizedlist>
</note>
<section xml:id="_setup_on_the_target_vm_image_3">
<title>Setup on the Target VM Image</title>
<simpara>Perform the following task on the VM before taking a snapshot of the VM.</simpara>
<itemizedlist>
<listitem>
<simpara>Run the Peach agent from a command processor as an administrator.<?asciidoc-br?>
Within the command processor, navigate to the peach folder and execute the following command:<?asciidoc-br?>
<literal>peach -a tcp</literal><?asciidoc-br?>
When Peach starts the VM, the Peach agent is running in a root shell.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="_pit_variables_3">
<title>Pit Variables</title>
<simpara>The following UI display identifies data values typically needed by a network
protocol Pit. The variables and values are independent of the monitors used in
the configuration. Pit variables are unique to the Pit and might differ with those
in the example illustration.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/UserGuide/Recipes/WindowsNetClient_PitVars.png" scale="50"/>
</imageobject>
<textobject><phrase>WindowsNetClient PitVars</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>The Pit User Guides describe the Pit-specific variables.</simpara>
<variablelist>
<varlistentry>
<term>Community String (Authentication)</term>
<listitem>
<simpara>Community string used for authentication. Peach and the network client must use the same community string. Check the server documentation for consistency of this value. If needed, change the value here to coincide with the value expected by the test target.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Source Port</term>
<listitem>
<simpara>Port number of the local machine that sends packets to the server. Several services use well-known ports that usually can be left unedited.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Target IPv4 Address</term>
<listitem>
<simpara>IPv4 address of the target machine (client). For information on obtaining the IPv4 address, see Retrieving Machine Information section of the Pit User Guide.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Target Port</term>
<listitem>
<simpara>SNMP port number of the remote machine that sends and receives packets. Several services use well-known ports that usually can be left unedited.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Timeout</term>
<listitem>
<simpara>Duration, in milliseconds, to wait for incoming data. During fuzzing, a timeout failure causes the fuzzer to skip to the next test case.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_agents_3">
<title>Agents</title>
<simpara>The following UI diagram acts as an overview, showing the Peach agents and the monitors within each agent. Peach uses the ordering within the agent to determine the order in which to load and run monitors.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/UserGuide/Recipes/WindowsNetClient_Agents.png" scale="50"/>
</imageobject>
<textobject><phrase>WindowsNetClient Agents</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>The local agent is defined first and lists the default information for both name and location. This definition for a local agent is typical and, otherwise, unremarkable. The NetworkCapture and Vmware monitors are independent of one another, allowing either monitor to top the list.</simpara>
<simpara>The remote agent, named "Remote Client Manager", has quite a different location specification. The location consists of concatenated pieces of information:</simpara>
<itemizedlist>
<listitem>
<simpara>Channel. The channel for a remote agent is <literal>tcp</literal>. A colon and two forward slashes separate the channel from the IPv4 address of the hardware interface.</simpara>
</listitem>
<listitem>
<simpara>Target IPv4 address of the remote machine. The IPv4 address of the agent is the second component of the location.  For more information, see the Retrieving Machine Information section of the <emphasis role="strong">SNMP Peach Pit User Guide</emphasis>.</simpara>
</listitem>
</itemizedlist>
<simpara>The monitor list within each agent is significant, as the monitors are launched in order from top to bottom within an agent.</simpara>
</section>
<section xml:id="_monitors_3">
<title>Monitors</title>
<simpara>This recipe uses four monitors, two on the machine with Peach and two on the remote machine. The recipe shows each monitor and describes its roles: fault detection, data collection, and automation.</simpara>
<section xml:id="_vmware_remote_client_manager_2">
<title>Vmware (Remote Client Manager)</title>
<simpara>The <link linkend="Monitors_Vmware">Vmware</link> monitor controls setting up and starting the virtual machine.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/UserGuide/Recipes/WindowsNetClient_Vmware.png" scale="50"/>
</imageobject>
<textobject><phrase>WindowsNetClient Vmware</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>The most significant parameters for the VMware monitor follow:</simpara>
<variablelist>
<varlistentry>
<term>Vmx</term>
<listitem>
<simpara>Identifies the full path of the virtual machine image. Peach loads the
snapshot of the VM image at the start of the fuzzing job and after a fault occurs.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Headless</term>
<listitem>
<simpara>Specifies whether the VM connects to a viewing window in the VMware
window. When developing a configuration, set this parameter to false. When
performing a fuzzing job, the setting doesn&#8217;t matter.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Host Type</term>
<listitem>
<simpara>Specifies the VMWare product used in the configuration.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Snapshot Name</term>
<listitem>
<simpara>Identifies the snapshot to use for the specific image.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
</section>
<section xml:id="_network_capture_interestingpackets_3">
<title>Network Capture (InterestingPackets)</title>
<simpara>The <link linkend="Monitors_NetworkCapture">Netowrk Capture Monitor</link> (InterestingPackets) captures network packets
sent and received from the test target. When a fault occurs, Peach stores the packets immediately surrounding the fault in the log of the test case.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/UserGuide/Recipes/WindowsNetClient_NetworkCapture.png" scale="50"/>
</imageobject>
<textobject><phrase>WindowsNetClient NetworkCapture</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>The most signification parameters for the network capture monitor follow:</simpara>
<variablelist>
<varlistentry>
<term>Device</term>
<listitem>
<simpara>Specifies the name of the interface on the local machine (the machine with
Peach) used to communicate with the test target. Use <literal>ipconfig –all</literal> to identify the
interface(s) available for use.</simpara>
</listitem>
</varlistentry>
</variablelist>
<note>
<simpara>You can find the appropriate host interface that communicates with the VM using the following steps:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Collect a list of interfaces (and their IPv4 addresses) by running <literal>ipconfig</literal>.</simpara>
</listitem>
<listitem>
<simpara>Test each interface in the list. Manually run a capture session with Wireshark using an interface from the list.</simpara>
</listitem>
<listitem>
<simpara>On the host machine, Ping the target IPv4 (of the VM).</simpara>
</listitem>
<listitem>
<simpara>If the correct interface of the host is used, you&#8217;ll see the Ping request and reply packet exchanges through Wireshark,</simpara>
</listitem>
<listitem>
<simpara>Loop to step 2 and repeat, using another interface.</simpara>
</listitem>
</orderedlist>
</note>
<variablelist>
<varlistentry>
<term>Filter</term>
<listitem>
<simpara>The packet filter helps capture only those packets associated with the
fuzzing session. The filter adheres to the syntax and requirements of the Pcap
filter specification.</simpara>
</listitem>
</varlistentry>
</variablelist>
<tip>
<simpara>WireShark refers to the Libpcap filters as capture filters. Use the capture filters in Peach. Wireshark also defines its own display filters that it uses to filter entries in its
session files. The display filters are not compatible with Libpcap.</simpara>
</tip>
</section>
<section xml:id="_pageheap">
<title>PageHeap</title>
<simpara>The <link linkend="Monitors_PageHeap">PageHeap</link> monitor manages registry settings that enables the Windows debugger to perform heap analysis. This monitor sets the appropriate registry values at the start of a fuzzing session and clears them at the session&#8217;s end. The monitor is housed by the remote agent.</simpara>
<note>
<simpara>PageHeap requires administrative privileges to run correctly.</simpara>
</note>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/UserGuide/Recipes/WindowsNetClient_PageHeap.png" scale="50"/>
</imageobject>
<textobject><phrase>WindowsNetClient PageHeap</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>The most significant parameter follows:</simpara>
<variablelist>
<varlistentry>
<term>Executable</term>
<listitem>
<simpara>Specifies the file name and file extension of the test target.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_windowsdebugger">
<title>WindowsDebugger</title>
<simpara>The <link linkend="Monitors_WindowsDebugger">WindowsDebugger</link> debugger monitor performs two main functions in this recipe:</simpara>
<itemizedlist>
<listitem>
<simpara>Starts the network client at the start of a fuzzing job and restarts the client when the VM snapshot refreshes.</simpara>
</listitem>
<listitem>
<simpara>Detects faults internal to the client.</simpara>
</listitem>
</itemizedlist>
<simpara>The WindowsDebugger monitor uses the settings in the following illustration:</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/UserGuide/Recipes/WindowsNetClient_WinDebugger.png" scale="50"/>
</imageobject>
<textobject><phrase>WindowsNetClient WinDebugger</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>The most significant parameters follow:</simpara>
<variablelist>
<varlistentry>
<term>Executable</term>
<listitem>
<simpara>Identifies the full path to the Windows service client. The client
resides on the remote machine; so, the full path is for the Windows file system.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Arguments</term>
<listitem>
<simpara>Arguments for the executable.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>No Cpu Kill</term>
<listitem>
<simpara>Controls whether the process stays alive if its CPU usage drops to zero. Specify <literal>true</literal> to keep the process running and to allow the process to release or close its resources before exiting. For more information, see the following section <emphasis>Closing the Client Process</emphasis>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Start On Call</term>
<listitem>
<simpara>Controls when the test target launches, and in turn, initiates contact with the service (Peach). Specify <literal>StartIterationEvent</literal> to launch the client at the start of the test case.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
</section>
<section xml:id="_closing_the_client_process_2">
<title>Closing the Client Process</title>
<simpara>In this recipe, Peach launches the network service client using the "Start On Call" parameter so that the client initiates contact with the server. Then, at the end of the test case after execution complete, the "No Cpu Kill" parameter provides control of how the client closes:</simpara>
<itemizedlist>
<listitem>
<simpara>If "No Cpu Kill" is <literal>true</literal>, Peach waits for the process to exit OR for a time to elapse specified by the "Wait For Exit Timeout" parameter.</simpara>
</listitem>
<listitem>
<simpara>If "No Cpu Kill" is <literal>false</literal>, Peach waits for the CPU usage of the process to reach zero percent OR for the process to exit OR for a time to elapse specified by the "Wait For Exit Timeout" parameter. The "No Cpu Kill" parameter default setting is <literal>false</literal>.</simpara>
</listitem>
</itemizedlist>
<note>
<simpara>If the waiting period ends, peach kills the target process if it is still running and starts the next iteration.</simpara>
</note>
<simpara>So, when do you need to let a process with zero CPU activity continue to execute?</simpara>
<simpara>Set "No Cpu Kill" to <literal>true</literal> when you&#8217;re fuzzing a network service client. In this scenario, Peach Fuzzer starts the network client using the "Start on Call" parameter to initiate contact with the service. When the client receives and processes the reply, Peach waits for the client to run to completion and watches for any faults that occur before the client exits.</simpara>
<simpara>Scenarios exempt from the "No Cpu Kill" option include the following:</simpara>
<itemizedlist>
<listitem>
<simpara>Fuzzing network service servers typically do not use the "Start On Call" option, so the "No Cpu Kill" option isn&#8217;t needed.</simpara>
</listitem>
<listitem>
<simpara>Fuzzing file formats require "Start on Call" to start the fuzzing target once the fuzzed data file is generated. The "No Cpu Kill" parameter can be used here; however, Peach can save time that will be replicated in each test case by letting the process terminate if the CPU usage falls to zero. In this case, not using "No Cpu Kill" is a performance optimization.</simpara>
</listitem>
<listitem>
<simpara>Embedded devices. Fuzzing configurations for these devices do not use the Peach debugging monitors: GDB, WindowsDebugger, or CrashWrangler. So, the "No Cpu Kill" option isn&#8217;t needed.</simpara>
</listitem>
<listitem>
<simpara>Kernel-mode debugging. Kernel-mode debugging has its own set of requirements. "No Cpu Kill" is not used here.</simpara>
</listitem>
</itemizedlist>
<section xml:id="_configuration_test_3">
<title>Configuration Test</title>
<simpara>Once the monitors and associated parameters are part of the configuration, you can test the configuration. From the Configuration menu along the left edge of the window, click on <literal>Test</literal> to run a single iteration (test case) on the configuration. Note that the test checks the connections and communications. It does NOT do any fuzzing.</simpara>
<simpara>For more information on testing a configuration, see <link linkend="Test_PitConfiguration">Test Pit Configuration</link>.</simpara>
</section>
</section>
</section>
<section xml:id="Recipe_WindowsNetServer">
<title>Recipe: Monitoring a Windows Network Service</title>
<simpara>This recipe describes the base setup needed to fuzz a Windows network service. The recipe is a model that you can follow exactly as is. Or, you can use the model as
a starting point and augment the model for your specific situation. This recipe
consists of the following parts:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>The workflow for the fuzzing session</simpara>
</listitem>
<listitem>
<simpara>The Peach monitoring and agent components to use in configuring the fuzzing setup</simpara>
</listitem>
<listitem>
<simpara>Configuration settings used to fuzz a sample service running this workflow</simpara>
</listitem>
</orderedlist>
<important>
<simpara>Assumptions/Givens in this recipe are that a Pit is ready to use; Peach is ready to run; and any software module needed to perform the fuzzing job is installed.</simpara>
</important>
<simpara>In this scenario, Peach runs on a host computer; the network server runs in a
Virtual Machine (VM) on the host. With Peach running on the host, it controls the
environment. If the network server crashes, the worst thing that happens is that
the virtual machine has to restart. Peach recovers the data if the network
server crashes.</simpara>
<section xml:id="_workflow_for_the_fuzzing_session_4">
<title>Workflow for the Fuzzing Session</title>
<simpara>The workflow lists the task sequence that occurs when running the fuzzing session.
The setup needed to implement the workflow follows in the next section. Start with
defining the workflow, especially if you plan to embellish the recipe.</simpara>
<simpara>Here is the workflow that Peach performs in fuzzing a Windows network service:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Revert to a virtual machine snapshot.</simpara>
</listitem>
<listitem>
<simpara>Wait for the machine to boot up.</simpara>
</listitem>
<listitem>
<simpara>Launch the network service.</simpara>
</listitem>
<listitem>
<simpara>Perform fuzzing. Create and run test cases.</simpara>
<itemizedlist>
<listitem>
<simpara>Peach initiates contact with the server and sends packets of fuzzed data to the server.</simpara>
</listitem>
<listitem>
<simpara>Check for faults, such as crashes and access violations.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>When a fault occurs, do the following:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Collect data surrounding the test case.</simpara>
</listitem>
<listitem>
<simpara>Revert to the VM snapshot.</simpara>
</listitem>
<listitem>
<simpara>Launch the network service.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Loop to step 4 (resume fuzzing).</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="_peach_components_needed_in_the_fuzzing_configuration_4">
<title>Peach Components Needed in the Fuzzing Configuration</title>
<simpara>Defining the Peach components divides in two parts: identifying the monitors to use in the configuration and identifying where to locate the specified monitors.</simpara>
<section xml:id="_identifying_monitors_4">
<title>Identifying Monitors</title>
<simpara>This part of the recipe revisits each step of the workflow to identify the monitors needed to implement the configuration:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Revert to a snapshot of a virtual machine.</simpara>
<simpara>Peach needs to automate the test environment and remove human interaction during the fuzzing job. We place the service in a virtual machine (VM) because Peach can use a VM monitor to automatically start and reset the test environment when needed.</simpara>
<simpara>The VM snapshot is taken while the guest OS and the Peach agent are running. Using such a snapshot avoids the wait time associated with booting up the virtual machine. Also, the same snapshot is used when Peach refreshes the test environment after a fault occurs.</simpara>
<simpara>The monitor for the VM environment, <link linkend="Monitors_Vmware">VMware</link> monitor, resides on the host machine.</simpara>
</listitem>
<listitem>
<simpara>Wait for the machine to boot up.</simpara>
<simpara>Peach waits for the VM snapshot to resume.</simpara>
</listitem>
<listitem>
<simpara>Launch the network service.</simpara>
<simpara>In Windows, Peach needs to explicitly launch the network service when PageHeap and the Windows debugger are used. The <link linkend="Monitors_WindowsService">WindowsService</link> monitor manages the service on the remote machine with the test target.</simpara>
</listitem>
<listitem>
<simpara>Perform fuzzing, checking for faults.</simpara>
<simpara>Perform fault detection in the VM. The <link linkend="Monitors_WindowsDebugger">WindowsDebugger</link> monitor watches the internals of the services and detects faults such as access violations and exceptions.</simpara>
<simpara>The <link linkend="Monitors_PageHeap">PageHeap</link> monitor complements the Windows debugger by enabling heap analysis in the debugger.</simpara>
<simpara>Both monitors run on the remote machine with the test target.</simpara>
</listitem>
<listitem>
<simpara>Collect data surrounding each fault as it happens.</simpara>
<simpara>Peach sends and receives network packets to the service. When a fault occurs, the packets involved with the fault are interesting. Peach captures the packets using the <link linkend="Monitors_NetworkCapture">NetworkCapture</link> monitor. This monitor resides on the local machine with Peach Fuzzer.</simpara>
</listitem>
<listitem>
<simpara>Resume fuzzing.</simpara>
<simpara>This step uses the VM monitor and VM snapshot from step 1 to refresh the test environment, and the WindowsService monitor from step 3 to start the network service in the refreshed environment. No additional monitors are needed for this step.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="_identifying_agents_4">
<title>Identifying Agents</title>
<simpara>Peach offers two types of agents to manage monitors and I/O publishers: local and remote.</simpara>
<itemizedlist>
<listitem>
<simpara>Local agents reside inside Peach.<?asciidoc-br?>
The local agent in this recipe addresses automation involving the VM and data collection
that captures network packets. The local agent houses the <link linkend="Monitors_Vmware">VMware</link>
 and the <link linkend="Monitors_NetworkCapture">NetworkCapture</link> monitors.</simpara>
<simpara>The VMware monitor starts a snapshot VM environment at the beginning of the fuzzing job,
as well as restarting the same VM snapshot after a fault occurs.</simpara>
</listitem>
<listitem>
<simpara>Remote agents reside in separate processes on remote machines with the test targets.<?asciidoc-br?>
In this case, the remote agent and the Windows service reside on the same machine.</simpara>
<simpara>The remote agent houses the <link linkend="Monitors_WindowsService">WindowsService</link>, the <link linkend="Monitors_PageHeap">PageHeap</link>, and the <link linkend="Monitors_WindowsDebugger">WindowsDebugger</link> monitors.</simpara>
<itemizedlist>
<listitem>
<simpara>The <link linkend="Monitors_WindowsService">WindowsService</link> monitor starts the network service at the beginning of the fuzzing job and restarts the service in the refreshed environment after a fault.</simpara>
</listitem>
<listitem>
<simpara>The <link linkend="Monitors_PageHeap">PageHeap</link> monitor manages registry settings at the beginning and the end of a fuzzing session, that in turn enables heap memory analysis by the debugger.</simpara>
</listitem>
<listitem>
<simpara>The <link linkend="Monitors_WindowsDebugger">WindowsDebugger</link> monitor detects faults that occur in the service.</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
<simpara>The result is that we end up with the following configuration:</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/UserGuide/Recipes/VM_Remote_Agent.png" scale="50"/>
</imageobject>
<textobject><phrase>VM Remote Agent</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Peach is located on one machine with a local agent that houses the VM monitor and the Network capture monitor. A second agent resides on the remote machine with the service. The remote agent houses the PageHeap, the WindowsDebugger, and the WindowsService monitors.</simpara>
<simpara>The local agent is simple to implement. All that&#8217;s needed is to define the agent, then specify the appropriate monitors and monitor settings used with the local agent.</simpara>
<simpara>The remote monitor is a little more involved. Like the local agent, the remote agent needs to be defined, then specify the appropriate monitors and monitor settings used with the remote agent. Second, the remote agent needs to run on the same OS as the test target. This step can be done separately from specifying the configuration details. In this recipe, a VM snapshot is used. See the appendix, Using Virtual Machines, for information on setting up the VM snapshot.</simpara>
</section>
</section>
<section xml:id="_sample_windows_service_configuration">
<title>Sample Windows Service Configuration</title>
<simpara>This section shows the recipe implemented for a Windows network service and consists of the following items:</simpara>
<itemizedlist>
<listitem>
<simpara>Setup on the Target VM Image</simpara>
</listitem>
<listitem>
<simpara>Settings for the service on the Windows VM</simpara>
</listitem>
<listitem>
<simpara>Pit variables</simpara>
</listitem>
<listitem>
<simpara>Peach agents</simpara>
</listitem>
<listitem>
<simpara>Peach monitors</simpara>
</listitem>
<listitem>
<simpara>Configuration Test</simpara>
</listitem>
</itemizedlist>
<section xml:id="_setup_on_the_target_vm_image_4">
<title>Setup on the Target VM Image</title>
<simpara>Perform the following items on the VM before taking a snapshot of the VM.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Run the Peach agent from a command processor with administrative access.<?asciidoc-br?>
Within the command processor, navigate to the peach folder and execute the following command:<?asciidoc-br?>
<literal>peach -a tcp</literal><?asciidoc-br?>
When Peach starts the VM, the Peach agent is running in a root shell.<?asciidoc-br?></simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="_windows_service_setup">
<title>Windows Service Setup</title>
<simpara>The sample configuration uses a Windows network service as the fuzzing target. Some services are included with Windows; but, might be turned off. Other services are either custom or available on the Web.</simpara>
<simpara>Use the following steps to ensure a service is ready for use:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>From the Windows Start button, right-click “Computer”, then select “Manage” from the shortcut menu.</simpara>
</listitem>
<listitem>
<simpara>Expand the “Services and Applications” entry in the Computer Management pane.</simpara>
</listitem>
<listitem>
<simpara>Double-click “Services”.</simpara>
</listitem>
<listitem>
<simpara>Search for the Service you are targeting.</simpara>
</listitem>
<listitem>
<simpara>If the status is not “Stopped”, right-click the service name and choose “Stop”.</simpara>
</listitem>
</orderedlist>
<simpara>Some properties of the service need to be configured to use the service. Right click on the Service entry to display its properties and adjust the necessary settings in the dialog.</simpara>
<simpara>The following action is performed on the local system.</simpara>
<itemizedlist>
<listitem>
<simpara>Allow access to run the service through the firewall on the local system.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="_pit_variables_4">
<title>Pit Variables</title>
<simpara>The following UI display identifies data values typically needed by a network
protocol Pit. The variables and values are independent of the monitors used in
the configuration. Pit variables are unique to the Pit and might differ with those
in the example illustration.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/UserGuide/Recipes/WindowsNetService_PitVars.png" scale="50"/>
</imageobject>
<textobject><phrase>WindowsNetService PitVars</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>The Pit User Guides describe the Pit-specific variables.</simpara>
<variablelist>
<varlistentry>
<term>Community String (Authentication)</term>
<listitem>
<simpara>Community string used for authentication by the network server. Check the network service documentation for consistency of this value. If needed, change the value here to coincide with the value expected by the test target.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Source Port</term>
<listitem>
<simpara>Port number of the local machine that sends packets to the server. Several services use well-known ports that usually can be left unedited.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Target IPv4 Address</term>
<listitem>
<simpara>IPv4 address of the target machine (server). For information on obtaining the IPv4 address, see Retrieving Machine Information in the Pit documentation.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Target Port</term>
<listitem>
<simpara>Port number of the server that receives packets. Several services use well-known ports that usually can be left unedited.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Timeout</term>
<listitem>
<simpara>Duration, in milliseconds, to wait for incoming data. During fuzzing, a timeout failure causes the fuzzer to skip to the next test case.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_agents_4">
<title>Agents</title>
<simpara>The following UI diagram acts as an overview, showing the Peach agents and the monitors within each agent. Peach uses the ordering within the agent to determine the order in which to load and run monitors.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/UserGuide/Recipes/WindowsNetService_Agents.png" scale="50"/>
</imageobject>
<textobject><phrase>WindowsNetService Agents</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>The local agent is defined first and lists the default information for both name and location. This definition for a local agent is typical and, otherwise, unremarkable. The monitor list includes the NetworkCapture and the Vmware monitors that are independent of each other.</simpara>
<simpara>The remote agent, named "Remote", has quite a different location specification. The location consists of concatenated pieces of information:</simpara>
<itemizedlist>
<listitem>
<simpara>Channel. The channel for a remote agent is <literal>tcp</literal>. A colon and two forward slashes separate the channel from the IPv4 address of the hardware interface.</simpara>
</listitem>
<listitem>
<simpara>IPv4 address. The IPv4 address of the agent is the second component of the location. Use <literal>ipconfig -all</literal> to  find this address of the remote machine.</simpara>
</listitem>
</itemizedlist>
<simpara>The monitor list within each agent is significant, as the monitors launch in sequence from top to bottom within an agent.</simpara>
<note>
<simpara>For first-time users, we recommend that you build incrementally to the final configuration by testing each monitor along the way. You can run the VM manually until you&#8217;re ready to automate the environment.</simpara>
</note>
<orderedlist numeration="arabic">
<listitem>
<simpara>Start with the local agent and the network capture monitor to capture network packets.</simpara>
</listitem>
<listitem>
<simpara>Add the remote agent and the WindowsService monitor.</simpara>
</listitem>
<listitem>
<simpara>Add the WindowsDebugger monitor to the remote agent.</simpara>
</listitem>
<listitem>
<simpara>Add the PageHeap monitor to the remote agent and reposition it atop the remote agent monitor list.</simpara>
</listitem>
<listitem>
<simpara>Add automation to the local agent using the Vmware monitor.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="_monitors_4">
<title>Monitors</title>
<simpara>This recipe uses five monitors, two on the machine with Peach and three on the remote machine. The recipe shows each monitor and describes its roles: fault detection, data collection, and automation.</simpara>
<tip>
<simpara>When specifying a backslash (\) in the Peach Web user interface, double them, as the parser treats the first \ as a meta character.</simpara>
</tip>
<section xml:id="_networkcapture_monitor">
<title>NetworkCapture Monitor</title>
<simpara>The <link linkend="Monitors_NetworkCapture">Netowrk Capture Monitor (InterestingPackets)</link> monitor captures network packets when a fault occurs and stores them in the log for the test case that generates the fault.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/UserGuide/Recipes/WindowsNetService_NetworkCapture.png" scale="50"/>
</imageobject>
<textobject><phrase>WindowsNetService NetworkCapture</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>The most signification parameters for the network capture monitor follow:</simpara>
<variablelist>
<varlistentry>
<term>Device</term>
<listitem>
<simpara>Name of the interface on the local machine (the machine with Peach) used
to communicate with the test target. Use <literal>ipconfig –all</literal> to identify the interface(s)
available for use.</simpara>
</listitem>
</varlistentry>
</variablelist>
<note>
<simpara>You can find the appropriate host interface that communicates with the VM using the following steps:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Collect a list of interfaces (and their IPv4 addresses) by running <literal>ipconfig</literal>.</simpara>
</listitem>
<listitem>
<simpara>Test each interface in the list. Manually run a capture session with Wireshark using an interface from the list.</simpara>
</listitem>
<listitem>
<simpara>On the host machine, Ping the target IPv4 (of the VM).</simpara>
</listitem>
<listitem>
<simpara>If the correct interface of the host is used, you&#8217;ll see the Ping request and reply packet exchanges through Wireshark,</simpara>
</listitem>
<listitem>
<simpara>Loop to step 2 and repeat, using another interface.</simpara>
</listitem>
</orderedlist>
</note>
<variablelist>
<varlistentry>
<term>Filter</term>
<listitem>
<simpara>The packet filter helps capture only those packets associated with the
fuzzing session. The filter adheres to the syntax and requirements of the Pcap
filter specification.</simpara>
</listitem>
</varlistentry>
</variablelist>
<tip>
<simpara>WireShark refers to the Libpcap filters as capture filters. Use the capture filters in Peach. Wireshark also defines its own display filters that it uses to filter entries in its
session files. The display filters are not compatible with Libpcap.</simpara>
</tip>
</section>
<section xml:id="_vmware_windows_virtual_machine_automation">
<title>Vmware (Windows virtual machine Automation)</title>
<simpara>The <link linkend="Monitors_Vmware">Vmware</link> monitor controls setting up and starting the virtual machine and uses the settings in the following illustration:</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/UserGuide/Recipes/WindowsNetService_Vmware.png" scale="50"/>
</imageobject>
<textobject><phrase>WindowsNetService Vmware</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>The most significant parameters for the VMware monitor follow:</simpara>
<variablelist>
<varlistentry>
<term>Vmx</term>
<listitem>
<simpara>Identifies the full path of the virtual machine image. Peach loads the
snapshot of the VM image at the start of the fuzzing job and after a fault occurs.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Headless</term>
<listitem>
<simpara>Specifies whether the VM connects to a viewing window in the VMware
window. When developing a configuration, set this parameter to false. When
performing a fuzzing job, the setting doesn&#8217;t matter.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Host Type</term>
<listitem>
<simpara>Specifies the VMWare product used in the configuration.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Snapshot Name</term>
<listitem>
<simpara>Identifies the snapshot to use for the specific image.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
</section>
<section xml:id="_pageheap_memory_heap_analyzer">
<title>PageHeap (Memory Heap Analyzer)</title>
<simpara>The <link linkend="Monitors_PageHeap">PageHeap</link> monitor enables the Windows Debugger to analyze heap memory allocations throughout the fuzzing session. This monitor manages the registry entries that govern heap monitoring. The monitor sets the entries at the beginning of the fuzzing session and clears them at the end of the session.</simpara>
<note>
<simpara>PageHeap requires administrative privileges to run correctly.</simpara>
</note>
<simpara>The PageHeap monitor uses the settings in the following illustration:</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/UserGuide/Recipes/WindowsNetService_PageHeap.png" scale="50"/>
</imageobject>
<textobject><phrase>WindowsNetService PageHeap</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>The most significant parameters for the PageHeap monitor follow:</simpara>
<variablelist>
<varlistentry>
<term>Executable</term>
<listitem>
<simpara>Name of the test target executable file. Provide the file name and
extension. The path is not needed.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Win Dbg Path</term>
<listitem>
<simpara>Folder on the test target containing the Windows debugging tools.
Use absolute path from the file system root to the folder.</simpara>
</listitem>
</varlistentry>
</variablelist>
<important>
<simpara>When using PageHeap with Windows services, run the PageHeap monitor when the service is stopped.</simpara>
</important>
</section>
<section xml:id="_windowsservice">
<title>WindowsService</title>
<simpara>The <link linkend="Monitors_WindowsService">WindowsService</link> monitor manages a Windows service. This monitor starts the network service at the start of the fuzzing job, and restarts the service when the VM is refreshed (after a fault). The monitor is housed by the remote agent.</simpara>
<simpara>The WindowsService monitor uses the settings in the following illustration:</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/UserGuide/Recipes/WindowsNetService_WinService.png" scale="50"/>
</imageobject>
<textobject><phrase>WindowsNetService WinService</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>The most significant parameter for the WindowsService monitor is “Service” that
specifies the name of the Windows service to monitor.</simpara>
</section>
<section xml:id="_windowsdebugger_2">
<title>WindowsDebugger</title>
<simpara>The <link linkend="Monitors_WindowsDebugger">WindowsDebugger</link> debugger monitor performs two major functions in this recipe:</simpara>
<itemizedlist>
<listitem>
<simpara>Detects faults internal to the service.</simpara>
</listitem>
<listitem>
<simpara>Create log files when a faulting condition occurs.</simpara>
</listitem>
</itemizedlist>
<simpara>The WindowsDebugger monitor uses the settings in the following illustration:</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/UserGuide/Recipes/WindowsNetService_WinDebugger.png" scale="50"/>
</imageobject>
<textobject><phrase>WindowsNetService WinDebugger</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>The most significant parameters for the WindowsDebugger monitor follow:</simpara>
<variablelist>
<varlistentry>
<term>Service</term>
<listitem>
<simpara>Name of the test target service on the remote machine. Provide
the service name given in the service properties.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Win Dbg Path</term>
<listitem>
<simpara>Folder on the test target containing the Windows debugging tools.
Use absolute path from the file system root to the folder.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_configuration_test_4">
<title>Configuration Test</title>
<simpara>Once the monitors and associated parameters are part of the configuration, you can test the configuration. From the Configuration menu along the left edge of the window, click on <literal>Test</literal> to run a single iteration (test case) on the configuration. Note that the test checks the connections and communications. It does NOT do any fuzzing.</simpara>
<simpara>For more information on testing a configuration, see <link linkend="Test_PitConfiguration">Test Pit Configuration</link>.</simpara>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
</section>
</section>
<section xml:id="Agent">
<title>Agents</title>
<simpara>A Peach agent is a light weight process that can host multiple monitors.
These monitors perform tasks such as fault detection, data collection and automation.</simpara>
<simpara>The Peach agent communicates over a network channel to the main Peach process where all captured information is reported.
This allows the main Peach process to perform monitoring locally or on the device under test.</simpara>
<simpara>Monitors that perform fault detection provide methods to identify when a problem with the target under test during testing. For example, you might use a debugger monitor to detect when a target crashes and collect information about the crash. Peach finds more issues when robust fault detection is configured.</simpara>
<simpara>Data collection monitors are used to gather additional information about a fault that has occured. This can include taking a network capture of the test traffic, collecting log files and running scripts to collect information about the target state. The goal is to collect any information that will be useful in tracking down the root cause of the faulting condition.</simpara>
<simpara>Automation monitors are used to automate the target and target environment. This can include startup automation such as configuring an environment and starting the target. Restarting the environment when a fault occurs so testing can continue. And finally shutting down the target/environment when testing has completed. Some configurations may also require triggering the target to connect/consume data.</simpara>
<figure>
<title>Peach Agent Block Diagram</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/AgentDiagram.svg" align="center"/>
</imageobject>
<textobject><phrase>AgentDiagram</phrase></textobject>
</mediaobject>
</figure>
<sidebar>
<title>Agent Privileges</title>
<simpara>Some monitors or publishers hosted by an agent process sometimes require heightened privileges.
If you receive an error regarding permissions, try running the agent with root or administrative priviledges.</simpara>
<simpara><emphasis role="strong">OS X/Linux/Unix</emphasis></simpara>
<simpara>On OS X, Linux and other Unix systems, a process can be launched as root using the <emphasis>sudo</emphasis> utility.</simpara>
<simpara>For local agents:</simpara>
<literallayout class="monospaced">sudo ./peach</literallayout>
<simpara>For remote agents:</simpara>
<literallayout class="monospaced">sudo ./peachagent</literallayout>
<simpara><emphasis role="strong">Windows</emphasis></simpara>
<simpara>On Windows a process can be started with administrator rights by right-clicking and selecting "Run as Adminsitrator". Optionally the user can be given additional needed priviledges by the system administrator.</simpara>
<simpara><emphasis role="strong">Privileged Monitors</emphasis></simpara>
<simpara>Which monitors require additional privileges depends on the specific OS and privileges of the user, but typically the following require special rights:</simpara>
<itemizedlist>
<listitem>
<simpara>PageHeap (Windows)</simpara>
</listitem>
<listitem>
<simpara>NetworkCapture (OS X/Linux/Unix)</simpara>
</listitem>
</itemizedlist>
</sidebar>
<sidebar>
<title>Network Firewall</title>
<simpara>Many modern operating systems such as Windows and Linux come with a firewall that prevents incoming or outgoing network traffic.
This can prevent a remote agent from communicating with Peach.
On Windows the user is asked when program first runs if a firewall rule should be added.</simpara>
<simpara>On Linux, specifically Ubuntu distributions, this command allows packets through the firewall using port 9001 (default the port for remote agents).</simpara>
<screen>sudo ufw allow 9001</screen>
</sidebar>
<section xml:id="_agent_channels">
<title>Agent Channels</title>
<variablelist>
<varlistentry>
<term>Local Agent (local)</term>
<listitem>
<simpara>The agent is hosted in the current Peach process. This is the default channel. An example agent URL is <literal>local://</literal></simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Remote Agent (tcp)</term>
<listitem>
<simpara>The external Peach agent communicates using network calls over TCP. Peach can run as a remote agent using the <link linkend="Program_PeachAgent">PeachAgent</link> program. Remote agents do not require a valid license and are only used to host monitors or remote publishers. An example agent URL is <literal>tcp://192.168.1.2:9002</literal></simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Custom Agent (RESTful API) (http)</term>
<listitem>
<simpara>This agent protocol uses RESTful style calls over HTTP. This channel is best suited for custom Peach agents. For more information, see the <literal>Agent</literal> topic in the <literal>Extending Peach</literal> section of the <emphasis>Peach Professional Developer Guide</emphasis>. An example agent URL is <literal>tcp://192.168.1.2:8080</literal></simpara>
</listitem>
</varlistentry>
</variablelist>
<section xml:id="_local_agent">
<title>Local Agent</title>
<simpara>The peach runtime supports a local agent that runs in process. LocalAgent is the default agent unless another agent type is specified.</simpara>
<simpara>Agent URL:</simpara>
<literallayout class="monospaced">local://</literallayout>
</section>
<section xml:id="_remote_agent">
<title>Remote Agent</title>
<simpara>Peach includes a remote <link linkend="Program_PeachAgent">agent server</link> that can be used to host Monitors and Publishers on remote machines. Usage of a remote agent requires a location URL of the following format:</simpara>
<simpara>Agent URL:</simpara>
<literallayout class="monospaced">tcp://HOST:PORT</literallayout>
<variablelist>
<varlistentry>
<term>HOST</term>
<listitem>
<simpara>Remote host the agent is running on</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>PORT</term>
<listitem>
<simpara>Remote port the agent is bound to (defaults to 9001)</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>Example:</simpara>
<literallayout class="monospaced">tcp://192.168.1.100:9001</literallayout>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
</section>
<section xml:id="Monitors">
<title>Monitors</title>
<simpara><link linkend="Agent">Agents</link> are special Peach processes that can be run locally or remotely.
These processes host one or more Monitors that can perform such actions as attaching debuggers,
watching memory consumption,
or detecting faults.</simpara>
<simpara>The following table lists each monitor by name,
function type (Fault detection, Data collection, Automation),
and by the operating systems that support the monitor.
If the operating systems column is blank for an entry,
that monitor is available in all supported operating systems.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Monitors</title>
<tgroup cols="5">
<colspec colname="col_1" colwidth="30*"/>
<colspec colname="col_2" colwidth="10*"/>
<colspec colname="col_3" colwidth="10*"/>
<colspec colname="col_4" colwidth="20*"/>
<colspec colname="col_5" colwidth="30*"/>
<thead>
<row>
<entry align="left" valign="top">Monitor</entry>
<entry align="left" valign="top">Fault Detection</entry>
<entry align="left" valign="top">Data Collection</entry>
<entry align="left" valign="top">Automation</entry>
<entry align="left" valign="top">Operating Systems <footnote><simpara>When an operating system is listed, the monitor is available only for the listed operating system. A blank entry indicates the monitor is available for Windows, Linux, and OS X operating systems.</simpara></footnote></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><link linkend="Monitors_Android">Android</link></simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="Monitors_AndroidEmulator">Android Emulator</link></simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="Monitors_ApcPower">APC Power</link></simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="Monitors_ButtonClicker">ButtonClicker</link></simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"><simpara>Windows</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="Monitors_CanaKitRelay">CanaKit Relay</link></simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="Monitors_CanCapture">CAN Capture</link></simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="Monitors_CanErrorFrame">CAN Error Frame</link></simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="Monitors_CanSendFrame">CAN Send Frame</link></simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="Monitors_CanTiming">CAN Timing</link></simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="Monitors_CanThreshold">CAN Threshold</link></simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="Monitors_CleanupFolder">Cleanup Folder</link></simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="Monitors_CleanupRegistry">Cleanup Registry</link></simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"><simpara>Windows</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="Monitors_CrashReporter">Crash Reporter</link></simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>OS X</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="Monitors_CrashWrangler">Crash Wrangler</link></simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"><simpara>OS X</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="Monitors_Gdb">Gdb</link></simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"><simpara>Linux, OS X</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="Monitors_GdbServer">GdbServer</link></simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"><simpara>Linux, OS X</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="Monitors_IpPower9258">IpPower9258</link></simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="Monitors_LinuxCoreFile">LinuxCoreFile</link></simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>Linux</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="Monitors_MemoryMonitor">Memory</link></simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="Monitors_NetworkCapture">NetworkCapture</link></simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="Monitors_PageHeap">Page Heap</link></simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"><simpara>Windows</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="Monitors_Ping">Ping</link></simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="Monitors_PopupWatcher">Popup Watcher</link></simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"><simpara>Windows</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="Monitors_Process">Process Launcher</link></simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="Monitors_ProcessKiller">Process Killer</link></simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="Monitors_RunCommand">Run Command</link></simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="Monitors_SaveFile">Save File</link></simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="Monitors_Serial">Serial Port</link></simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="Monitors_SnmpPower">SNMP Power</link></simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="Monitors_Socket">Socket Listener</link></simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="Monitors_SshCommand">SSH Command</link></simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="Monitors_SshDownloader">SSH Downloader</link></simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="Monitors_Syslog">Syslog</link></simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="Monitors_TcpPort">TcpPort</link></simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="Monitors_Vmware">Vmware Control</link></simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="Monitors_WindowsDebugger">Windows Debugger</link></simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"><simpara>Windows</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="Monitors_WindowsService">Windows Service</link></simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"><simpara>Windows</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara><?asciidoc-pagebreak?></simpara>
<section xml:id="Monitors_Android">
<title>Android Monitor</title>
<simpara><emphasis role="strong">Monitor Categories</emphasis>: <emphasis role="strong">Automation</emphasis>, <emphasis role="strong">Fault detection</emphasis></simpara>
<simpara>The <emphasis>Android</emphasis> monitor examines both targeted Android applications and the state of the
Android OS. Peach supports Android OS versions 4.0 to 5.1, inclusively.</simpara>
<simpara>Two expected use cases are:</simpara>
<itemizedlist>
<listitem>
<simpara>Maintaining state while fuzzing native code</simpara>
</listitem>
<listitem>
<simpara>Launching and monitoring Android Java applications.</simpara>
</listitem>
</itemizedlist>
<simpara>The <emphasis>Android</emphasis> monitor can start or restart the device at the following times:</simpara>
<itemizedlist>
<listitem>
<simpara>The start of a fuzzing run</simpara>
</listitem>
<listitem>
<simpara>The start of each test iteration</simpara>
</listitem>
<listitem>
<simpara>The start of an iteration that immediately follows a fault</simpara>
</listitem>
<listitem>
<simpara>When called from the state model</simpara>
</listitem>
</itemizedlist>
<simpara>The Android monitor watches the message logs and the device, and can generate faults for the following conditions:</simpara>
<itemizedlist>
<listitem>
<simpara>A logging message matches the fault search criteria, Peach logs a fault.</simpara>
</listitem>
<listitem>
<simpara>A logging message matches the fault search criteria, Peach logs a fault and stops fuzzing.</simpara>
</listitem>
<listitem>
<simpara>A physical device becomes non-responsive.</simpara>
</listitem>
<listitem>
<simpara>A virtual device becomes non-responsive or lost.</simpara>
</listitem>
</itemizedlist>
<simpara>After detecting a fault, the monitor collects data from the device log files and crash dumps.</simpara>
<simpara>Additionally, the monitor logs exceptions, and updates fault bucket information. For bucketing,
Peach uses the text from the fault to determine the major bucket level. The minor bucket level
is not used. The risk evaluation looks for error, fatal error, or unknown.</simpara>
<simpara>The <emphasis>Android</emphasis> monitor uses the Android Debugging Bridge (adb) to communicate with a device. This
monitor can target both emulated and physical devices. The <emphasis>Android</emphasis> monitor requires
<link xl:href="http://developer.android.com/sdk/index.html">Android Platform Tools</link> and either an emulator or a
physical Android device. The configuration for a physical device follows. For a configuration using
a virtual device, see the <link linkend="Monitors_AndroidEmulator">Android Emulator Monitor</link>.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/Monitors/Android.png"/>
</imageobject>
<textobject><phrase>Android</phrase></textobject>
</mediaobject>
</informalfigure>
<note>
<simpara>Connecting to a physical device requires the device serial number. You can obtain this from a
connected device by using the following adb command: "adb&#160;devices". The result is a list of
devices that adb found. The information for each device consists of two parts: the device
number and the connection status between adb and the device. The list includes physical and
virtual devices.</simpara>
<simpara>For more information about debugging Android devices, see the following:</simpara>
<itemizedlist>
<listitem>
<simpara><link xl:href="http://developer.android.com/tools/help/adb.html">Android Debug Bridge</link>.</simpara>
</listitem>
<listitem>
<simpara><link xl:href="http://www.howtogeek.com/125769/how-to-install-and-use-abd-the-android-debug-bridge-utility/">How To Install and Use ADB, the Android Debug Bridge Utility</link></simpara>
</listitem>
</itemizedlist>
</note>
<section xml:id="_parameters_2">
<title>Parameters</title>
<simpara><emphasis>Required:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>ApplicationName</term>
<listitem>
<simpara>Name of the Android application.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>ActivityName</term>
<listitem>
<simpara>Name of the application activity, defaults to "".</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>AdbPath</term>
<listitem>
<simpara>Directory path to adb, defaults to "".</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>ClearAppData</term>
<listitem>
<simpara>Removes the application data and cache every iteration, defaults to false.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>ClearAppDataOnFault</term>
<listitem>
<simpara>Removes the application data and cache on faulting iterations, defaults to false.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>CommandTimeout</term>
<listitem>
<simpara>Sets the maximum number of seconds to wait for the adb command to complete, defaults to 10 seconds.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>ConnectTimeout</term>
<listitem>
<simpara>Sets the maximum number of seconds to wait to establish an adb connection, defaults to 5 seconds.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>DeviceMonitor</term>
<listitem>
<simpara>Identifies the Android monitor that supplies the device serial number, defaults to "". Used when monitoring a virtual device.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>DeviceSerial</term>
<listitem>
<simpara>The serial number of the device to monitor, defaults to "". Used when monitoring a physical device.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>FaultRegex</term>
<listitem>
<simpara>Specifies a regular expression; when matched from a log entry, triggers a fault. The default pattern
is <emphasis>(^E/ActivityMonitor)|(^E/AndroidRuntime)|(^F/.*)</emphasis>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>FaultWaitTime</term>
<listitem>
<simpara>Sets the time period, in milliseconds, to wait when checking for a fault, defaults to 0 ms.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>IgnoreRegex</term>
<listitem>
<simpara>Specifies a regular expression; when matched, the monitor ignores potential false positive faults, defaults to "".</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>MustStopRegex</term>
<listitem>
<simpara>Specifies a regular expression; when a match occurs, the monitor triggers a fault and stops fuzzing, defaults to "".</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>ReadyTimeout</term>
<listitem>
<simpara>Sets the maximum number of seconds to wait for the device to reach readiness&#8212;&#8203;able to respond to inputs, defaults to 600 seconds.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>RebootEveryN</term>
<listitem>
<simpara>Specifies the number of iterations between successive device reboots, defaults to 0.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>RebootOnFault</term>
<listitem>
<simpara>Reboots the device when a fault occurs, defaults to false.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>RestartEveryIteration</term>
<listitem>
<simpara>Restarts the application every iteration, defaults to false.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>StartOnCall</term>
<listitem>
<simpara>Starts the application when notified by the state machine. The string value used here must match the Call Action statement of the state model. The default string is "".</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>WaitForReadyOnCall</term>
<listitem>
<simpara>Waits for the device to be ready when notified by the state machine. The string used here must match the corresponding Call Action statement of the state model. the default string is "".</simpara>
</listitem>
</varlistentry>
</variablelist>
<tip>
<simpara>The DeviceMonitor and the DeviceSerial parameters are mutually exclusive. Use DeviceSerial to provide the serial number of a physical device. Use DeviceMonitor when using the Android Emulator, as the Emulator will provide the serial number of the virtual device.</simpara>
</tip>
</section>
<section xml:id="_examples_4">
<title>Examples</title>
<example>
<title>Basic Usage with a Physical Device <?asciidoc-br?></title>
<simpara>This parameter example is from a setup that the BadBehaviorActivity, sending random taps to generate different types of exceptions and crashes. The setup is for a physical Android device.</simpara>
<simpara><literal>Android Monitor (App) Parameters</literal></simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="66.6667*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Value</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>ApplicationName</simpara></entry>
<entry align="left" valign="top"><simpara><literal>com.android.development</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>ActivityName</simpara></entry>
<entry align="left" valign="top"><simpara><literal>.BadBehaviorActivity</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>AdbPath</simpara></entry>
<entry align="left" valign="top"><simpara><literal>C:\adt-bundle-windows-x86_64-20131030\sdk\platform-tools</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>DeviceSerial</simpara></entry>
<entry align="left" valign="top"><simpara><literal>emulator-5554</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</example>
<example>
<title>Basic Usage with a Virtual Device<?asciidoc-br?></title>
<simpara>This parameter example is from a setup that the BadBehaviorActivity, sending random taps to generate different types of exceptions and crashes. The setup is for a virtual Android device, and uses the Android monitor, as well as the Android Emulator monitor.</simpara>
<simpara>If you want to run the Android emulator, set your AdbPath to the directory containing the adb (Android Debug Bridge)
platform-tools directory and point the EmulatorPath in the Android Emulator Monitor to the adb tools directory.</simpara>
<simpara>The Avd parameter in the Android Emulator Monitor must also be the name of a valid AVD (Android Virtual Device).
Use the following steps to create a new AVD:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Open the <emphasis>android.bat</emphasis> file located in the adb SDK tools directory.</simpara>
</listitem>
<listitem>
<simpara>From the GUI that opens, click on <emphasis>Tools</emphasis> in the menu bar, then <emphasis>Manage AVDs&#8230;&#8203;</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>From the window that opens, click <emphasis>New&#8230;&#8203;</emphasis> and create a new AVD.</simpara>
</listitem>
</orderedlist>
<simpara><emphasis>Android Emulator (Emu) Monitor Parameters</emphasis></simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="66.6667*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Value</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Avd</simpara></entry>
<entry align="left" valign="top"><simpara><literal>Nexus4</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>EmulatorPath</simpara></entry>
<entry align="left" valign="top"><simpara><literal>C:\adt-bundle-windows-x86_64-20131030\sdk\tools</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis>Android Monitor (App) Parameters</emphasis></simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="66.6667*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Value</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>ApplicationName</simpara></entry>
<entry align="left" valign="top"><simpara><literal>com.android.development</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>ActivityName</simpara></entry>
<entry align="left" valign="top"><simpara><literal>.BadBehaviorActivity</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>AdbPath</simpara></entry>
<entry align="left" valign="top"><simpara><literal>C:\adt-bundle-windows-x86_64-20131030\sdk\platform-tools</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>DeviceMonitor</simpara></entry>
<entry align="left" valign="top"><simpara><literal>Emu</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Monitors_AndroidEmulator">
<title>AndroidEmulator Monitor</title>
<simpara><emphasis role="strong">Monitor Categories</emphasis>: <emphasis role="strong">Automation</emphasis>, <emphasis role="strong">Fault detection</emphasis></simpara>
<simpara>The <emphasis>AndroidEmulator</emphasis> monitor handles setup and teardown for Android Virtual Devices (AVDs)
running within the Android Emulator. This monitor detects faults related to the emulator
operation, not fuzzing results.</simpara>
<simpara>The monitor provides the following functionality:</simpara>
<itemizedlist>
<listitem>
<simpara>Start a virtual device at the start of a fuzzing run.</simpara>
</listitem>
<listitem>
<simpara>Start a virtual device at the start of each test iteration.</simpara>
</listitem>
<listitem>
<simpara>Start a virtual device when called from the state model.</simpara>
</listitem>
<listitem>
<simpara>Start a virtual device at the beginning of an iteration that immediately follows a fault.</simpara>
</listitem>
<listitem>
<simpara>Shuts down at the end of a fuzzing session.</simpara>
</listitem>
<listitem>
<simpara>Logs timeout messages when querying the emulator for the device serial number.</simpara>
</listitem>
<listitem>
<simpara>Logs timeout messages when shutting down the emulator.</simpara>
</listitem>
<listitem>
<simpara>logs messages sent to StdErr.</simpara>
</listitem>
<listitem>
<simpara>Logs messages sent to StdOut.</simpara>
</listitem>
</itemizedlist>
<simpara>This monitor requires the following items to run:</simpara>
<itemizedlist>
<listitem>
<simpara>The Android monitor that watches the OS and application being fuzzed.</simpara>
</listitem>
<listitem>
<simpara>The <link xl:href="http://developer.android.com/tools/help/emulator.html">Android Emulator</link></simpara>
</listitem>
<listitem>
<simpara>The <link xl:href="http://developer.android.com/sdk/index.html">Android Platform Tools</link>.</simpara>
</listitem>
</itemizedlist>
<simpara>The fuzzing configuration for a virtual or emulated device follows. For a configuration using a physical device, see the <link linkend="Monitors_Android">Android Monitor</link>.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/Monitors/AndroidEmulator.png"/>
</imageobject>
<textobject><phrase>AndroidEmulator</phrase></textobject>
</mediaobject>
</informalfigure>
<section xml:id="_parameters_3">
<title>Parameters</title>
<simpara><emphasis>Required:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>Avd</term>
<listitem>
<simpara>Android virtual device.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>EmulatorPath</term>
<listitem>
<simpara>Directory containing the Android emulator.
If not provided, Peach searches the directories in the PATH variable for the installed emulator.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Headless</term>
<listitem>
<simpara>If true, runs the emulator <emphasis role="strong">without a display</emphasis>. Defaults to false.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>RestartAfterFault</term>
<listitem>
<simpara>If <literal>true</literal>, restarts the emulator when any monitor detects a fault.
If <literal>false</literal>, restarts the emulator only if the emulator exits or crashes.
This argument defaults to <literal>true</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>RestartEveryIteration</term>
<listitem>
<simpara>Restart emulator on every iteration. Defaults to false.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>StartOnCall</term>
<listitem>
<simpara>Start the emulator when notified by the state machine.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>StartTimeout</term>
<listitem>
<simpara>How many seconds to wait for emulator to start running. Defaults to 30.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>StopTimeout</term>
<listitem>
<simpara>How many seconds to wait for emulator to exit. Defaults to 30.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_5">
<title>Examples</title>
<example>
<title>Basic Usage Example<?asciidoc-br?></title>
<simpara>This parameter example is from a setup that the BadBehaviorActivity, sending random taps to generate
different types of exceptions and crashes. The setup is for a virtual device that uses the Android
Emulator Monitor, as well as the Android monitor.</simpara>
<simpara>In order to run the Android emulator, set the EmulatorPath in the Android Emulator Monitor to the
adb tools directory, and set the Avd parameter to the name of an Android virtual device.
Here the name of the virtual device is "Nexus4".</simpara>
<simpara>In the Android monitor, set the AdbPath to the platform-tools directory containing the adb (Android Debug Bridge).</simpara>
<simpara><literal>Android Emulator (Emu) Monitor Parameters</literal></simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="66.6667*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Value</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Avd</simpara></entry>
<entry align="left" valign="top"><simpara><literal>Nexus4</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>EmulatorPath</simpara></entry>
<entry align="left" valign="top"><simpara><literal>C:\adt-bundle-windows-x86_64-20131030\sdk\tools</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><literal>Android Monitor (App) Parameters</literal></simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="66.6667*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Value</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>ApplicationName</simpara></entry>
<entry align="left" valign="top"><simpara><literal>com.android.development</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>ActivityName</simpara></entry>
<entry align="left" valign="top"><simpara><literal>.BadBehaviorActivity</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>AdbPath</simpara></entry>
<entry align="left" valign="top"><simpara><literal>C:\adt-bundle-windows-x86_64-20131030\sdk\platform-tools</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>DeviceMonitor</simpara></entry>
<entry align="left" valign="top"><simpara><literal>Emu</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</example>
<note>
<simpara>Position the Android Emulator Monitor before (above) the Android monitor in your Pit,
so that, at run time, the virtual device exists when adb tries to connect to it. Peach
executes the monitors in the order that they are listed in the fuzzing definition.</simpara>
</note>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Monitors_ApcPower">
<title>APC Power Monitor</title>
<simpara><emphasis role="strong">Monitor Categories</emphasis>: <emphasis role="strong">Automation</emphasis></simpara>
<simpara>The <emphasis>APC Power</emphasis> monitor switches outlets on an APC power distribution unit (PDU) on and off via SNMPv1.
This monitor is useful for automatically power cycling devices during a fuzzing session.
APC&#8217;s Switched Rack Power Distribution Unit (AC7900) is known to work with this monitor.</simpara>
<simpara>Each <emphasis>APC Power</emphasis> monitor switches one or more of a PDU&#8217;s outlets, according to the configuration.
All affected outlets are given the same commands, so turning some outlets on and others off would require another monitor.
The monitor can reset the power outlets at the following points in time:</simpara>
<itemizedlist>
<listitem>
<simpara>At the start or end of a fuzzing run</simpara>
</listitem>
<listitem>
<simpara>At the start or end of each test iteration</simpara>
</listitem>
<listitem>
<simpara>After detecting a fault</simpara>
</listitem>
<listitem>
<simpara>At the start of an iteration that immediately follows a fault</simpara>
</listitem>
<listitem>
<simpara>When a specified call is received from the state model</simpara>
</listitem>
</itemizedlist>
<tip>
<simpara>The <link linkend="Monitors_IpPower9258">IpPower9258 Monitor</link> provides
 similar features, specific to the IP Power 9258 devices. The
 <link linkend="Monitors_SnmpPower">SnmpPower Monitor</link> is designed to work with
 non-APC PDUs that can be controlled via SNMPv1. For controlling power
 to a device by wiring through a relay, Peach provides a monitor for
 the <link linkend="Monitors_CanaKitRelay">CanaKit 4-Port USB Relay Controller</link>.</simpara>
</tip>
<section xml:id="_parameters_4">
<title>Parameters</title>
<simpara><emphasis>Required:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>Host</term>
<listitem>
<simpara>IP address of the switched power distribution unit.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>OutletGrouping</term>
<listitem>
<simpara>Whether outlets on the PDU are identified individually (<literal>Outlet</literal>) or in groups (<literal>OutletGroup</literal>). Default is <literal>Outlet</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Outlets</term>
<listitem>
<simpara>Comma-separated list of numeric identifiers for outlets or outlet groups to control.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>Port</term>
<listitem>
<simpara>SNMP port on the switched power distribution unit. Default is <literal>161</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>ReadCommunity</term>
<listitem>
<simpara>SNMP community string to use when reading the state of the outlets. Default is <literal>public</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>WriteCommunity</term>
<listitem>
<simpara>SNMP community string to use when modifying the state of the outlets. Default is <literal>private</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>RequestTimeout</term>
<listitem>
<simpara>Maximum duration in millseconds to block when sending an SNMP request to the PDU. Default is <literal>1000</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>SanityCheckOnStart</term>
<listitem>
<simpara>On startup, ensure switch state changes persist. Default is <literal>true</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>SanityCheckWaitTimeout</term>
<listitem>
<simpara>Maximum duration to wait for state change to take effect during startup sanity check. Default is <literal>3000</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>ResetOnCall</term>
<listitem>
<simpara>Reset power when the specified call is received from the state model.
This value is used only when the <emphasis>When</emphasis> parameter is set to <literal>OnCall</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>PowerOffOnEnd</term>
<listitem>
<simpara>Power off when the fuzzing session completes, default is <literal>false</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>PowerOnOffPause</term>
<listitem>
<simpara>Pause in milliseconds between power off/power on, default is <literal>500</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>When</term>
<listitem>
<simpara>When to reset power on the specified outlets or outlet groups. Default is <literal>OnFault</literal>.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="66.6667*"/>
<thead>
<row>
<entry align="left" valign="top">"When" Setting</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>DetectFault</simpara></entry>
<entry align="left" valign="top"><simpara>Reset power when checking for a fault.
This occurs after OnIterationEnd.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>OnStart</simpara></entry>
<entry align="left" valign="top"><simpara>Reset power when the fuzzing session starts.
This occurs once per session.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>OnEnd</simpara></entry>
<entry align="left" valign="top"><simpara>Reset power when the fuzzing session stops.
This occurs once per session.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>OnIterationStart</simpara></entry>
<entry align="left" valign="top"><simpara>Reset power at the start of each iteration.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>OnIterationEnd</simpara></entry>
<entry align="left" valign="top"><simpara>Reset power at the end of each iteration.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>OnFault</simpara></entry>
<entry align="left" valign="top"><simpara>Reset power when any monitor detects a fault.
This is the default setting.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>OnIterationStartAfterFault</simpara></entry>
<entry align="left" valign="top"><simpara>Reset power at the start of an iteration that immediately follows a fault detection.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>OnCall</simpara></entry>
<entry align="left" valign="top"><simpara>Reset power when the call specified by the <emphasis>ResetOnCall</emphasis> parameter is received from the state model.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<figure>
<title>When Choices for Performing an Action</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/Monitors/Timings_SSH.png"/>
</imageobject>
<textobject><phrase>Timings SSH</phrase></textobject>
</mediaobject>
</figure>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_6">
<title>Examples</title>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Monitors_ButtonClicker">
<title>ButtonClicker Monitor</title>
<simpara><emphasis role="strong">Monitor Category</emphasis>: <emphasis role="strong">Automation</emphasis></simpara>
<simpara>The <emphasis>ButtonClicker</emphasis> monitor provides automation functionality by clicking buttons
in the Windows GUI. This monitor runs in the Windows environment. <emphasis>ButtonClicker</emphasis>
watches and clicks the appropriate button within the specified window. You can use
<emphasis>ButtonClicker</emphasis> to click a button in the window, such as "OK" or "Close".</simpara>
<simpara>The intent of this monitor is to initiate an action or to close a window to keep a
fuzzing session active. <emphasis>Buttonclicker</emphasis> runs from the beginning of a fuzzing session
to the end of the session.</simpara>
<simpara>The following example uses an FTP client, FileZilla, that sometimes opens a popup window
asking whether to install an update. Here, <emphasis>ButtonClicker</emphasis> monitor provides a mouse
click to the "Close" button to close the popup window. With the popup window out of
the way, fuzzing continues without delay.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/Monitors/ButtonClicker_FTP.png"/>
</imageobject>
<textobject><phrase>ButtonClicker FTP</phrase></textobject>
</mediaobject>
</informalfigure>
<note>
<simpara>Another monitor to consider for watching popup windows is
<link linkend="Monitors_PopupWatcher">PopupWatcher</link>, that can monitor several popup windows.</simpara>
</note>
<section xml:id="_parameters_5">
<title>Parameters</title>
<simpara><emphasis>Required:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>WindowText</term>
<listitem>
<simpara>Text from the window title that identifies the window to receive the button
click. The text string can be part or all of the window title.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>ButtonName</term>
<listitem>
<simpara>Text label of the button to click. The label is displayed to the user,
and is on or near the button that will receive the click.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Optional:</emphasis></simpara>
<simpara>None.</simpara>
<tip>
<simpara>If Peach has trouble clicking a button, the button might have a link to a shortcut key.</simpara>
<simpara>The shortcut key is displayed in the label using an underlined character. Windows does
this by inserting an ampersand "&amp;" immediately before the shortcut key within the button
label. Further, not all underlining shows in the initial display of the window.</simpara>
<simpara>In an application, you can manually force underlining to display in window buttons by
pressing the &lt;CTRL&gt; or &lt;ALT&gt; key. Once you find the underlining in the application,
you can adjust the value of the <literal>ButtonName</literal> parameter for <emphasis>ButtonClick</emphasis> by inserting
an ampersand (&amp;) immediately before any underlined character. Then, Peach will find the
button to click.</simpara>
<simpara>For example, in Microsoft Word, the Browsing dialog box used to open a document does
not immediately display underlining in its command buttons. You can see this by following
the sequence that opens a file:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Click <emphasis role="strong">File</emphasis> on the ribbon.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Open</emphasis> on the vertical menu.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Computer</emphasis> in the Open column.</simpara>
</listitem>
<listitem>
<simpara>Click the <emphasis role="strong">Browse</emphasis> button.<?asciidoc-br?>
The dialog opens and the "Open" button in the lower right corner is not underlined. Press the &lt;ALT&gt; or &lt;CTRL&gt; key to see the underlining as in the following illustration.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/Monitors/ButtonClicker_Shortcut.png"/>
</imageobject>
<textobject><phrase>ButtonClicker Shortcut</phrase></textobject>
</mediaobject>
</informalfigure>
</listitem>
</orderedlist>
</tip>
</section>
<section xml:id="_examples_7">
<title>Examples</title>
<formalpara>
<title>Basic Usage Example<?asciidoc-br?></title>
<para>This parameter example is from the FTP client previous listed. The monitor will respond to the popup window that asks whether to install an update.</para>
</formalpara>
<simpara>The ButtonClicker monitor uses the following parameter settings to click the "Close" button in the popup window :</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="66.6667*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Value</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>WindowText</simpara></entry>
<entry align="left" valign="top"><simpara><literal>for Updates</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>ButtonName</simpara></entry>
<entry align="left" valign="top"><simpara><literal>Close</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Monitors_CanaKitRelay">
<title>CanaKitRelay Monitor</title>
<simpara><emphasis role="strong">Monitor category</emphasis>: <emphasis role="strong">Automation</emphasis></simpara>
<simpara>The <emphasis>CanaKitRelay</emphasis> monitor provides automation to a number of test configurations:</simpara>
<itemizedlist>
<listitem>
<simpara>Control power to an external device that is the fuzzing target.
You can turn it on at the start of the test,
then toggle power after a fault occurs to return the device to a known, stable state.</simpara>
</listitem>
<listitem>
<simpara>Control a supporting device in a fuzzing test configuration.
Supporting devices can include recording devices,
lighting,
heating devices,
sound or motion generators.
An example is turning on an espresso machine after every 10,000th test iteration.</simpara>
</listitem>
<listitem>
<simpara>Emulate a button push by inserting the device into a circuit containing the button.
The idea is to automate the press of a button,
such as <literal>NumLock</literal>,
or the play button on a surveillance device.</simpara>
</listitem>
<listitem>
<simpara>For simulating the attachment or removal of a cable,
such as USB,
by routing the power line (VCC) through the relay.</simpara>
</listitem>
</itemizedlist>
<simpara>The CanaKit is an external product that you can add as part of your test configuration.
The kit consists of 4 relays.
A relay is an electrically operated switch that uses an electromagnet to operate a switching mechanism. Each relay in the kit is capable of controlling a 5-amp,
110V AC or a 24V DC circuit.
Communication with the kit occurs over USB.</simpara>
<simpara>For more information on the kit,
including configurations,
installation,
and the relay command set,
see <link xl:href="http://www.canakit.com/4-port-usb-relay-controller.html">CanaKit 4-Port USB Relay Controller</link>.</simpara>
<simpara>You can purchase the CanaKit from the manufacturer at the previous web site or from Amazon.com.
In each case,
the kit price is about $60.00 U.S. plus shipping costs.</simpara>
<simpara>The <emphasis>CanaKitRelay</emphasis> monitor controls one relay in a kit.
Use one monitor per relay to control multiple relays concurrently.
Within a fuzzing session,
the monitor can trigger the relay at the following times:</simpara>
<itemizedlist>
<listitem>
<simpara>At the start or end of a fuzzing run</simpara>
</listitem>
<listitem>
<simpara>At the start or end of each test iteration</simpara>
</listitem>
<listitem>
<simpara>During the detection of a fault</simpara>
</listitem>
<listitem>
<simpara>After detecting a fault</simpara>
</listitem>
<listitem>
<simpara>At the start of an iteration that immediately follows a fault</simpara>
</listitem>
<listitem>
<simpara>When a specified call is received from the state model</simpara>
</listitem>
</itemizedlist>
<simpara>The following diagram shows a sample configuration that controls power through Relay 1.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/Monitors/CanaKitRelay.png"/>
</imageobject>
<textobject><phrase>CanaKitRelay</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Each relay supplies three terminals:
Normally Open (NO),
Common (COM),
and Normally Closed (NC).
Basic configurations will connect the hot wire to Common and the other wire to either NO or NC.
For DC connections,
attach the anode (+) to the Common terminal.</simpara>
<simpara>NO provides an open circuit when the relay is off.
NC provides a closed circuit when the relay is off,
giving opposite on/off states from NO.
The following diagram shows the terminal layout and imagines that Relay 1 is On.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/Monitors/CanaKitRelay_Terminals.png"/>
</imageobject>
<textobject><phrase>CanaKitRelay Terminals</phrase></textobject>
</mediaobject>
</informalfigure>
<tip>
<simpara>The CanaKit Relay requires a driver that is available at the supplier&#8217;s website.
At the time of this writing,
the driver is unsigned,
which forces you to turn off Driver Signing Enforcement when installing the driver in 64-bit Windows 8.
For instructions on how to install unsigned drivers in this environment,
see <link xl:href="http://www.howtogeek.com/167723/how-to-disable-driver-signature-verification-on-64-bit-windows-8.1-so-that-you-can-install-unsigned-drivers/">How to Disable Driver Signature Verification on 64-Bit Windows 8.1</link>.</simpara>
</tip>
<simpara>After installing the CanaKit device driver,
connect the unit to your PC.
Windows dynamically assigns a serial port to the USB channel for the connection.
You can see the port assignment by looking at the <literal>Ports(COM and LPT)</literal> entry in the Device Manager.
The Device Manager is available from the System applet in the Control Panel.</simpara>
<note>
<simpara>For controlling power to devices using 3-prong outlets, Peach
provides the <link linkend="Monitors_IpPower9258">IpPower9258</link>,
<link linkend="Monitors_ApcPower">ApcPower</link>, and
<link linkend="Monitors_SnmpPower">SnmpPower</link> monitors.</simpara>
</note>
<section xml:id="_parameters_6">
<title>Parameters</title>
<simpara><emphasis>Required:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>SerialPort</term>
<listitem>
<simpara>Serial port for the board (such as COM2).</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>RelayNumber</term>
<listitem>
<simpara>Relay to trigger (1, 2, 3, or 4).
Each relay number corresponds to a single relay in the kit, as shown in the first diagram.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>Action</term>
<listitem>
<simpara>Perform an action on the specified relay, defaults to ToggleOff.
Valid actions include the following:</simpara>
</listitem>
</varlistentry>
</variablelist>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="66.6667*"/>
<thead>
<row>
<entry align="left" valign="top">Action</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>ToggleOff</simpara></entry>
<entry align="left" valign="top"><simpara>Sets the relay to the OFF position, then sets the relay to the ON position.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>ToggleOn</simpara></entry>
<entry align="left" valign="top"><simpara>Sets the relay to the ON position, then sets the relay to the OFF position.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>SetOn</simpara></entry>
<entry align="left" valign="top"><simpara>Sets the relay to the ON position.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>SetOff</simpara></entry>
<entry align="left" valign="top"><simpara>Sets the relay to the OFF position.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<variablelist>
<varlistentry>
<term>StartOnCall</term>
<listitem>
<simpara>Toggle power when the specified call is received from the state model.
This value is used only when the <emphasis>When</emphasis> parameter is set to <literal>OnCall</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>ToggleDelay</term>
<listitem>
<simpara>Pause in milliseconds between off/on, defaults to <literal>500</literal>.
Formerly named OnOffPause.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>When</term>
<listitem>
<simpara>Specify one of the following values to determine when a relay should be toggled:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="66.6667*"/>
<thead>
<row>
<entry align="left" valign="top">"When" Setting</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>DetectFault</simpara></entry>
<entry align="left" valign="top"><simpara>Toggle power when checking for a fault.
This occurs after OnIterationEnd.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>OnStart</simpara></entry>
<entry align="left" valign="top"><simpara>Toggle power when the fuzzing session starts.
This occurs once per session.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>OnEnd</simpara></entry>
<entry align="left" valign="top"><simpara>Toggle power when the fuzzing session stops.
This occurs once per session.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>OnIterationStart</simpara></entry>
<entry align="left" valign="top"><simpara>Toggle power at the start of each iteration.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>OnIterationEnd</simpara></entry>
<entry align="left" valign="top"><simpara>Toggle power at the end of each iteration.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>OnFault</simpara></entry>
<entry align="left" valign="top"><simpara>Toggle power when any monitor detects a fault.
This is the default setting.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>OnIterationStartAfterFault</simpara></entry>
<entry align="left" valign="top"><simpara>Toggle power at the start of an iteration that immediately follows a fault detection.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>OnCall</simpara></entry>
<entry align="left" valign="top"><simpara>Toggle power when the call specified by the <emphasis>StartOnCall</emphasis> parameter is received from the state model.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<figure>
<title>When Choices for Performing an Action</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/Monitors/Timings_SSH.png"/>
</imageobject>
<textobject><phrase>Timings SSH</phrase></textobject>
</mediaobject>
</figure>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_8">
<title>Examples</title>
<formalpara>
<title>Reset power on Relay 1<?asciidoc-br?></title>
<para>This uses the CanaKitRelay monitor to reset relay&#160;1,
which toggles the power off,
then back on.
A device attached to this relay will restart when the relay resets.
The default setting for the <emphasis>When</emphasis> parameter is <literal>OnFault</literal>,
so the relay will be toggled after a fault is detected.</para>
</formalpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="66.6667*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Value</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>SerialPort</simpara></entry>
<entry align="left" valign="top"><simpara><literal>COM5</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>RelayNumber</simpara></entry>
<entry align="left" valign="top"><simpara><literal>1</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Monitors_CanCapture">
<title>CAN Capture Monitor</title>
<simpara><emphasis role="strong">Monitor Category</emphasis>: <emphasis role="strong">Data Collection</emphasis></simpara>
<simpara>The <emphasis>CAN Capture</emphasis> monitor collects all frames received (but not transmitted) on the specified interface.  If a fault occure, the capture is saved in the <emphasis>PCAP</emphasis> format, loadable into Wireshark for analysis.</simpara>
<note>
<simpara>Not all information from the CAN frame is visible in Wireshark.
Basic flags and data are available, but not the full frame.  This is a
limitation of the format and not Peach Fuzzer.</simpara>
</note>
<section xml:id="_parameters_7">
<title>Parameters</title>
<simpara><emphasis>Required:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>CanDriver</term>
<listitem>
<simpara>Driver to use. Defaults to <emphasis>Vector XL</emphasis>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>CanChannel</term>
<listitem>
<simpara>Channel number</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>CanBitrate</term>
<listitem>
<simpara>Set the bitrate for CAN packet transmission (default 500,000)</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Optional:</emphasis></simpara>
<simpara>None</simpara>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Monitors_CanErrorFrame">
<title>CAN Error Frame Monitor</title>
<simpara><emphasis role="strong">Monitor Category</emphasis>: <emphasis role="strong">Fault detection</emphasis></simpara>
<simpara>The <emphasis>CAN Error Frame</emphasis> monitor is will trigger a fault when an error frame is received on the specified device/channel.  Multiple <emphasis>CAN Error Frame</emphasis> monitors can be configured to monitor different devices/channel combinations.</simpara>
<section xml:id="_parameters_8">
<title>Parameters</title>
<simpara><emphasis>Required:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>CanDriver</term>
<listitem>
<simpara>Driver to use. Defaults to <emphasis>Vector XL</emphasis>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>CanChannel</term>
<listitem>
<simpara>Channel number</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>CanBitrate</term>
<listitem>
<simpara>Set the bitrate for CAN packet reception (default 500,000)</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Optional:</emphasis></simpara>
<simpara>No optional parameters supported on this monitor.</simpara>
</section>
<section xml:id="_examples_9">
<title>Examples</title>
<example>
<title>Fault if an error frame is received+</title>
<simpara>This parameter example is from a setup that uses the CAN Error Frame Monitor
to fault if an error frame is received.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="66.6667*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Value</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>CanDriver</simpara></entry>
<entry align="left" valign="top"><simpara><literal>Vector XL</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>CanChannel</simpara></entry>
<entry align="left" valign="top"><simpara><literal>1</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>CanBitrate</simpara></entry>
<entry align="left" valign="top"><simpara>(default)</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Monitors_CanSendFrame">
<title>CAN Send Frame Monitor</title>
<simpara><emphasis role="strong">Monitor Category</emphasis>: <emphasis role="strong">Automation</emphasis></simpara>
<simpara>The <emphasis>CAN Send Frame</emphasis> monitor is used to send CAN frames that are not fuzzed.
Frames can be sent at specific points during a test case, every N milliseconds,
or both. This can be useful to simulate messages required by a target.</simpara>
<simpara>The CAN frames being sent can share the same driver and channel as the fuzzing, or
use a different driver/channel.</simpara>
<note>
<simpara>The DLC is auto set based on the data size provided.</simpara>
</note>
<section xml:id="_parameters_9">
<title>Parameters</title>
<simpara><emphasis>Required:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>CanDriver</term>
<listitem>
<simpara>Driver to use. Defaults to <emphasis>Vector XL</emphasis>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>CanChannel</term>
<listitem>
<simpara>Channel number</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>CanBitrate</term>
<listitem>
<simpara>Set the bitrate for CAN packet transmission (default 500,000)</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Id</term>
<listitem>
<simpara>CAN Frame ID field in hex.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Data</term>
<listitem>
<simpara>CAN data to transmit in hex.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>SendEvery</term>
<listitem>
<simpara>Send frame every N milliseconds. Disable by setting to zero. Defaults to 0.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>When</term>
<listitem>
<simpara>Specify one of the following values to determine when a CAN frame should be sent (defaults to <literal>OnStart</literal>):</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="66.6667*"/>
<thead>
<row>
<entry align="left" valign="top">"When" Setting</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>DetectFault</simpara></entry>
<entry align="left" valign="top"><simpara>Send CAN frame when checking for a fault.
This occurs after OnIterationEnd.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>OnStart</simpara></entry>
<entry align="left" valign="top"><simpara>Send CAN frame when the fuzzing session starts.
This occurs once per session.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>OnEnd</simpara></entry>
<entry align="left" valign="top"><simpara>Send CAN frame when the fuzzing session stops.
This occurs once per session.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>OnIterationStart</simpara></entry>
<entry align="left" valign="top"><simpara>Send CAN frame at the start of each iteration.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>OnIterationEnd</simpara></entry>
<entry align="left" valign="top"><simpara>Send CAN frame at the end of each iteration.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>OnFault</simpara></entry>
<entry align="left" valign="top"><simpara>Send CAN frame when any monitor detects a fault.
This is the default setting.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>OnIterationStartAfterFault</simpara></entry>
<entry align="left" valign="top"><simpara>Send CAN frame at the start of an iteration that immediately follows a fault detection.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>OnCall</simpara></entry>
<entry align="left" valign="top"><simpara>Send CAN frame when the call specified by the <emphasis>StartOnCall</emphasis> parameter is received from the state model.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<figure>
<title>When Choices for Performing an Action</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/Monitors/Timings_SSH.png"/>
</imageobject>
<textobject><phrase>Timings SSH</phrase></textobject>
</mediaobject>
</figure>
</listitem>
</varlistentry>
<varlistentry>
<term>StartOnCall</term>
<listitem>
<simpara>Send frame when the specified event is received from the state model.
This value is used only when the <emphasis>When</emphasis> parameter is set to <literal>OnCall</literal>.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_10">
<title>Examples</title>
<example>
<title>Send CAN Frame Every 500 ms<?asciidoc-br?></title>
<simpara>This parameter example is from a setup that uses the CAN Send Frame monitor
to send a CAN frame every 500 ms.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="66.6667*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Value</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>CanDriver</simpara></entry>
<entry align="left" valign="top"><simpara><literal>Vector XL</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>CanChannel</simpara></entry>
<entry align="left" valign="top"><simpara><literal>1</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>CanBitrate</simpara></entry>
<entry align="left" valign="top"><simpara>(default)</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Id</simpara></entry>
<entry align="left" valign="top"><simpara><literal>0x07DC</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Data</simpara></entry>
<entry align="left" valign="top"><simpara><literal>AA BB CC DD EE FF</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>SendEvery</simpara></entry>
<entry align="left" valign="top"><simpara><literal>500</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>When</simpara></entry>
<entry align="left" valign="top"><simpara>(default)</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>StartOnCall</simpara></entry>
<entry align="left" valign="top"><simpara>(default)</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Monitors_CanTiming">
<title>CAN Timing Monitor</title>
<simpara><emphasis role="strong">Monitor Category</emphasis>: <emphasis role="strong">Fault detection</emphasis></simpara>
<simpara>The <emphasis>CAN Timing</emphasis> monitor is will trigger a fault when a frame is not received within a specified time window.
Many CAN targets are designed to send one or more CAN frames every N milliseconds.
When transmition of these frames stops or is out of spec, this can indicate a failure in the target device.</simpara>
<simpara>The CAN frames being sent can share the same driver and channel as the fuzzing, or use a different driver/channel.</simpara>
<section xml:id="_parameters_10">
<title>Parameters</title>
<simpara><emphasis>Required:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>CanDriver</term>
<listitem>
<simpara>Driver to use. Defaults to <emphasis>Vector XL</emphasis>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>CanChannel</term>
<listitem>
<simpara>Channel number</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>CanBitrate</term>
<listitem>
<simpara>Set the bitrate for CAN packet reception (default 500,000)</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Id</term>
<listitem>
<simpara>CAN Frame ID field in hex to expect</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Window</term>
<listitem>
<simpara>Reception window (how often frame should be received) in milliseconds.
If frame with <literal>Id</literal> is not received in this window of time, a fault will be raised.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Optional:</emphasis></simpara>
</section>
<section xml:id="_examples_11">
<title>Examples</title>
<example>
<title>Expect frame every half second<?asciidoc-br?></title>
<simpara>This parameter example is from a setup that uses the CAN Timing Monitor
to fault if a specific CAN frame is not received every half second.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="66.6667*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Value</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>CanDriver</simpara></entry>
<entry align="left" valign="top"><simpara><literal>Vector XL</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>CanChannel</simpara></entry>
<entry align="left" valign="top"><simpara><literal>1</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>CanBitrate</simpara></entry>
<entry align="left" valign="top"><simpara>(default)</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Id</simpara></entry>
<entry align="left" valign="top"><simpara><literal>0x07DC</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Window</simpara></entry>
<entry align="left" valign="top"><simpara><literal>500</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Monitors_CanThreshold">
<title>CAN Threshold Monitor</title>
<simpara><emphasis role="strong">Monitor Category</emphasis>: <emphasis role="strong">Fault detection</emphasis></simpara>
<simpara>The <emphasis>CAN Threshold</emphasis> monitor triggers a fault when a CAN signal is outside a specified threshold.
The threshold is provided as a python expression that must evaluate to bool true or false.</simpara>
<simpara>This is one of several ways to monitor a CAN target during fuzzing to determin if testing has adversely affected the target.</simpara>
<simpara>The CAN frames being sent can share the same driver and channel as the fuzzing, or use a different driver/channel.</simpara>
<section xml:id="_parameters_11">
<title>Parameters</title>
<simpara><emphasis>Required:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>CanDriver</term>
<listitem>
<simpara>Driver to use. Defaults to <emphasis>Vector XL</emphasis>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>CanChannel</term>
<listitem>
<simpara>Channel number</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>CanBitrate</term>
<listitem>
<simpara>Set the bitrate for CAN packet reception (default 500,000)</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Id</term>
<listitem>
<simpara>CAN Frame ID field in hex to expect</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>SignalEndian</term>
<listitem>
<simpara>Endianness of signal (if needed). Defaults to <literal>little</literal>.  Options are <literal>little</literal> or <literal>big</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>SignalOffset</term>
<listitem>
<simpara>Bit offset to signal start</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>SignalSize</term>
<listitem>
<simpara>Length of signal field in bits</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>SignalType</term>
<listitem>
<simpara>Data type of signal.
This is used to convert signal data into a usable type in the python threshold expression.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="66.6667*"/>
<thead>
<row>
<entry align="left" valign="top">Signal Types</entry>
<entry align="left" valign="top"></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Int</simpara></entry>
<entry align="left" valign="top"><simpara>SignalSize can be any value 32 or lower</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Float</simpara></entry>
<entry align="left" valign="top"><simpara>SignalSize must be 32 or 64</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Long</simpara></entry>
<entry align="left" valign="top"><simpara>SignalSize between 33 and 64</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>String</simpara></entry>
<entry align="left" valign="top"><simpara>Interpreted as UTF-8</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Binary</simpara></entry>
<entry align="left" valign="top"><simpara>SignalSize must be factor of 8</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</listitem>
</varlistentry>
<varlistentry>
<term>Expression</term>
<listitem>
<simpara>Stateless threshold expression used to determin if the signal value is within spec.
Expression results are cached for speed, and must not be statefull.
The threshold expression is specified as a Python 2 expression.
The provided expression must evaluate to a bool true/false.
Python expressions are single line code statements.
The following is an example of a code snippet that verifies a signal value is between 10 and 20 inclusive:
<literal>signal &gt;= 10 and signal &lt;= 20</literal></simpara>
<simpara>The Python expressions have access to the following local variables:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="66.6667*"/>
<thead>
<row>
<entry align="left" valign="top">Local Variables</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>id</simpara></entry>
<entry align="left" valign="top"><simpara>CAN Frame ID as a python int</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>logger</simpara></entry>
<entry align="left" valign="top"><simpara>Logging interface output stored in debug.log in run folder and test output. logger.Debug(msg)</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>signal</simpara></entry>
<entry align="left" valign="top"><simpara>Signal value decoded based on provided type</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Optional:</emphasis></simpara>
<simpara>No optional parameters.</simpara>
</section>
<section xml:id="_examples_12">
<title>Examples</title>
<example>
<title>Expect frame every half second<?asciidoc-br?></title>
<simpara>This parameter example is from a setup that uses the CAN Threshold Monitor
to fault if a signal in the CAN frame with id 0x7DE is not between 10 and 100.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="66.6667*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Value</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>CanDriver</simpara></entry>
<entry align="left" valign="top"><simpara><literal>Vector XL</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>CanChannel</simpara></entry>
<entry align="left" valign="top"><simpara><literal>1</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>CanBitrate</simpara></entry>
<entry align="left" valign="top"><simpara>(default)</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Id</simpara></entry>
<entry align="left" valign="top"><simpara><literal>0x07DE</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>SignalEndian</simpara></entry>
<entry align="left" valign="top"><simpara>(default)</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>SignalOffset</simpara></entry>
<entry align="left" valign="top"><simpara><literal>0</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>SignalSize</simpara></entry>
<entry align="left" valign="top"><simpara><literal>8</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>SignalType</simpara></entry>
<entry align="left" valign="top"><simpara><literal>int</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Expression</simpara></entry>
<entry align="left" valign="top"><simpara><literal>signal &gt; 10 and signal &lt; 100</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Monitors_CleanupFolder">
<title>CleanupFolder Monitor</title>
<simpara><emphasis role="strong">Monitor Category</emphasis>: <emphasis role="strong">Automation</emphasis></simpara>
<simpara>The <emphasis>CleanupFolder</emphasis> monitor provides automated cleanup of files created during a
fuzzing session. This monitor purges files produced during an iteration before
the start of the following iteration. CleanupFolder acts upon a specified directory,
and does not affect any files or directories that predate the fuzzing session.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>The directory, <literal>clean2</literal>, initially contains a single file.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/Monitors/CleanupFolder_PreFuzz.png"/>
</imageobject>
<textobject><phrase>CleanupFolder PreFuzz</phrase></textobject>
</mediaobject>
</informalfigure>
</listitem>
<listitem>
<simpara>Before each iteration, the CleanupFolder monitor deletes from the specified folder
all files that were generated in the previous fuzzing iteration.</simpara>
</listitem>
<listitem>
<simpara>During each iteration, the File publisher creates a fuzzed file.</simpara>
</listitem>
<listitem>
<simpara>The following image shows the output from a file fuzzing session that uses <emphasis>CleanupFolder</emphasis> on the <literal>clean2</literal> directory. The session duration is 5 iterations.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/Monitors/CleanupFolder_Cleaned.png"/>
</imageobject>
<textobject><phrase>CleanupFolder Cleaned</phrase></textobject>
</mediaobject>
</informalfigure>
</listitem>
<listitem>
<simpara>The following image shows the <literal>clean2</literal> directory with output from a file fuzzing session that does <emphasis>not</emphasis> use <emphasis>CleanupFolder</emphasis>, but is otherwise identical to the pit used for the previous diagram. Files generated in the fuzzing session are highlighted.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/Monitors/CleanupFolder_NotCleaned.png"/>
</imageobject>
<textobject><phrase>CleanupFolder NotCleaned</phrase></textobject>
</mediaobject>
</informalfigure>
</listitem>
</orderedlist>
<note>
<simpara>The FilePerIteration publisher, that generates a new filename for each fuzzed file, produced the fuzzed output files for both of the previous images.</simpara>
</note>
<section xml:id="_parameters_12">
<title>Parameters</title>
<simpara><emphasis>Required:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>Folder</term>
<listitem>
<simpara>Folder to clean.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Optional:</emphasis></simpara>
<simpara>None.</simpara>
</section>
<section xml:id="_examples_13">
<title>Examples</title>
<example>
<title>Remove contents of a folder<?asciidoc-br?></title>
<simpara>This parameter example is from a setup that uses the CleanupFolder monitor to remove a fuzzed file created by the File publisher.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="66.6667*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Value</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Folder</simpara></entry>
<entry align="left" valign="top"><simpara><literal>C:\clean2</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Monitors_CleanupRegistry">
<title>CleanupRegistry Monitor (Windows)</title>
<simpara><emphasis role="strong">Monitor Category</emphasis>: <emphasis role="strong">Automation</emphasis></simpara>
<simpara>The <emphasis>CleanupRegistry</emphasis> monitor provides automated cleanup of Windows registry
entries created during a fuzzing session. Cleanup occurs before every iteration.</simpara>
<simpara>This monitor uses a specified registry key (a parent key) as a reference point
and deletes all child keys or descendants of the parent key. All child keys at
all levels beneath the parent key are removed. Values attached to child keys are
removed as well.</simpara>
<simpara>Optionally, <emphasis>CleanupRegistry</emphasis> can include or exclude the parent key and values
attached to the parent key in its purge.</simpara>
<note>
<simpara>The Windows Registry is a hierarchical database that stores information about
the computer system, configuration, applications, current user settings, and
performance data. The contents and use of the registry has evolved since its
inception. Originally, the registry stored installation and initialization
settings for applications. On current versions of Windows, the registry contains
information for the current user, and much more, such as a list of external
serial ports that the machine has allocated.</simpara>
<simpara>One common use of the registry is to store a list of the most recently used
files used in an application. This list is typically displayed to a user to
improve the experience of selecting a file for the application to open.</simpara>
<simpara>The Windows registry consists of five hierarchies called hives, as shown in
the following illustration. Each hive consists of keys and values.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/Monitors/CleanupRegistry_Hives.png"/>
</imageobject>
<textobject><phrase>CleanupRegistry Hives</phrase></textobject>
</mediaobject>
</informalfigure>
<itemizedlist>
<listitem>
<simpara>A key is a container that can contain other keys and values. A key has a name,
a type, and optionally, a data value. The following illustration shows a selected
key. The complete name for this key is reported in the lower left corner.</simpara>
</listitem>
<listitem>
<simpara>A value is an item associated with a key that has a type, a data value, and
optionally, a name. In the following illustration, the named values defined for the
selected key are listed in the right side of the window.</simpara>
</listitem>
</itemizedlist>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/Monitors/CleanupRegistry_Values.png"/>
</imageobject>
<textobject><phrase>CleanupRegistry Values</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Each hive has one root key that is the entry point to the hive. These root keys
are the prefixes described for the <emphasis>CleanupRegistry</emphasis> <literal>Key</literal> parameter. The hives
used most often are <literal>HKCU</literal> and <literal>HKLM</literal>, but keys from other hives are accessible as well.</simpara>
<simpara>Locating a key in the registry is similar to locating a folder on disk. Start with
the root key and specify the sequence of keys you need to reach the desired key.
Separate keys with the back slash character "\", just like the folders in a path.</simpara>
<simpara>A root key, such as <literal>HKCU,</literal> has child keys; that is, the keys that it contains.
A non-root key, such as <literal>HKCU\Software</literal>, has a parent key (<literal>HKCU</literal>) and, optionally,
child keys. Note that <literal>HKCU</literal> is the parent key of <literal>Software</literal>. The key
<literal>HKCU\Software\Mozilla\FireFox</literal> also has two child keys or children (<literal>Crash Reporter</literal> and <literal>TaskBarIDs</literal>).</simpara>
<simpara>For more information, see
<link xl:href="http://en.wikipedia.org/wiki/Windows_Registry">Windows Registry</link>. Note the rich
bibliography, which can serve as a foundation for additional reading. Also, the
Microsoft Developer Network (MSDN) has several articles on the registry.</simpara>
</note>
<tip>
<simpara>In <emphasis>CleanupRegistry</emphasis>, you do not have control over individual values. You simply
identify the parent key, and specify whether you need to zap the parent key;
then let the monitor clean up around that registry key after each iteration.</simpara>
<simpara>Sometimes, applications keep lists of recently used files in the registry, typically
in the HKCU or HKLM hives. If you receive an error about not being able to create
a key in the registry, you might need to clear the children of a specified key.</simpara>
</tip>
<section xml:id="_parameters_13">
<title>Parameters</title>
<simpara><emphasis>Required:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>Key</term>
<listitem>
<simpara>Registry key to remove. The following <emphasis role="strong">key prefixes</emphasis> are used: <?asciidoc-br?>
   <emphasis role="strong">HKCU</emphasis> - Current user <?asciidoc-br?>
<emphasis role="strong">HKCC</emphasis> - Current configuration <?asciidoc-br?>
<emphasis role="strong">HKLM</emphasis> - Local machine <?asciidoc-br?>
<emphasis role="strong">HKPD</emphasis> - Performance data <?asciidoc-br?>
<emphasis role="strong">HKU</emphasis> - Users</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>ChildrenOnly</term>
<listitem>
<simpara>If true, omits the parent key from the purge, thereby deleting
all descendants (sub-keys) of the specified key.<?asciidoc-br?>
If false, the parent key and all descendants are deleted. Defaults to false.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_14">
<title>Examples</title>
<formalpara>
<title>Cleanup for Office<?asciidoc-br?></title>
<para>This parameter example is from a setup that uses the CleanupRegistry monitor to remove a specified key from the Windows Registry.</para>
</formalpara>
<informalexample>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="66.6667*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Value</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Key</simpara></entry>
<entry align="left" valign="top"><simpara><literal>HKLM\SOFTWARE\Office13\Recovery</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>The following image shows the portion of the registry that contains the key to delete.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/Monitors/CleanupRegistry_Delete.png"/>
</imageobject>
<textobject><phrase>CleanupRegistry Delete</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>This monitor deleted the key. The following image shows the same area of the registry after fuzzing and using the CleanupRegistry monitor.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/Monitors/CleanupRegistry_AfterDelete.png"/>
</imageobject>
<textobject><phrase>CleanupRegistry AfterDelete</phrase></textobject>
</mediaobject>
</informalfigure>
</informalexample>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Monitors_CrashReporter">
<title>CrashReporter Monitor (OS X)</title>
<simpara><emphasis role="strong">Monitor categories</emphasis>: <emphasis role="strong">Data collection</emphasis>, <emphasis role="strong">Fault detection</emphasis></simpara>
<simpara>The <emphasis>CrashReporter</emphasis> monitor collects and logs core dump information from crashes detected by the OS X System Crash Reporter.
Use <emphasis>CrashReporter</emphasis> when crashes can occur and you cannot use <link linkend="Monitors_CrashWrangler">CrashWrangler</link>.</simpara>
<simpara>The monitoring scope can focus on a single executable,
specified by setting the <emphasis role="strong">ProcessName</emphasis> parameter.
Or,
the monitoring scope can include all processes.
By default, all processes are monitored.</simpara>
<important>
<simpara>Before fuzzing,
make sure to disable the Apple crash report dialog window. When the fuzzing session ends, reenable the crash report dialog window.
Commands to disable and enable the crash report dialog window follow:</simpara>
<itemizedlist>
<listitem>
<simpara>Disable the crash report dialog:</simpara>
<simpara><literal>defaults write com.apple.CrashReporter DialogType none</literal></simpara>
</listitem>
<listitem>
<simpara>Enable the crash report dialog after fuzzing:</simpara>
<simpara><literal>defaults write com.apple.CrashReporter DialogType crashreport</literal></simpara>
</listitem>
</itemizedlist>
</important>
<section xml:id="_parameters_14">
<title>Parameters</title>
<simpara><emphasis>Required:</emphasis></simpara>
<simpara>None.</simpara>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>ProcessName</term>
<listitem>
<simpara>Name of the process to watch (optional, defaults to all)</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_15">
<title>Examples</title>
<example>
<title>Catch crashes from Movie Player<?asciidoc-br?></title>
<simpara>This parameter example is from a setup that monitors a movie player for OS X.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="66.6667*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Value</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>ProcessName</simpara></entry>
<entry align="left" valign="top"><simpara><literal>mplayer</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Monitors_CrashWrangler">
<title>CrashWrangler Monitor (OS X)</title>
<simpara><emphasis role="strong">Monitor Categories</emphasis>: <emphasis role="strong">Automation</emphasis>, <emphasis role="strong">Data collection</emphasis>, <emphasis role="strong">Fault detection</emphasis></simpara>
<important>
<simpara>The gdb debugger and <link linkend="Monitors_Gdb">gdb</link> monitor are the preferred tools to detect crashes and to collect core files on OS X.</simpara>
</important>
<simpara>The <emphasis>CrashWrangler</emphasis> monitor launches a process attached to the CrashWrangler debugger
and monitors the process for crashes and other faults. This monitor runs only on OS X
systems. Use this monitor when gdb is not an option, such as when anti-debugging
mechanisms are used on the test target.</simpara>
<simpara><emphasis>CrashWrangler</emphasis> monitor detects crashes, exceptions, access violations, and faults.
This monitor can generate faults for an application that exits early or that fails to exit.</simpara>
<simpara>After detecting a fault, the  <emphasis>CrashWrangler</emphasis> monitor collects a stack trace, data from
the device log files, and crash dumps. Additionally, the monitor logs exceptions, and
updates fault bucket information. For bucketing, Peach uses the text from the fault to
determine the major bucket level. The minor bucket level is not used. The risk
evaluation provides the following levels: exploitable, not exploitable, or unknown.</simpara>
<tip>
<simpara>This monitor uses Apple&#8217;s Crash Wrangler tool that can be downloaded from the
developer website. Crash Wrangler must be compiled on each machine it is used.</simpara>
<simpara>When using more than one instance of CrashWrangler in the same fuzzing session, assign unique names for the CwLockFile, CwLogFile, and CwPidFile files used with each instance of CrashWrangler. This practice will avoid contention issues involving these files.</simpara>
</tip>
<section xml:id="_parameters_15">
<title>Parameters</title>
<simpara><emphasis>Required:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>Executable</term>
<listitem>
<simpara>Command or application to launch. This parameter name is preferred over Command.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Command</term>
<listitem>
<simpara>Command to execute. Alias with Executable.</simpara>
</listitem>
</varlistentry>
</variablelist>
<note>
<simpara>The Command parameter is supported, but is being deprecated. Instead, use the Executable parameter.</simpara>
</note>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>Arguments</term>
<listitem>
<simpara>Command line arguments for the application that CrashWrangler launches, defaults to none.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>CwLockFile</term>
<listitem>
<simpara>CrashWrangler Lock file, defaults to <literal>cw.lock</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>CwLogFile</term>
<listitem>
<simpara>CrashWrangler Log file, defaults to <literal>cw.log</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>CwPidFile</term>
<listitem>
<simpara>CrashWrangler PID file, defaults to <literal>cw.pid</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>ExecHandler</term>
<listitem>
<simpara>Crash Wrangler execution handler program, defaults to <literal>exc_handler</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>ExploitableReads</term>
<listitem>
<simpara>Are read a/v&#8217;s considered exploitable? Defaults to false.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>FaultOnEarlyExit</term>
<listitem>
<simpara>Trigger a fault if the process exits prematurely, defaults to false.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>NoCpuKill</term>
<listitem>
<simpara>Disable process killing by CPU usage, Defaults to false.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>RestartAfterFault</term>
<listitem>
<simpara>If "true", restarts the target when any monitor detects a fault.
If "false", restarts the target only if the process exits or crashes.<?asciidoc-br?>
This argument defaults to true.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>RestartOnEachTest</term>
<listitem>
<simpara>Restarts the process for each iteration, defaults to false.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>StartOnCall</term>
<listitem>
<simpara>Start the executable on a state model call, defaults to none.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>UseDebugMalloc</term>
<listitem>
<simpara>Use the OS X Debug Malloc (slower), defaults to false.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>WaitForExitOnCall</term>
<listitem>
<simpara>Wait for the process to exit on a state model call and fault if a timeout occurs, defaults to none.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>WaitForExitTimeout</term>
<listitem>
<simpara>WaitForExitOnCall timeout value, expressed in milliseconds. -1 is infinite, defaults to 10000.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_16">
<title>Examples</title>
<example>
<title>Fuzzing Safari</title>
<simpara>This parameter example is from a setup that fuzzes the Safari browser on OS X.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="66.6667*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Value</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Executable</simpara></entry>
<entry align="left" valign="top"><simpara><literal>/Applications/Safari.app/Contents/MacOS/Safari</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Arguments</simpara></entry>
<entry align="left" valign="top"><simpara><literal>fuzzed.bin</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>UseDebugMalloc</simpara></entry>
<entry align="left" valign="top"><simpara><literal>true</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>ExploitableReads</simpara></entry>
<entry align="left" valign="top"><simpara><literal>true</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>ExecHandler</simpara></entry>
<entry align="left" valign="top"><simpara><literal>./exc_handler</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>StartOnCall</simpara></entry>
<entry align="left" valign="top"><simpara><literal>ScoobySnacks</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Monitors_Gdb">
<title>Gdb Monitor (Linux, OS X)</title>
<simpara><emphasis role="strong">Monitor Categories</emphasis>: <emphasis role="strong">Automation</emphasis>, <emphasis role="strong">Data collection</emphasis>, <emphasis role="strong">Fault detection</emphasis></simpara>
<simpara>The <emphasis>Gdb</emphasis> monitor uses GDB to launch an executable. It then monitors the executing process for specific signals/exceptions.
<emphasis>Gdb</emphasis> is the main debugger for Linux and OS X operating systems.</simpara>
<simpara>When a configured signal/exception is handled,
<emphasis>Gdb</emphasis> collects and logs information about the crash including frame information, registers and backtrace.</simpara>
<simpara><emphasis>Gdb</emphasis> supports bucketing of crashes and basic risk ranking that is based on the exploitability of the fault. Bucketing uses categories for major and minor issues.
The exploitability evaluation is similar to the !exploitable debugging extension for .NET.</simpara>
<simpara>For GDB Server support see the <link linkend="Monitors_GdbServer">GdbServer</link> monitor.</simpara>
<note>
<simpara>The <emphasis>Gdb</emphasis> monitor requires a recent version of GDB.</simpara>
</note>
<section xml:id="_parameters_16">
<title>Parameters</title>
<simpara><emphasis>Required:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>Executable</term>
<listitem>
<simpara>Executable to launch. This should be just the executable. Command line arguments can be provided using the optional <emphasis>Arguments</emphasis> parameter.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>Arguments</term>
<listitem>
<simpara>Command line arguments for the executable.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>FaultOnEarlyExit</term>
<listitem>
<simpara>Trigger a fault if the process exits prematurely, defaults to <literal>false</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>GdbPath</term>
<listitem>
<simpara>Path to <literal>gdb</literal>, defaults to <literal>/usr/bin/gdb</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>HandleSignals</term>
<listitem>
<simpara>Signals to consider faults.
Space separated list of signals/exceptions to handle as fautls.
Defaults to: SIGSEGV SIGFPE SIGABRT SIGILL SIGPIPE SIGBUS SIGSYS SIGXCPU SIGXFSZ EXC_BAD_ACCESS EXC_BAD_INSTRUCTION EXC_ARITHMETIC</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>NoCpuKill</term>
<listitem>
<simpara>Disable process killing when the CPU usage nears zero, defaults to <literal>false</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>RestartAfterFault</term>
<listitem>
<simpara>If <literal>true</literal>, restarts the target when any monitor detects a fault.
If <literal>false</literal>, restarts the target only if the process exits or crashes.
This argument defaults to <literal>true</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>RestartOnEachTest</term>
<listitem>
<simpara>Restarts the process for each iteration, defaults to <literal>false</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Script</term>
<listitem>
<simpara>Script file used to drive GDB and perform crash analysis.
This script sets up GDB to run the target application, report back information such as child pid, and handle any signals.
This script also performs crash anlysis and bucketing.
An example script is provided in the examples section.</simpara>
<simpara>The script is a Mushtache style template with the following available parameters:</simpara>
<variablelist>
<varlistentry>
<term>executable</term>
<listitem>
<simpara>Maps to the Executable parameter</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>arguments</term>
<listitem>
<simpara>Maps to the Arguments parameter</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>exploitableScript</term>
<listitem>
<simpara>Default crash analysis and bucketing script</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>faultOnEarlyExit</term>
<listitem>
<simpara>Maps to the FaultOnEarlyExit parameter</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>gdbLog</term>
<listitem>
<simpara>Log file used to record information that will be logged with any fault</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>gdbCmd</term>
<listitem>
<simpara>This script file after being processed by Mushtache</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>gdbPath</term>
<listitem>
<simpara>Maps to the GdbPath parameter</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>gdbPid</term>
<listitem>
<simpara>Pid file generated by script at start of executable</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>gdbTempDir</term>
<listitem>
<simpara>Temporary directory to hold generated data</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>handleSignals</term>
<listitem>
<simpara>Maps to the HandleSignals parameter</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>noCpuKill</term>
<listitem>
<simpara>Maps to the NoCpuKill parameter</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>restartOnEachTest</term>
<listitem>
<simpara>Maps to the RestartOnEachTest parameter</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>restartAfterFault</term>
<listitem>
<simpara>Maps to the RestartAfterFault parameter</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>startOnCall</term>
<listitem>
<simpara>Maps to the StartOnCall parameter</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>waitForExitOnCall</term>
<listitem>
<simpara>Maps to the WaitForExitOnCall parameter</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>waitFOrExitTimeout</term>
<listitem>
<simpara>Maps to the WaitForExitTimeout parameter</simpara>
</listitem>
</varlistentry>
</variablelist>
</listitem>
</varlistentry>
<varlistentry>
<term>StartOnCall</term>
<listitem>
<simpara>Start the executable on a state model call.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>WaitForExitOnCall</term>
<listitem>
<simpara>Wait for the process to exit on a state model call and fault if a timeout is reached.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>WaitForExitTimeout</term>
<listitem>
<simpara>WaitForExitOnCall timeout value, expressed in milliseconds. <literal>-1</literal> is infinite, defaults to <literal>10000</literal>.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_gdb_installation">
<title>Gdb Installation</title>
<simpara>Installing <literal>gdb</literal> on Linux consists of using the package manager to download and install the <literal>gdb</literal> debugger and the needed support files and libraries.</simpara>
<itemizedlist>
<listitem>
<simpara>For Ubuntu systems, run the following command install <literal>gdb</literal>:</simpara>
<screen>sudo apt-get install gdb</screen>
</listitem>
<listitem>
<simpara>For CentOS and RedHat Enterprise Linux installations, run the following command to install <literal>gdb</literal>:</simpara>
<screen>sudo yum install gdb</screen>
</listitem>
<listitem>
<simpara>For SUSE Enterprise Linux installations, run the following command to install <literal>gdb</literal>:</simpara>
<screen>sudo zypper install gdb</screen>
</listitem>
</itemizedlist>
<simpara>You can also install <literal>gdb</literal> on OS X using a package manager. See the <link xl:href="http://ntraft.com/installing-gdb-on-os-x-mavericks/">Installing GDB on OS X Mavericks</link> article for more information.</simpara>
</section>
<section xml:id="_examples_17">
<title>Examples</title>
<example>
<title>Script Example</title>
<simpara>This is an example <literal>Script</literal> for driving GDB.</simpara>
<simpara>The <emphasis>Gdb</emphasis> monitor expects specific output that the included exploit analysis to generate the fault title, risk and bucket hashes.</simpara>
<simpara>The following regular expressions are used to extract information from log.  If replacing the crash analysis portion of the script make sure to output to allow the first three regexes to pass.</simpara>
<literallayout class="monospaced">"^Hash: (\w+)\.(\w+)$"  -- Major and Minor bucket
"^Exploitability Classification: (.*)$" -- Risk
"^Short description: (.*)$" -- Title
"^Other tags: (.*)$" -- If found, added to Title</literallayout>
<simpara>Script:</simpara>
<screen>define log_if_crash
 if ($_thread != 0x00)
  printf "Crash detected, running exploitable.\n"
  set logging overwrite on
  set logging redirect on
  set logging on {{gdbLog}}                 <co xml:id="CO2-1"/>
  exploitable -v                            <co xml:id="CO2-2"/>
  printf "\n--- Info Frame ---\n\n"
  info frame
  printf "\n--- Info Registers ---\n\n"
  info registers
  printf "\n--- Backtrace ---\n\n"
  thread apply all bt full
  set logging off
 end
end

handle all nostop noprint
handle {{handleSignals}} stop print

file {{executable}}
set args {{arguments}}
source {{exploitableScript}}

python
def on_start(evt):
    import tempfile, os
    h,tmp = tempfile.mkstemp()
    os.close(h)
    with open(tmp, 'w') as f:
        f.write(str(gdb.inferiors()[0].pid))
    os.renames(tmp, '{{gdbPid}}')           <co xml:id="CO2-3"/>
    gdb.events.cont.disconnect(on_start)
gdb.events.cont.connect(on_start)
end

printf "starting inferior: '{{executable}} {{arguments}}'\n"

run
log_if_crash
quit</screen>
<calloutlist>
<callout arearefs="CO2-3">
<para>Must generate <emphasis>gdbPid</emphasis> when target has been started</para>
</callout>
<callout arearefs="CO2-1">
<para>Must generate <emphasis>gdbLog</emphasis> when a fault has been handled</para>
</callout>
<callout arearefs="CO2-2">
<para>Generates output compatable with regexes</para>
</callout>
</calloutlist>
</example>
<example>
<title>Base Usage Example+</title>
<simpara>This parameter example is from a typical setup where a state model call triggers launching of the executable.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="66.6667*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Value</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Executable</simpara></entry>
<entry align="left" valign="top"><simpara><literal>/usr/bin/curl</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Arguments</simpara></entry>
<entry align="left" valign="top"><simpara><literal>http://localhost</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>StartOnCall</simpara></entry>
<entry align="left" valign="top"><simpara><literal>ScoobySnacks</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Monitors_GdbServer">
<title>GdbServer Monitor (Linux, OS X)</title>
<simpara><emphasis role="strong">Monitor Categories</emphasis>: <emphasis role="strong">Automation</emphasis>, <emphasis role="strong">Data collection</emphasis>, <emphasis role="strong">Fault detection</emphasis></simpara>
<simpara>The <emphasis>GdbServer</emphasis> monitor uses GDB to access a remote debugger that implements the gdb server protocol. This can be <literal>gdbserver</literal> or any other implementation.
This monitor also supportes the multi mode of the extended <literal>gdbserver</literal> protocol via the <emphasis>RemoteExecutable</emphasis> parameter.</simpara>
<simpara>When a configured signal/exception is handled,
<emphasis>GdbServer</emphasis> collects and logs information about the crash including frame information, registers and backtrace.</simpara>
<simpara><emphasis>GdbServer</emphasis> supports bucketing of crashes and basic risk ranking that is based on the exploitability of the fault. Bucketing uses categories for major and minor issues.
The exploitability evaluation is similar to the !exploitable debugging extension for .NET.</simpara>
<simpara>For normal GDB support see the <link linkend="Monitors_Gdb">Gdb</link> monitor.</simpara>
<note>
<simpara>The <emphasis>GdbServer</emphasis> monitor requires a recent version of GDB.</simpara>
</note>
<section xml:id="_parameters_17">
<title>Parameters</title>
<simpara><emphasis>Required:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>Target</term>
<listitem>
<simpara>GDB target command arguments.
Example: <literal>remote 192.168.1.2:6000</literal>.</simpara>
<simpara>When possible use the extended-remote version: <literal>extended-remote IP:PORT</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>LocalExecutable</term>
<listitem>
<simpara>Local copy of executable remote target is running.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>RemoteExecutable</term>
<listitem>
<simpara>Enables multi-process capabilities in the extended gdb server protocol. Provides the remote executable name to load and run. This is the remote exec file-name.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>FaultOnEarlyExit</term>
<listitem>
<simpara>Trigger a fault if the process exits prematurely, defaults to <literal>false</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>GdbPath</term>
<listitem>
<simpara>Path to <literal>gdb</literal>, defaults to <literal>/usr/bin/gdb</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>HandleSignals</term>
<listitem>
<simpara>Signals to consider faults.
Space separated list of signals/exceptions to handle as fautls.
Defaults to: SIGSEGV SIGFPE SIGABRT SIGILL SIGPIPE SIGBUS SIGSYS SIGXCPU SIGXFSZ EXC_BAD_ACCESS EXC_BAD_INSTRUCTION EXC_ARITHMETIC</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>NoCpuKill</term>
<listitem>
<simpara>Disable process killing when the CPU usage nears zero, defaults to <literal>false</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>RestartAfterFault</term>
<listitem>
<simpara>If <literal>true</literal>, restarts the debugger when any monitor detects a fault.
If <literal>false</literal>, restarts the debugger only if the process exits or crashes.
This argument defaults to <literal>true</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>RestartOnEachTest</term>
<listitem>
<simpara>Restarts the process for each iteration, defaults to <literal>false</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Script</term>
<listitem>
<simpara>Script file used to drive GDB and perform crash analysis.
This script sets up GDB to run the target application, report back information such as child pid, and handle any signals.
This script also performs crash anlysis and bucketing.
An example script is provided in the examples section.</simpara>
<simpara>The script is a Mushtache style template with the following available parameters:</simpara>
<variablelist>
<varlistentry>
<term>exploitableScript</term>
<listitem>
<simpara>Default crash analysis and bucketing script</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>faultOnEarlyExit</term>
<listitem>
<simpara>Maps to the FaultOnEarlyExit parameter</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>gdbLog</term>
<listitem>
<simpara>Log file used to record information that will be logged with any fault</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>gdbCmd</term>
<listitem>
<simpara>This script file after being processed by Mushtache</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>gdbPath</term>
<listitem>
<simpara>Maps to the GdbPath parameter</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>gdbPid</term>
<listitem>
<simpara>Pid file generated by script at start of executable</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>gdbTempDir</term>
<listitem>
<simpara>Temporary directory to hold generated data</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>handleSignals</term>
<listitem>
<simpara>Maps to the HandleSignals parameter</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>localExecutable</term>
<listitem>
<simpara>Maps to the LocalExecutableParameter</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>noCpuKill</term>
<listitem>
<simpara>Maps to the NoCpuKill parameter</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>remoteExecutable</term>
<listitem>
<simpara>Maps to the RemoteExecutable parameter</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>restartOnEachTest</term>
<listitem>
<simpara>Maps to the RestartOnEachTest parameter</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>restartAfterFault</term>
<listitem>
<simpara>Maps to the RestartAfterFault parameter</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>startOnCall</term>
<listitem>
<simpara>Maps to the StartOnCall parameter</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>target</term>
<listitem>
<simpara>Maps to the Target parameter</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>waitForExitOnCall</term>
<listitem>
<simpara>Maps to the WaitForExitOnCall parameter</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>waitFOrExitTimeout</term>
<listitem>
<simpara>Maps to the WaitForExitTimeout parameter</simpara>
</listitem>
</varlistentry>
</variablelist>
</listitem>
</varlistentry>
<varlistentry>
<term>StartOnCall</term>
<listitem>
<simpara>Start the executable on a state model call.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>WaitForExitOnCall</term>
<listitem>
<simpara>Wait for the process to exit on a state model call and fault if a timeout is reached.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>WaitForExitTimeout</term>
<listitem>
<simpara>WaitForExitOnCall timeout value, expressed in milliseconds. <literal>-1</literal> is infinite, defaults to <literal>10000</literal>.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_gdb_installation_2">
<title>Gdb Installation</title>
<simpara>Installing <literal>gdb</literal> on Linux consists of using the package manager to download and install the <literal>gdb</literal> debugger and the needed support files and libraries.</simpara>
<itemizedlist>
<listitem>
<simpara>For Ubuntu systems, run the following command install <literal>gdb</literal>:</simpara>
<screen>sudo apt-get install gdb</screen>
</listitem>
<listitem>
<simpara>For CentOS and RedHat Enterprise Linux installations, run the following command to install <literal>gdb</literal>:</simpara>
<screen>sudo yum install gdb</screen>
</listitem>
<listitem>
<simpara>For SUSE Enterprise Linux installations, run the following command to install <literal>gdb</literal>:</simpara>
<screen>sudo zypper install gdb</screen>
</listitem>
</itemizedlist>
<simpara>You can also install <literal>gdb</literal> on OS X using a package manager. See the <link xl:href="http://ntraft.com/installing-gdb-on-os-x-mavericks/">Installing GDB on OS X Mavericks</link> article for more information.</simpara>
</section>
<section xml:id="_examples_18">
<title>Examples</title>
<example>
<title>Script Example</title>
<simpara>This is an example <literal>Script</literal> for driving GDB.</simpara>
<simpara>The <emphasis>GdbServer</emphasis> monitor expects specific output that the included exploit analysis to generate the fault title, risk and bucket hashes.</simpara>
<simpara>The following regular expressions are used to extract information from log.  If replacing the crash analysis portion of the script make sure to output to allow the first three regexes to pass.</simpara>
<literallayout class="monospaced">"^Hash: (\w+)\.(\w+)$"  -- Major and Minor bucket
"^Exploitability Classification: (.*)$" -- Risk
"^Short description: (.*)$" -- Title
"^Other tags: (.*)$" -- If found, added to Title</literallayout>
<simpara>Script:</simpara>
<screen>define log_if_crash
 if ($_thread != 0x00)
  printf "Crash detected, running exploitable.\n"
  set logging overwrite on
  set logging redirect on
  set logging on {{gdbLog}}                 <co xml:id="CO3-1"/>
  exploitable -v                            <co xml:id="CO3-2"/>
  printf "\n--- Info Frame ---\n\n"
  info frame
  printf "\n--- Info Registers ---\n\n"
  info registers
  printf "\n--- Backtrace ---\n\n"
  thread apply all bt full
  set logging off
 end
end

handle all nostop noprint
handle {{handleSignals}} stop print

file {{executable}}
source {{exploitableScript}}

python

import sys

def on_start(evt):
    import tempfile, os
    h,tmp = tempfile.mkstemp()
    os.close(h)
    with open(tmp, 'w') as f:
        f.write(str(gdb.inferiors()[0].pid))
    os.renames(tmp, '{{gdbPid}}')           <co xml:id="CO3-3"/>
    gdb.events.cont.disconnect(on_start)

gdb.events.cont.connect(on_start)

print("starting inferior: '{{target}} {{remoteExecutable}}'")

try:
  if len('{{remoteExecutable}}') &gt; 1:
    print('starting in extended-remote, multi-process mode')
    gdb.execute('set remote exec-file {{remoteExecutable}}')
    gdb.execute('target {{target}}')
    gdb.execute('run')
  else:
    gdb.execute('target {{target}}')
    gdb.execute('continue')

except:
  e = sys.exc_info()[1]
  print('Exception starting target: ' + str(e))
  import tempfile, os
  h,tmp = tempfile.mkstemp()
  os.close(h)
  with open(tmp, 'w') as f:
    f.write(str(e))
  os.renames(tmp, '{{gdbConnectError}}')  <co xml:id="CO3-4"/>
  gdb.execute('quit')

end

log_if_crash
quit</screen>
<calloutlist>
<callout arearefs="CO3-3">
<para>Must generate <emphasis>gdbPid</emphasis> when target has been started</para>
</callout>
<callout arearefs="CO3-1">
<para>Must generate <emphasis>gdbLog</emphasis> when a fault has been handled</para>
</callout>
<callout arearefs="CO3-4">
<para>On remote connection error, output the error message to <emphasis>gdbConnectError</emphasis></para>
</callout>
<callout arearefs="CO3-2">
<para>Generates output compatable with regexes</para>
</callout>
</calloutlist>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Monitors_IpPower9258">
<title>IpPower9258 Monitor</title>
<simpara><emphasis role="strong">Monitor Category</emphasis>: <emphasis role="strong">Automation</emphasis></simpara>
<simpara>The <emphasis>IpPower9258</emphasis> monitor controls an IP Power 9258 Network Power Controller (IP9258).
The IP9258 consists of four three-prong outlets that support electrical loads of 6 amps at 110 or 240 VAC.
Communications between Peach and the IP9258 uses Ethernet cabling.
This monitor allows devices plugged into the IP Power 9258 switch to be powered on/off during fuzzing.</simpara>
<simpara>Each <emphasis>IpPower9258</emphasis> monitor switches an individual outlet.
Use one monitor per outlet to control multiple outlets concurrently.
The monitor can toggle power on an outlet at the following points in time:</simpara>
<itemizedlist>
<listitem>
<simpara>At the start or end of a fuzzing run</simpara>
</listitem>
<listitem>
<simpara>At the start or end of each test iteration</simpara>
</listitem>
<listitem>
<simpara>During the detection of a fault</simpara>
</listitem>
<listitem>
<simpara>After detecting a fault</simpara>
</listitem>
<listitem>
<simpara>At the start of an iteration that immediately follows a fault</simpara>
</listitem>
<listitem>
<simpara>When a specified call is received from the state model</simpara>
</listitem>
</itemizedlist>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/Monitors/IpPower9258.png"/>
</imageobject>
<textobject><phrase>IpPower9258</phrase></textobject>
</mediaobject>
</informalfigure>
<tip>
<simpara>Peach also supports power distribution units that can be
controlled using SNMPv1. For APC PDUs use the
<link linkend="Monitors_ApcPower">APC Power Monitor</link>, and for others try the
<link linkend="Monitors_SnmpPower">SNMP Power Monitor</link>. To control power to a
device by wiring through a relay, Peach provides the
<link linkend="Monitors_CanaKitRelay">CanaKit 4-Port USB Relay Monitor</link>.</simpara>
</tip>
<section xml:id="_parameters_18">
<title>Parameters</title>
<simpara><emphasis>Required:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>Host</term>
<listitem>
<simpara>Host or IP address (can include HTTP interface port e.g. :8080)</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Port</term>
<listitem>
<simpara>Port/Outlet to reset (1, 2, 3, 4)</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>User</term>
<listitem>
<simpara>Username to be used when connecting to the IP Power 9258 device.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Password</term>
<listitem>
<simpara>Password to be used when connecting to the IP Power 9258 device.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>StartOnCall</term>
<listitem>
<simpara>Toggle power when the specified call is received from the state model.
This value is used only when the <emphasis>When</emphasis> parameter is set to <literal>OnCall</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>PowerOnOffPause</term>
<listitem>
<simpara>Pause in milliseconds between power off/power on, default is <literal>500</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>PowerOffOnEnd</term>
<listitem>
<simpara>Power off when the fuzzing session completes, default is <literal>false</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>When</term>
<listitem>
<simpara>Specify one of the following values to determine when a port should be toggled:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="66.6667*"/>
<thead>
<row>
<entry align="left" valign="top">"When" Setting</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>DetectFault</simpara></entry>
<entry align="left" valign="top"><simpara>Toggle power when checking for a fault.
This occurs after OnIterationEnd.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>OnStart</simpara></entry>
<entry align="left" valign="top"><simpara>Toggle power when the fuzzing session starts.
This occurs once per session.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>OnEnd</simpara></entry>
<entry align="left" valign="top"><simpara>Toggle power when the fuzzing session stops.
This occurs once per session.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>OnIterationStart</simpara></entry>
<entry align="left" valign="top"><simpara>Toggle power at the start of each iteration.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>OnIterationEnd</simpara></entry>
<entry align="left" valign="top"><simpara>Toggle power at the end of each iteration.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>OnFault</simpara></entry>
<entry align="left" valign="top"><simpara>Toggle power when any monitor detects a fault.
This is the default setting.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>OnIterationStartAfterFault</simpara></entry>
<entry align="left" valign="top"><simpara>Toggle power at the start of an iteration that immediately follows a fault detection.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>OnCall</simpara></entry>
<entry align="left" valign="top"><simpara>Toggle power when the call specified by the <emphasis>StartOnCall</emphasis> parameter is received from the state model.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<figure>
<title>When Choices for Performing an Action</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/Monitors/Timings_SSH.png"/>
</imageobject>
<textobject><phrase>Timings SSH</phrase></textobject>
</mediaobject>
</figure>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_19">
<title>Examples</title>
<example>
<title>Catch crashes from Movie Player<?asciidoc-br?></title>
<simpara>This parameter example is from a setup that controls port 1 of a IP Power 9258 Network Power Controller.
After a fault is detected,
the monitor toggles the power on port 1.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="66.6667*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Value</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Host</simpara></entry>
<entry align="left" valign="top"><simpara><literal>192.168.1.1:8080</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Port</simpara></entry>
<entry align="left" valign="top"><simpara><literal>1</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>User</simpara></entry>
<entry align="left" valign="top"><simpara><literal>peach</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Password</simpara></entry>
<entry align="left" valign="top"><simpara><literal>power</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Monitors_LinuxCoreFile">
<title>LinuxCoreFile Monitor (Linux)</title>
<simpara><emphasis role="strong">Monitor Categories</emphasis>: <emphasis role="strong">Data collection</emphasis>, <emphasis role="strong">Fault detection</emphasis></simpara>
<important>
<simpara>The <literal>gdb</literal> debugger and <link linkend="Monitors_Gdb">Gdb Monitor</link> are the preferred tools to detect crashes and to collect core files on Linux.</simpara>
<simpara>This monitor runs only on Linux systems.
Use this monitor when <literal>gdb</literal> is not an option,
such as when anti-debugging mechanisms are used on the test target.</simpara>
</important>
<simpara>The <emphasis>LinuxCoreFile</emphasis> monitor detects when a process crashes and collects the resulting core file.
The monitoring scope includes all processes by default, but can focus on a single executable.</simpara>
<simpara>This monitor runs for the entire fuzzing session and uses the Linux crash recording facility.
When a crash occurs,
the <emphasis>LinuxCoreFile</emphasis> monitor pulls the logging information and available core files,
and sets the bucketing information.
The major bucket is based on the name of the crashed executable,
and the minor bucket is a constant value based on the string "CORE".</simpara>
<simpara>At the end of the session,
<emphasis>LinuxCoreFile</emphasis> restores the saved state and removes the logging folder.</simpara>
<simpara>Because the <emphasis>LinuxCoreFile</emphasis> monitor registers a custom core file handler with the Linux kernel,
only one instance of the monitor is allowed to run on a host at any given time.</simpara>
<formalpara>
<title><emphasis role="strong">Setup Requirements</emphasis></title>
<para>This monitor has the following setup requirements:</para>
</formalpara>
<itemizedlist>
<listitem>
<simpara><emphasis>LinuxCoreFile</emphasis> requires root or equivalent privileges to run.
The <emphasis>LinuxCoreFile</emphasis> monitor registers a script with the kernel to catch core dumps of faulting processes.</simpara>
</listitem>
<listitem>
<simpara>Core files must be enabled.
If the maximum core file size in the system is zero, no core files are created.
You can enable core file generation using the following process:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Find the current core file hard and soft limits in use by the operating system.
The hard limit is an absolute maximum that,
once set,
cannot be increased during a session.
The soft limit is the current maximum file size that you can adjust up to the value of the hard limit.
If the hard limit or the soft limit is set to zero,
core files are disabled.</simpara>
<itemizedlist>
<listitem>
<simpara>You can display the core file hard limit using the following command:</simpara>
<screen>ulimit -Hc</screen>
</listitem>
<listitem>
<simpara>You can display the current core file soft limit using the following command:</simpara>
<screen>ulimit -Sc</screen>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Set the core file hard limit using the following command.
You can specify <literal>unlimited</literal> or a numeric value that represents the number of 512-byte blocks to allow in a core file:</simpara>
<screen>ulimit -Hc unlimited</screen>
</listitem>
<listitem>
<simpara>Set the core file soft limit using the following command.
You can specify any value less than or equal to the hard limit.</simpara>
<screen>ulimit -Sc unlimited</screen>
<simpara>The hard and soft limits can be added to <literal>/etc/sysctl.conf</literal>.
Then, whenever this file loads, appropriate core file limits are specified.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara><literal>gdb</literal> must be installed to analyze the resulting core files.
For information on installing <literal>gdb</literal>, see the <link linkend="Monitors_Gdb">Gdb Monitor</link>.</simpara>
</listitem>
</itemizedlist>
<section xml:id="_parameters_19">
<title>Parameters</title>
<simpara><emphasis>Required:</emphasis></simpara>
<simpara>None.</simpara>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>Executable</term>
<listitem>
<simpara>Target executable process,
used to filter crashes,
defaults to all processes.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>LogFolder</term>
<listitem>
<simpara>Folder with log files,
defaults to <literal>/var/peachcrash</literal>.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_20">
<title>Examples</title>
<example>
<title>Catch crashes from Movie Player<?asciidoc-br?></title>
<simpara>This parameter example is from a setup that monitors a movie player in Linux.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="66.6667*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Value</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Executable</simpara></entry>
<entry align="left" valign="top"><simpara><literal>mplayer</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Monitors_MemoryMonitor">
<title>Memory Monitor</title>
<simpara><emphasis role="strong">Monitor Category</emphasis>:  <emphasis role="strong">Data collection</emphasis>, <emphasis role="strong">Fault detection</emphasis></simpara>
<simpara>The <emphasis>Memory</emphasis> monitor provides two modes of operation:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Data collection</simpara>
<simpara>When the <emphasis>MemoryLimit</emphasis> is <literal>0</literal>,
the monitor will collect memory metrics at the end of each iteration.
If a fault is triggered by another monitor,
the collected memory metrics will be stored as <literal>Usage.txt</literal> in the fault&#8217;s data bundle.</simpara>
</listitem>
<listitem>
<simpara>Fault detection</simpara>
<simpara>When the <emphasis>MemoryLimit</emphasis> is &gt; <literal>0</literal>,
the monitor will initiate a fault when the memory usage for the process being monitored exceeds the specified limit.</simpara>
</listitem>
</orderedlist>
<simpara>The reported metrics for this monitor include the following items:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Private memory size</emphasis> -
Number of bytes allocated for the process.
An approximate number of bytes a process is using.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Working set memory</emphasis> -
Total physical memory used by the process, consisting of in-memory private bytes plus memory-mapped files,
such as DLLs.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Peak working set</emphasis> -
Largest working set used by the process.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Virtual memory size</emphasis> -
Total address space occupied by the entire process,
including the working set plus paged private bytes and the standby list.</simpara>
</listitem>
</itemizedlist>
<note>
<simpara>This monitor requires that you set a memory limit and identify a process to monitor,
specifying the process by name or by process id.</simpara>
</note>
<section xml:id="_parameters_20">
<title>Parameters</title>
<simpara><emphasis>Required:</emphasis></simpara>
<simpara>Either one of <emphasis>Pid</emphasis> or <emphasis>ProcessName</emphasis> is required.
It is an error to specify both.</simpara>
<variablelist>
<varlistentry>
<term>Pid</term>
<listitem>
<simpara>Process ID to monitor.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>ProcessName</term>
<listitem>
<simpara>Name of the process to monitor.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>MemoryLimit</term>
<listitem>
<simpara>A value specified in bytes.</simpara>
<simpara>When <literal>0</literal> is specified,
enable data collection mode,
which causes memory metrics to be collected
at the end of every iteration.</simpara>
<simpara>When a value greater than <literal>0</literal> is specified,
enable fault detection mode,
which causes a fault to occur if the memory usage of the monitored process exceeds the specified limit.</simpara>
<simpara>Defaults to <literal>0</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>StopOnFault</term>
<listitem>
<simpara>Stop fuzzing if a fault is triggered, defaults to <literal>false</literal>.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_21">
<title>Examples</title>
<example>
<title>Monitor memory usage of Notepad</title>
<simpara>This parameter example is from a setup that monitors memory usage of Notepad.
It is configured to generate a fault if memory usage exceeds 10MB.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="66.6667*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Value</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>MemoryLimit</simpara></entry>
<entry align="left" valign="top"><simpara><literal>10000000</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>ProcessName</simpara></entry>
<entry align="left" valign="top"><simpara><literal>Notepad</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Monitors_NetworkCapture">
<title>NetworkCapture Monitor</title>
<simpara><emphasis role="strong">Monitor Categories</emphasis>: <emphasis role="strong">Data collection</emphasis>, <emphasis role="strong">Fault detection</emphasis></simpara>
<simpara>The <emphasis>NetworkCapture</emphasis> monitor performs network captures during the fuzzing iteration.
When a packet arrives,
this monitor writes the content into a file,
increments the received packet count,
and waits for the next packet to arrive.
If a filter is used,
the captured packets and associated packet count are for packets that pass the filtering criteria.</simpara>
<simpara>The captured data begins afresh for each iteration.
If a fault occurs,
the captured data is logged as a <literal>.pcap</literal> file and returned with the fault data.
The <literal>.pcap</literal> file is compatible with Wireshark and <literal>tcpdump</literal>.
A sample capture follows:</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/Monitors/NetworkCapture.png"/>
</imageobject>
<textobject><phrase>NetworkCapture</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Peach supports multiple <emphasis>NetworkCapture</emphasis> monitors in the same pit,
as well as simple and compound packet filters in a single monitor.
A compound packet filter consists of more than one packet filter joined by AND or OR.</simpara>
<note>
<simpara>A packet filter is a boolean value applied to a packet.
If the result of the operation is true,
the packet is accepted.
If the result is false,
the packet is ignored.</simpara>
<simpara>The main benefit of using filters is performance.
Applying a filter to a packet produces a smaller dataset, resulting in faster processing time for each iteration.</simpara>
<simpara>Two strategies for developing effective filters:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Develop a filter that pinpoints the packets to process.</simpara>
</listitem>
<listitem>
<simpara>Develop a filter that prunes unwanted packets using negative logic.</simpara>
</listitem>
</orderedlist>
<simpara>Generally,
using one monitor with a complex filter is better than using two monitors with simpler filters.
Using one monitor places all the packets in a single file with an order of arrival.
Using multiple monitors makes correlating arrival more difficult because each monitor has its own file to keep the processed packets.</simpara>
<simpara>For information on filter strings,
see the following:</simpara>
<itemizedlist>
<listitem>
<simpara><link xl:href="http://www.infosecwriters.com/text_resources/pdf/JStebelton_BPF.pdf">Berkely Packet Filters - The Basics</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="http://www.tcpdump.org/manpages/tcpdump.1.html">tcpdump man page</link></simpara>
</listitem>
</itemizedlist>
</note>
<section xml:id="_parameters_21">
<title>Parameters</title>
<simpara><emphasis>Required:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>Device</term>
<listitem>
<simpara>Device name or port where the packet capture takes place.</simpara>
</listitem>
</varlistentry>
</variablelist>
<note>
<simpara>The Peach command line option <literal>--showdevices</literal> causes Peach to generate a list of all available network interfaces.</simpara>
<itemizedlist>
<listitem>
<simpara>On Windows platforms, the <literal>ipconfig</literal> utility lists the network devices.</simpara>
</listitem>
<listitem>
<simpara>On Unix platforms, the <literal>ifconfig</literal> utility lists the network devices.</simpara>
</listitem>
</itemizedlist>
</note>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>Filter</term>
<listitem>
<simpara>PCAP style filter string.
If present,
the filter restricts capture to packets that match the filter string.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_22">
<title>Examples</title>
<example>
<title>Show the network devices from <literal>ipconfig</literal></title>
<simpara>This example uses <literal>ipconfig</literal> from the Windows command line to list the available network devices on the
system.
The device names follow:</simpara>
<itemizedlist>
<listitem>
<simpara>Local Area Connection</simpara>
</listitem>
<listitem>
<simpara>Wi-Fi</simpara>
</listitem>
<listitem>
<simpara>Ethernet</simpara>
</listitem>
<listitem>
<simpara>VMware Network Adapter VMnet1</simpara>
</listitem>
<listitem>
<simpara>VMware Network Adapter VMnet8</simpara>
</listitem>
</itemizedlist>
<simpara>Type the following command and press ENTER.</simpara>
<screen>&gt;ipconfig

The list of devices follows:

Windows IP Configuration

Wireless LAN adapter Local Area Connection:

   Media State . . . . . . . . . . . : Media disconnected
   Connection-specific DNS Suffix  . :

Wireless LAN adapter Wi-Fi:

   Media State . . . . . . . . . . . : Media disconnected
   Connection-specific DNS Suffix  . :

Ethernet adapter Ethernet:

   Connection-specific DNS Suffix  . :
   Link-local IPv6 Address . . . . . : fe80::d0ef:e30b:2d5c:12c5%3
   IPv4 Address. . . . . . . . . . . : 10.0.1.47
   Subnet Mask . . . . . . . . . . . : 255.255.255.0
   Default Gateway . . . . . . . . . : 10.0.1.1

Ethernet adapter VMware Network Adapter VMnet1:

   Connection-specific DNS Suffix  . :
   Link-local IPv6 Address . . . . . : fe80::7859:6e2f:6816:4c38%14
   IPv4 Address. . . . . . . . . . . : 192.168.47.1
   Subnet Mask . . . . . . . . . . . : 255.255.255.0
   Default Gateway . . . . . . . . . :

Ethernet adapter VMware Network Adapter VMnet8:

   Connection-specific DNS Suffix  . :
   Link-local IPv6 Address . . . . . : fe80::9185:c8de:2e72:1855%15
   IPv4 Address. . . . . . . . . . . : 192.168.127.1
   Subnet Mask . . . . . . . . . . . : 255.255.255.0
   Default Gateway . . . . . . . . . :</screen>
</example>
<example>
<title>Capture output to CrashableServer on port 4244</title>
<simpara>This parameter example is from a setup that captures all network traffic using the NetworkCapture monitor when a fault occurs.
When running the fuzzing definition for this example,
a crash occurs after a few iterations.
When Peach logs the fault,
a <literal>.pcap</literal> file is created inside the fault record.</simpara>
<simpara><emphasis role="strong">NetworkCapture monitor settings</emphasis></simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="66.6667*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Value</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Device</simpara></entry>
<entry align="left" valign="top"><simpara><literal>Local Area Connection</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Filter</simpara></entry>
<entry align="left" valign="top"><simpara><literal>port 4244</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>The setup for this example uses a second monitor,
the <link linkend="Monitors_WindowsDebugger">Windows Debugger</link> monitor,
to launch the <literal>CrashableServer</literal> executable,
normally located in the Peach directory.
The following table lists the parameters for that monitor.</simpara>
<simpara><emphasis role="strong">Windows Debugger monitor settings</emphasis></simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="66.6667*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Value</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Executable</simpara></entry>
<entry align="left" valign="top"><simpara><literal>CrashableServer.exe</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Arguments</simpara></entry>
<entry align="left" valign="top"><simpara><literal>127.0.0.1 4244</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Monitors_PageHeap">
<title>PageHeap Monitor (Windows)</title>
<simpara><emphasis role="strong">Monitor Category</emphasis>: <emphasis role="strong">Automation</emphasis></simpara>
<simpara>The <emphasis>PageHeap</emphasis> monitor enables heap allocation monitoring for an executable through the Windows debugger. Peach sets and clears the parameters used for monitoring heap allocation at the beginning and end of the fuzzing session.</simpara>
<note>
<simpara>The <emphasis>PageHeap</emphasis> monitor requires heightened or administrative permissions to run.</simpara>
</note>
<section xml:id="_parameters_22">
<title>Parameters</title>
<simpara><emphasis>Required:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>Executable</term>
<listitem>
<simpara>Executable name (no path)</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>WinDbgPath</term>
<listitem>
<simpara>Path to the Windows Debugger installation.
If not provided, Peach attempts to locate the directory.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_23">
<title>Examples</title>
<example>
<title>Enable for Notepad</title>
<simpara>This parameter example is from a setup that monitors heap allocation in Notepad.
The example is a common setup in which both the PageHeap and the <link linkend="Monitors_WindowsDebugger">Windows Debugger</link> monitors are configured for the fuzzing run.</simpara>
<simpara><emphasis>PageHeap Monitor Parameters</emphasis></simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="66.6667*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Value</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Executable</simpara></entry>
<entry align="left" valign="top"><simpara><literal>notepad.exe</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis>Windows Debugger Monitor Parameters</emphasis></simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="66.6667*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Value</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Executable</simpara></entry>
<entry align="left" valign="top"><simpara><literal>notepad.exe</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Arguments</simpara></entry>
<entry align="left" valign="top"><simpara><literal>fuzzed.txt</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>StartOnCall</simpara></entry>
<entry align="left" valign="top"><simpara><literal>launchProgram</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Monitors_Ping">
<title>Ping Monitor</title>
<simpara><emphasis role="strong">Monitor Category</emphasis>: <emphasis role="strong">Fault detection</emphasis></simpara>
<simpara>The <emphasis>Ping</emphasis> monitor verifies whether a device is functioning by sending a packet to a target location,
and waiting for a response from the device.
<emphasis>Ping</emphasis> continues to monitor until either a <emphasis>Timeout</emphasis> occurs or a response from the target device reaches the <emphasis>Ping</emphasis> monitor.
Ping runs at the end of each iteration.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/Monitors/Ping.png"/>
</imageobject>
<textobject><phrase>Ping</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>In the first scenario (left),
Ping successfully interacts with the test target.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>At the end of each iteration, the Ping monitor sends a message to the test target.</simpara>
</listitem>
<listitem>
<simpara>In this case, the target receives the message and sends a response.</simpara>
</listitem>
<listitem>
<simpara>The monitor waits a specified time period for a response.
In this case,
the response within the time period,
and gives the "OK" response.
The Ping Monitor resets for the sequence to repeat at the end of the next iteration.</simpara>
</listitem>
</orderedlist>
<simpara>In the second scenario (right),
the test target is non-responsive.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>At the end of the iteration, the Ping monitor sends a message to the test target.</simpara>
</listitem>
<listitem>
<simpara>(2B) In this case, the target is non-responsive or no longer exists. No response is sent.</simpara>
</listitem>
<listitem>
<simpara>(3B) The monitor waits a specified time period for a response.
In this case, a timeout occurs.
The Ping monitor issues a fault and collects data around the fault.
Ping resets for the next iteration.</simpara>
</listitem>
</orderedlist>
<simpara><emphasis>Ping</emphasis> can validate that a target is still up or is waiting to restart.
This is useful when fuzzing embedded devices that crash surreptitiously.</simpara>
<simpara>Additionally,
by using the <emphasis>FaultOnSuccess</emphasis> parameter,
<emphasis>Ping</emphasis> can help you to verify whether or not a new device at a specific address becomes available,
or that a non-functioning device starts to function.
For example,
if you are fuzzing a device that programmatically turns other computers on,
you can use <emphasis>Ping</emphasis> with <emphasis>FaultOnSuccess</emphasis> set to <literal>true</literal> to determine whether the computers are off (an uninteresting result) or on (an interesting result).</simpara>
<note>
<simpara>When running under Unix, the following restrictions apply:</simpara>
<itemizedlist>
<listitem>
<simpara>Root privileges are required</simpara>
</listitem>
<listitem>
<simpara><emphasis>Data</emphasis> parameter is limited to 72 bytes</simpara>
</listitem>
</itemizedlist>
</note>
<section xml:id="_parameters_23">
<title>Parameters</title>
<simpara><emphasis>Required:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>Host</term>
<listitem>
<simpara>Host name or IP address to ping.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>Data</term>
<listitem>
<simpara>Data to send in the ping packet payload.
If this value is left blank,
the OS will use default data to send.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>FaultOnSuccess</term>
<listitem>
<simpara>Fault if ping is successful, defaults to <literal>false</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Timeout</term>
<listitem>
<simpara>Timeout value expressed in milliseconds, defaults to <literal>1000</literal>.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_24">
<title>Examples</title>
<example>
<title>Ping Host</title>
<simpara>This parameter example is from a setup that pings the Peach Fuzzer, LLC, website.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="66.6667*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Value</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Host</simpara></entry>
<entry align="left" valign="top"><simpara><literal>www.peachfuzzer.com</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Timeout</simpara></entry>
<entry align="left" valign="top"><simpara><literal>10000</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Monitors_PopupWatcher">
<title>PopupWatcher Monitor (Windows)</title>
<simpara><emphasis role="strong">Monitor Categories</emphasis>: <emphasis role="strong">Automation</emphasis>, <emphasis role="strong">Fault detection</emphasis></simpara>
<simpara>The <emphasis>PopupWatcher</emphasis> monitor closes pop-up windows based on a window title.
<emphasis>PopupWatcher</emphasis> monitors the test target for a list of windows.
When a window opens whose name is in the list,
<emphasis>PopupWatcher</emphasis> closes the pop-up window,
and if specified in the configuration,
initiates a fault.</simpara>
<simpara>This monitor starts at the beginning of the session and runs to the session end.</simpara>
<note>
<simpara>Some applications re-use a pop-up window for many purposes.
The window has one title,
but the main area of the window can display several different messages depending on the context of the application.
If you&#8217;re interested in monitoring a pop-up window based on content rather than the window title,
consider using the <link linkend="Monitors_ButtonClicker">ButtonClicker Monitor</link>.</simpara>
</note>
<section xml:id="_parameters_24">
<title>Parameters</title>
<simpara><emphasis>Required:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>WindowNames</term>
<listitem>
<simpara>One or more Window names separated by commas.</simpara>
</listitem>
</varlistentry>
</variablelist>
<tip>
<simpara>The comma-delimited list should not contain any white-space characters.</simpara>
</tip>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>Fault</term>
<listitem>
<simpara>Trigger a fault when a pop-up window is found, default <literal>false</literal>.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_25">
<title>Examples</title>
<example>
<title>Fault on Assert</title>
<simpara>This parameter example is from a setup that initiates a fault when a window titled <literal>Assertion</literal> is found.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="66.6667*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Value</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>WindowNames</simpara></entry>
<entry align="left" valign="top"><simpara><literal>Assertion</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Fault</simpara></entry>
<entry align="left" valign="top"><simpara><literal>true</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Monitors_Process">
<title>Process Monitor</title>
<simpara><emphasis role="strong">Monitor Categories</emphasis>: <emphasis role="strong">Automation</emphasis>, <emphasis role="strong">Fault detection</emphasis></simpara>
<simpara>The <emphasis>Process</emphasis> monitor controls a process during a fuzzing run.
This monitor provides automation by controlling when the process starts,
restarts and ends,
and whether the process should be killed.
This monitor also provides fault detection for early exit and failure to exit.
Finally,
the <emphasis>Process</emphasis> monitor provides data collection by copying messages from standard out and standard error.</simpara>
<simpara>The <emphasis>Process</emphasis> monitor provides the following functionality:</simpara>
<itemizedlist>
<listitem>
<simpara>Start a process at the session start.</simpara>
</listitem>
<listitem>
<simpara>Start or restart a process on every iteration.</simpara>
</listitem>
<listitem>
<simpara>Start a process in response to a call from the state model.</simpara>
</listitem>
<listitem>
<simpara>Wait for a process to exit in response to a call from the state model.</simpara>
</listitem>
<listitem>
<simpara>Restart a process when it exits.</simpara>
</listitem>
<listitem>
<simpara>Terminates a process if the CPU usage is low.</simpara>
</listitem>
<listitem>
<simpara>Logs a fault if a process exits early.</simpara>
</listitem>
<listitem>
<simpara>Logs a fault if a process fails to exit.</simpara>
</listitem>
</itemizedlist>
<simpara>The <emphasis>Process</emphasis> monitor initiates a fault when a process being monitored experiences the following conditions:</simpara>
<itemizedlist>
<listitem>
<simpara>Early exit</simpara>
</listitem>
<listitem>
<simpara>Timeout while waiting for exit</simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://github.com/google/sanitizers/wiki/AddressSanitizer">Address Sanitizer</link> detection</simpara>
</listitem>
</itemizedlist>
<section xml:id="_parameters_25">
<title>Parameters</title>
<simpara><emphasis>Required:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>Executable</term>
<listitem>
<simpara>Executable to launch</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>Arguments</term>
<listitem>
<simpara>Command line arguments</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>FaultOnEarlyExit</term>
<listitem>
<simpara>Trigger fault if process exits, defaults to <literal>false</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>NoCpuKill</term>
<listitem>
<simpara>Disable process killing when the CPU usage nears zero, defaults to <literal>false</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>RestartOnEachTest</term>
<listitem>
<simpara>Restart process on every iteration.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>RestartAfterFault</term>
<listitem>
<simpara>If <literal>true</literal>, restarts the target when any monitor detects a fault.
If <literal>false</literal>, restarts the target only if the process exits or crashes.
This argument defaults to <literal>true</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>StartOnCall</term>
<listitem>
<simpara>Start process when the specified call is received from the state model.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>WaitForExitOnCall</term>
<listitem>
<simpara>Wait for process to exit when the specified call is received from the state model.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>WaitForExitTimeout</term>
<listitem>
<simpara>Wait timeout value, expressed in milliseconds.
Triggers a fault when the timeout period expires.
Defaults to <literal>10000</literal>.
Use <literal>-1</literal> for infinite, no timeout.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_26">
<title>Examples</title>
<simpara>The following parameter examples are from different uses of the <emphasis>Process</emphasis> monitor.
While not exhaustive,
the examples provide a good base for comparing and contrasting parameter settings for the various uses of this monitor.</simpara>
<example>
<title>Start a Process at the Start of a Session</title>
<simpara>The following parameter example is from a setup that starts a process at the beginning of a fuzzing session.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="66.6667*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Value</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Executable</simpara></entry>
<entry align="left" valign="top"><simpara><literal>notepad.exe</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Arguments</simpara></entry>
<entry align="left" valign="top"><simpara><literal>fuzzed.txt</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</example>
<example>
<title>Start a Process at the Start of each Iteration</title>
<simpara>The following parameter example is from a setup that starts a process at the beginning of each test iteration.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="66.6667*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Value</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Executable</simpara></entry>
<entry align="left" valign="top"><simpara><literal>notepad.exe</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Arguments</simpara></entry>
<entry align="left" valign="top"><simpara><literal>fuzzed.txt</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>RestartOnEachTest</simpara></entry>
<entry align="left" valign="top"><simpara><literal>true</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</example>
<example>
<title>Start a Process When Called from the State Model (Delayed Start)</title>
<simpara>The following parameter example is from a setup that starts a process when called from the state model, amid a test iteration.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="66.6667*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Value</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Executable</simpara></entry>
<entry align="left" valign="top"><simpara><literal>notepad.exe</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Arguments</simpara></entry>
<entry align="left" valign="top"><simpara><literal>fuzzed.txt</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>StartOnCall</simpara></entry>
<entry align="left" valign="top"><simpara><literal>LaunchProgram</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</example>
<example>
<title>Suspend Fuzzing Until a Process Closes</title>
<simpara>The following parameter example is from a setup that interrupts fuzzing and waits for a process to close before resuming.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="66.6667*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Value</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Executable</simpara></entry>
<entry align="left" valign="top"><simpara><literal>notepad.exe</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Arguments</simpara></entry>
<entry align="left" valign="top"><simpara><literal>fuzzed.txt</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>WaitForExitOnCall</simpara></entry>
<entry align="left" valign="top"><simpara><literal>WaitForExit</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Monitors_ProcessKiller">
<title>ProcessKiller Monitor</title>
<simpara><emphasis role="strong">Monitor Category</emphasis>: <emphasis role="strong">Automation</emphasis></simpara>
<simpara>The <emphasis>ProcessKiller</emphasis> monitor kills (terminates) specified processes after each iteration.</simpara>
<section xml:id="_parameters_26">
<title>Parameters</title>
<simpara><emphasis>Required:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>ProcessNames</term>
<listitem>
<simpara>Comma separated list of the processes to kill.</simpara>
</listitem>
</varlistentry>
</variablelist>
<note>
<simpara>The process name is usually the executable filename without the extension (<literal>.exe</literal>).
For example, <literal>notepad.exe</literal> will be <literal>Notepad</literal> or <literal>notepad</literal>.
For Windows operating systems,
the process name can be found by using the <literal>tasklist.exe</literal> command.</simpara>
<simpara>The comma-delimited list should not contain any white-space characters.</simpara>
</note>
<simpara><emphasis>Optional:</emphasis></simpara>
<simpara>None.</simpara>
</section>
<section xml:id="_examples_27">
<title>Examples</title>
<example>
<title>Terminate <literal>notepad</literal> and <literal>mspaint</literal></title>
<simpara>This parameter example is from a setup that terminates the notepad and the paint processes whenever they run.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="66.6667*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Value</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>ProcessNames</simpara></entry>
<entry align="left" valign="top"><simpara><literal>notepad,mspaint</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Monitors_RunCommand">
<title>Run Command</title>
<simpara><emphasis role="strong">Monitor Categories</emphasis>: <emphasis role="strong">Automation</emphasis>, <emphasis role="strong">Data collection</emphasis>, <emphasis role="strong">Fault detection</emphasis></simpara>
<simpara>The <emphasis>RunCommand</emphasis> monitor can be used to launch a command at various points in time during a fuzzing session:</simpara>
<itemizedlist>
<listitem>
<simpara>At the start or end of a fuzzing run</simpara>
</listitem>
<listitem>
<simpara>At the start or end of each test iteration</simpara>
</listitem>
<listitem>
<simpara>After detecting a fault</simpara>
</listitem>
<listitem>
<simpara>At the start of an iteration that immediately follows a fault</simpara>
</listitem>
<listitem>
<simpara>When a specified call is received from the state model</simpara>
</listitem>
</itemizedlist>
<simpara>If a fault occurs,
the monitor captures and logs the console output from <literal>stdout</literal> and <literal>stderr</literal>.
Additionally,
this monitor can initiate a fault under the following conditions (in-order of evaluation):</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>An <link xl:href="https://github.com/google/sanitizers/wiki/AddressSanitizer">Address Sanitizer</link> message appears in <literal>stderr</literal>.</simpara>
</listitem>
<listitem>
<simpara>The specified regular expression matches messages in <literal>stdout</literal> or <literal>stderr</literal>.</simpara>
</listitem>
<listitem>
<simpara>The command takes longer to finish than the specified timeout duration.</simpara>
</listitem>
<listitem>
<simpara>The command exits with a specified exit code.</simpara>
</listitem>
<listitem>
<simpara>The command exits with a nonzero exit code.</simpara>
</listitem>
</orderedlist>
<section xml:id="_parameters_27">
<title>Parameters</title>
<simpara><emphasis>Required:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>Command</term>
<listitem>
<simpara>The command or application to launch.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>Arguments</term>
<listitem>
<simpara>Command line arguments</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>FaultOnNonZeroExit</term>
<listitem>
<simpara>When this value is set to <literal>true</literal>,
generate a fault if the exit code is non-zero.
The default value is <literal>false</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>FaultOnExitCode</term>
<listitem>
<simpara>When this value is set to <literal>true</literal>,
generate a fault if the exit code matches the specified <emphasis>FaultExitCode</emphasis> parameter.
The default value is <literal>false</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>FaultExitCode</term>
<listitem>
<simpara>When <emphasis>FaultOnExitCode</emphasis> is set to <literal>true</literal>, generate a fault if the specified exit code occurs.
The default value is <literal>1</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>StartOnCall</term>
<listitem>
<simpara>Launch the command when the monitor receives the specified call from the state machine.
This value is used only when the <emphasis>When</emphasis> parameter is set to <literal>OnCall</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>FaultOnRegex</term>
<listitem>
<simpara>If this value is specified,
generate a fault if the specified regular expression matches the command output.
The default value is unspecified.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Timeout</term>
<listitem>
<simpara>Maximum time period, in milliseconds, for the process to run.
Generate a fault if the command runs longer than the specified value.
This feature is disabled by specifying <literal>-1</literal> for the time period.
The default value is <literal>-1</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>WorkingDirectory</term>
<listitem>
<simpara>Set the current working directory for the command launched by this monitor.
The default value is the Peach current working directory.
The current working directory for the command is valid until the command changes the directory or ends.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>When</term>
<listitem>
<simpara>Specify one of the following values to determine when to launch the command:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="66.6667*"/>
<thead>
<row>
<entry align="left" valign="top">"When" Setting</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>OnStart</simpara></entry>
<entry align="left" valign="top"><simpara>Run command when the fuzzing session starts.
This occurs once per session.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>OnEnd</simpara></entry>
<entry align="left" valign="top"><simpara>Run command when the fuzzing session stops.
This occurs once per session.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>OnIterationStart</simpara></entry>
<entry align="left" valign="top"><simpara>Run command at the start of each iteration.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>OnIterationEnd</simpara></entry>
<entry align="left" valign="top"><simpara>Run command at the end of each iteration.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>OnFault</simpara></entry>
<entry align="left" valign="top"><simpara>Run command when any monitor detects a fault.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>OnIterationStartAfterFault</simpara></entry>
<entry align="left" valign="top"><simpara>Run command at the start of an iteration that immediately follows a fault detection.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>OnCall</simpara></entry>
<entry align="left" valign="top"><simpara>Run command when the call specified by the <emphasis>StartOnCall</emphasis> parameter is received from the state model.
This is the default setting.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<figure>
<title>When Choices</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/Monitors/Timings_All.png"/>
</imageobject>
<textobject><phrase>Timings All</phrase></textobject>
</mediaobject>
</figure>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_28">
<title>Examples</title>
<example>
<title>Using <emphasis>RunCommand</emphasis> for Fault Detection</title>
<simpara>This parameter example detects a fault by checking for any lines that begin with <literal>ERROR_</literal>.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="66.6667*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Value</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Command</simpara></entry>
<entry align="left" valign="top"><simpara><literal>python</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Arguments</simpara></entry>
<entry align="left" valign="top"><simpara><literal>check_for_fault.py</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>WorkingDirectory</simpara></entry>
<entry align="left" valign="top"><simpara><literal>C:\MyScripts</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>FaultOnRegex</simpara></entry>
<entry align="left" valign="top"><simpara><literal>^ERROR_</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>When</simpara></entry>
<entry align="left" valign="top"><simpara><literal>OnIterationEnd</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</example>
<example>
<title>Using <emphasis>RunCommand</emphasis> for Data Collection</title>
<simpara>This parameter example captures <literal>stderr</literal> and <literal>stdout</literal> for data collection when another monitor detects a fault.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="66.6667*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Value</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Command</simpara></entry>
<entry align="left" valign="top"><simpara><literal>python</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Arguments</simpara></entry>
<entry align="left" valign="top"><simpara><literal>collect_log.py</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>WorkingDirectory</simpara></entry>
<entry align="left" valign="top"><simpara><literal>C:\MyScripts</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>When</simpara></entry>
<entry align="left" valign="top"><simpara><literal>OnFault</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</example>
<example>
<title>Using <emphasis>RunCommand</emphasis> for Automation</title>
<simpara>This parameter example runs the <literal>clear_state.py</literal> python script on the next iteration start after a fault is detected.
This can be used to get the target back into a working state so that fuzzing can continue.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="66.6667*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Value</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Command</simpara></entry>
<entry align="left" valign="top"><simpara><literal>python</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Arguments</simpara></entry>
<entry align="left" valign="top"><simpara><literal>clear_state.py</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>WorkingDirectory</simpara></entry>
<entry align="left" valign="top"><simpara><literal>C:\MyScripts</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>When</simpara></entry>
<entry align="left" valign="top"><simpara><literal>OnIterationStartAfterFault</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Monitors_SaveFile">
<title>SaveFile Monitor</title>
<simpara><emphasis role="strong">Monitor Categories</emphasis>: <emphasis role="strong">Data collection</emphasis></simpara>
<simpara>The <emphasis>SaveFile</emphasis> monitor saves a specified file as part of the logged data when a fault occurs.
A copy of the file is placed in the log folder.</simpara>
<section xml:id="_parameters_28">
<title>Parameters</title>
<simpara><emphasis>Required:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>Filename</term>
<listitem>
<simpara>File to save when a fault is detected by another monitor.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Optional:</emphasis></simpara>
<simpara>None.</simpara>
</section>
<section xml:id="_examples_29">
<title>Examples</title>
<example>
<title>Collect logs when a fault occurs</title>
<simpara>In this example,
the <link linkend="Monitors_Process">Process Monitor</link> is used to launch <literal>nginx</literal> as the target.
When a fault is detected by this monitor,
the <emphasis>SaveFile</emphasis> monitor is configured to collect logs from <literal>nginx</literal>.
These logs will be available as part of the data collected for the fault.</simpara>
<simpara><emphasis>Process (Launch nginx) Parameters</emphasis></simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="66.6667*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Value</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Executable</simpara></entry>
<entry align="left" valign="top"><simpara><literal>/usr/sbin/nginx</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis>SaveFile (Save error.log) Parameters</emphasis></simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="66.6667*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Value</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Filename</simpara></entry>
<entry align="left" valign="top"><simpara><literal>/var/log/nginx/error.log</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis>SaveFile (Save access.log) Parameters</emphasis></simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="66.6667*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Value</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Filename</simpara></entry>
<entry align="left" valign="top"><simpara><literal>/var/log/nginx/access.log</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Monitors_Serial">
<title>Serial Port Monitor</title>
<simpara><emphasis role="strong">Monitor Categories</emphasis>: <emphasis role="strong">Automation</emphasis>, <emphasis role="strong">Data collection</emphasis>, <emphasis role="strong">Fault detection</emphasis></simpara>
<simpara>The <emphasis>Serial Port</emphasis> monitor can be used to perform
data collection,
fault detection,
or automation,
based on specified parameters.</simpara>
<simpara>The default usage of the <emphasis>Serial Port</emphasis> monitor is data collection.
The data received via the serial port is logged when a fault occurs.</simpara>
<simpara>To perform fault detection,
specify a regular expression using the <emphasis>FaultRegex</emphasis> parameter.
When the regular expression matches,
Peach generates a fault.</simpara>
<simpara>For automation tasks, use the <emphasis>WaitForRegex</emphasis> and <emphasis>WaitWhen</emphasis> parameters.
These automation parameters cause Peach to wait for matching input before continuing.
The <emphasis>Serial Port</emphasis> monitor can wait at various points in time during a fuzzing session:</simpara>
<itemizedlist>
<listitem>
<simpara>At the start or end of a fuzzing run</simpara>
</listitem>
<listitem>
<simpara>At the start or end of each test iteration</simpara>
</listitem>
<listitem>
<simpara>After detecting a fault</simpara>
</listitem>
<listitem>
<simpara>At the start of an iteration that immediately follows a fault</simpara>
</listitem>
<listitem>
<simpara>When a specified call is received from the state model</simpara>
</listitem>
</itemizedlist>
<simpara>Additionally,
Peach supports multiple <emphasis>Serial Port</emphasis> monitors in a pit,
allowing for more complex configurations.
This can be used to monitor multiple serial ports.
Multiple monitors may also be configured to use the same port, allowing for fault detection,
automation,
and/or data collection to occur on a single port.</simpara>
<section xml:id="_parameters_29">
<title>Parameters</title>
<simpara><emphasis>Required:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>Port</term>
<listitem>
<simpara>The port to use (for example, <literal>COM1</literal> or <literal>/dev/ttyS0</literal>)</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>BaudRate</term>
<listitem>
<simpara>The baud rate (only standard values are allowed).
Defaults to <literal>115200</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>DataBits</term>
<listitem>
<simpara>The data bits value.
Defaults to <literal>8</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Parity</term>
<listitem>
<simpara>Specifies the parity bit.
Defaults to <literal>None</literal>.
Available options for this parameter are:</simpara>
<informaltable tabstyle="horizontal" frame="none" colsep="0" rowsep="0">
<tgroup cols="2">
<colspec colwidth="15*"/>
<colspec colwidth="85*"/>
<tbody valign="top">
<row>
<entry>
<simpara>Even</simpara>
<simpara>Mark</simpara>
<simpara>None</simpara>
<simpara>Odd</simpara>
<simpara>Space</simpara>
</entry>
<entry>
</entry>
</row>
</tbody>
</tgroup>
</informaltable>
</listitem>
</varlistentry>
<varlistentry>
<term>StopBits</term>
<listitem>
<simpara>Specifies the number of stop bits used.
Defaults to <literal>One</literal>.
Available options for this parameter are:</simpara>
<informaltable tabstyle="horizontal" frame="none" colsep="0" rowsep="0">
<tgroup cols="2">
<colspec colwidth="15*"/>
<colspec colwidth="85*"/>
<tbody valign="top">
<row>
<entry>
<simpara>One</simpara>
<simpara>OnePointFive</simpara>
<simpara>Two</simpara>
</entry>
<entry>
</entry>
</row>
</tbody>
</tgroup>
</informaltable>
</listitem>
</varlistentry>
<varlistentry>
<term>Handshake</term>
<listitem>
<simpara>Specifies the control protocol used in establishing a serial port communication.
Defaults to <literal>None</literal>.
Available options for this parameter are:</simpara>
<informaltable tabstyle="horizontal" frame="none" colsep="0" rowsep="0">
<tgroup cols="2">
<colspec colwidth="15*"/>
<colspec colwidth="85*"/>
<tbody valign="top">
<row>
<entry>
<simpara>None</simpara>
<simpara>RequestToSend</simpara>
<simpara>RequestToSendXOnXOff</simpara>
<simpara>XOnXOff</simpara>
</entry>
<entry>
</entry>
</row>
</tbody>
</tgroup>
</informaltable>
</listitem>
</varlistentry>
<varlistentry>
<term>DtrEnable</term>
<listitem>
<simpara>Enables the Data Terminal Ready (DTR) signal during serial communication.
Defaults to <literal>false</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>RtsEnable</term>
<listitem>
<simpara>Enables the Request To Transmit (RTS) signal during serial communication.
Defaults to <literal>false</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>MaxBufferSize</term>
<listitem>
<simpara>Maximum amount of serial data to store in bytes.
Defaults to <literal>1048576</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>FaultRegex</term>
<listitem>
<simpara>Generate a fault when the specified regular expression matches received data.
This causes the <emphasis>Serial Port</emphasis> monitor to be used for fault detection.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>WaitRegex</term>
<listitem>
<simpara>Wait until the specified regular expression matches received data.
This causes the <emphasis>Serial Port</emphasis> monitor to be used for automation.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>WaitOnCall</term>
<listitem>
<simpara>Begin waiting for the regular expression specified in the <emphasis>WaitRegex</emphasis> parameter after the monitor receives the specified call from the state machine.
This value is used only when the <emphasis>WaitWhen</emphasis> parameter is set to <literal>OnCall</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>WaitWhen</term>
<listitem>
<simpara>Specify one of the following values to determine when to begin waiting for the regular expression specified in the <emphasis>WaitRegex</emphasis> parameter to match received data:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="66.6667*"/>
<thead>
<row>
<entry align="left" valign="top">"WaitWhen" Setting</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>OnStart</simpara></entry>
<entry align="left" valign="top"><simpara>Waits when the fuzzing session starts.
This occurs once per session.
This is the default setting.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>OnEnd</simpara></entry>
<entry align="left" valign="top"><simpara>Waits when the fuzzing session stops.
This occurs once per session.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>OnIterationStart</simpara></entry>
<entry align="left" valign="top"><simpara>Waits at the start of each iteration.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>OnIterationEnd</simpara></entry>
<entry align="left" valign="top"><simpara>Waits at the end of each iteration.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>OnFault</simpara></entry>
<entry align="left" valign="top"><simpara>Waits when any monitor detects a fault.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>OnIterationStartAfterFault</simpara></entry>
<entry align="left" valign="top"><simpara>Waits at the start of the iteration that immediately follows a fault detection.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>OnCall</simpara></entry>
<entry align="left" valign="top"><simpara>Waits upon receipt of the call specified by the <emphasis>WaitOnCall</emphasis> parameter from the state model.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<figure>
<title>WaitWhen Choices</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/Monitors/Timings_All.png"/>
</imageobject>
<textobject><phrase>Timings All</phrase></textobject>
</mediaobject>
</figure>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_30">
<title>Examples</title>
<example>
<title>Data Collection example</title>
<simpara>This parameter example is from a setup that uses the default settings for the <emphasis>Serial Port</emphasis> monitor,
resulting in the monitor performing data collection of the data received over <literal>COM1</literal> when a fault is detected by another monitor.
Other than the mandatory <emphasis>Port</emphasis> declaration, the setup uses default values.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="66.6667*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Value</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Port</simpara></entry>
<entry align="left" valign="top"><simpara><literal>COM1</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</example>
<example>
<title>Fault Detection example</title>
<simpara>This parameter example is from a setup that detects a fault on <literal>COM1</literal>.
In addition to normal data collection,
this setup generates a fault when the text <literal>ERROR</literal> is received over the serial port.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="66.6667*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Value</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Port</simpara></entry>
<entry align="left" valign="top"><simpara><literal>COM1</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>FaultRegex</simpara></entry>
<entry align="left" valign="top"><simpara><literal>ERROR</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</example>
<example>
<title>Combined Automation and Fault Detection example</title>
<simpara>This example might be used when fuzzing a network device such as a router.
One <emphasis>Serial Port</emphasis> monitor is configured to wait until the router has booted before starting the fuzzing session.
Another <emphasis>Serial Port</emphasis> monitor is configured to detect faults and also to wait for the router to finish rebooting after a fault is detected.
The <link linkend="Monitors_IpPower9258">IpPower9258 Monitor</link> is configured to reboot the router after a fault is detected.</simpara>
<simpara><emphasis role="strong">Serial Port (Wait for boot) parameters</emphasis></simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="66.6667*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Value</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Monitor</simpara></entry>
<entry align="left" valign="top"><simpara><literal>SerialPort</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Name</simpara></entry>
<entry align="left" valign="top"><simpara><literal>Wait for boot</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Port</simpara></entry>
<entry align="left" valign="top"><simpara><literal>COM1</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>WaitRegex</simpara></entry>
<entry align="left" valign="top"><simpara><literal>Boot up completed</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis role="strong">Serial Port (Detect fault) parameters</emphasis></simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="66.6667*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Value</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Monitor</simpara></entry>
<entry align="left" valign="top"><simpara><literal>SerialPort</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Name</simpara></entry>
<entry align="left" valign="top"><simpara><literal>Detect fault</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Port</simpara></entry>
<entry align="left" valign="top"><simpara><literal>COM1</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>FaultRegex</simpara></entry>
<entry align="left" valign="top"><simpara><literal>ERROR</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>WaitRegex</simpara></entry>
<entry align="left" valign="top"><simpara><literal>Boot up completed</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>WaitWhen</simpara></entry>
<entry align="left" valign="top"><simpara><literal>OnIterationAfterFault</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis role="strong">IpPower9258 (Reboot router) parameters</emphasis></simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="66.6667*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Value</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Monitor</simpara></entry>
<entry align="left" valign="top"><simpara><literal>IpPower9258</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Name</simpara></entry>
<entry align="left" valign="top"><simpara><literal>Reboot router</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Host</simpara></entry>
<entry align="left" valign="top"><simpara><literal>192.168.1.1:8080</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Port</simpara></entry>
<entry align="left" valign="top"><simpara><literal>1</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>User</simpara></entry>
<entry align="left" valign="top"><simpara><literal>peach</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Password</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PeachPower</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>When</simpara></entry>
<entry align="left" valign="top"><simpara><literal>OnFault</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</example>
<example>
<title>Multiple Serial Port monitors for different ports</title>
<simpara>This example connects Peach to the console port and also the debug port of a target device.
The monitor on the console port is set up for fault detection, data collection, and automation.
The monitor on the debug port is set up for data collection.</simpara>
<simpara><emphasis role="strong">Console Port</emphasis></simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="66.6667*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Value</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Monitor</simpara></entry>
<entry align="left" valign="top"><simpara><literal>SerialPort</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Name</simpara></entry>
<entry align="left" valign="top"><simpara><literal>Console Port</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Port</simpara></entry>
<entry align="left" valign="top"><simpara><literal>COM1</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>FaultRegex</simpara></entry>
<entry align="left" valign="top"><simpara><literal>ERROR</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>WaitRegex</simpara></entry>
<entry align="left" valign="top"><simpara><literal>Boot up completed</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>WaitWhen</simpara></entry>
<entry align="left" valign="top"><simpara><literal>OnIterationAfterFault</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis role="strong">Debug Port</emphasis></simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="66.6667*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Value</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Monitor</simpara></entry>
<entry align="left" valign="top"><simpara><literal>SerialPort</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Name</simpara></entry>
<entry align="left" valign="top"><simpara><literal>Debug Port</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Port</simpara></entry>
<entry align="left" valign="top"><simpara><literal>COM2</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Monitors_SnmpPower">
<title>SNMP Power Monitor</title>
<simpara><emphasis role="strong">Monitor Categories</emphasis>: <emphasis role="strong">Automation</emphasis></simpara>
<simpara>The <emphasis>SNMP Power</emphasis> monitor switches outlets on a power distribution unit (PDU) on and off via SNMPv1.
This monitor is useful for automatically power cycling devices during a fuzzing session.</simpara>
<simpara>Each <emphasis>SNMP Power</emphasis> monitor switches one or more of a PDU&#8217;s outlets, according to the configuration.
All affected outlets are given the same commands, so turning some outlets on and others off would require another monitor.
The monitor can reset the power outlets at the following points in time:</simpara>
<itemizedlist>
<listitem>
<simpara>At the start or end of a fuzzing run</simpara>
</listitem>
<listitem>
<simpara>At the start or end of each test iteration</simpara>
</listitem>
<listitem>
<simpara>After detecting a fault</simpara>
</listitem>
<listitem>
<simpara>At the start of an iteration that immediately follows a fault</simpara>
</listitem>
<listitem>
<simpara>When a specified call is received from the state model</simpara>
</listitem>
</itemizedlist>
<tip>
<simpara>The <link linkend="Monitors_IpPower9258">IpPower9258 Monitor</link> and
<link linkend="Monitors_ApcPower">ApcPower Monitor</link> provide similar features, for
IP Power 9258 and APC devices, respectively. For controlling power to
a device by wiring through a relay, Peach provides a monitor for the
<link linkend="Monitors_CanaKitRelay">CanaKit 4-Port USB Relay Controller</link>.</simpara>
</tip>
<section xml:id="_parameters_30">
<title>Parameters</title>
<simpara><emphasis>Required:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>Host</term>
<listitem>
<simpara>IP address of the switched power distribution unit.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>OIDs</term>
<listitem>
<simpara>Comma-separated list of OIDs for controlling the power outlets.
To determine the OIDs, start by installing the SNMP MIB provided by the device manufacturer.
Use a utility like <literal>snmptranslate</literal> to lookup numeric OID associate with the OID name of an outlet.
For example, <literal>snmptranslate -On PowerNet-MIB::sPDUOutletCtl.1</literal> indicates <literal>.1.3.6.1.4.1.318.1.1.4.4.2.1.3.1</literal> is the OID to use for outlet 1 on an APC Switched Power Distribution Unit (AC7900).</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>OnCode</term>
<listitem>
<simpara>On indicator code used by outlet OIDs. Default is <literal>1</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>OffCode</term>
<listitem>
<simpara>Off indicator code used by outlet OIDs. Default is <literal>2</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Port</term>
<listitem>
<simpara>SNMP port on the switched power distribution unit. Default is <literal>161</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>ReadCommunity</term>
<listitem>
<simpara>SNMP community string to use when reading the state of the outlets. Default is <literal>public</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>WriteCommunity</term>
<listitem>
<simpara>SNMP community string to use when modifying the state of the outlets. Default is <literal>private</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>RequestTimeout</term>
<listitem>
<simpara>Maximum duration in millseconds to block when sending an SNMP request to the PDU. Default is <literal>1000</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>SanityCheckOnStart</term>
<listitem>
<simpara>On startup, ensure switch state changes persist. Default is <literal>true</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>SanityCheckWaitTimeout</term>
<listitem>
<simpara>Maximum duration to wait for state change to take effect during startup sanity check. Default is <literal>3000</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>ResetOnCall</term>
<listitem>
<simpara>Reset power when the specified call is received from the state model.
This value is used only when the <emphasis>When</emphasis> parameter is set to <literal>OnCall</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>PowerOffOnEnd</term>
<listitem>
<simpara>Power off when the fuzzing session completes, default is <literal>false</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>PowerOnOffPause</term>
<listitem>
<simpara>Pause in milliseconds between power off/power on, default is <literal>500</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>When</term>
<listitem>
<simpara>When to reset power on the specified outlets. Default is <literal>OnFault</literal>.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="66.6667*"/>
<thead>
<row>
<entry align="left" valign="top">"When" Setting</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>DetectFault</simpara></entry>
<entry align="left" valign="top"><simpara>Reset power when checking for a fault.
This occurs after OnIterationEnd.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>OnStart</simpara></entry>
<entry align="left" valign="top"><simpara>Reset power when the fuzzing session starts.
This occurs once per session.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>OnEnd</simpara></entry>
<entry align="left" valign="top"><simpara>Reset power when the fuzzing session stops.
This occurs once per session.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>OnIterationStart</simpara></entry>
<entry align="left" valign="top"><simpara>Reset power at the start of each iteration.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>OnIterationEnd</simpara></entry>
<entry align="left" valign="top"><simpara>Reset power at the end of each iteration.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>OnFault</simpara></entry>
<entry align="left" valign="top"><simpara>Reset power when any monitor detects a fault.
This is the default setting.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>OnIterationStartAfterFault</simpara></entry>
<entry align="left" valign="top"><simpara>Reset power at the start of an iteration that immediately follows a fault detection.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>OnCall</simpara></entry>
<entry align="left" valign="top"><simpara>Reset power when the call specified by the <emphasis>ResetOnCall</emphasis> parameter is received from the state model.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<figure>
<title>When Choices for Performing an Action</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/Monitors/Timings_SSH.png"/>
</imageobject>
<textobject><phrase>Timings SSH</phrase></textobject>
</mediaobject>
</figure>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_31">
<title>Examples</title>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Monitors_Socket">
<title>Socket Monitor</title>
<simpara><emphasis role="strong">Monitor Category</emphasis>: <emphasis role="strong">Data collection</emphasis>, <emphasis role="strong">Fault detection</emphasis></simpara>
<simpara>The <emphasis>Socket</emphasis> monitor waits for an incoming TCP or UDP connection at the end of a test iteration.
This monitor accepts a point-to-point connection to a single host or a multicast connection where the host broadcasts to one or more clients.
Multicast connections are not supported when using the TCP protocol.</simpara>
<simpara>The monitor can be configured to be used for data collection or fault detection depending on the <emphasis>FaultOnSuccess</emphasis> parameter value and whether or not data is received within the specified timeout.
The following table provides the available options:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="33.3333*"/>
<colspec colname="col_3" colwidth="33.3334*"/>
<thead>
<row>
<entry align="left" valign="top">FaultOnSuccess</entry>
<entry align="left" valign="top">Data Received</entry>
<entry align="left" valign="top">Behavior</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>true</literal></simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>Data collection</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>true</literal></simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
<entry align="left" valign="top"><simpara>Fault detection</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>false</literal></simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>Fault detection</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>false</literal></simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
<entry align="left" valign="top"><simpara>Data collection</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<section xml:id="_parameters_31">
<title>Parameters</title>
<simpara><emphasis>Required:</emphasis></simpara>
<simpara>None.</simpara>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>Host</term>
<listitem>
<simpara>IP address of the remote host to receive data from.
Defaults to <literal>""</literal>,
which means accept data from any host.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Interface</term>
<listitem>
<simpara>IP address of the interface to listen on.
Defaults to <literal>0.0.0.0</literal>,
which means listen to all interfaces on the host.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Port</term>
<listitem>
<simpara>Port to listen on.
Defaults to <literal>8080</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Protocol</term>
<listitem>
<simpara>Protocol type to listen for.
Defaults to <literal>tcp</literal>.
Available options for this parameter are <literal>tcp</literal> and <literal>udp</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Timeout</term>
<listitem>
<simpara>Length of time in milliseconds to wait for an incoming connection.
Defaults to <literal>1000</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>FaultOnSuccess</term>
<listitem>
<simpara>Generate a fault if no data is received.
Defaults to <literal>false</literal>.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_32">
<title>Examples</title>
<example>
<title>Fault Detection example</title>
<simpara>This example generates a fault if data from a tcp connection on port <literal>53</literal> is received at the end of a test iteration.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="66.6667*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Value</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Port</simpara></entry>
<entry align="left" valign="top"><simpara><literal>53</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Monitors_SshCommand">
<title>SshCommand Monitor</title>
<simpara><emphasis role="strong">Monitor Categories</emphasis>: <emphasis role="strong">Automation</emphasis>, <emphasis role="strong">Data collection</emphasis>, <emphasis role="strong">Fault detection</emphasis></simpara>
<simpara>The <emphasis>SshCommand</emphasis> monitor connects to a remote host over SSH (Secure Shell),
runs a command,
and waits for the command to complete.
The output from the process is logged when a fault is detected.
This monitor can operate as a fault detector,
data collector,
and automation module depending on configuration.</simpara>
<simpara><emphasis>SshCommand</emphasis> supports password, keyboard, and private key authentication methods.</simpara>
<simpara>To increase the speed of operation,
the monitor holds open the SSH connection to the remote machine across test iterations.
This removes the cost of authenticating every time the command is executed.
If multiple <emphasis>SshCommand</emphasis> monitors are configured against the same remote host,
multiple SSH connections are created and held open.</simpara>
<simpara><emphasis role="strong">Fault Detection</emphasis></simpara>
<simpara>This monitor can perform fault detection depending on the configuration of the <emphasis>FaultOnMatch</emphasis> and <emphasis>CheckValue</emphasis> parameters.
The following table describes the behavior of these parameters:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="33.3333*"/>
<colspec colname="col_3" colwidth="33.3334*"/>
<thead>
<row>
<entry align="left" valign="top">FaultOnMatch</entry>
<entry align="left" valign="top">CheckValue match</entry>
<entry align="left" valign="top">Behavior</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>true</literal></simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>Fault detection</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>true</literal></simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
<entry align="left" valign="top"><simpara>Data collection</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>false</literal></simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>Data collection</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>false</literal></simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
<entry align="left" valign="top"><simpara>Fault detection</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>This monitor will also automatically detect <link xl:href="https://github.com/google/sanitizers/wiki/AddressSanitizer">AddressSanitizer</link> crash information and generate a fault if found.</simpara>
<simpara><emphasis role="strong">Data Collection</emphasis></simpara>
<simpara>The monitor always collects the output from the executed command and reports it for logging when a fault is detected.</simpara>
<simpara><emphasis role="strong">Automation</emphasis></simpara>
<simpara>The <emphasis>SshCommand</emphasis> monitor can run the specified command at various points in time during a fuzzing session:</simpara>
<itemizedlist>
<listitem>
<simpara>At the start or end of a fuzzing run</simpara>
</listitem>
<listitem>
<simpara>At the start or end of each test iteration</simpara>
</listitem>
<listitem>
<simpara>While detecting a fault</simpara>
</listitem>
<listitem>
<simpara>After detecting a fault</simpara>
</listitem>
<listitem>
<simpara>At the start of an iteration that immediately follows a fault</simpara>
</listitem>
<listitem>
<simpara>When a specified call is received from the state model</simpara>
</listitem>
</itemizedlist>
<section xml:id="_parameters_32">
<title>Parameters</title>
<simpara><emphasis>Required:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>Host</term>
<listitem>
<simpara>Remote hostname or IP address for the SSH connection.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Username</term>
<listitem>
<simpara>Username for authentication with the remote host.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Command</term>
<listitem>
<simpara>The command to execute on the remote host.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>Password</term>
<listitem>
<simpara>Password for authentication with the remote host.
Defaults to <literal>""</literal>.
Either the <emphasis>Password</emphasis> or the <emphasis>KeyPath</emphasis> parameter must be set.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>KeyPath</term>
<listitem>
<simpara>A local path to the private part of an SSH key-pair to be used for authentication with the remote host.
Defaults to <literal>""</literal>.
Either the <emphasis>Password</emphasis> or the <emphasis>KeyPath</emphasis> parameter must be set.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>CheckValue</term>
<listitem>
<simpara>A regular expression to match the command output.
Defaults to <literal>""</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>FaultOnMatch</term>
<listitem>
<simpara>Trigger a fault if <emphasis>FaultOnMatch</emphasis> is <literal>true</literal> and the <emphasis>CheckValue</emphasis> regular expression matches,
or <emphasis>FaultOnMatch</emphasis> is <literal>false</literal> and the <emphasis>CheckValue</emphasis> regular expression does not match.
Defaults to <literal>false</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>StartOnCall</term>
<listitem>
<simpara>Run the specified command after the monitor receives the specified call from the state machine.
This value is used only when the <emphasis>When</emphasis> parameter is set to <literal>OnCall</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>When</term>
<listitem>
<simpara>Specify one of the following values to determine when to run the specified command:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="66.6667*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis>When</emphasis> Value</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>DetectFault</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Run the command to perform fault detection.
Requires a regular expression to be specified in the <emphasis>CheckValue</emphasis> parameter.
This is the default setting.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>OnStart</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Run the command when fuzzing session starts.
This occurs once per session.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>OnEnd</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Run the command when fuzzing session stops.
This occurs once per session.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>OnIterationStart</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Run the command at the start of each iteration.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>OnIterationEnd</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Run the command at the end of each iteration.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>OnFault</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Run the command when any monitor detects a fault.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>OnIterationStartAfterFault</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Run the command at the start of an iteration that immediately follows a fault detection.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>OnCall</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Run the command upon receipt of the call specified by the <emphasis>WaitOnCall</emphasis> parameter from the state model.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<figure>
<title>When Choices</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/Monitors/Timings_SSH.png"/>
</imageobject>
<textobject><phrase>Timings SSH</phrase></textobject>
</mediaobject>
</figure>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_33">
<title>Examples</title>
<example>
<title>Fault Detection example</title>
<simpara>This example connects to the target machine using SSH during the fault detection phase of a test iteration.
A fault occurs if any core files exist.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="66.6667*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Value</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Host</simpara></entry>
<entry align="left" valign="top"><simpara><literal>my.target.com</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Username</simpara></entry>
<entry align="left" valign="top"><simpara><literal>tester</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Password</simpara></entry>
<entry align="left" valign="top"><simpara><literal>Password!</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Command</simpara></entry>
<entry align="left" valign="top"><simpara><literal>ls /var/cores/*.core</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>CheckValue</simpara></entry>
<entry align="left" valign="top"><simpara><literal>target.*?.core</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>FaultOnMatch</simpara></entry>
<entry align="left" valign="top"><simpara><literal>true</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Monitors_SshDownloader">
<title>SshDownloader Monitor</title>
<simpara><emphasis role="strong">Monitor Categories</emphasis>: <emphasis role="strong">Data collection</emphasis></simpara>
<simpara>The <emphasis>SshDownloader</emphasis> monitor downloads a file or folder from a remote host over SSH SFTP (Secure Shell File Transfer Protocol) after any other monitor detects a fault.</simpara>
<simpara><emphasis>SshDownloader</emphasis> supports password, keyboard, and private key authentication methods.</simpara>
<simpara><emphasis>SshDownloader</emphasis> can be configured to delete files from the source after they have been downloaded.</simpara>
<section xml:id="_parameters_33">
<title>Parameters</title>
<simpara><emphasis>Required:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>Host</term>
<listitem>
<simpara>Remote hostname or IP address for the SSH connection.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Username</term>
<listitem>
<simpara>Username for authentication with the remote host.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>Password</term>
<listitem>
<simpara>Password for authentication with the remote host.
Defaults to <literal>""</literal>.
Either the <emphasis>Password</emphasis> or the <emphasis>KeyPath</emphasis> parameter must be set.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>KeyPath</term>
<listitem>
<simpara>A local path to the private part of an SSH key-pair to be used for authentication with the remote host.
Defaults to <literal>""</literal>.
Either the <emphasis>Password</emphasis> or the <emphasis>KeyPath</emphasis> parameter must be set.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>File</term>
<listitem>
<simpara>Path of the remote file to download.
Defaults to <literal>""</literal>.
Either the <emphasis>File</emphasis> or the <emphasis>Folder</emphasis> parameter must be set.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Folder</term>
<listitem>
<simpara>Path of the remote folder to download.
Defaults to <literal>""</literal>.
Either the <emphasis>File</emphasis> or the <emphasis>Folder</emphasis> parameter must be set.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Remove</term>
<listitem>
<simpara>When this value is set to <literal>true</literal>,
remove the remote file after the download completes.
Defaults to <literal>true</literal>.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_34">
<title>Examples</title>
<example>
<title>Download a log file</title>
<simpara>This example downloads a log file when a fault is detected by any other monitor.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="66.6667*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Value</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Host</simpara></entry>
<entry align="left" valign="top"><simpara><literal>my.target.com</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Username</simpara></entry>
<entry align="left" valign="top"><simpara><literal>tester</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Password</simpara></entry>
<entry align="left" valign="top"><simpara><literal>Password!</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>File</simpara></entry>
<entry align="left" valign="top"><simpara><literal>/var/log/syslog</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Remove</simpara></entry>
<entry align="left" valign="top"><simpara><literal>false</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Monitors_Syslog">
<title>Syslog Monitor</title>
<simpara><emphasis role="strong">Monitor Categories</emphasis>: <emphasis role="strong">Automation</emphasis>, <emphasis role="strong">Data collection</emphasis>, <emphasis role="strong">Fault detection</emphasis></simpara>
<simpara>The <emphasis>Syslog</emphasis> monitor listens on a specified port for incoming syslog messages.
This monitor is capable of performing automation, data collection, and fault detection.</simpara>
<simpara>The default usage of the <emphasis>Syslog</emphasis> monitor is data collection.
The syslog messages received are logged when a fault occurs.</simpara>
<simpara>To perform fault detection,
specify a regular expression using the <emphasis>FaultRegex</emphasis> parameter.
When the regular expression matches an incoming syslog message,
Peach generates a fault.</simpara>
<simpara>For automation tasks, use the <emphasis>WaitForRegex</emphasis> and <emphasis>WaitWhen</emphasis> parameters.
These automation parameters cause Peach to wait for matching input before continuing.
The <emphasis>Syslog</emphasis> monitor can wait at various points in time during a fuzzing session:</simpara>
<itemizedlist>
<listitem>
<simpara>At the start or end of a fuzzing run</simpara>
</listitem>
<listitem>
<simpara>At the start or end of each test iteration</simpara>
</listitem>
<listitem>
<simpara>After detecting a fault</simpara>
</listitem>
<listitem>
<simpara>At the start of an iteration that immediately follows a fault</simpara>
</listitem>
<listitem>
<simpara>When a specified call is received from the state model</simpara>
</listitem>
</itemizedlist>
<section xml:id="_parameters_34">
<title>Parameters</title>
<simpara><emphasis>Required:</emphasis></simpara>
<simpara>None.</simpara>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>Port</term>
<listitem>
<simpara>Port number to listen on.
The default value is <literal>514</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Interface</term>
<listitem>
<simpara>IP address of the interface to listen on.
The default value is <literal>0.0.0.0</literal>, which listens on all interfaces.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>FaultRegex</term>
<listitem>
<simpara>Generate a fault when the specified regular expression matches received data.
This causes the <emphasis>Syslog</emphasis> monitor to be used for fault detection.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>WaitRegex</term>
<listitem>
<simpara>Wait until the specified regular expression matches received data.
This causes the <emphasis>Syslog</emphasis> monitor to be used for automation.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>WaitOnCall</term>
<listitem>
<simpara>Begin waiting for the regular expression specified in the <emphasis>WaitRegex</emphasis> parameter after the monitor receives the specified call from the state machine.
This value is used only when the <emphasis>WaitWhen</emphasis> parameter is set to <literal>OnCall</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>WaitWhen</term>
<listitem>
<simpara>Specify one of the following values to determine when to begin waiting for the regular expression specified in the <emphasis>WaitRegex</emphasis> parameter to match received data:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="66.6667*"/>
<thead>
<row>
<entry align="left" valign="top">"WaitWhen" Setting</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>OnStart</simpara></entry>
<entry align="left" valign="top"><simpara>Waits when the fuzzing session starts.
This occurs once per session.
This is the default setting.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>OnEnd</simpara></entry>
<entry align="left" valign="top"><simpara>Waits when the fuzzing session stops.
This occurs once per session.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>OnIterationStart</simpara></entry>
<entry align="left" valign="top"><simpara>Waits at the start of each iteration.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>OnIterationEnd</simpara></entry>
<entry align="left" valign="top"><simpara>Waits at the end of each iteration.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>OnFault</simpara></entry>
<entry align="left" valign="top"><simpara>Waits when any monitor detects a fault.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>OnIterationStartAfterFault</simpara></entry>
<entry align="left" valign="top"><simpara>Waits at the start of the iteration that immediately follows a fault detection.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>OnCall</simpara></entry>
<entry align="left" valign="top"><simpara>Waits upon receipt of the call specified by the <emphasis>WaitOnCall</emphasis> parameter from the state model.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<figure>
<title>WaitWhen Choices</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/Monitors/Timings_All.png"/>
</imageobject>
<textobject><phrase>Timings All</phrase></textobject>
</mediaobject>
</figure>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_35">
<title>Examples</title>
<example>
<title>Data Collection example</title>
<simpara>This parameter example is from a setup that uses the <emphasis>Syslog</emphasis> monitor to listen on the default port for incoming messages.
When a fault occurs,
all messages are saved.
Default values are used;
no values are specified.</simpara>
</example>
<example>
<title>Fault Detection example</title>
<simpara>This parameter example is from a setup that detects a fault from incoming syslog messages.
In addition to normal data collection,
this setup generates a fault when the text <literal>ERROR</literal> is received.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="66.6667*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Value</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>FaultRegex</simpara></entry>
<entry align="left" valign="top"><simpara><literal>ERROR</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</example>
<example>
<title>Combined Automation and Fault Detection example</title>
<simpara>This example might be used when fuzzing a network device such as a router.
One <emphasis>Syslog</emphasis> monitor is configured to wait until the router has booted before starting the fuzzing session.
Another <emphasis>Syslog</emphasis> monitor is configured to detect faults and also to wait for the router to finish rebooting after a fault is detected.
The <link linkend="Monitors_IpPower9258">IpPower9258 Monitor</link> is configured to reboot the router after a fault is detected.</simpara>
<simpara><emphasis role="strong">Syslog (Wait for boot) parameters</emphasis></simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="66.6667*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Value</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Monitor</simpara></entry>
<entry align="left" valign="top"><simpara><literal>Syslog</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Name</simpara></entry>
<entry align="left" valign="top"><simpara><literal>Wait for boot</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>WaitRegex</simpara></entry>
<entry align="left" valign="top"><simpara><literal>Boot up completed</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis role="strong">Syslog (Detect fault) parameters</emphasis></simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="66.6667*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Value</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Monitor</simpara></entry>
<entry align="left" valign="top"><simpara><literal>Syslog</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Name</simpara></entry>
<entry align="left" valign="top"><simpara><literal>Detect fault</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>FaultRegex</simpara></entry>
<entry align="left" valign="top"><simpara><literal>ERROR</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>WaitRegex</simpara></entry>
<entry align="left" valign="top"><simpara><literal>Boot up completed</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>WaitWhen</simpara></entry>
<entry align="left" valign="top"><simpara><literal>OnIterationAfterFault</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis role="strong">IpPower9258 (Reboot router) parameters</emphasis></simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="66.6667*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Value</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Monitor</simpara></entry>
<entry align="left" valign="top"><simpara><literal>IpPower9258</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Name</simpara></entry>
<entry align="left" valign="top"><simpara><literal>Reboot router</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Host</simpara></entry>
<entry align="left" valign="top"><simpara><literal>192.168.1.1:8080</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Port</simpara></entry>
<entry align="left" valign="top"><simpara><literal>1</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>User</simpara></entry>
<entry align="left" valign="top"><simpara><literal>peach</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Password</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PeachPower</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>When</simpara></entry>
<entry align="left" valign="top"><simpara><literal>OnFault</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Monitors_TcpPort">
<title>TcpPort Monitor</title>
<simpara><emphasis role="strong">Monitor Categories</emphasis>: <emphasis role="strong">Automation</emphasis>, <emphasis role="strong">Data collection</emphasis>, <emphasis role="strong">Fault detection</emphasis></simpara>
<simpara>The <emphasis>TcpPort</emphasis> monitor detects state changes on TCP ports.
A state change is a transition in port status from <emphasis>Open</emphasis> to <emphasis>Closed</emphasis> or from <emphasis>Closed</emphasis> to <emphasis>Open</emphasis>.
The <emphasis>TcpPort</emphasis> monitor can be configured in the following ways:</simpara>
<itemizedlist>
<listitem>
<simpara>as an automation task (wait until a specified state occurs)</simpara>
</listitem>
<listitem>
<simpara>fault detection (fault on a specific state)</simpara>
</listitem>
<listitem>
<simpara>data collection (report the current state)</simpara>
</listitem>
</itemizedlist>
<simpara>For automation tasks,
the <emphasis>When</emphasis> parameter can be configured to detect the state of a TCP port
at various points in time during a fuzzing session:</simpara>
<itemizedlist>
<listitem>
<simpara>At the start or end of a fuzzing run</simpara>
</listitem>
<listitem>
<simpara>At the start or end of each test iteration</simpara>
</listitem>
<listitem>
<simpara>After detecting a fault</simpara>
</listitem>
<listitem>
<simpara>At the start of an iteration that immediately follows a fault</simpara>
</listitem>
<listitem>
<simpara>When a specified call is received from the state model</simpara>
</listitem>
</itemizedlist>
<section xml:id="_parameters_35">
<title>Parameters</title>
<simpara><emphasis>Required:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>Host</term>
<listitem>
<simpara>Hostname or IP address of the remote host</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Port</term>
<listitem>
<simpara>Port number to monitor</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>Action</term>
<listitem>
<simpara>Action to take (Automation, Data, Fault).
Defaults to <literal>Automation</literal>.</simpara>
<informaltable tabstyle="horizontal" frame="none" colsep="0" rowsep="0">
<tgroup cols="2">
<colspec colwidth="15*"/>
<colspec colwidth="85*"/>
<tbody valign="top">
<row>
<entry>
<simpara>Automation</simpara>
</entry>
<entry>
<simpara>Wait for the port to reach a specified state.
The <emphasis>When</emphasis> parameter determines when the monitor should detect the state of the specified port.</simpara>
</entry>
</row>
<row>
<entry>
<simpara>Data</simpara>
</entry>
<entry>
<simpara>Report the state of the port immediately following a fault that is detected by any other monitor.</simpara>
</entry>
</row>
<row>
<entry>
<simpara>Fault</simpara>
</entry>
<entry>
<simpara>Generate a fault if the port is in a specified state at the end of an iteration.</simpara>
</entry>
</row>
</tbody>
</tgroup>
</informaltable>
</listitem>
</varlistentry>
</variablelist>
<variablelist>
<varlistentry>
<term>State</term>
<listitem>
<simpara>Port state to monitor.
The default value is <literal>Open</literal>.</simpara>
<informaltable tabstyle="horizontal" frame="none" colsep="0" rowsep="0">
<tgroup cols="2">
<colspec colwidth="15*"/>
<colspec colwidth="85*"/>
<tbody valign="top">
<row>
<entry>
<simpara>Open</simpara>
</entry>
<entry>
<simpara>The port is available for use.</simpara>
</entry>
</row>
<row>
<entry>
<simpara>Closed</simpara>
</entry>
<entry>
<simpara>The port is not available.</simpara>
</entry>
</row>
</tbody>
</tgroup>
</informaltable>
</listitem>
</varlistentry>
</variablelist>
<variablelist>
<varlistentry>
<term>Timeout</term>
<listitem>
<simpara>The amount of time in milliseconds to wait for the specified TCP state to occur.
Specify <literal>-1</literal> to indicate an infinte timeout.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>WaitOnCall</term>
<listitem>
<simpara>Detect port state upon recept of the specified call from the state model.
This value is used only when the <emphasis>When</emphasis> parameter is set to <literal>OnCall</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>When</term>
<listitem>
<simpara>Specify one of the following values to control when port state detection should occur during a fuzzing session:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="66.6667*"/>
<thead>
<row>
<entry align="left" valign="top">"When" Setting</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>OnStart</simpara></entry>
<entry align="left" valign="top"><simpara>Detect port state when the fuzzing session starts.
This occurs once per session.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>OnEnd</simpara></entry>
<entry align="left" valign="top"><simpara>Detect port state when the fuzzing session stops.
This occurs once per session.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>OnIterationStart</simpara></entry>
<entry align="left" valign="top"><simpara>Detect port state at the start of each iteration.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>OnIterationEnd</simpara></entry>
<entry align="left" valign="top"><simpara>Detect port state at the end of each iteration.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>OnFault</simpara></entry>
<entry align="left" valign="top"><simpara>Detect port state when any monitor detects a fault.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>OnIterationStartAfterFault</simpara></entry>
<entry align="left" valign="top"><simpara>Detect port state at the start of the iteration that immediately follows a fault detection.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>OnCall</simpara></entry>
<entry align="left" valign="top"><simpara>Detect port state upon receipt of the call specified by the <emphasis>WaitOnCall</emphasis> parameter from the state model.
This is the default setting.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<figure>
<title>When Choices</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/Monitors/Timings_All.png"/>
</imageobject>
<textobject><phrase>Timings All</phrase></textobject>
</mediaobject>
</figure>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_36">
<title>Examples</title>
<example>
<title>Automation example: Open</title>
<simpara>This example causes Peach to wait until the remote port is in an open state after the <literal>WaitForPort</literal> call is received from the state model.
No timeout interval is provided, so Peach will wait forever.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="66.6667*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Value</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Host</simpara></entry>
<entry align="left" valign="top"><simpara><literal>192.168.133.4</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Port</simpara></entry>
<entry align="left" valign="top"><simpara><literal>502</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>WaitOnCall</simpara></entry>
<entry align="left" valign="top"><simpara><literal>WaitForPort</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</example>
<example>
<title>Automation example: Closed</title>
<simpara>This example causes Peach to wait until the remote port in in a closed state after the <literal>WaitForPort</literal> call is received from the state model.
No timeout interval is provided, so Peach will wait forever.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="66.6667*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Value</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Host</simpara></entry>
<entry align="left" valign="top"><simpara><literal>192.168.133.4</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Port</simpara></entry>
<entry align="left" valign="top"><simpara><literal>502</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>State</simpara></entry>
<entry align="left" valign="top"><simpara><literal>Closed</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>WaitOnCall</simpara></entry>
<entry align="left" valign="top"><simpara><literal>WaitForPort</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</example>
<example>
<title>Fault Detection example</title>
<simpara>This example inspects the state of the remote port at the end of an iteration.
A fault is generated if the port is closed at the end of an iteration.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="66.6667*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Value</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Host</simpara></entry>
<entry align="left" valign="top"><simpara><literal>192.168.133.4</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Port</simpara></entry>
<entry align="left" valign="top"><simpara><literal>502</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Action</simpara></entry>
<entry align="left" valign="top"><simpara><literal>Fault</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>State</simpara></entry>
<entry align="left" valign="top"><simpara><literal>Closed</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</example>
<example>
<title>Data Collection example</title>
<simpara>This example causes the TcpPort monitor to report the state of a port after a fault is detected by any other monitor.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="66.6667*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Value</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Host</simpara></entry>
<entry align="left" valign="top"><simpara><literal>192.168.133.4</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Port</simpara></entry>
<entry align="left" valign="top"><simpara><literal>502</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Action</simpara></entry>
<entry align="left" valign="top"><simpara><literal>Data</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Monitors_Vmware">
<title>Vmware Monitor</title>
<simpara><emphasis role="strong">Monitor Categories</emphasis>: <emphasis role="strong">Automation</emphasis></simpara>
<simpara>The <emphasis>Vmware</emphasis> monitor can control a VMware virtual machine (VM).
This monitor works with a snapshot of the VM that provides a consistent VM environment throughout a fuzzing session.
The <emphasis>Vmware</emphasis> monitor can start a VM snapshot and,
optionally,
reset the VM to a snapshot configuration each iteration.</simpara>
<simpara>The following illustration shows the VMWare Snapshot Manager,
which is used for managing snapshots for a particular VM.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/Monitors/Vmware_SnapshotManager.png" scale="60"/>
</imageobject>
<textobject><phrase>Vmware SnapshotManager</phrase></textobject>
</mediaobject>
</informalfigure>
<section xml:id="_parameters_36">
<title>Parameters</title>
<simpara><emphasis>Required:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>Vmx</term>
<listitem>
<simpara>Path to the virtual machine.</simpara>
<tip>
<simpara>When using with vSphere/ESXi,
prefix the VM image name with the storage location in brackets.
For example, <literal>[ha-datacenter/datastore1] guest/guest.vmx</literal>.</simpara>
</tip>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>SnapshotName</term>
<listitem>
<simpara>VM snapshot name.</simpara>
<simpara>Either <emphasis>SnapshotName</emphasis> or <emphasis>SnapshotIndex</emphasis> must be specified,
but it is an error to specify both.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>SnapshotIndex</term>
<listitem>
<simpara>VM snapshot index specification.</simpara>
<simpara>Either <emphasis>SnapshotName</emphasis> or <emphasis>SnapshotIndex</emphasis> must be specified,
but it is an error to specify both.</simpara>
<simpara>The index specification is a list of zero-based index values delimited by a period (<literal>.</literal>).
The specification resolves which leaf in a tree of snapshots should be used.</simpara>
<simpara>For example,
in the following tree of snapshots,
the snapshot named <literal>Snapshot 1.2.1</literal> would be used when <literal>0.1.0</literal> is specifed.</simpara>
<itemizedlist>
<listitem>
<simpara>Snapshot 1</simpara>
<itemizedlist>
<listitem>
<simpara>Snapshot 1.1</simpara>
</listitem>
<listitem>
<simpara>Snapshot 1.2</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Snapshot 1.2.1</emphasis></simpara>
</listitem>
<listitem>
<simpara>Snapshot 1.2.2</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Snapshot 2</simpara>
<itemizedlist>
<listitem>
<simpara>Snapshot 2.1</simpara>
</listitem>
<listitem>
<simpara>Snapshot 2.2</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term>Host</term>
<listitem>
<simpara>Hostname or IP address the VMware host.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>HostPort</term>
<listitem>
<simpara>TCP/IP port of the VMware host.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Login</term>
<listitem>
<simpara>Username for authentication with the VMware host.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Password</term>
<listitem>
<simpara>Password for authentication with the VMware host.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>HostType</term>
<listitem>
<simpara>Type of remote host, defaults to <literal>Default</literal></simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="66.6667*"/>
<thead>
<row>
<entry align="left" valign="top">VM Product</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><emphasis role="strong">VIServer</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara>vCenter Server, ESX/ESXi hosts, VMWare Server 2.0</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><emphasis role="strong">Workstation</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara>VMWare Workstation</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><emphasis role="strong">WorkstationShared</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara>VMWare Workstation (Shared Mode)</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><emphasis role="strong">Player</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara>VMWare Player</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><emphasis role="strong">Server</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara>VMWare Server 1.0.x</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><emphasis role="strong">Default</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara>Default</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</listitem>
</varlistentry>
<varlistentry>
<term>ResetEveryIteration</term>
<listitem>
<simpara>If <literal>true</literal> is specified,
reset the VM on every iteration.
Defaults to <literal>false</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>ResetOnFaultBeforeCollection</term>
<listitem>
<simpara>If <literal>true</literal> is specified,
reset the VM after a fault is detected by any other monitor.
Defaults to <literal>false</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>StopOnFaultBeforeCollection</term>
<listitem>
<simpara>If <literal>true</literal> is specified,
stop the VM after a fault is detected by any other monitor.
Defaults to <literal>false</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>WaitForToolsInGuest</term>
<listitem>
<simpara>If <literal>true</literal> is specified,
wait for VMware tools to start within the guest whenever a VM is restarted.
Defaults to <literal>true</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>WaitTimeout</term>
<listitem>
<simpara>The number of seconds to wait for VMware tools to start within a guest.
Defaults to <literal>600</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Headless</term>
<listitem>
<simpara>Run a VM without a GUI.
Using this parameter can improve performance but may cause issues if the target interacts with the desktop.
Defaults to <literal>true</literal>.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_37">
<title>Examples</title>
<example>
<title>Start Virtual Machine</title>
<simpara>This parameter example is from a setup that programmatically starts a VM.</simpara>
<itemizedlist>
<listitem>
<simpara>The monitor requires both the physical filename with path of the VM and the <literal>SnapshotName</literal> of the VM.</simpara>
</listitem>
<listitem>
<simpara>The <literal>HostType</literal> identifies the VMWare product that is hosting the VM.</simpara>
</listitem>
<listitem>
<simpara>The <literal>Headless</literal> parameter provides visual feedback while configuring the test setup.</simpara>
</listitem>
</itemizedlist>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="66.6667*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Value</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Vmx</simpara></entry>
<entry align="left" valign="top"><simpara><literal>D:\VirtualMachines\OfficeWebTest\OfficeWebTest.vmx</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>HostType</simpara></entry>
<entry align="left" valign="top"><simpara><literal>Workstation</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>SnapshotName</simpara></entry>
<entry align="left" valign="top"><simpara><literal>Fuzzing</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Headless</simpara></entry>
<entry align="left" valign="top"><simpara><literal>false</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</example>
<example>
<title>Start Virtual Machine hosted on ESXi</title>
<simpara>This parameter example is from a setup that programmatically starts a VM.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="66.6667*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Value</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Vmx</simpara></entry>
<entry align="left" valign="top"><simpara><literal>[ha-datacenter/datastore1] guest/guest.vmx</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>SnapshotName</simpara></entry>
<entry align="left" valign="top"><simpara><literal>Fuzzing</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Monitors_WindowsDebugger">
<title>WindowsDebugger Monitor (Windows)</title>
<simpara><emphasis role="strong">Monitor Categories</emphasis>: <emphasis role="strong">Automation</emphasis>, <emphasis role="strong">Data collection</emphasis>, <emphasis role="strong">Fault detection</emphasis></simpara>
<simpara>The <emphasis>WindowsDebugger</emphasis> monitor controls a windows debugger instance.</simpara>
<simpara>This monitor launches an executable file, a process, or a service with the debugger
attached; or, this monitor can attach the debugger to a running executable,
process, or service.</simpara>
<simpara>The <emphasis>WindowsDebugger</emphasis> performs automation, fault detection, and data collection.</simpara>
<itemizedlist>
<listitem>
<simpara>Automation manages when the fuzzing target (process, service, etc) starts and restarts. This can occur
at the start of a fuzzing session, at the start of each iteration, after detecting a fault,
or upon receiving a call from the state model.</simpara>
</listitem>
<listitem>
<simpara>Fault detection watches and reports crashes and faults&#8212;&#8203;when the target exits prematurely,
and when the target fails to exit.</simpara>
</listitem>
<listitem>
<simpara>Data collection retrieves stack traces, logs, and other information provided by the debugger.
Note that this monitor provides bucket information&#8212;&#8203;major and minor hash values&#8212;&#8203;as part of
data collected on faults. For more information on bucketing provided by this monitor, see <link xl:href="http://msecdbg.codeplex.com/">!exploitable</link>.</simpara>
</listitem>
</itemizedlist>
<section xml:id="_parameters_37">
<title>Parameters</title>
<simpara><emphasis>Exactly one of the three required parameters is needed for each instance of this monitor.
The other two required parameters are not used.</emphasis></simpara>
<variablelist>
<varlistentry>
<term>Executable</term>
<listitem>
<simpara>Executable to launch via the debugger. If the executable has command-line arguments,  specify these in the "Arguments" parameter.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>ProcessName</term>
<listitem>
<simpara>Name of the process that the debugger attaches.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Service</term>
<listitem>
<simpara>Name of the Windows process or service to  attach to the debugger. If the service
crashes or is stopped, this monitor will restart the service.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>Arguments</term>
<listitem>
<simpara>Command-line arguments for the executable file specified with the "Executable" parameter.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>SymbolsPath</term>
<listitem>
<simpara>Path to the debugging symbol files. The default value is Microsoft public
symbols server,SRV*http://msdl.microsoft.com/download/symbols.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>WinDbgPath</term>
<listitem>
<simpara>Path to the Windows Debugger installation. If undeclared, Peach attempts to locate a local installation of the debugger.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>StartOnCall</term>
<listitem>
<simpara>Defers launching the target until the state model issues a call to the monitor
to begin. Upon receiving the call, the debugger attaches to the process, or starts the process
or executable.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>IgnoreFirstChanceGuardPage</term>
<listitem>
<simpara>Ignores faults from the first chance guard page. These faults
are sometimes false positives or anti-debugging faults, defaults to false.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>IgnoreSecondChanceGuardPage</term>
<listitem>
<simpara>Ignores faults from the second chance guard page. These faults
are sometimes false positives or anti-debugging faults, defaults to false.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>IgnoreFirstChanceReadAv</term>
<listitem>
<simpara>Ignores faults from the first chance read access violations. These faults
are sometimes false positives, defaults to false.  Whem monitoring a Java process,
it is recommended to set this parameter to true.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>NoCpuKill</term>
<listitem>
<simpara>Allows or disallows the CPU to idle. If true, the CPU can idle without terminating
the target. If false, Peach polls and then terminates the target if it is caught idling. The
default value is false.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>CpuPollInterval</term>
<listitem>
<simpara>Specifies the time interval, expressed in milliseconds (ms), that the monitor
waits between successive polls of the target. This argument is used when NoCpuKill is false.
The default value is 200 ms.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>FaultOnEarlyExit</term>
<listitem>
<simpara>Triggers a fault if the target exits prematurely, defaults to false.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>RestartAfterFault</term>
<listitem>
<simpara>If "true", restarts the target when any monitor detects a fault.
If "false", restarts the target only if the process exits or crashes.<?asciidoc-br?>
This argument defaults to true.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>RestartOnEachTest</term>
<listitem>
<simpara>Restarts the process for each iteration, defaults to false.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>ServiceStartTimeout</term>
<listitem>
<simpara>When debugging a windows service, this specifies how long the
monitor should wait for the service to start. The default value is 60 seconds.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>WaitForExitOnCall</term>
<listitem>
<simpara>Exits the target upon receiving a call from the state model. If the
call fails to occur within an acceptable  waiting period, issue a fault and then exit. The
WaitForExitTimeout parameter specifies the waiting period.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>WaitForExitTimeout</term>
<listitem>
<simpara>Specifies the WaitForExitOnCall timeout value, expressed in milliseconds,
defaults to 10000 ms (10 sec). The value -1 specifies an infinite waiting period.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_38">
<title>Examples</title>
<formalpara>
<title>Command Line Configuration<?asciidoc-br?></title>
<para>This parameter example is from a setup that launches an application with command-line arguments from the Windows Debugger. The setup also supplies the path where the Windows Debugger resides.</para>
</formalpara>
<informalexample>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="66.6667*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Value</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Executable</simpara></entry>
<entry align="left" valign="top"><simpara><literal>CrashableServer.exe</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Arguments</simpara></entry>
<entry align="left" valign="top"><simpara><literal>127.0.0.1 4244</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>WinDbgPath</simpara></entry>
<entry align="left" valign="top"><simpara><literal>C:\Program Files (x86)\Debugging Tools for Windows (x86)</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</informalexample>
<formalpara>
<title>Service Configuration<?asciidoc-br?></title>
<para>This parameter example attaches the debugger to a service.</para>
</formalpara>
<informalexample>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="66.6667*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Value</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Service</simpara></entry>
<entry align="left" valign="top"><simpara><literal>WinDefend</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</informalexample>
<formalpara>
<title>Process Configuration<?asciidoc-br?></title>
<para>This parameter example attaches the debugger to a process name.</para>
</formalpara>
<informalexample>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="66.6667*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Value</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>ProcessName</simpara></entry>
<entry align="left" valign="top"><simpara><literal>CrashableServer.exe</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</informalexample>
<formalpara>
<title>StartOnCall Configuration <?asciidoc-br?></title>
<para>This parameter example uses the debugger to launch an application with command-line arguments. Further, the launch starts after the monitor receives a call request from the state model to initiate the launch.</para>
</formalpara>
<informalexample>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="66.6667*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Value</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Executable</simpara></entry>
<entry align="left" valign="top"><simpara><literal>CrashableServer.exe</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Arguments</simpara></entry>
<entry align="left" valign="top"><simpara><literal>127.0.0.1 4244</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>StartOnCall</simpara></entry>
<entry align="left" valign="top"><simpara><literal>launchProgram</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</informalexample>
<formalpara>
<title>Exit Configurations <?asciidoc-br?></title>
<para>This parameter example uses the debugger to launch an application with command-line arguments. Further, the monitor polls the application for idleness, and terminates the application if it finds an idle CPU. At the end of each iteration, Peach waits a maximum of 250ms for the application to close of its own accord before terminating the application.</para>
</formalpara>
<informalexample>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="66.6667*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Value</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Executable</simpara></entry>
<entry align="left" valign="top"><simpara><literal>CrashableServer.exe</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Arguments</simpara></entry>
<entry align="left" valign="top"><simpara><literal>127.0.0.1 4244</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>NoCpuKill</simpara></entry>
<entry align="left" valign="top"><simpara><literal>true</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>FaultOnEarlyExit</simpara></entry>
<entry align="left" valign="top"><simpara><literal>false</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>WaitForExitTimeout</simpara></entry>
<entry align="left" valign="top"><simpara><literal>250</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</informalexample>
<formalpara>
<title>WaitForExitOnCall Configuration <?asciidoc-br?></title>
<para>This parameter example uses the debugger to launch an application with command-line arguments. Further, the monitor defers closing the application until receiving the notice from the state model.</para>
</formalpara>
<informalexample>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="66.6667*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Value</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Executable</simpara></entry>
<entry align="left" valign="top"><simpara><literal>CrashableServer.exe</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Arguments</simpara></entry>
<entry align="left" valign="top"><simpara><literal>127.0.0.1 4244</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>WaitForExitOnCall</simpara></entry>
<entry align="left" valign="top"><simpara><literal>exitProgram</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</informalexample>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Monitors_WindowsKernelDebugger">
<title>WindowsKernelDebugger Monitor (Windows)</title>
<simpara><emphasis role="strong">Monitor Categories</emphasis>: <emphasis role="strong">Data collection</emphasis>, <emphasis role="strong">Fault detection</emphasis></simpara>
<simpara>The <emphasis>WindowsKernelDebugger</emphasis> monitor controls debugging of a remote windows kernel
debugging instance. At least two machines are involved:</simpara>
<itemizedlist>
<listitem>
<simpara>The target machine that receives fuzzing data.</simpara>
</listitem>
<listitem>
<simpara>The host machine that controls the debugging session. Peach resides on this machine</simpara>
</listitem>
</itemizedlist>
<simpara>The <emphasis>WindowsKernelDebugger</emphasis> performs fault detection, and data collection.</simpara>
<itemizedlist>
<listitem>
<simpara>Fault detection watches and reports crashes and faults&#8212;&#8203;when the target exits prematurely,
and when the target fails to exit.</simpara>
</listitem>
<listitem>
<simpara>Data collection retrieves stack traces, logs, and other information provided by the debugger.
Note that this monitor provides bucket information&#8212;&#8203;major and minor hash values&#8212;&#8203;as part of
data collected on faults. For more information on bucketing provided by this monitor, see <link xl:href="http://msecdbg.codeplex.com/">!exploitable</link>.</simpara>
</listitem>
</itemizedlist>
<simpara>The workflow for this configuration follows:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>On the host machine, start Peach with the WindowsKernelDebugger Monitor.<?asciidoc-br?>
This action starts the fuzzing and loads a copy of Windbg in kernel mode. The
host machine enters a waiting state because the target machine will initiate and
secure the connection for the debugging session.</simpara>
</listitem>
<listitem>
<simpara>On the target machine, open Windbg, and choose "Connect to Remote Session" from the File menu.</simpara>
<itemizedlist>
<listitem>
<simpara>For the "Connection String", specify the "transport:port" and the server for the debugging session, as in this example: <literal>net:port=5000,key=1.2.3.4</literal>.<?asciidoc-br?></simpara>
</listitem>
<listitem>
<simpara>Click OK.</simpara>
</listitem>
</itemizedlist>
</listitem>
</orderedlist>
<simpara>The debug session starts on the target machine. The target machine initiates contact
with the host to establish the connection. Once the connection is secure, the host
machine (with Peach) drives the activities.</simpara>
<important>
<simpara>Instrumenting this configuration requires additional monitors external to the target. The monitors need to be able to restart the target after a crash, and to have the host resume fuzzing.</simpara>
</important>
<section xml:id="_parameters_38">
<title>Parameters</title>
<variablelist>
<varlistentry>
<term>KernelConnectionString</term>
<listitem>
<simpara>Connection string for attaching the debugger to a kernel-mode process
(e.g. a driver). The connection string <literal>net:port=5000,key=1.2.3.4</literal> indicates this is the debug server and uses the tcp transport on port 5000. The Windows debugger offers a choice of transports; and, the port is arbitrary. For more information on using other values, see MSDN articles on live kernel mode, debugging, remote debugging, and kernel connection strings.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>SymbolsPath</term>
<listitem>
<simpara>Path to the debugging symbol files. The default value is Microsoft public
symbols server <literal>SRV*http://msdl.microsoft.com/download/symbols</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>WinDbgPath</term>
<listitem>
<simpara>Path to the windbg installation. If undeclared, Peach attempts to locate a local installation of the debugger.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>ConnectTimeout</term>
<listitem>
<simpara>Duration, in milliseconds, to wait to receive a kernel connection. The default value is 3000 ms.</simpara>
<simpara><?asciidoc-pagebreak?></simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
</section>
<section xml:id="Monitors_WindowsService">
<title>WindowsService Monitor (Windows)</title>
<simpara><emphasis role="strong">Monitor Categories</emphasis>: <emphasis role="strong">Automation</emphasis>, <emphasis role="strong">Fault detection</emphasis></simpara>
<simpara>The <emphasis>WindowsService</emphasis> monitor controls a windows service. When the monitor runs, it checks
the state of the service. If the service exits prematurely, <emphasis>WindowsService</emphasis> generates a fault.
If a fault is detected by from <emphasis>windowsService</emphasis> or from another monitor, the monitor collects status of
the service and continues.</simpara>
<simpara>If the service is not running, this monitor attempts to restore the service to a running state, whether starting, restarting, or resuming from a paused state.</simpara>
<section xml:id="_parameters_39">
<title>Parameters</title>
<simpara><emphasis>Required:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>Service</term>
<listitem>
<simpara>Name that identifies the service to the system, such as the display name of the service.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>FaultOnEarlyExit</term>
<listitem>
<simpara>Fault if the service exits early, defaults to false.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>MachineName</term>
<listitem>
<simpara>Name of the computer on which the service resides, defaults to local machine.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Restart</term>
<listitem>
<simpara>Specifies whether to start the service on each iteration, defaults to false.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>StartTimeout</term>
<listitem>
<simpara>Specifies the duration, in minutes, to wait for the service to start, defaults to 1 minute.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_39">
<title>Examples</title>
<example>
<title>Start IIS<?asciidoc-br?></title>
<simpara>This parameter example is from a minimal setup that monitors the Internet Information Service (IIS) at the beginning of the fuzzing run. The example runs on the local machine with a startup timeout period of 1 minute. In this case, the monitor does not generate a fault if the service exits early, nor restarts the service for each test iteration.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="66.6667*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Value</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Service</simpara></entry>
<entry align="left" valign="top"><simpara><literal>World Wide Web Publishing Service</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
</section>
<section xml:id="ReproducingFaults">
<title>Reproducing Faults</title>
<simpara>A fault that occurs in a fuzzing session needs to be reproducible so that it can be investigated, understood, and mitigated.
Peach has the following features that aid in reproducing faults that occur during fuzzing:</simpara>
<itemizedlist>
<listitem>
<simpara>Automatic fault reproduction</simpara>
</listitem>
<listitem>
<simpara>Replay the fuzzing session</simpara>
</listitem>
</itemizedlist>
<simpara>When a fault is detected at the end of a test case, Peach automatically enters reproduction mode.
How Peach implements fault reproduction depends on the type of target being fuzzed.</simpara>
<figure>
<title>Fault Reproduction Flow Chart</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/FaultFlowchart.svg" align="center"/>
</imageobject>
<textobject><phrase>FaultFlowchart</phrase></textobject>
</mediaobject>
</figure>
<section xml:id="_iteration_based_targets">
<title>Iteration Based Targets</title>
<simpara>Iteration based test targets are targets that restart with every test case.
File fuzzing targets are typically iteration based targets.
For example, an image viewer that is started during every test case would be considered an iteration target.
When reproducing a fault found on an iteration target, Peach will only try the initial faulting test case.
Peach will not try and reproduce the fault using previous test cases.</simpara>
<note>
<simpara>There are rare cases in which an iteration based target retains enough state through a data store that a prior test case may impact the crash.  As faults are triaged if you find a significant number of faults that fall into this category it may make sense to reconfigure the Pit to be session based.  Currently this is only possible if you have developer access to the pit in question.</simpara>
</note>
</section>
<section xml:id="_session_based_targets">
<title>Session Based Targets</title>
<simpara>Session based test targets are targets that do not restart with every test case.
Server or service targets are typically session based targets.
For example, an FTP server that is started at the beginning of a fuzzing session would be considered a session target.
With session targets, it is possible that a detected fault is the byproduct of previously executed test cases.
Therefore, when reproducing a fault found on a session target, Peach will replay sequences of previous test cases.
Peach will then locate the exact test case or range of test cases required to reproduce the fault.
If a fault is reproduced on a non-fuzz (control) test case that runs after one or more fuzz test cases,
Peach will record the range of test cases executed and consider the fault to be reproducable.</simpara>
<section xml:id="_searching_for_reproduction">
<title>Searching For Reproduction</title>
<simpara>When Peach detects a fault, it always attempts to reproduce the fault.
This reproduction involves searching through previously executed test cases.
The following steps describe the major elements of the search:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Replay the most recent test. This typically is where the fault surfaces.<?asciidoc-br?>
If the fault reproduces, the system logs the information and the search finishes.<?asciidoc-br?>
If the test target restarts with each fuzzing iteration, the search finishes because the test started in a known, clean state.
Otherwise, continue with step 2.</simpara>
</listitem>
<listitem>
<simpara>Replay the last 10 iterations, running them in the same sequence as in the fuzzing session.<?asciidoc-br?>
If the fault reproduces, the system logs the information and the search finishes. Otherwise, continue with step 3.</simpara>
</listitem>
<listitem>
<simpara>Double the number of iterations, and run them in the same sequence as in the fuzzing session.<?asciidoc-br?>
If the fault reproduces, the system logs the information and the search finishes. If not, continue the search, each time doubling the number of iterations to run. The criteria for stopping follows:<?asciidoc-br?></simpara>
<itemizedlist>
<listitem>
<simpara>Reproduce the fault.</simpara>
</listitem>
<listitem>
<simpara>Encounter a critical point in the data; the effort to recreate the fault encountered another fault that peach found and logged during the test session.</simpara>
</listitem>
<listitem>
<simpara>Encounter a user-specified limit for the search.</simpara>
</listitem>
</itemizedlist>
</listitem>
</orderedlist>
<simpara>Using a search limit of 200, the following sets of iterations would run until the limit is reached:</simpara>
<itemizedlist>
<listitem>
<simpara>1 iteration<?asciidoc-br?></simpara>
</listitem>
<listitem>
<simpara>10 iterations<?asciidoc-br?></simpara>
</listitem>
<listitem>
<simpara>20 iterations<?asciidoc-br?></simpara>
</listitem>
<listitem>
<simpara>40 iterations<?asciidoc-br?></simpara>
</listitem>
<listitem>
<simpara>80 iterations<?asciidoc-br?></simpara>
</listitem>
<listitem>
<simpara>160 iterations<?asciidoc-br?></simpara>
</listitem>
<listitem>
<simpara>200 iterations (greater than 160 iterations and less than 320 iterations, which is the next cutoff point)</simpara>
</listitem>
</itemizedlist>
<simpara>All told, a maximum of 511 iterations would run (1 + 10 + 20 + &#8230;&#8203; + 200) without human intervention; and some of the iterations would be repeated on subsequent passes.</simpara>
<simpara>Some additional considerations about automated fault reproduction include the following:</simpara>
<itemizedlist>
<listitem>
<simpara>Control iterations are treated as in a normal fuzzing session. That is, the results of a control iteration serves as a standard of comparison for the results of record iterations. Also, the frequency of performing a control iteration is determined by the <emphasis>controlIteration</emphasis> attribute of the <emphasis>Test</emphasis> element.</simpara>
</listitem>
<listitem>
<simpara>Record iterations are still compared to control iterations. If the results of a record iteration matches the results of a control iteration, all is well and good, and processing advances to the next iterations. If the results of a record iteration do not match the results of a control iteration, the results are logged and the search to reproduce the fault ends.</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="_how_to_control_the_automated_fault_reproduction">
<title>How to Control the Automated Fault Reproduction</title>
<simpara>If you use a licensed Peach Pit, the appropriate automated settings are already included in the fuzzing definition.</simpara>
</section>
<section xml:id="_replay_the_fuzzing_session">
<title>Replay the Fuzzing Session</title>
<simpara>Any test case generated by Peach can be replayed.
This allows an engineer to more easily perform root cause analysis of the fault discovered in the device under test.
In order for Peach to replay a test case, you need:</simpara>
<itemizedlist>
<listitem>
<simpara>The exact version of Peach</simpara>
</listitem>
<listitem>
<simpara>The pit used in the fuzzing session (the DataModel and the StateModel must be identical to those used in the fuzzing session)</simpara>
</listitem>
<listitem>
<simpara>The seed value used in the fuzzing job</simpara>
</listitem>
<listitem>
<simpara>The test case that caused the fault</simpara>
</listitem>
</itemizedlist>
<simpara>With this information, you can re-run the appropriate part of the fuzzing session.
For an example, see the <link linkend="Replay_Existing_Test_Sequence">example</link> listed in the <link linkend="Program_Peach">The Peach Command Line Interface</link>.</simpara>
<simpara>If the command line does not specify an iteration range or a starting iteration, the entire fuzzing session runs.</simpara>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="_appendixes">
<title>Appendixes</title>
<section xml:id="VM_Setup">
<title>Using Virtual Machines</title>
<simpara>When a configuration requires two or more machines, one machine runs Peach to generate
the fuzzing test cases and to manage the fuzzing contributions of the other, remote machines. Within each remote machine, an agent process runs that handles monitoring of the test target and communications with Peach.</simpara>
<simpara>A remote machine can be either a physical machine or a virtual machine (VM). Peach
includes monitors for automating VMs that use VMware products. Further, many of the
recipes assume a VM is used and that it has a saved state called a snapshot. Peach can
use the snapshot for initially loading the VM in a fuzzing job and for resetting the VM after detecting a fault.</simpara>
<simpara>Since a Peach agent always runs in the remote machines, it helps the automation effort
to create the snapshot with the Peach agent running. The resulting benefit is that
whenever Peach reverts to the snapshot, the VM starts with the Peach agent loaded
and running.</simpara>
<simpara>The steps to create a VM snapshot for Peach follows:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Start the VM to house the test target (such as a network service).</simpara>
</listitem>
<listitem>
<simpara>Start a Peach Agent in the VM.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>For Windows VMs,</simpara>
<orderedlist numeration="lowerroman">
<listitem>
<simpara>Open a command Processor with administrative privileges.</simpara>
</listitem>
<listitem>
<simpara>Navigate to the folder containing Peach, such as: <literal>cd C:\peach</literal></simpara>
</listitem>
<listitem>
<simpara>Launch the Peach agent: <literal>peach –a tcp</literal></simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>For Linux and OS X VMs,</simpara>
<orderedlist numeration="lowerroman">
<listitem>
<simpara>Open a terminal.</simpara>
</listitem>
<listitem>
<simpara>Navigate to the folder containing peach, such as: <literal>cd ~/peach</literal></simpara>
</listitem>
<listitem>
<simpara>Start the script for running the Peach agent: <literal>./peach –a tcp</literal></simpara>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Using the VMware menu on the host OS, select VM &#8594; Snapshot &#8594; Take Snapshot.
The following dialog appears. The title bar identifies image used in the snapshot.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/UserGuide/VM_Snapshot_Ubuntu.png" scale="50"/>
</imageobject>
<textobject><phrase>VM Snapshot Ubuntu</phrase></textobject>
</mediaobject>
</informalfigure>
</listitem>
<listitem>
<simpara>Fill in the following information in the dialog:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Name: The name must be unique.</simpara>
</listitem>
<listitem>
<simpara>Description: This is an optional field.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Click &lt;Take Snapshot&gt; to record the VM state.</simpara>
</listitem>
</orderedlist>
<important>
<simpara><emphasis role="strong">IMPORTANT</emphasis>: Save the following pieces of information. They are needed for automating the VM.</simpara>
<itemizedlist>
<listitem>
<simpara>Full path of the VM image used in the snapshot.<?asciidoc-br?>
The VM image is stored on the file system. The VM image file extension is <literal>.vmx</literal>.</simpara>
</listitem>
<listitem>
<simpara>Snapshot name.</simpara>
</listitem>
</itemizedlist>
</important>
</section>
<section xml:id="Recipe_StaticIpSetup">
<title>Setting a Static IPv4 Address</title>
<simpara>While running automated fuzzing sessions, use this to ensure the IP address on the target system is the same every time it runs. Different operating systems have different ways of implementing it.</simpara>
<simpara>The information for Windows and Ubuntu Linux systems is provided. The workflow for other Unix-based systems, such as OS X, CentOS, and SUSE Linux, are similar.</simpara>
<section xml:id="_windows">
<title>Windows</title>
<simpara>This consists of changing the Internet Protocol Version 4 settings for the network adapter used in the test.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>You can navigate to the IPv4 Settings using the following menu entries:</simpara>
<simpara>Control Panel &#8594; Network and Internet &#8594; Network Connections</simpara>
</listitem>
<listitem>
<simpara>Select the appropriate network adapter.</simpara>
</listitem>
<listitem>
<simpara>Right-click and select Properties from the shortcut menu.</simpara>
</listitem>
<listitem>
<simpara>Select the Internet Protocol Version 4 (IPv4) entry and click "Properties".</simpara>
<simpara>The following properties dialogs for the IPv4 protocol display settings for a dynamic IP assignment on the left. The static values are displayed on the right. Values specified for the static IPv4 address are fictitious. Use the values provided by running the <literal>ipconfig –all</literal> command in a command processor.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/UserGuide/IPv4_Chg_to_Static.png" scale="50"/>
</imageobject>
<textobject><phrase>IPv4 Chg to Static</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Click "Use the following IP address", and fill in the values for the IP address, submask, and gateway, as well as the entries for DNS servers.</simpara>
</listitem>
<listitem>
<simpara>When finished, click OK.</simpara>
</listitem>
</orderedlist>
<section xml:id="_linux">
<title>Linux</title>
<simpara>The change to use a static IPv4 address is similar to the change made to Windows systems. The biggest difference is adding a step to restart the network service after the changes.</simpara>
<simpara>The changes are made to entries in the <literal>/etc/network/interfaces</literal> file. Note that root privileges are needed to update this file.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Configure the network interface</simpara>
<simpara>Initial settings (Before change)</simpara>
<informalexample>
<simpara>auto lo<?asciidoc-br?>
iface lo inet loopback<?asciidoc-br?>
iface eth0 inet dynamic</simpara>
</informalexample>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Change the first line of the interface entry (here, the <literal>eth0</literal> interface) by replacing <literal>dynamic</literal> with <literal>static</literal>.</simpara>
</listitem>
<listitem>
<simpara>Supply the address of the interface to the entry listed by <literal>ifconfig</literal>.</simpara>
</listitem>
<listitem>
<simpara>Supply the gateway address that is the address of the router.</simpara>
<simpara>Edited settings (Changes applied)</simpara>
<informalexample>
<simpara>auto lo<?asciidoc-br?>
iface lo inet loopback<?asciidoc-br?>
iface eth0 inet static<?asciidoc-br?></simpara>
<literallayout class="monospaced">address 192.168.1.101 +
netmask 255.255.255.0 +
gateway 192.168.1.1 +</literallayout>
</informalexample>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Save the changes.</simpara>
</listitem>
<listitem>
<simpara>Configure the DNS server.</simpara>
<simpara>The DNS name servers need to be updated.</simpara>
<itemizedlist>
<listitem>
<simpara>If your Ubuntu system is 14.04 or greater, add the following line to <literal>/etc/network/interfaces</literal>:</simpara>
<informalexample>
<simpara>dns-nameservers 8.8.8.8</simpara>
</informalexample>
</listitem>
<listitem>
<simpara>For Ubuntu systems earlier than 14.04, the update DNS server update occurs in the <literal>/etc/resolv.conf</literal> file. Add the IP addresses for the servers using the following syntax.</simpara>
<informalexample>
<literallayout class="monospaced">nameserver xxx.xxx.xxx.xxx
nameserver xxx.xxx.xxx.xxx</literallayout>
<simpara>+
Example: Using the Google DNS servers, these lines would be:
<emphasis role="strong">    nameserver 8.8.8.8
</emphasis>    nameserver 8.8.4.4</simpara>
</informalexample>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Save the change.</simpara>
</listitem>
<listitem>
<simpara>Restart the network service.</simpara>
<simpara>As with the DNS servers, 2 permutations exist.
<emphasis role="strong"> For Ubuntu systems version 14.04 and greater, use the following command:<?asciidoc-br?>
    systemctl restart ifup@eth0
</emphasis> For Ubuntu systems with a version less than 14.04, use the following command:<?asciidoc-br?>
    sudo /etc/init.d/networking restart</simpara>
</listitem>
</orderedlist>
</section>
</section>
</section>
</section>
</article>