<?xml version="1.0" encoding="UTF-8"?>
<?asciidoc-toc maxdepth="3"?>
<?asciidoc-numbered?>
<article xmlns="http://docbook.org/ns/docbook" xmlns:xl="http://www.w3.org/1999/xlink" version="5.0" xml:lang="en">
<info>
<title>Peach Fuzzer Professional</title>
<subtitle>Developer Guide</subtitle>
<date>2021-09-28</date>
<author>
<personname>
<firstname>Peach Fuzzer, LLC</firstname>
</personname>
</author>
<authorinitials>P</authorinitials>
</info>
<simpara><?asciidoc-pagebreak?></simpara>
<section xml:id="Preface">
<title>Preface</title>
<simpara>This document is one of two books that together form the official documentation of Peach Fuzzer Professional  v0.0. This documentation set is written by the Peach Fuzzer Professional team, and represents a concerted effort to document fully all of the Peach Fuzzer Professional features.</simpara>
<simpara>This book, the Peach Fuzzer Professional Developer Guide, focuses on developer needs such as advanced configurations, building custom fuzzing definitions, and extending the various areas of Peach. Topics of interest include Modeling, Providing Sample Data, Running Peach, Tutorials, and Extending Peach. The reference section is comprehensive.</simpara>
<simpara>The primary audience for this guide is a software developer who is familiar with C, Python, and XML. Also needed is intimate knowledge of the test target because that drives design decisions.</simpara>
<simpara>Day-to-day activities are located in the Peach Fuzzer Professional User Guide that focuses on running Peach with the Web user interface, reading fuzzing results, and setting up monitors from a set of recipes.</simpara>
<simpara>Peach Fuzzer has been in active development through three major revisions since 2004. Until 2014, no complete documentation existed. The current Developer Guide and User Guide bear witness that documenting Peach is an on-going effort.</simpara>
<section xml:id="_what_is_peach_fuzzer_professional">
<title>What is Peach Fuzzer Professional?</title>
<simpara>Peach Fuzzer Professional (Peach) is a fuzzer for data consumers. Peach is a smart fuzzer that operates by performing the following actions:</simpara>
<itemizedlist>
<listitem>
<simpara>Understand the data structure and the flows of the test target</simpara>
</listitem>
<listitem>
<simpara>Create and feed malformed data to the test target</simpara>
</listitem>
<listitem>
<simpara>Monitor the test target to record interesting information when unintended or undesirable behavior occurs (monitors include debuggers and network packet sniffers)</simpara>
</listitem>
</itemizedlist>
<simpara>Peach is a versatile product and has been used to fuzz a wide range of products and devices:</simpara>
<itemizedlist>
<listitem>
<simpara>web browsers (file consumers)</simpara>
</listitem>
<listitem>
<simpara>web servers (network servers)</simpara>
</listitem>
<listitem>
<simpara>mobile devices (such as Android iOS)</simpara>
</listitem>
<listitem>
<simpara>robots</simpara>
</listitem>
<listitem>
<simpara>SCADA systems</simpara>
</listitem>
<listitem>
<simpara>Semiconductor chips</simpara>
</listitem>
</itemizedlist>
<simpara>Because Peach can easily extend its interfacing and monitoring, it is the most adaptable fuzzer that exists.</simpara>
</section>
<section xml:id="_a_brief_history_of_peach">
<title>A Brief History of Peach</title>
<simpara>Peach Fuzzer has been in active development since 2004. Since then it has gone through three major versions:</simpara>
<simpara><emphasis role="strong">Peach v1</emphasis></simpara>
<simpara>Peach v1 was written in 2004 during the PH-Neutral conference in Berlin Germany.
Peach was the first fuzzer to take a more object-oriented approach.
Because Peach was originally written in Python, this version required writing Python code to target and utilize.</simpara>
<simpara><emphasis role="strong">Peach v2</emphasis></simpara>
<simpara>Peach v2 was a complete redesign of Peach based on the lessons learned developing and using the first version.
It introduced all of the core concepts still used in Peach today.</simpara>
<simpara>Because Peach v2 was the first true modeling fuzzer available, it became widely used in the industry.
This was the first Peach version to use the three M&#8217;s approach to fuzzing: Model, Mutate, and Monitor.
Peach v2 still required writing Python code to target and utilize.</simpara>
<simpara><emphasis role="strong">Peach v3</emphasis></simpara>
<simpara>Peach had outgrown Python as a language so Peach v3 was rewritten using the Microsoft .NET environment and the C# language.</simpara>
<simpara>In Peach v3, the core concepts remain the same, but the internals were re-architected to allow for the next generation of features.
The fuzzing definitions (Pits) are largely backwards compatible with the prior version.
Peach v3 introduced Peach Farm, the tool set for scaling fuzzing and for controlling fuzzing server farms.</simpara>
<simpara>Peach is currently developed and maintained by Peach Fuzzer, LLC, in Seattle, WA.</simpara>
</section>
<section xml:id="_additional_resources">
<title>Additional Resources</title>
<simpara>More information about Peach is available on the Web:</simpara>
<itemizedlist>
<listitem>
<simpara><link xl:href="http://peachfuzzer.com">Peach Fuzzer website</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="http://www.peachfuzzer.com/products/peach-pits/">Current Pits and Pit Packs</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://forums.peachfuzzer.com">Peach User Forums</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://vimeo.com/148176046">Installing Peach Fuzzer Software video</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="_bug_reporting_guidelines">
<title>Bug Reporting Guidelines</title>
<simpara>Support for Peach Fuzzer is available in two ways:</simpara>
<itemizedlist>
<listitem>
<simpara>The Peach Forums site</simpara>
</listitem>
<listitem>
<simpara>Using the Peach ticketing system to open a support ticket</simpara>
</listitem>
</itemizedlist>
<section xml:id="Peach_Forums">
<title>Peach Forums</title>
<simpara>There are two sets of forums for Peach, the community forums and the professional forums. Both forums are hosted at <link xl:href="https://forums.peachfuzzer.com">https://forums.peachfuzzer.com</link>.</simpara>
<simpara>Peach Fuzzer Professional users should access the private forums to receive support for the commercial versions of Peach. Responses on the commercial forums are prioritized over the public community forums.</simpara>
<simpara>To access the Peach Fuzzer Professional forums, follow these steps:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Register an account on the forums site.</simpara>
</listitem>
<listitem>
<simpara>Send an email to <link xl:href="mailto:support@peachfuzzer.com">support@peachfuzzer.com</link> with your license email and forum username.</simpara>
</listitem>
<listitem>
<simpara>Your account will be granted access to the commercial forums within 24 business hours.</simpara>
</listitem>
</orderedlist>
<simpara>Forums are monitored by the team at Peach Fuzzer, LLC; however, there is no guarantee of response time.</simpara>
</section>
<section xml:id="_support_tickets">
<title>Support Tickets</title>
<simpara>You can open a support ticket by sending an email to <emphasis>support@peachfuzzer.com</emphasis>. You will receive an initial response within 24 business hours of opening the ticket. Peach support is available Monday through Friday. Peach support is not currently available on weekends or holidays.</simpara>
<simpara>When opening a ticket, please provide the following information in your email:</simpara>
<itemizedlist>
<listitem>
<simpara>Operating system(s) in use by Peach and any agents</simpara>
</listitem>
<listitem>
<simpara>Exact version of Peach being used. This is available from the console output and in the <emphasis>status.txt</emphasis> log file</simpara>
</listitem>
<listitem>
<simpara>Detailed description of the issue and expected behavior</simpara>
</listitem>
<listitem>
<simpara>Console output using the <emphasis>--trace</emphasis> argument</simpara>
</listitem>
<listitem>
<simpara>(if possible) the full Pit file and configuration files</simpara>
</listitem>
</itemizedlist>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
</section>
<section xml:id="Installation">
<title>Installation</title>
<simpara>The following list contains links to the sections that describe in detail how to download, install and activate Peach Fuzzer.</simpara>
<variablelist>
<varlistentry>
<term><link linkend="Installation_Hardware">Recommended Hardware</link></term>
<listitem>
<simpara>This section describes the minimum and recommended hardware requirements for common fuzzing scenarios.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Installation_Download">Product Download</link></term>
<listitem>
<simpara>This section contains the steps required to download the product for your desired platform.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Product Installation</term>
<listitem>
<simpara>This section lists the software prerequisites, OS specific configuration, and steps for installing the product on each of the three supported platforms:</simpara>
<itemizedlist>
<listitem>
<simpara><link linkend="InstallOnWindows">Windows</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="InstallOnLinux">Linux</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="InstallOnOSX">OSX</link></simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term>Product Activation</term>
<listitem>
<simpara>The list below contains links to the steps for activating the different types of Peach Fuzzer licenses.</simpara>
<itemizedlist>
<listitem>
<simpara><link linkend="ActivateOnline">Usage Based (Online Synchronization)</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="ActivateOffline">Usage Based (Offline Synchronization)</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="ActivateNodeLock">Node Locked</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="ActivateEnterprise">Enterprise</link></simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term>Optional Configuration</term>
<listitem>
<simpara>The list below contains links to optional post-install configurations.</simpara>
<itemizedlist>
<listitem>
<simpara><link linkend="InstallSecureInstall">Enabling HTTPS And Authentication</link></simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>
<section xml:id="Installation_Hardware">
<title>Hardware Requirements</title>
<simpara>The following are generic hardware recommendations. Adjust based on your needs.</simpara>
<section xml:id="_local_target">
<title>Local Target</title>
<simpara>When fuzzing a local target (software running on the same machine as Peach),
additional resources are required for the target process.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="5">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="20*"/>
<colspec colname="col_3" colwidth="20*"/>
<colspec colname="col_4" colwidth="20*"/>
<colspec colname="col_5" colwidth="20*"/>
<thead>
<row>
<entry align="left" valign="top">Target Type</entry>
<entry align="left" valign="top">Architecture</entry>
<entry align="left" valign="top">Cores</entry>
<entry align="left" valign="top">Ram</entry>
<entry align="left" valign="top">Disk</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Network</simpara></entry>
<entry align="left" valign="top"><simpara>64-bit</simpara></entry>
<entry align="left" valign="top"><simpara>4</simpara></entry>
<entry align="left" valign="top"><simpara>8GB</simpara></entry>
<entry align="left" valign="top"><simpara>60GB SSD</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>File</simpara></entry>
<entry align="left" valign="top"><simpara>64-bit</simpara></entry>
<entry align="left" valign="top"><simpara>4</simpara></entry>
<entry align="left" valign="top"><simpara>16GB</simpara></entry>
<entry align="left" valign="top"><simpara>60GB SSD</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Other</simpara></entry>
<entry align="left" valign="top"><simpara>64-bit</simpara></entry>
<entry align="left" valign="top"><simpara>4</simpara></entry>
<entry align="left" valign="top"><simpara>8GB</simpara></entry>
<entry align="left" valign="top"><simpara>60GB SSD</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
<section xml:id="_remote_target">
<title>Remote Target</title>
<simpara>Remote target fuzzing occurs when the target is not located on the machine running Peach.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="5">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="20*"/>
<colspec colname="col_3" colwidth="20*"/>
<colspec colname="col_4" colwidth="20*"/>
<colspec colname="col_5" colwidth="20*"/>
<thead>
<row>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top">Architecture</entry>
<entry align="left" valign="top">Cores</entry>
<entry align="left" valign="top">Ram</entry>
<entry align="left" valign="top">Disk</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Minimum</simpara></entry>
<entry align="left" valign="top"><simpara>64-bit</simpara></entry>
<entry align="left" valign="top"><simpara>2</simpara></entry>
<entry align="left" valign="top"><simpara>4GB</simpara></entry>
<entry align="left" valign="top"><simpara>60GB Any</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Recommended</simpara></entry>
<entry align="left" valign="top"><simpara>64-bit</simpara></entry>
<entry align="left" valign="top"><simpara>2</simpara></entry>
<entry align="left" valign="top"><simpara>8GB</simpara></entry>
<entry align="left" valign="top"><simpara>60GB SSD</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<tip>
<simpara>It&#8217;s possible to run Peach on 32-bit systems,
but it&#8217;s not recommended as it places severe limits on memory usage (max 2GB).</simpara>
</tip>
</section>
</section>
<section xml:id="Installation_Download">
<title>Downloading</title>
<simpara>The first step of the installation is to download the Peach Fuzzer distribution files from the Peach download site.
Once the appropriate files have been downloaded,
follow the instructions for your specific operating system found in the next section.</simpara>
<variablelist>
<varlistentry>
<term><link linkend="Installation_UserAccount">User Account Download</link></term>
<listitem>
<simpara>If you were assigned an account with a username/password, follow these instructions to sign in and download Peach Fuzzer.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Installation_UserAccount">Enterprise Download</link></term>
<listitem>
<simpara>If you were provided an enterprise license file, follow the instructions to sign in and download Peach Fuzzer.</simpara>
</listitem>
</varlistentry>
</variablelist>
<section xml:id="Installation_UserAccount">
<title>User Account Download</title>
<orderedlist numeration="arabic">
<listitem>
<simpara>When your Peach Fuzzer welcome email arrives, click the link to reset your initial password.</simpara>
</listitem>
<listitem>
<simpara>Navigate to <link xl:href="https://portal.peachfuzzer.com">https://portal.peachfuzzer.com</link> with your preferred web browser.</simpara>
</listitem>
<listitem>
<simpara>At the login prompt under the Portal Login section,
enter the new username/password that was recently reset and click <literal>Sign In</literal>.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/Installation/Portal_Home.png"/>
</imageobject>
<textobject><phrase>Portal Home</phrase></textobject>
</mediaobject>
</informalfigure>
<note>
<simpara>Contact <link xl:href="mailto:support@peach.tech">support@peach.tech</link> if you need your account password reset.</simpara>
</note>
</listitem>
<listitem>
<simpara>On the <literal>Downloads</literal> page, select the Peach Fuzzer release version and operating system to install.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Choose a release version from the items on the left side.</simpara>
</listitem>
<listitem>
<simpara>Click the download icon on the right side after deciding which OS and architecture is needed.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/Installation/Portal_Downloads.png"/>
</imageobject>
<textobject><phrase>Portal Downloads</phrase></textobject>
</mediaobject>
</informalfigure>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>If your organization has multiple entitlements,
you may need to select an Activation ID that corresponds to the license the download should be tied to.
This selection page will not be displayed if there is only one entitlement for your organization.
Contact <link xl:href="mailto:licensing@peach.tech">licensing@peach.tech</link> for more information if you are unsure which Activation ID to select.</simpara>
</listitem>
<listitem>
<simpara>After a few moments, an End User License Agreement acceptance page appears.
Click <literal>I ACCEPT</literal> to continue.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/Installation/EULA_Acceptance.png"/>
</imageobject>
<textobject><phrase>EULA Acceptance</phrase></textobject>
</mediaobject>
</informalfigure>
</listitem>
<listitem>
<simpara>The download will begin.
Depending on your network connection,
this could take a few minutes.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="Installation_LicenseFile">
<title>Enterprise Download</title>
<note>
<simpara>You need a copy of your Peach Fuzzer license on your system to perform the download.</simpara>
</note>
<orderedlist numeration="arabic">
<listitem>
<simpara>Using a web browser, navigate to <link xl:href="https://portal.peachfuzzer.com">https://portal.peachfuzzer.com</link></simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/Installation/Portal_Home_Enterprise.png"/>
</imageobject>
<textobject><phrase>Portal Home Enterprise</phrase></textobject>
</mediaobject>
</informalfigure>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Click the <literal>Choose File</literal> button. The upload dialog display allows you to select the <literal>Peach.license</literal> file.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/Installation/LicenseUpload.png"/>
</imageobject>
<textobject><phrase>LicenseUpload</phrase></textobject>
</mediaobject>
</informalfigure>
</listitem>
<listitem>
<simpara>Navigate to the location of the license</simpara>
</listitem>
<listitem>
<simpara>Select the license (<literal>Peach.license</literal>)</simpara>
</listitem>
<listitem>
<simpara>Click <literal>Open</literal> to return to the download home page.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Upon returning to the Peach download home page, click <literal>Sign In with License</literal>.</simpara>
</listitem>
<listitem>
<simpara>On the <literal>Downloads</literal> page, select the Peach Fuzzer release version and operating system to install.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Choose a release version from the items on the left side.</simpara>
</listitem>
<listitem>
<simpara>Click the download icon on the right side after deciding which OS and architecture is needed.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/Installation/Portal_Downloads.png"/>
</imageobject>
<textobject><phrase>Portal Downloads</phrase></textobject>
</mediaobject>
</informalfigure>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>After a few moments, an End User License Agreement acceptance page appears.
Click <literal>I ACCEPT</literal> to continue.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/Installation/EULA_Acceptance.png"/>
</imageobject>
<textobject><phrase>EULA Acceptance</phrase></textobject>
</mediaobject>
</informalfigure>
</listitem>
<listitem>
<simpara>The download will begin.
Depending on your network connection,
this could take a few minutes.</simpara>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="InstallOnWindows">
<title>Windows</title>
<simpara>Peach is officially supported on the following Windows&#174; Operating Systems:</simpara>
<itemizedlist>
<listitem>
<simpara>Windows 7 SP1 (x86 and x64)</simpara>
</listitem>
<listitem>
<simpara>Windows 8 (x86 and x64)</simpara>
</listitem>
<listitem>
<simpara>Windows 8.1 (x86 and x64)</simpara>
</listitem>
<listitem>
<simpara>Windows 10 (x64)</simpara>
</listitem>
<listitem>
<simpara>Windows Server 2008 SP2 (x86 and x64)</simpara>
</listitem>
<listitem>
<simpara>Windows Server 2008 R2 SP1 (x64)</simpara>
</listitem>
<listitem>
<simpara>Windows Server 2012 (x64)</simpara>
</listitem>
<listitem>
<simpara>Windows Server 2012 R2 (x64)</simpara>
</listitem>
</itemizedlist>
<simpara>The only required software is the Microsoft .NET Framework v4.5.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Download and install the <link xl:href="https://dotnet.microsoft.com/download/dotnet-framework-runtime/net452">Microsoft .NET Framework v4.5.2 (Installer)</link>.</simpara>
</listitem>
<listitem>
<simpara>Install the <link xl:href="https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/debugger-download-tools">Microsoft Debugging Tools for Windows</link> (optional).</simpara>
<note>
<simpara>This is only required if you want to use a debugger to detect crashes in fuzzed programs.</simpara>
</note>
</listitem>
<listitem>
<simpara>Install <link xl:href="https://www.wireshark.org/#download">Wireshark</link> (optional).</simpara>
<note>
<simpara>This is only required if you want to collect network captures during fuzzing runs.</simpara>
</note>
</listitem>
<listitem>
<simpara>Unzip the Peach distribution to the appropriate folder.
The file is a zip file with the extension <literal>.zip</literal>.
Use the filename that begins with <literal>peach-pro</literal> and contains the appropriate architecture for your system,
such as <literal>peach-pro-0.0.0-win_x64_release.zip</literal>.</simpara>
</listitem>
<listitem>
<simpara>When fuzzing, many security products (such as anti-virus programs) can interfere or slowdown fuzzing.
For network fuzzing,
make sure none of the network or host-based network intrusion detection systems (IDS) are running.
For file fuzzing,
disable anti-virus software;
or mark Peach,
the target application,
and any directories that might have files used in fuzzing,
as out of scope for real time monitoring.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="InstallOnLinux">
<title>Linux</title>
<simpara>Peach is supported on three distributions of Linux;
Peach may run on other Linux distributions,
but are not officially supported.
This section provides instructions for installing Peach on the following supported Linux systems,
and includes a checklist for installing Peach on other Linux systems:</simpara>
<itemizedlist>
<listitem>
<simpara>Ubuntu/Debian Linux</simpara>
</listitem>
<listitem>
<simpara>Redhat Enterprise Linux (RHEL and CentOS)</simpara>
</listitem>
<listitem>
<simpara>SUSE Enterprise Linux (SLES)</simpara>
</listitem>
</itemizedlist>
<section xml:id="_ubuntudebian_linux">
<title>Ubuntu/Debian Linux</title>
<simpara>When installing Peach on an Ubuntu or Debian Linux system,
the operating system is ready for Peach without modification.
The installation starts with the Mono .NET runtime, then Peach.
If you want to attach a debugger to a target process,
install GDB when the Mono installation completes.</simpara>
<note>
<simpara>Peach Fuzzer, LLC,
recommends using Ubuntu Linux version 16.04 LTS,
and Mono .NET runtime version 4.8.1 from the mono project.
The mono project has <literal>apt</literal> packages for Ubuntu.</simpara>
<simpara>Peach will not run with Mono version 5.0 or newer due to incompatibilities with IronPython.
If you have Mono 5.0 installed, you must downgrade to 4.8.1.</simpara>
<simpara>Peach will not run with version 4.4 of the Mono runtime as there are known
handle leaks which can cause Peach to run out of memory during long fuzzing runs.
If you have Mono 4.4 installed,
you can either upgrade to 4.6+ or downgrade to 4.2.</simpara>
<simpara>Some Linux kernel versions have known issues with the Mono runtime.
When using Ubuntu 14.04 LTS,
avoid using kernel versions 3.13.0-48 through 3.13.0-54 inclusive.
Version 14.04 LTS might require that you update the Linux kernel.
If so, perform the following to update the kernel: <literal>sudo apt-get install linux-image-generic</literal>.</simpara>
<simpara>The Peach installer checks for compatibility and alerts the user if an incompatibility has been detected.</simpara>
</note>
<simpara>The following steps will prepare Peach to run properly:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Install the latest <literal>mono-complete</literal> package.</simpara>
<screen>sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys  3FA7E0328081BFF6A14DA29AA6A19B38D3D831EF

echo "deb http://download.mono-project.com/repo/debian wheezy/snapshots/4.8.1.0 main" | sudo tee /etc/apt/sources.list.d/mono-xamarin.list

sudo apt-get update

sudo apt-get install mono-complete</screen>
</listitem>
<listitem>
<simpara>Install libpcap using the following command:</simpara>
<screen>sudo apt-get install libpcap</screen>
</listitem>
<listitem>
<simpara>Optionally, install the GNU Debugger (GDB) to enable debugging of local processes.</simpara>
<screen>sudo apt-get install gdb</screen>
</listitem>
<listitem>
<simpara>Unzip the Peach distribution to the appropriate folder.
The file is a zip file with the extension <literal>.zip</literal>.
Use the filename that begins with <literal>peach-pro</literal> and contains the appropriate architecture for your system,
such as <literal>peach-pro-0.0.0-linux_x86_64_release.zip</literal>.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="_redhat_enterprise_linux_rhel_and_centos">
<title>Redhat Enterprise Linux (RHEL and CentOS)</title>
<simpara>Installing Peach on a RHEL CentOS platform requires additional steps.
Begin by installing Extra Packages for Enterprise Linux (EPEL),
followed by the Mono package and Peach.</simpara>
<note>
<simpara>Peach Fuzzer, LLC, recommends using Mono .NET runtime version 4.8.1 from the mono project.
The mono project has <literal>yum</literal> packages for RHEL and CentOS distributions.</simpara>
<simpara>Peach will not run with Mono version 5.0 or newer due to incompatibilities with IronPython.
If you have Mono 5.0 installed, you must downgrade to 4.8.1.</simpara>
<simpara>Peach will not run with version 4.4 of the Mono runtime as there are known
handle leaks which can cause Peach to run out of memory during long fuzzing runs.
If you have Mono 4.4 installed,
you can either upgrade to 4.6+ or downgrade to 4.2.</simpara>
</note>
<note>
<simpara>The following Mono installation steps are taken from the
<link xl:href="http://www.mono-project.com/docs/getting-started/install/linux/#centos-7-fedora-19-and-later-and-derivatives">Mono Project</link>.</simpara>
</note>
<simpara>The following steps provide the needed details:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Install <literal>yum-utils</literal> using the following command:</simpara>
<screen>sudo yum install yum-utils</screen>
</listitem>
<listitem>
<simpara>Install Extra Packages for Enterprise Linux (EPEL) using the following command:</simpara>
<screen>sudo yum install epel-release</screen>
</listitem>
<listitem>
<simpara>Import the GPG signing key for the mono package using the following command. Note the long search key:</simpara>
<screen>sudo rpm --import "http://keyserver.ubuntu.com/pks/lookup?op=get&amp;search=0x3FA7E0328081BFF6A14DA29AA6A19B38D3D831EF"</screen>
</listitem>
<listitem>
<simpara>Add and enable the mono project repository for CentOS using the yum configuration manager:</simpara>
<screen>sudo yum-config-manager --add-repo http://download.mono-project.com/repo/centos/</screen>
</listitem>
<listitem>
<simpara>Install the latest version of Mono using the following command:</simpara>
<screen>sudo yum install mono-complete-4.8.1.0-0.xamarin.1</screen>
</listitem>
<listitem>
<simpara>Install libpcap using the following command:</simpara>
<screen>sudo yum install libpcap</screen>
</listitem>
<listitem>
<simpara>Unzip the Peach distribution to the appropriate folder.
The file is a zip file with the extension <literal>.zip</literal>.
Use the filename that begins with <literal>peach-pro</literal> and contains the appropriate architecture for your system,
such as <literal>peach-pro-0.0.0-linux_x86_64_release.zip</literal>.</simpara>
</listitem>
</orderedlist>
<tip>
<simpara>If you receive and error regarding libMonoPosixHelper the <literal>/etc/mono/config</literal> file may need to be edited.
To edit locate a line that looks like the following (the path may be different):</simpara>
<screen>&lt;dllmap dll="MonoPosixHelper" target="/usr/lib/libMonoPosixHelper.so" os="!windows" /&gt;</screen>
<simpara>Once found use the Linux <emphasis>find</emphasis> command to locate the shared library:</simpara>
<screen>find /usr -name "*libMonoPosixHelper.so"</screen>
<simpara>And finally, update the <literal>/etc/mono/config</literal> entry to the correct path.</simpara>
</tip>
<note>
<simpara>For more information, see the following resources:
* <link xl:href="http://www.mono-project.com/docs/getting-started/install/linux#centos-fedora-and-derivatives">http://www.mono-project.com/docs/getting-started/install/linux#centos-fedora-and-derivatives</link>
* <link xl:href="https://fedoraproject.org/wiki/EPEL#How_can_I_use_these_extra_packages.3F">https://fedoraproject.org/wiki/EPEL#How_can_I_use_these_extra_packages.3F</link></simpara>
</note>
</section>
<section xml:id="_suse_enterprise_linux_sles">
<title>SUSE Enterprise Linux (SLES)</title>
<simpara>To install Peach on a SUSE Enterprise Linux platform,
use the 1-click SUSE mono-complete installation file.
If you want to attach a debugger to a target process,
install GDB when the Mono installation completes.</simpara>
<note>
<simpara>Peach Fuzzer, LLC, recommends using Mono .NET runtime version 4.8.1 from the mono project.
The mono project has packages for SLES distributions.</simpara>
<simpara>Peach will not run with Mono version 5.0 or newer due to incompatibilities with IronPython.
If you have Mono 5.0 installed, you must downgrade to 4.8.1.</simpara>
<simpara>Peach will not run with version 4.4 of the Mono runtime as there are known
handle leaks which can cause Peach to run out of memory during long fuzzing runs.
If you have Mono 4.4 installed,
you can either upgrade to 4.6+ or downgrade to 4.2.</simpara>
</note>
<simpara>The following steps provide the needed details:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Import the GPG signing key for the mono package using the following command. Note the long search key:</simpara>
<screen>sudo rpm --import "http://keyserver.ubuntu.com/pks/lookup?op=get&amp;search=0x3FA7E0328081BFF6A14DA29AA6A19B38D3D831EF"</screen>
</listitem>
<listitem>
<simpara>Add and enable the mono project repository using the zypper configuration manager:</simpara>
<screen>sudo zypper ar -f http://download.mono-project.com/repo/centos/ mono</screen>
</listitem>
<listitem>
<simpara>Install the latest supported version of Mono using the following command:</simpara>
<screen>sudo zypper in mono-complete=4.8.1.0-0.xamarin.1</screen>
</listitem>
<listitem>
<simpara>Install libpcap using the following command:</simpara>
<screen>sudo zypper in libpcap</screen>
</listitem>
<listitem>
<simpara>Optionally, install the GNU Debugger (GDB) for debugging local processes.</simpara>
<screen>sudo yum install gdb</screen>
</listitem>
<listitem>
<simpara>Unzip the Peach binary distribution to the appropriate folder.
The file is a zip file with the extension <literal>.zip</literal>.
Use the filename that begins with <literal>peach-pro</literal> and contains the appropriate architecture for your system,
such as <literal>peach-pro-0.0.0-linux_x86_64_release.zip</literal>.</simpara>
</listitem>
</orderedlist>
<tip>
<simpara>If you receive and error regarding libMonoPosixHelper the <literal>/etc/mono/config</literal> file may need to be edited.
To edit locate a line that looks like the following (the path may be different):</simpara>
<screen>&lt;dllmap dll="MonoPosixHelper" target="/usr/lib/libMonoPosixHelper.so" os="!windows" /&gt;</screen>
<simpara>Once found use the Linux <emphasis>find</emphasis> command to locate the shared library:</simpara>
<screen>find /usr -name "*libMonoPosixHelper.so"</screen>
<simpara>And finally, update the <literal>/etc/mono/config</literal> entry to the correct path.</simpara>
</tip>
</section>
<section xml:id="_other_linux_distributions">
<title>Other Linux Distributions</title>
<simpara>For other Linux versions,
the installation steps are a checklist,
not specific commands.
The checklist follows:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Install the Mono runtime. Version 4.8.1 is recommended.</simpara>
</listitem>
<listitem>
<simpara>Unzip the Peach distribution to an appropriate folder.
The file is a zip file with the extension <literal>.zip</literal>.
Use the filename that begins with <literal>peach-pro</literal> and contains the appropriate architecture for your system,
such as <literal>peach-pro-0.0.0-linux_x86_64_release.zip</literal>.</simpara>
</listitem>
</orderedlist>
<note>
<simpara>Peach Fuzzer, LLC, recommends using Mono .NET runtime version 4.8.1 from the mono project.</simpara>
<simpara>Peach will not run with Mono version 5.0 or newer due to incompatibilities with IronPython.
If you have Mono 5.0 installed, you must downgrade to 4.8.1.</simpara>
<simpara>Peach will not run with version 4.4 of the Mono runtime as there are known
handle leaks which can cause Peach to run out of memory during long fuzzing runs.
If you have Mono 4.4 installed,
you can either upgrade to 4.6+ or downgrade to 4.2.</simpara>
</note>
</section>
</section>
<section xml:id="InstallOnOSX">
<title>macOS</title>
<simpara>To install on macOS, follow the installation steps provided below.  Installation will require installing the Mono .NET runtime, then Peach.
To enable support for the <link linkend="Monitors_CrashWrangler">CrashWrangler</link> monitor,
install CrashWrangler and Xcode.
Note that installing CrashWrangler is optional;
it is only needed when running the target locally.</simpara>
<note>
<simpara>Peach Fuzzer, LLC,
recommends using Mono .NET runtime version 4.8.1 from the mono project.</simpara>
<simpara>Peach will not run with Mono version 5.0 or newer due to incompatibilities with our Python runtime.
If you have Mono 5.0 installed, you must downgrade to 4.8.1.</simpara>
<simpara>Peach will not run with version 4.4 of the Mono runtime as there are known
handle leaks which can cause Peach to run out of memory during long fuzzing runs.
If you have Mono 4.4 installed, you can either upgrade to 4.6+ or downgrade to 4.2.</simpara>
</note>
<orderedlist numeration="arabic">
<listitem>
<simpara>Install the <link xl:href="https://download.mono-project.com/archive/4.8.1/macos-10-universal/">Mono package</link>.</simpara>
</listitem>
<listitem>
<simpara>Unzip the Peach distribution to an appropriate folder.
The file is a zip file with the extension <literal>.zip</literal>.
Use the filename that begins with <literal>peach-pro</literal> and contains the appropriate architecture for your system,
such as <literal>peach-pro-0.0.0-osx_release.zip</literal>.</simpara>
</listitem>
<listitem>
<simpara>Install CrashWrangler.</simpara>
<simpara>CrashWrangler <emphasis role="strong">MUST</emphasis> be compiled on each macOS machine.
Peach includes the CrashWrangler source files in the peach distribution.
Here are instructions to install and compile CrashWrangler from the peach zip.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Ensure XCode is installed.</simpara>
</listitem>
<listitem>
<simpara>Open <literal>Terminal.app</literal>.</simpara>
</listitem>
<listitem>
<simpara>Navigate to the folder where you extracted <literal>peach-pro-0.0.0-osx_release.zip</literal>.</simpara>
</listitem>
<listitem>
<simpara>Finish installing CrashWrangler using the following commands.</simpara>
<screen># Navigate to the folder containing CrashWrangler distribution
cd CrashWrangler

# Extract CrashWrangler sources
unzip 52607_crashwrangler.zip

# Navigate to the folder containing the extracted CrashWrangler sources
cd crashwrangler

# Compile CrashWrangler
$ make

# Ensure installation directory exists
sudo mkdir -p /usr/local/bin

# Install CrashWrangler
sudo cp exc_handler /usr/local/bin

# Navigate to the folder containing peach
cd ../../

# Verify CrashWrangler can run
exc_handler</screen>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
</section>
<section xml:id="License_Activation">
<title>License Activation</title>
<simpara>The list below contains links to the steps for activating the different types of Peach Fuzzer licenses.</simpara>
<variablelist>
<varlistentry>
<term>Usage Based (Online Synchronization)</term>
<listitem>
<simpara>The most common method for activating a usage based license.
A Cloud License Server will be automatically provisioned and managed for you.
However, Peach Fuzzer will require a persistent connection to the Internet.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Usage Based (Offline Synchronization)</term>
<listitem>
<simpara>Users who wish to use Peach Fuzzer in an offline without having access to the Internet can deploy a
Local License Server onsite to provide offline activation and synchronization of licensing information.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Node Locked</term>
<listitem>
<simpara>The license is tied to the physical machine running Peach Fuzzer.
No license server is required and internet connectivity is only needed for activation.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Enterprise</term>
<listitem>
<simpara>No activation is required for enterprise customers.</simpara>
</listitem>
</varlistentry>
</variablelist>
<section xml:id="ActivateOnline">
<title>Usage Based (Online Synchronization)</title>
<simpara>A Cloud License Server provides functionality for serving and monitoring a counted pool of licenses for Peach Fuzzer.
A persistent connection to the Internet is required so that usage data can be uploaded to the Cloud License Server while a Peach Fuzzer job is running.
Peach Fuzzer will automatically activate the first time it is run.</simpara>
<note>
<simpara>If a proxy server is required to connect to the Internet, it must be configured as described below.</simpara>
</note>
<section xml:id="_windows_proxy_configuration">
<title>Windows Proxy configuration</title>
<simpara>On Windows, the system proxy setting is the correct way to configure the proxy peach will use to connect to the licensing server.</simpara>
<variablelist>
<varlistentry>
<term>Windows 10</term>
<listitem>
<simpara>The system proxy settings are configured at Settings &gt; Network &amp; Internet &gt; Proxy.
From there you will be able to enter the IP and Port of the proxy server.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Windows 8</term>
<listitem>
<simpara>The system proxy settings are configured at PC Settings &gt; Network Proxy.
From there you will be able to enter the IP and Port of the proxy server.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Windows 7</term>
<listitem>
<simpara>The system proxy settings are configured through the Internet Settings dialog.
Open the Internet Options window located at Control Panel &gt; Network and Internet &gt; Internet Options.<?asciidoc-br?></simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Click the "Connections" tab at the top of the Internet Options window.<?asciidoc-br?></simpara>
</listitem>
<listitem>
<simpara>Click the "LAN Settings" button at the bottom of the window.<?asciidoc-br?></simpara>
</listitem>
<listitem>
<simpara>Click the "Advanced" button under Proxy Server will allow you to change advanced settings and enable a manual proxy server.</simpara>
</listitem>
</orderedlist>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_linux_proxy_configuration">
<title>Linux Proxy Configuration</title>
<simpara>The proxy configuration on Linux is controlled via two environment variables <literal>http_proxy</literal> and <literal>https_proxy</literal>.
Ensure both variables are set prior to starting Peach Fuzzer.</simpara>
<screen>export http_proxy=http://xxxxx
export https_proxy=https://xxxxx</screen>
</section>
</section>
<section xml:id="ActivateOffline">
<title>Usage Based (Offline Synchronization)</title>
<simpara>The Local License Server provides functionality for serving and monitoring a counted pool of licenses for Peach Fuzzer.
Users who wish to use Peach Fuzzer without having access to the Internet can deploy a
Local License Server onsite to provide offline activation and synchronization of licensing
information.</simpara>
<simpara>The instructions for installing and activating a Local License Server can be found on the <link xl:href="https://portal.peachfuzzer.com">Peach Portal</link> by navigating to the "Licensing" tab and clicking the "Local License Server" button for the desired license.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/Installation/Portal_LLS_Button.png"/>
</imageobject>
<textobject><phrase>Portal LLS Button</phrase></textobject>
</mediaobject>
</informalfigure>
</section>
<section xml:id="ActivateNodeLock">
<title>Node Locked</title>
<simpara>No license server is required, as node locked licenses are tied to an individual machine.
Peach Fuzzer will automatically activate the first time it is run.</simpara>
<simpara>If your license has changed and you want Peach Fuzzer refresh its license, run the following command:</simpara>
<screen>peach --activate</screen>
<simpara>If you wish to move your license to a new machine, you must first deactivate the existing instance by running the following command:</simpara>
<screen>peach --deactivate</screen>
<note>
<simpara>Peach Fuzzer requires an internet connection in order to perform activation and deactivation.  Once activated, no further internet connectivity is required.</simpara>
</note>
</section>
<section xml:id="ActivateEnterprise">
<title>Enterprise</title>
<simpara>No activation is required for enterprise customers.
The enterprise license is automatically embedded in the Peach Fuzzer download.</simpara>
</section>
</section>
<section xml:id="InstallSecureInstall">
<title>Enabling HTTPS And Authentication</title>
<simpara>Peach Fuzzer Professional uses a web interface for configuration and control of the fuzzing engine.
By default, the web interface is accessible with no encryption (SSL/TLS) and no authentication.
If the use of HTTPS or authentication is required, a reverse proxy (apache/nginx/traefik) can be used to provide both SSL/TLS and authentication.</simpara>
<section xml:id="_reverse_proxy_with_nginx">
<title>Reverse Proxy with NGINX</title>
<simpara>The following steps will configure NGINX as a reverse proxy for Peach adding TLS and authentication:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Install nginx using your Linux package manager</simpara>
</listitem>
<listitem>
<simpara>Create required key.  For self signed keys this
<link xl:href="http://www.selfsignedcertificate.com/">online self-signed certificate generator</link> can be used.</simpara>
</listitem>
<listitem>
<simpara>Install the included NGINX configuration file to /etc/nginx/sites-available/peach</simpara>
</listitem>
<listitem>
<simpara>Install certificate and key and update configuration file if needed</simpara>
</listitem>
<listitem>
<simpara>Create .htpasswd with username/passwords replacing <literal>USERNAME</literal> with your username</simpara>
<screen>sudo sh -c "echo -n 'USERNAME:' &gt;&gt; /etc/nginx/.htpasswd"
sudo sh -c "openssl passwd -apr1 &gt;&gt; /etc/nginx/.htpasswd"</screen>
</listitem>
<listitem>
<simpara>Add a firewall rule to block external access to Peach&#8217;s port 8888.  Make sure this rule is enabled on bootup.</simpara>
</listitem>
<listitem>
<simpara>Link /etc/nginx/sites-available/peach to /etc/nginx/sites-enabled/peach</simpara>
</listitem>
<listitem>
<simpara>Restart NGINX and verify configuration is working</simpara>
</listitem>
</orderedlist>
<section xml:id="_nginx_configuration_file">
<title>NGINX Configuration File</title>
<screen># HTTPS server
#
server {
        listen 443;
        server_name localhost;

        root html;
        index index.html index.htm;

        ssl on;
        ssl_certificate /etc/ssl/certs/ssl.crt;
        ssl_certificate_key /etc/ssl/private/ssl.key;

        ssl_session_timeout 5m;

        ssl_protocols TLSv1.1 TLSv1.2;
        ssl_ciphers "HIGH:!aNULL:!MD5 or HIGH:!aNULL:!MD5:!3DES";
        ssl_prefer_server_ciphers on;

        location / {
                # First attempt to serve request as file, then
                # as directory, then fall back to displaying a 404.
                #try_files $uri $uri/ =404;
                # Uncomment to enable naxsi on this location
                # include /etc/nginx/naxsi.rules


                auth_basic "Restricted";
                auth_basic_user_file /etc/nginx/.htpasswd;
                proxy_pass http://127.0.0.1:8888/;
        }
}</screen>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
</section>
</section>
<section xml:id="Brand_new_items">
<title>What&#8217;s new in Peach Fuzzer Professional v0.0</title>
<simpara>This section provides a high-level view of the changes introduced this
release of Peach Fuzzer Professional.</simpara>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
<section xml:id="Intro_to_FuzzingBrand_new_items">
<title>Introduction to Fuzzing</title>
<simpara>Welcome to the world of fuzzing!</simpara>
<simpara><emphasis>What is fuzzing?</emphasis></simpara>
<simpara>Fuzzing is the art of performing unexpected actions that result in target misbehavior.</simpara>
<simpara><emphasis>What is our goal when we fuzz?</emphasis></simpara>
<simpara>Our goal is to find new, previously unknown security vulnerabilities. Finding vulnerabilities is limited only by our ability to detect them automatically.</simpara>
<simpara>The most common target for fuzzing is a data consumer such a network service or a web browser. For a data consumer, the unexpected actions consist of sending data to the consumer that is malformed, fuzzed, in some way. Consuming fuzzed data can trigger vulnerabilities in the target. The likelihood that a single change causes a vulnerability might not be high, but when the act of sending fuzzed data repeats over 100,000 times, a very good chance exists that the target will misbehave in some interesting manner.</simpara>
<simpara>Fuzzers submit thousands, hundreds of thousands, and even millions of data samples malformed in some way; fuzzers call the malformed data mutations. Once written, fuzzers typically run for long time periods finding more and more vulnerabilities, called faults.</simpara>
<simpara>Consider the following C structure and corresponding data shown in hex:</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/DevGuide/FuzzingIntro/struct_with_hex.png"/>
</imageobject>
<textobject><phrase>struct with hex</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>The data consumer or test target parses data into the structure. The data and structure are color coded to show which parts of the data are loaded into each member of the structure <emphasis>Header</emphasis>. Following the structure, two lines of code occur that use the <emphasis>Header</emphasis> structure. Looking at that code, we can identify several issues that could likely lead to crashing our program that we could trigger by changing our input data.</simpara>
<simpara>The first thing we could do is change the <emphasis>len</emphasis> in our data from 0x0021 to 0x0001. This would cause the memory allocation to return a smaller amount of memory than what is needed for copying data using the <emphasis>strcpy</emphasis> function. Once <emphasis>strcpy</emphasis> executes, we will have written past the end of <emphasis>msg_data</emphasis>, possibly causing the target process to crash.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/DevGuide/FuzzingIntro/struct_with_hex_len.png"/>
</imageobject>
<textobject><phrase>struct with hex len</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Another change we could make to the data is to remove or change the null byte that terminates the string <emphasis>data</emphasis>. In C, string functions operate on data up to the null character. If the null byte is changed, the <emphasis>strcpy</emphasis> function  copies more than 33 bytes into <emphasis>msg_data</emphasis>. This could cause the target process to crash.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/DevGuide/FuzzingIntro/struct_with_hex_data.png"/>
</imageobject>
<textobject><phrase>struct with hex data</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>The two changes we made to trigger two similar but different bugs in the code is something we look to automate with fuzzing. Taking this input data and randomly changing a byte to a random value, would, over the course of many attempts, eventually find both of these issues.</simpara>
<simpara>One of the goals with fuzzing is to find as many faults in targets with the least amount of human time.</simpara>
<section xml:id="_dumb_fuzzing">
<title>Dumb Fuzzing</title>
<simpara>Several types of fuzzing technology exist; one of the most common technologies is
dumb fuzzing. Dumb fuzzers are a class of fuzzers that operate with the following characteristics:</simpara>
<itemizedlist>
<listitem>
<simpara>Limited or no information or understanding of the target.</simpara>
</listitem>
<listitem>
<simpara>Limited or no understanding of the data they provide the target.</simpara>
</listitem>
</itemizedlist>
<simpara>Dumb fuzzers are popular because they take very little effort to get running and
can produce good results with certain targets. Since they lack any knowledge about
the data that the target is consuming, they have limited practical use.</simpara>
<simpara>The most common mutation that dumb fuzzers perform is bit flipping. Bit flipping selects a part of data to change and modifies it in a simple manner. One might
make a single change, or multiple changes depending on the fuzzer. The resulting
data is sent to the data consumer to see whether it causes the data consumer to misbehave&#8212;&#8203;such as crash.</simpara>
<simpara>You can build a dumb fuzzer with Peach. For an example, see the <link linkend="TutorialDumbFuzzing">dumb file fuzzing tutorial.</link></simpara>
<simpara>Dumb fuzzing makes a great starting point when first fuzzing as it is the easiest
method to use. However, in many cases, dumb fuzzing does not work. One example
that prevents a dumb fuzzer from working is the use of checksums in the data format.
Checksums validate integrity of the data during transmission or storage. Any change to the data will result in a checksum that does not match, as shown in the following image:</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/DevGuide/FuzzingIntro/crc_missmatch.png"/>
</imageobject>
<textobject><phrase>crc missmatch</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>The highlighted <literal>FF</literal> in the data stream is a byte that was changed during fuzzing. The new checksum value does not match the one that already exists in the file.</simpara>
<simpara>If the data consumer validates the checksum, the validation failure will cause the
data consumer to stop the test case. If the failure is early in the data consumer&#8217;s processing cycle (such as upon receipt of the data), the fuzzed data would not deeply test the data consumer; in turn, this action would limit the number of faults that can be found in the test target.</simpara>
<simpara>Smart fuzzers allow updating the data to correct for things like checksums, encryption, encoding, and compression so that the data passes through the initial system checks and is processed by the data consumer.</simpara>
<simpara>Peach makes it easy to shift from dumb fuzzing into smart fuzzing.</simpara>
</section>
<section xml:id="_smart_fuzzing">
<title>Smart Fuzzing</title>
<simpara>Smart fuzzers are a class of fuzzers that operate with some knowledge and understanding of the target, and of data that the target consumes. The amount of knowledge depends on the fuzzer used.</simpara>
<simpara>A typical smart fuzzer does the following things:</simpara>
<itemizedlist>
<listitem>
<simpara>Understand the data format used by the target application to consume incoming data.</simpara>
</listitem>
<listitem>
<simpara>Monitor the target for fault conditions.</simpara>
</listitem>
<listitem>
<simpara>Modify the data to gain better coverage or increase the ability to detect certain types of issues.</simpara>
</listitem>
</itemizedlist>
<simpara>Data understanding includes:</simpara>
<itemizedlist>
<listitem>
<simpara>Type information (string, integer, byte array).</simpara>
</listitem>
<listitem>
<simpara>Relationships between fields in the data (length, offset, count).</simpara>
</listitem>
<listitem>
<simpara>Ability integrity fields such as a checksum or a CRC.</simpara>
</listitem>
</itemizedlist>
<simpara>At this level, understanding the data structures and data types allows the fuzzer to make more-informed changes (mutations) to the data. Smart fuzzers use this understanding level to find more bugs.</simpara>
<simpara>Smart fuzzers can control and monitor the fuzzing environment. Environment and instrumentation controls start all the components of the system so they are ready to fuzz; on a faulting condition, they reset the environment to a known, good state. Smart fuzzers can detect a faulting condition and collect any interesting data in the system at the time of the fault (including output from a debugger, a network capture, or files on the file system), and log the data for later review. High-quality smart fuzzers can run unattended for long periods and capture enough information to allow a resource to reasonably reproduce and investigate the faults that occurred.</simpara>
<simpara>Smart fuzzers also perform bug bucketing and basic risk analysis.
  Fuzzing commonly finds the same issue multiple times during a long run. Bucketing is an industry term for associating similar (and possibly duplicate) issues together.  Bucketing implementations can use a simple set of categories to group issues, or use a tiered set of categories. The Peach Fuzzer buckets issues using two tiers: major and minor levels.</simpara>
<itemizedlist>
<listitem>
<simpara>Minor differences between faults mean that the issues are basically the same, but worth reviewing to make sure.</simpara>
</listitem>
<listitem>
<simpara>Major differences are generally distinct issues.</simpara>
</listitem>
</itemizedlist>
<simpara>Along with buckets, initial risk analysis allows you to direct your attention first on higher risk faults before spending time on lower risk issues. Risk analysis is not always possible, but useful when it can be performed.</simpara>
<simpara>For an example of building a smart fuzzer with Peach, see the <link linkend="TutorialFileFuzzing">smart file fuzzing tutorial.</link></simpara>
</section>
<section xml:id="Fuzzing_ExitCriteria">
<title>When to Stop Fuzzing</title>
<simpara>A fuzzing bar sets requirements for a fuzzing job and answers the question, How long do we fuzz?</simpara>
<simpara>Here is one set of exiting criteria that consists of two requirements:</simpara>
<itemizedlist>
<listitem>
<simpara>The fuzzer must run a set number of test cases.<?asciidoc-br?>
The number of test cases performed must meet or exceed the specified threshold.</simpara>
</listitem>
<listitem>
<simpara>The fuzzer must have at least Y consecutive clean test cases.<?asciidoc-br?>
A clean test case generates zero new faults.</simpara>
</listitem>
</itemizedlist>
<simpara>As soon as both requirements occur, fuzzing can stop.</simpara>
<simpara>For example, when fuzzing a new product, the release criteria might be set to 250,000 total fuzzing test cases on the product and yield 150,000 consecutive clean test cases.</simpara>
<simpara>The following diagram shows one way of meeting this criteria and focuses on the number of test cases performed, test case failures, and the number of consecutive clean test cases.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/Fuzzing_Exit_Criteria_Case1_3_8.png"/>
</imageobject>
<textobject><phrase>Fuzzing Exit Criteria Case1 3 8</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>A few items are worth noting:</simpara>
<itemizedlist>
<listitem>
<simpara>The total number of test cases performed is 250K.</simpara>
</listitem>
<listitem>
<simpara>The number of consecutive clean test cases is 200K, surpassing the requirement of
150K clean test cases. The last 50K test cases were needed to meet the first requirement.</simpara>
</listitem>
<listitem>
<simpara>The count of consecutive clean test cases reset to zero when a new fault was found at the 50,000th test case.</simpara>
</listitem>
</itemizedlist>
<simpara>The next diagram shows another way of meeting this criteria.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/Fuzzing_Exit_Criteria_Case2_3_8.png"/>
</imageobject>
<textobject><phrase>Fuzzing Exit Criteria Case2 3 8</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Again, a few of items are worth noting:</simpara>
<itemizedlist>
<listitem>
<simpara>The total number of test cases performed is 450K.</simpara>
</listitem>
<listitem>
<simpara>The number of consecutive clean test cases is 150K.</simpara>
</listitem>
<listitem>
<simpara>The count of the consecutive clean test cases restarted three times due to
new faults occurring in test cases: after 76K, 200K, and 300K.</simpara>
</listitem>
</itemizedlist>
<simpara>The requirements used in the previous example are reasonable for a first release of a product. However, each successive version of a product should become more and more stable. This can be realized by increasing the total number of test cases performed by the fuzzer, and the number of consecutive clean test cases that result from fuzzing. The following table provides increasing requirements as a product matures.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="14.2857*"/>
<colspec colname="col_2" colwidth="42.8571*"/>
<colspec colname="col_3" colwidth="42.8572*"/>
<thead>
<row>
<entry align="left" valign="top">Year</entry>
<entry align="left" valign="top">Required Iterations</entry>
<entry align="left" valign="top">Clean Iterations</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Year 1</simpara></entry>
<entry align="left" valign="top"><simpara>250,000</simpara></entry>
<entry align="left" valign="top"><simpara>150,000</simpara></entry>
</row>
<row>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Year 2</simpara></entry>
<entry align="left" valign="top"><simpara>500,000</simpara></entry>
<entry align="left" valign="top"><simpara>250,000</simpara></entry>
</row>
<row>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Year 4</simpara></entry>
<entry align="left" valign="top"><simpara>High      750,000</simpara></entry>
<entry align="left" valign="top"><simpara>High    500,000</simpara></entry>
</row>
<row>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>Medium    500,000</simpara></entry>
<entry align="left" valign="top"><simpara>Medium  250,000</simpara></entry>
</row>
<row>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>Low       500,000</simpara></entry>
<entry align="left" valign="top"><simpara>Low     250,000</simpara></entry>
</row>
<row>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Year 5</simpara></entry>
<entry align="left" valign="top"><simpara>High    1,000,000</simpara></entry>
<entry align="left" valign="top"><simpara>High    750,000</simpara></entry>
</row>
<row>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>Medium    750,000</simpara></entry>
<entry align="left" valign="top"><simpara>Medium  500,000</simpara></entry>
</row>
<row>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>Low       500,000</simpara></entry>
<entry align="left" valign="top"><simpara>Low     250,000</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<note>
<simpara>What was once the Software Development Life Cycle (SDLC) has evolved into
the Secure Development Lifecycle (SDL) to protect corporate assets from zero-day
attacks. Fuzzing is part of the SDL, specifically in the security push and the
Verification Phase. Peach Fuzzer can operate on non-executable file formats,
protocol stacks, and data that originates from a lesser-privileged trust boundary.</simpara>
</note>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="_methodology">
<title>Methodology</title>
<simpara>The following sections introduce a basic methodology for fuzzing. Our goal is to find previously unknown vulnerabilities with a high return on investment (ROI). We approach this by intelligently picking our targets and finding a balance between the amount of human power required to build and maintain our fuzzers versus the number of faults we will find. To accomplish this goal, we need to do the following:</simpara>
<itemizedlist>
<listitem>
<simpara>Select the correct targets</simpara>
</listitem>
<listitem>
<simpara>Develop adequate fuzzers that achieve good coverage</simpara>
</listitem>
<listitem>
<simpara>Understand when to fuzz</simpara>
</listitem>
<listitem>
<simpara>Understand how long to fuzz</simpara>
</listitem>
</itemizedlist>
<section xml:id="_selecting_fuzzing_targets">
<title>Selecting Fuzzing Targets</title>
<simpara>Selecting good fuzzing targets is critical to success. For teams just starting down the fuzzing road, it is important to get good early results to prove the program and to build confidence in the technology and process. Once the team becomes confident with the process and tools, they should chose more complex targets. When picking a fuzzing target, a number of factors play into the choice.</simpara>
<simpara>For each possible target, consider and evaluate the following things:</simpara>
<variablelist>
<varlistentry>
<term>What is the risk of issues found in the target?</term>
<listitem>
<simpara>If issues are identified in this target, are they important to fix? Would they be seen as a high priority? Ideally, a target should be picked because the resulting issues would have a high diagnosis priority.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Does the development of the target pre-date a secure development lifecycle (SDL) being in place?</term>
<listitem>
<simpara>Targets developed prior to an SDL process are more likely to contain security issues.
Additionally, this characteristic is true of applications that contain complex parsers and logic.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>What types of issues (bugs) would we expect to find in this target?</term>
<listitem>
<simpara>The types of issues we are looking to identify should map well to fuzzing. The easiest issues to find are those that crash the target.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Does the fuzzer support tools that can be used out-of-the-box to identify issues in this target?</term>
<listitem>
<simpara>If Peach already has the tools to identify the issues intended to be found without any extensions, it will be easier and faster to create/configure our fuzzer.
For Windows, Linux, and OS X, this could be debugger support.
With embedded devices, support tools should be able to ping the device, or otherwise detect that the device has stopped working.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Does the data format contain cryptographic components&#8212;&#8203;such as encryption or signatures, or custom complex authentication?</term>
<listitem>
<simpara>This question eliminates targets that would require custom extensions. Initially, we want to avoid the more complex and sophisticated parts of fuzzing. Formats that include a cryptographic component, but are not available as licensed Pits can be challenging to create.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>When we select a fuzzing target, our goal is to find something that is not very difficult to fuzz, yet will provide a good payout based on the number or type of issues found.</simpara>
</section>
<section xml:id="_developing_fuzzers">
<title>Developing Fuzzers</title>
<simpara>Having an appropriate fuzzing model is crucial to achieving good results.
Peach Fuzzer has many off-the-shelf fuzzing models (Pits) that eliminate
development time. Individual Pits and groups of themed Pits are available from Peach Fuzzer, LLC.</simpara>
<simpara>If you have custom extensions or need to fuzz a proprietary item, such as a custom file format or protocol, you&#8217;ll need to develop the custom portion of the fuzzing
model. Peach Fuzzer includes the components needed to build a fuzzing definition, as well as documentation to extend Peach where custom components are needed.</simpara>
<simpara>For information on developing fuzzing definitions, see the following sections:</simpara>
<itemizedlist>
<listitem>
<simpara><link linkend="PeachPit">Pit Files</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="AgentsMonitors">Monitoring the Test Environment</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="TestConfig">Test</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="DebuggingPitFiles">Debugging Pit Files</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="TutorialDumbFuzzing">Dumb File Fuzzing Tutorial</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="TutorialFileFuzzing">File Fuzzing Tutorial</link></simpara>
</listitem>
</itemizedlist>
<simpara>For information on Peach components, see <link linkend="ReferenceSection_Intro">Reference</link>.</simpara>
<simpara>For information on building custom components, see <link linkend="Extending">Extending Peach</link>.</simpara>
</section>
<section xml:id="_secure_development_lifecycle">
<title>Secure Development Lifecycle</title>
<simpara>A robust secure development lifecycle (SDL) program should include requirements for fuzzing. Using the Microsoft SDL as an example, fuzzing typically integrates into the validation phase. After the first iteration with fuzzing is integrated, the project team should decide if fuzzing can be started earlier on the next revision of the deliverable. <emphasis role="strong">Fuzzers are most effective when the target is reasonably stable and fully featured.</emphasis> If the target is unstable or not usable, basic stability issues limit the ability to identify security issues. For example, if the data formats or features are in flux, the amount of human effort to maintain the fuzzers will increase. That, in turn, can lower the return on investment.</simpara>
<simpara>As a team gains experience with fuzzing, they become better equipped to identify the best time to start fuzzing. Typically, more mature products can fuzz earlier in the development cycle than newer products.</simpara>
</section>
<section xml:id="_deciding_how_long_to_fuzz">
<title>Deciding How Long to Fuzz</title>
<simpara>The best way to measure how long to fuzz is by counting iterations. An iteration is a single test performed by the fuzzer. The number of iterations required to fully test a target vary based on the data format complexity and quality of the target. In a perfect world, you would fuzz until you stop finding issues by hitting a plateau. In reality, projects have ship dates and limited resources. Setting a bar to reach for each cycle is a good method to use. For more information, see <link linkend="Fuzzing_ExitCriteria">When to Stop Fuzzing</link>.</simpara>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="_introduction_to_peach">
<title>Introduction to Peach</title>
<simpara>Peach is a hybrid fuzzer, combining part of both mutation and generational fuzzing.</simpara>
<simpara>Fuzzing with Peach centers on the three M&#8217;s of Peach: model, mutate, and monitor.</simpara>
<itemizedlist>
<listitem>
<simpara>Model - We model the data format and data/state flow.</simpara>
</listitem>
<listitem>
<simpara>Mutate - The fuzzing engine uses the data and state models to mutate data intelligently, in preparation of sending the malformed data to the target.</simpara>
</listitem>
<listitem>
<simpara>Monitor - We monitor our test target and the test environment to identify fault conditions and to collect information used to investigate and remediate the faults.</simpara>
</listitem>
</itemizedlist>
<simpara>A Peach fuzzing definition consists of the data and state models, monitoring declarations, and specifics about the test environment. Even though fuzzing definitions included with Peach have all of these components, you still need to describe the monitoring details, based on your test target and operating system.</simpara>
<simpara>Peach specifically targets data consumers. The data could be a file format, a network protocol, or an argument to an RPC interface.</simpara>
<simpara>Peach has the following high-level concepts:</simpara>
<variablelist>
<varlistentry>
<term>Pit</term>
<listitem>
<simpara>Fuzzing definitions in Peach are Pits.
Peach Pits are XML files that contain all the information Peach needs to perform a fuzzing operation.
This includes data models, state models, agent configurations (agents host the monitors), and test details.</simpara>
<simpara>Peach includes one or more licensed Pits purchased individually or in themed groups called Pit Packs. Peach offers Pits for more than 25 network protocols, and for some file formats. To fuzz with a Pit, you can run the Peach Web interface to configure the Pit, and then immediately use it.</simpara>
<simpara>If your needs extend beyond the available Pits offered by Peach, you can create a fuzzing definition for a custom file format, a proprietary network protocol, an embedded device, a kernel driver, and more.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Modeling</term>
<listitem>
<simpara>Peach operates by fuzzing data and state models of the test targets. Because security testing (fuzzing) focuses on what happens when inappropriate data enters or appears in a system or when inappropriate state transitions occur, Peach focuses heavily on data modeling and state modeling.</simpara>
<simpara>For the average Peach user, most of the human time and energy now goes into analyzing fuzzing job results and fixing bugs. This is due to the availability of pre-made,
off-the-shelf Pits, and the Peach Web UI.</simpara>
<simpara>In most cases, gone are the days of time-consuming activities, such as defining and solidifying the data and state models of a fuzzing definition.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Publisher</term>
<listitem>
<simpara>Publishers are I/O interfaces. 	They take abstract concepts such as input, output, and call (used in state modeling) and provide the actual transport or implementation.</simpara>
<simpara>Peach includes a number of Publishers so your pits and test configurations can perform the following tasks:</simpara>
<itemizedlist>
<listitem>
<simpara>write to files,</simpara>
</listitem>
<listitem>
<simpara>connect to other devices using TCP, UDP or other network protocols,</simpara>
</listitem>
<listitem>
<simpara>make web requests, or</simpara>
</listitem>
<listitem>
<simpara>call COM objects.</simpara>
</listitem>
</itemizedlist>
<simpara>If you need a custom Publisher, it is one of the simplest Peach components to create.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Fuzzing Strategy</term>
<listitem>
<simpara>The fuzzing strategy is the logic that describes the test approach for a fuzzing session. The fuzzing strategy addresses some fundamental questions that impact a fuzzing session that include the following:</simpara>
<itemizedlist>
<listitem>
<simpara>Do we want Peach to test each element of the data and state models individually?</simpara>
</listitem>
<listitem>
<simpara>Do we want Peach to test more than one element at a time?</simpara>
</listitem>
<listitem>
<simpara>How many mutators do we want Peach to apply to each fuzzing element?</simpara>
</listitem>
<listitem>
<simpara>Do we want to limit the number of iterations in the test session?</simpara>
</listitem>
</itemizedlist>
<simpara>Peach includes several fuzzing strategies. They should be sufficient for the majority of users.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Mutators</term>
<listitem>
<simpara>Mutators produce altered or mutated data. Some mutators use a reference data value and create new values based on the reference value. Other mutators generate new values from scratch, from a formula, or from a random number generator.</simpara>
<simpara>Mutators tend to contain very simple logic and should perform a single type of mutation. Some examples follow:</simpara>
<itemizedlist>
<listitem>
<simpara>Produce a number that is within 50 units from the supplied reference value.</simpara>
</listitem>
<listitem>
<simpara>Produce a string that has a length between 1 and 10,000.</simpara>
</listitem>
<listitem>
<simpara>Produce 500 random numbers between 0 and sizeof(int32).</simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term>Agents</term>
<listitem>
<simpara>Agents are special Peach processes that can run locally or remotely, and host one or more Monitors or remote Publishers.
Agents are the basis for the robust monitor facility provided by the Peach Fuzzing Platform and allow for monitoring simple fuzzing configurations through very complex systems that have many tiers.</simpara>
<simpara>A Peach fuzzer can use zero or more agents.</simpara>
<simpara>Agents can be used for fault detection, data collection, and instrumentation of targets involved in the fuzzing run.
They do not host fuzzing engines themselves, nor do they play a part in parallel or distributed fuzzing.
Agents can also host Remote Publishers.</simpara>
<simpara>Agents can be written in any language. Peach Professional includes a built in agent and also basic implementations in several languages in the SDK.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Monitors</term>
<listitem>
<simpara>Monitors run within Peach Agent processes and perform utility tasks such as taking captures of network traffic
during a fuzzing iteration, or attaching a debugger to a process to detect crashes, or even re-starting a network service if it crashes or stops.</simpara>
<simpara>Peach includes a number of monitors. Like Publishers, monitors are easy to write and integrate into the Peach environment.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Logger</term>
<listitem>
<simpara>A logging facility saves crashes and fuzzing run information.</simpara>
<simpara>Peach comes with a file system logger by default.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>The following sections dive deeper into all of these concepts and more.</simpara>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
<section xml:id="_iteration_types">
<title>Iteration Types</title>
<simpara>Peach performs several different types of iterations during a fuzzing session. The following sections introduce each iteration type and describe when the iteration type is most effectively used.</simpara>
<section xml:id="Iteration_record">
<title>Record Iteration</title>
<simpara>The record iteration performs a baseline test that a Peach Pit is operating correctly. The record iteration is the first iteration of a fuzzing session. Peach does not fuzz any data: no mutations. The expected outcome is that the state model executes with no errors.</simpara>
<simpara>Every time Peach starts, it performs a record iteration to record and evaluate
the information it receives for this fuzzing session. Information captured from
the record iteration will be used during later iterations. The captured
information includes the following items:</simpara>
<itemizedlist>
<listitem>
<simpara>Applicable data models and data elements, to estimate the total iteration count required for <link linkend="Iteration_fuzzing">fuzzing iterations</link></simpara>
</listitem>
<listitem>
<simpara>Which mutators can act on which data elements</simpara>
</listitem>
<listitem>
<simpara>Choices and arrays</simpara>
</listitem>
<listitem>
<simpara>Data flows, to compare with the <link linkend="Iteration_control">control iterations</link></simpara>
</listitem>
<listitem>
<simpara>States and actions flows</simpara>
</listitem>
</itemizedlist>
<simpara><link linkend="Iteration_control">Control iterations</link>, if configured, verify that the fuzzer executes the same set of actions as in the record iteration to determine whether
the target is still operational.</simpara>
<simpara>When running Peach with one test, you will actually see two iterations performed&#8212;&#8203;a record iteration and a single fuzzing iteration.</simpara>
<simpara>See also <link linkend="Iteration_control">control iterations</link> and <link linkend="Iteration_fuzzing">fuzzing iterations</link>.</simpara>
</section>
<section xml:id="Iteration_control">
<title>Control Iteration</title>
<simpara>Control iterations verify the correct target operation for a long running target (one that is operational across multiple test cases).</simpara>
<simpara>An example of a long running target is a network service that starts once at the beginning of the fuzzing session; Peach monitors the service to see if it faults. For targets that are not long running, such as a process that restarts for every test case, control iterations are normally not necessary.</simpara>
<note>
<simpara>Control iterations must be explicitly enabled in the pit file.</simpara>
</note>
<simpara>Control iterations work in conjunction with <link linkend="Iteration_record">record iterations</link>. The state-model execution sequence is recorded during a record iteration. A control iteration will perform a test case with no mutations occurring and compare the execution sequence with the recorded sequence. The two sequences should match. If not, Peach generates a fault.</simpara>
<simpara>For example, if 10 actions occur on the record iteration and only 6 occur on the control, Peach assumes that the target is in a bad state and generates a fault since the bad state is likely interesting (as a denial of service vulnerability) from a security standpoint. When a fault occurs, actions can be taken to restart the system.</simpara>
<simpara>Control iterations are configured on the <link linkend="Test"><emphasis>Test</emphasis> element</link> using the <emphasis>controlIteration</emphasis> attribute. The value provided is a positive integer that defines how often to perform a control iteration. A value of 1 will cause control iterations to be performed after each iteration.</simpara>
<formalpara>
<title>Syntax example</title>
<para>
<programlisting language="xml" linenumbering="unnumbered">&lt;Test name="TheTest" controlIteration="1"&gt; .... &lt;/Test&gt;</programlisting>
</para>
</formalpara>
<simpara>A second attribute, <emphasis>nonDeterministicActions</emphasis>, allows Peach to continue fuzzing when
the execution flow of a control iteration might not match the execution flow of the
record iteration.</simpara>
<simpara>For example, some protocols that use a challenge-response authentication process negotiate
the number of iterations needed to gain authentication. In this case, the sequence flow is
indefinite and control iteration sequence flow should not be compared to that of the
record iteration.</simpara>
<simpara>When the value of <emphasis>nonDeterministicActions</emphasis> is <quote>false</quote>, the default action occurs, in which
Peach enforces a matching execution flow sequence between the record iteration and each
control iteration. If the flows do not match, Peach issues a fault.</simpara>
<simpara>When the value of <emphasis>nonDeterministicActions</emphasis> is <literal>true</literal>, the Peach skips the check of
the execution flow sequence. If a control iteration state flow differs from the state flow of a record iteration, Peach does not produce a fault.</simpara>
<formalpara>
<title>Syntax example</title>
<para>
<programlisting language="xml" linenumbering="unnumbered">&lt;Test name="TheTest" controlIteration="1" nonDeterministicActions="true"&gt; .... &lt;/Test&gt;</programlisting>
</para>
</formalpara>
<simpara>See also <link linkend="Iteration_control">control iterations</link> and <link linkend="Iteration_fuzzing">fuzzing iterations</link>.</simpara>
</section>
<section xml:id="Iteration_fuzzing">
<title>Fuzzing Iteration</title>
<simpara>Fuzzing iterations are the most common iteration type. The majority of iterations are usually fuzzing iterations.</simpara>
<simpara>A fuzzing iteration mutates the models to produce a fuzz test case to send to the target.</simpara>
<itemizedlist>
<listitem>
<simpara>During a fuzzing iteration, we assume the target will behave in unexpected ways, such as errors from our I/O interface (time outs, short writes or reads).</simpara>
</listitem>
<listitem>
<simpara>After a fuzzing iteration, we probably will not be able to fully execute our state models or correctly crack the returned data. Because  error conditions generated by fuzzing iterations are likely to happen (even if no issue has occurred), they are usually ignored.</simpara>
</listitem>
</itemizedlist>
<simpara>An expected error seen during a fuzzing iteration will cause Peach, at most, to skip to the next iteration.</simpara>
<simpara>For targets that are long running (such as network services), configure the <link linkend="Iteration_control">control iterations</link> to validate such that the target can maintain correct operation.</simpara>
<simpara>See also <link linkend="Iteration_record">record iterations</link> and <link linkend="Iteration_control">control iterations</link>.</simpara>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="PeachPit">
<title>Pit Files</title>
<simpara>Peach Pit files are XML files that contain all of the information needed for Peach to perform a fuzzing run. When starting a fuzzing session, Peach uses a Peach Pit file and, sometimes, an associated configuration file.</simpara>
<simpara>Peach provides several Pit files that, with some configuration settings, run out-of-the-box. If your needs extend beyond the Pit library, you can create a new Pit file from scratch or by modifying an existing Pit file.</simpara>
<simpara>Peach Pit files contain the following elements:</simpara>
<itemizedlist>
<listitem>
<simpara><link linkend="GeneralConfiguration">General Configuration elements</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="DataModel">Data Modeling elements</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="StateModel">State Modeling elements</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="AgentsMonitors">Agents and Monitors</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="TestConfig">Test Configuration elements</link></simpara>
</listitem>
</itemizedlist>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
<section xml:id="_modeling">
<title>Modeling</title>
<simpara>Modeling describes the format and flow of the data to fuzz, whether in a file format, a network protocol, an embedded system, or a kernel driver. Accurate models are at the core of a successful Peach Fuzzer experience.</simpara>
<simpara>The two types of models used in Peach are the data model that describes the format of the data we fuzz and the state model that provides the flow of data to and from the target. A dumb fuzzer in Peach is a simplistic data model, while a smart (or fully fleshed out) Peach fuzzer has a full data model and state model for both the test data and the system under test.</simpara>
<simpara>When modeling with Peach, remember to model enough depth to enable the fuzzer to work but not more. Instead of worrying about business rules or constraints, focus on the information type, relationships between data elements, and updating items such as checksums.</simpara>
<important>
<simpara>Modeling is about data structure, not logic.</simpara>
</important>
<simpara>When creating custom Peach fuzzers, we recommend initially creating a dumb or simple version of the fuzzer and then extending it. This allows you to run the dumb version of the fuzzer as you develop the fuller, fleshed-out version. This stepping stone approach is also easier for novices to implement.</simpara>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
<section xml:id="DataModeling">
<title>Data Modeling</title>
<simpara>Data models describe the data structures of the test target. A data model includes type information, basic relationships, and the ability to update elements (such as checksums). A data model should not include business rules or business-related constraints, such as those that appear in specifications.</simpara>
<simpara>The goal of building a data model data is to find a balance between effort and fuzzing ability. Spending much effort beyond the balancing point does not measurably increase bug detection in the target. This extra effort lowers the fuzzing return on investment. On the other hand, spending too little effort and not reaching the balancing point decreases the number of found bugs, again hurting the fuzzing return on investment.</simpara>
<simpara>Data models contain the following concepts:</simpara>
<variablelist>
<varlistentry>
<term><link linkend="DataModeling_DataElements">Data elements</link></term>
<listitem>
<simpara>Data elements describe the intrinsic data types (such as number and string).</simpara>
<simpara>Since mutators are written to operate on data elements, providing the correct data element information is critical to fuzzing success. Incorrect data elements mean less effective mutations.</simpara>
</listitem>
</varlistentry>
</variablelist>
<variablelist>
<varlistentry>
<term><link linkend="Relation">Relations</link></term>
<listitem>
<simpara>Peach models three basic types of relationships between data elements: size, count, and offset.</simpara>
<simpara>Data elements sometimes provide modeling information used by other element information like array counts or string length.
Modeling relationships provides several benefits:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>It allows the fuzzer to update the relationships during fuzzing.</simpara>
</listitem>
<listitem>
<simpara>If a string is lengthened, the associated length field can be updated to match. That way, the fuzzing data can penetrate deeper into the logic of the target application.</simpara>
</listitem>
<listitem>
<simpara>Mutators can mutate several fields together, providing much smarter data mutations.</simpara>
</listitem>
</orderedlist>
</listitem>
</varlistentry>
</variablelist>
<variablelist>
<varlistentry>
<term><link linkend="Fixup">Fixups</link></term>
<listitem>
<simpara>Fixups are special utility classes that calculate new checksums, CRC&#8217;s and other operations that rely on data from another data element.</simpara>
<simpara>By fixing data features such as checksums, the values in the data model have a greater chance to pass initial validation checks and exercise the data consumer&#8217;s core logic.</simpara>
</listitem>
</varlistentry>
</variablelist>
<variablelist>
<varlistentry>
<term><link linkend="Transformer">Transformers</link></term>
<listitem>
<simpara>In addition to fixups, Peach provides the ability to perform static transformations such as encoding/decoding and compression/decompression on data. Static transformations can be added and removed; the transformers can decode on input and encode on output.</simpara>
<simpara>Transformers are useful when a format contains data that is encoded or compressed before it reaches the fuzzer. The transformer can decode the data, apply the fuzzing elements to the data, then encode the result so that the fuzzing target receives encoded data as it normally would.</simpara>
</listitem>
</varlistentry>
</variablelist>
<variablelist>
<varlistentry>
<term><link linkend="Analyzers">Analyzers</link></term>
<listitem>
<simpara>In many cases (like structured data such as ASN.1 or XML), it is easier to write code to generate a data model than to manually define a data model. Analyzers let you write code helpers to generate or modify the data model.</simpara>
<simpara>Cracking occurs when loading a sample file or when performing on input actions (such as <emphasis>input</emphasis>, <emphasis>getProperty</emphasis>, and the result from a <emphasis>call</emphasis> action). We use Analyzers to crack data into a model.</simpara>
<simpara>Although Analyzers are moderately easy to add since they directly deal with the
data model, implementing an analyzer requires greater knowledge of Peach internals
than other data modeling components.</simpara>
</listitem>
</varlistentry>
</variablelist>
<section xml:id="DataModeling_DataElements">
<title>Data Elements</title>
<simpara>Data elements describe the intrinsic types that begin to model the data. Typically data are comprised of several data types (such as numbers and string).
Providing the correct data elements is critical to the success of a fuzzer. Since mutators operate on specific types of data elements, if a data element is incorrect, less effective mutations will occur.</simpara>
<simpara>Common data elements:</simpara>
<variablelist>
<varlistentry>
<term><link linkend="DataModel">DataModel</link></term>
<listitem>
<simpara>The <emphasis>DataModel</emphasis> element is a top-level element that defines a data model.</simpara>
<simpara>Multiple <emphasis>DataModels</emphasis> can exist in a pit file. <emphasis>DataModels</emphasis> by themselves
have no size and are containers for other data elements.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Blob">Blob</link></term>
<listitem>
<simpara>A Blob is a container for unstructured data (think of a byte array). The term Blob is borrowed from the relational database field for a column that holds raw binary data.</simpara>
<simpara>Data held in Blobs will be dumb fuzzed.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Block">Block</link></term>
<listitem>
<simpara>The Block element is a container for other data elements.</simpara>
<simpara>By themselves, Blocks do not have size nor contain other data. The main use of a Block is to group other data elements so they can be referenced or operated on as a unit. For example, if two data elements need to be included in a checksum calculation, they can be grouped in a block element. Then, by placing the fixup element as a child element in the block, both data elements will be included in the fixup calculation.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Choice">Choice</link></term>
<listitem>
<simpara>The choice element allows switch-like conditional statements in Peach data models. Choice is used when modeling type-length-value (TLV) metaphors, or in other situations when the data format changes.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Flags">Flags</link></term>
<listitem>
<simpara>The Flags element defines a set of flags.</simpara>
<simpara>Flags is a container for Flag elements that define the individual flags. This can
be a nice shortcut when dealing with a flag set that has many unused positions.</simpara>
<simpara>The <emphasis>Number</emphasis> element supports unaligned sizes and can also be used to define flags.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Flag">Flag</link></term>
<listitem>
<simpara>Defines a specific flag in a flag set. Flag elements have a bit position and bit length.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Number">Number</link></term>
<listitem>
<simpara>Defines a binary integer.</simpara>
<simpara>Numbers are packed to bit/byte representation with byte order (endian-ness). For ASCII strings, use the String element.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Padding">Padding</link></term>
<listitem>
<simpara>Defines a padding for a block or data model.</simpara>
<simpara>Padding supports various options and is used when the padding size is variable (pad to 8-bit or byte boundary).</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Stream">Stream</link></term>
<listitem>
<simpara>A Stream represents a group of data files that contain other files (like zip files) in a single model. Stream-aware publishers can use the stream metadata and content to combine all streams in a data model into a single file.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="String">String</link></term>
<listitem>
<simpara>Defines a string type with encoding. Supported character encodings include ASCII and various Unicode formats.</simpara>
</listitem>
</varlistentry>
</variablelist>
<tip>
<simpara>You can add custom data elements. New data elements should be containers that expose existing types such as Blob, Number, and String. This approach allows your custom data element to use the existing mutators. If you add a custom data type that is not based on any of the existing types, you will need to add mutators that can fuzz the new data type. Otherwise, fuzzing for the new type won&#8217;t be effective.</simpara>
</tip>
<example>
<title>UDP Packet Example</title>
<simpara>This example describes how to format a UDP packet.</simpara>
<simpara>This example does not provide any business logic or constraints on the data. It contains just enough information to describe the types and relations, and to update the checksum field. When fuzzing this data model, Peach will be able to keep the <emphasis>Length</emphasis> field in sync with the <emphasis>Data</emphasis> field changes, unless it specifically decides to mutate the <emphasis>Length</emphasis>. The same is true of the <emphasis>CheckSum</emphasis> field.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;DataModel name="UdpPacket"&gt;
  &lt;Number name="SrcPort" size="16" endian ="big" /&gt;
  &lt;Number name="DestPort" size="16" endian="big" /&gt;
  &lt;Number name="Length" size="16" endian="big"&gt;
    &lt;Relation type="size" of="UdpPacket" /&gt;
  &lt;/Number&gt;
  &lt;Number name="CheckSum" size="16" endian="big"&gt;
    &lt;Fixup class="UDPChecksumFixup"&gt;
      &lt;Param name="ref" value="UdpPacket"/&gt;
    &lt;/Fixup&gt;
  &lt;/Number&gt;

  &lt;Blob name="Data" /&gt;
&lt;/DataModel&gt;</programlisting>
</example>
<section xml:id="_handling_xml_documents">
<title>Handling XML Documents</title>
<simpara>When fuzzing XML documents, you have a choice of fuzzing targets:</simpara>
<itemizedlist>
<listitem>
<simpara>The consumer of the data stored in the XML document.</simpara>
</listitem>
<listitem>
<simpara>The XML parser.</simpara>
</listitem>
</itemizedlist>
<simpara>The first target is the most common and is the focus of this section. The second target fuzzes the XML parser.</simpara>
<simpara>When targeting the data consumer, two special data modeling elements apply to the XML document to modify both the document structure and the document content.</simpara>
<variablelist>
<varlistentry>
<term><link linkend="XmlElement">XmlElement</link></term>
<listitem>
<simpara>Defines an XML element used to fuzz consumers of XML documents.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="XmlAttribute">XmlAttribute</link></term>
<listitem>
<simpara>Defines an XML attribute and is used to fuzz consumers of XML documents.
<emphasis>XmlAttribute</emphasis> is only valid as a child of <emphasis>XmlElement</emphasis>.</simpara>
</listitem>
</varlistentry>
</variablelist>
<note>
<simpara>The <link linkend="Analyzers_Xml">XML analyzer</link> automatically converts XML to data models. When fuzzing XML documents, use <link linkend="Analyzers_Xml">XML analyzer</link> so you don&#8217;t have to manually enter the document structure into Peach.</simpara>
</note>
<important>
<simpara>When using <emphasis>XmlAttribute</emphasis> or <emphasis>XmlElement</emphasis>, the XML parser is not targeted. The target is only the consumer of the data stored in the XML document.</simpara>
</important>
</section>
</section>
<section xml:id="Data_Modeling_DataRelationships">
<title>Relationships in Data</title>
<simpara>Data formats usually have related values. If you understand the basic data relationships types, it will be easier for you to fuzz your data correctly.</simpara>
<simpara>The basic relationships supported in Peach are <emphasis>size of</emphasis> (sometimes called <quote>length of</quote>), <emphasis>count of</emphasis>, and <emphasis>offset of</emphasis>. These basic relationships often produce some of the most interesting mutations during fuzzing as they directly tie to parsing the target data. These basic relationships also form the smallest set of relationships required to correctly output, mutate, and crack most data formats.</simpara>
<simpara>When fuzzing relationships, Peach can either fuzz each part of the relationship separately, or fuzz them together. This can lead to more powerful and interesting mutations.</simpara>
<variablelist>
<varlistentry>
<term><link linkend="Relations_Size">size</link></term>
<listitem>
<simpara>Size relations are the most common relationship found in data formats. Size models length and size fields. The relation is always placed on the size or length field and references the data element that needs a run-time size definition.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Relations_Count">count</link></term>
<listitem>
<simpara>Count relations are the second most common relations found in data formats. Count relations model the array metaphor with a count specifier. Like size relations, the relationship element is always placed on the field that contains the count (the runtime value), not the array.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Relations_Offset">offset</link></term>
<listitem>
<simpara>Offset relations are the least common data format relationship. Offset relations are used in data formats where one element provides the offset to some data.</simpara>
<simpara>When offsets appear, they are usually arrays of offsets to arrays of data. Peach has a special way of handling this. See the <link linkend="DataModeling_Placement">arrays of offsets to data</link> for more information.</simpara>
</listitem>
</varlistentry>
</variablelist>
<section xml:id="_adjusting_relation_values">
<title>Adjusting Relation Values</title>
<simpara>At some point, you will come across a format that will require a modification to the relation value. Perhaps the value requires a mask, or perhaps you need to double the value specified in the relation.</simpara>
<simpara>Relations in Peach allow you to associate Python expressions when reading and when setting the value of the relation. The attributes <emphasis>expressionGet</emphasis> and <emphasis>expressionSet</emphasis> perform this function. The relation value is exposed as <emphasis>size</emphasis> for a size relation, <emphasis>count</emphasis> for a count relation, or <emphasis>offset</emphasis> for an offset relation.</simpara>
<example>
<title>Example of expressionGet and expressionSet</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;Number name="HalfLength" size="32"&gt;
  &lt;Relation type="size" of="Data" expressionGet="size * 2" expressionSet="size / 2" /&gt;
&lt;/Number&gt;
&lt;Blob name="Data" /&gt;</programlisting>
</example>
<simpara>For more information about <emphasis>expressionGet</emphasis> and <emphasis>expressionSet</emphasis> with each relation type, see <link linkend="Relation">Relation</link>.</simpara>
</section>
<section xml:id="DataModeling_Placement">
<title>Arrays of Offsets to Data</title>
<simpara>&#8230;&#8203;Or, the story of <link linkend="Placement">Placement</link>.</simpara>
<simpara>A common data pattern seen is arrays of offsets to data.</simpara>
<simpara>When cracking this type of data, Peach cracks both the offset relation and
its corresponding data when parsing the array element. This creates a situation
where the corresponding data will end up in the wrong place&#8212;&#8203;not at the offset.
Peach provides <emphasis>Placement</emphasis>, a child-element, to move the parent data element to
the correct location post-cracking.</simpara>
<simpara>Consider the following data model:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;DataModel name="ArrayOfOffsets"&gt;

  &lt;Block name="Item" maxOccurs="1024"&gt;

	&lt;Number name="StringLength" size="32"&gt;
	  &lt;Relation type="size" of="Data" /&gt;
	&lt;/Number&gt;

    &lt;Number name="OffsetOfData" size="32"&gt;
	  &lt;Relation type="offset" of="Data"/&gt;
	&lt;/Number&gt;

	&lt;String name="Data" /&gt;

  &lt;/Block&gt;

&lt;/DataModel&gt;</programlisting>
<simpara>The structure of data formed when cracking data into the model looks like:</simpara>
<itemizedlist>
<listitem>
<simpara>ArrayOfOffsets</simpara>
</listitem>
<listitem>
<simpara>Item-0 <?asciidoc-br?></simpara>
<itemizedlist>
<listitem>
<simpara>StringLength</simpara>
</listitem>
<listitem>
<simpara>OffsetOfData</simpara>
</listitem>
<listitem>
<simpara>Data</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Item-1</simpara>
<itemizedlist>
<listitem>
<simpara>StringLength</simpara>
</listitem>
<listitem>
<simpara>OffsetOfData</simpara>
</listitem>
<listitem>
<simpara>Data</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Item-N</simpara>
<itemizedlist>
<listitem>
<simpara>StringLength</simpara>
</listitem>
<listitem>
<simpara>OffsetOfData</simpara>
</listitem>
<listitem>
<simpara>Data</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
<simpara>However, the data does not actually look like this. The format should instead
look like the following layout, with the Data element located where the <emphasis>OffsetOfData</emphasis>
specifies.
In this second layout, the data directly follows the array of lengths and offsets.</simpara>
<itemizedlist>
<listitem>
<simpara>ArrayOfOffsets</simpara>
</listitem>
<listitem>
<simpara>Item-0 <?asciidoc-br?></simpara>
<itemizedlist>
<listitem>
<simpara>StringLength</simpara>
</listitem>
<listitem>
<simpara>OffsetOfData</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Item-1</simpara>
<itemizedlist>
<listitem>
<simpara>StringLength</simpara>
</listitem>
<listitem>
<simpara>OffsetOfData</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Item-N</simpara>
<itemizedlist>
<listitem>
<simpara>StringLength</simpara>
</listitem>
<listitem>
<simpara>OffsetOfData</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Data-0</simpara>
</listitem>
<listitem>
<simpara>Data-1</simpara>
</listitem>
<listitem>
<simpara>Data-N</simpara>
</listitem>
</itemizedlist>
<simpara>Peach can achieve this format using the <emphasis>Placement</emphasis> element. Here is the modified XML
that produces the correct data model:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;DataModel name="ArrayOfOffsets"&gt;

  &lt;Block name="Item" maxOccurs="1024"&gt;

	&lt;Number name="StringLength" size="32"&gt;
	  &lt;Relation type="size" of="Data" /&gt;
	&lt;/Number&gt;

    &lt;Number name="OffsetOfData" size="32"&gt;
	  &lt;Relation type="offset" of="Data"/&gt;
	&lt;/Number&gt;

	&lt;String name="Data"&gt;
	  &lt;Placement before="PlaceDataHere" /&gt;
	&lt;/String&gt;

  &lt;/Block&gt;

  &lt;Block name="PlaceDataHere"/&gt;

&lt;/DataModel&gt;</programlisting>
<simpara>The resulting data model looks like the following:</simpara>
<itemizedlist>
<listitem>
<simpara>ArrayOfOffsets</simpara>
</listitem>
<listitem>
<simpara>Item-0 <?asciidoc-br?></simpara>
<itemizedlist>
<listitem>
<simpara>StringLength</simpara>
</listitem>
<listitem>
<simpara>OffsetOfData</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Item-1</simpara>
<itemizedlist>
<listitem>
<simpara>StringLength</simpara>
</listitem>
<listitem>
<simpara>OffsetOfData</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Item-N</simpara>
<itemizedlist>
<listitem>
<simpara>StringLength</simpara>
</listitem>
<listitem>
<simpara>OffsetOfData</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Data-0</simpara>
</listitem>
<listitem>
<simpara>Data-1</simpara>
</listitem>
<listitem>
<simpara>Data-N</simpara>
</listitem>
<listitem>
<simpara>PlaceDataHere</simpara>
</listitem>
</itemizedlist>
<simpara>The block named PlaceDataHere is a zero-length data element and does not produce any actual data. It serves solely as a point to place our data.</simpara>
</section>
</section>
<section xml:id="Cracking">
<title>Cracking Data into the Data Model</title>
<simpara>In Peach, cracking is the process of parsing data into a data model where data elements have initial values set.
The two most common examples of cracking are:
loading a sample file from disk using the <link linkend="Data">Data</link> element,
and data received through a state model&#8217;s <link linkend="Action_input">input action</link>.</simpara>
<simpara>Cracking sample data into a model is a good way to verify that the model works correctly.
Peach provides several features to support cracking.
When building a Pit,
Peach also provides methods to debug the cracking process.</simpara>
<section xml:id="_features_specific_to_cracking">
<title>Features Specific to Cracking</title>
<variablelist>
<varlistentry>
<term><link linkend="token">token</link> attribute</term>
<listitem>
<simpara>A token is a string of one or more characters that are significant as a group.
In Peach,
one function of tokens is to identify delimiters that separate strings in an input stream.
When cracking data into a model,
the input stream must include elements marked as tokens.
Strings that have unknown lengths,
but are separated by tokens,
can be cracked at the appropriate locations.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="constraint">constraint</link> attribute</term>
<listitem>
<simpara>Constraints are scripting expressions that are evaluated and return true or false. The constraint is executed when cracking data into a data element. Constraints provide similar functionality to tokens, but are more flexible. For example, a token attribute used on a <link linkend="String">String</link> element would be case sensitive. A constraint can be used with a scripting comparison that is not case sensitive.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Placement">Placement</link> element</term>
<listitem>
<simpara>Placement is used in conjunction with the <link linkend="Relations_Offset">offset</link> relation to move an element inside of the model. See <link linkend="DataModeling_Placement">the story of placement</link> for more information.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Analyzers">Analyzers</link> element</term>
<listitem>
<simpara>Analyzers provide code that generate or modify a data model. When compared to generating a <emphasis>DataModel</emphasis> manually, analyzers usually reduce the time and effort needed to create a data model (especially in self-describing formats such as ASN.1 and XML).</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>--debug</literal> argument</term>
<listitem>
<simpara>The Peach <literal>--debug</literal> command line argument is the main method of debugging the cracking process. The debug argument causes Peach to provide detailed output for every step of the cracking process. See <link linkend="debug-cracking">Debugging the Cracking Process</link> for information on how to use this output.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="debug-cracking">
<title>Debugging the Cracking Process</title>
<simpara>When writing data models, it is useful to understand, in detail, how cracking occurs for both debugging and data validation. Peach provides two tools for debugging and validating that data is cracking correctly,
the <literal>--debug</literal> argument to Peach and the <link linkend="Program_PeachValidator">Peach Validator</link> tool.</simpara>
<itemizedlist>
<listitem>
<simpara>The <literal>--debug</literal> argument enables verbose debugging messages from Peach, including the cracking process.</simpara>
</listitem>
<listitem>
<simpara>The Peach Validator tool provides a graphical view of the data model before and after data is cracked into the model.</simpara>
</listitem>
</itemizedlist>
<simpara>The combination of these tools provides enough information to debug and to validate your pit.</simpara>
<section xml:id="_understanding_the_debug_output">
<title>Understanding the <literal>--debug</literal> Output</title>
<simpara>The following example explains the output of <literal>--debug</literal>, and the debugging process.</simpara>
<simpara>The focus of this example is the first part of a PNG Pit, and writing the debug
output to the console. PNG is a common image file format. A full fuzzing definition
of this format is available from Peach as a stand-alone Pit or as part of the
Image Pit Pack.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

	&lt;DataModel name="PngModel"&gt;
		&lt;Blob /&gt;
	&lt;/DataModel&gt;

	&lt;StateModel name="State" initialState="Initial"&gt;
		&lt;State name="Initial"&gt;

			&lt;Action type="output"&gt;
				&lt;DataModel ref="PngModel" /&gt;
				&lt;Data fileName="##Peach.Pwd##\samples_png\snail.png" /&gt;
			&lt;/Action&gt;

		&lt;/State&gt;
	&lt;/StateModel&gt;

	&lt;Test name="Default"&gt;
		&lt;StateModel ref="State"/&gt;

		&lt;Publisher class="File"&gt;
			&lt;Param name="FileName" value="fuzzed.png" /&gt;
		&lt;/Publisher&gt;
	&lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>When run with the <literal>--debug</literal> argument, it produces the following output:</simpara>
<screen>&gt; peach -1 --debug example.xml

[*] Test 'Default' starting with random seed 28899.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Cracker.DataCracker ----------------------------------<co xml:id="CO1-1"/>
Peach.Core.Cracker.DataCracker DataModel 'PngModel' Bytes: 0/33546, Bits: 0/268368 <co xml:id="CO1-2"/>
Peach.Core.Cracker.DataCracker getSize: -----&gt; DataModel 'PngModel'
Peach.Core.Cracker.DataCracker scan: DataModel 'PngModel'
Peach.Core.Cracker.DataCracker scan: Blob 'PngModel.DataElement_0' -&gt; Offset: 0, Unsized element
Peach.Core.Cracker.DataCracker getSize: &lt;----- Deterministic: ???
Peach.Core.Cracker.DataCracker Crack: DataModel 'PngModel' Size: &lt;null&gt;, Bytes: 0/33546, Bits: 0/268368
Peach.Core.Cracker.DataCracker ----------------------------------<co xml:id="CO1-3"/>
Peach.Core.Cracker.DataCracker Blob 'PngModel.DataElement_0' Bytes: 0/33546, Bits: 0/268368 <co xml:id="CO1-4"/>
Peach.Core.Cracker.DataCracker getSize: -----&gt; Blob 'PngModel.DataElement_0'
Peach.Core.Cracker.DataCracker scan: Blob 'PngModel.DataElement_0' -&gt; Offset: 0, Unsized element
Peach.Core.Cracker.DataCracker lookahead: Blob 'PngModel.DataElement_0'
Peach.Core.Cracker.DataCracker getSize: &lt;----- Last Unsized: 268368
Peach.Core.Cracker.DataCracker Crack: Blob 'PngModel.DataElement_0' Size: 268368, Bytes: 0/33546, Bits: 0/268368 <co xml:id="CO1-5"/>
Peach.Core.Dom.DataElement Blob 'PngModel.DataElement_0' value is: 89 50 4e 47 0d 0a 1a 0a 00 00 00 0d 49 48 44 52 00 00 01 00 00 00 01 00 08 02 00 00 00 d3 10 3f.. (Len: 33546 bytes) <co xml:id="CO1-6"/>
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.FilePublisher start()
Peach.Core.Publishers.FilePublisher open()
Peach.Core.Publishers.FilePublisher output(33546 bytes) <co xml:id="CO1-7"/>
Peach.Core.Publishers.FilePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.FilePublisher stop()

[*] Test 'Default' finished.</screen>
<calloutlist>
<callout arearefs="CO1-1">
<para>Debug messages are prefixed with the full class name they originate from. For cracking messages, you see a combination of DataCracker and DataElements.<?asciidoc-br?>
The long dashed line indicates the start of a new data element</para>
</callout>
<callout arearefs="CO1-2">
<para>The element type and element name are provided. This is the current data offset in bytes and in bits.</para>
</callout>
<callout arearefs="CO1-3">
<para>The long dashed line indicates the start of a new data element</para>
</callout>
<callout arearefs="CO1-4">
<para>Again, the element type and element name are provided. This is the current data offset in bytes and in bits. Since we have not yet read any bytes, we are still at offset zero.</para>
</callout>
<callout arearefs="CO1-5">
<para>The amount of data, in bits, to load into our element; and the current position, in bytes and in bits.</para>
</callout>
<callout arearefs="CO1-6">
<para>After cracking data into an element, the value is displayed. If the value is long, the display of the value might be truncated. Also, the total size in bytes is provided.</para>
</callout>
<callout arearefs="CO1-7">
<para>The total size sent as output to the Publisher. This should match the size of our input file.</para>
</callout>
</calloutlist>
<simpara>As part of data validation, verify that the amount of data being sent and cracked matches the size of the file.</simpara>
<screen>&gt; dir samples_png\snail.png

 Volume in drive C has no label.
 Volume Serial Number is

 Directory of samples_png

03/12/2014  07:00 PM            33,546 snail.png
               1 File(s)         33,546 bytes</screen>
<simpara>In this case, the sizes match.</simpara>
<simpara>We can also use the Peach Validator to get a visual representation of what is happening. Launch Peach Validator and load <emphasis>example.xml</emphasis> via the toolbar. Notice the tree view on the bottom half of the window. This is the data model and data elements. Because no data has been loaded, the values are all empty. Notice the <emphasis>DataElement_0</emphasis> element; this is the unnamed <link linkend="Blob">Blob</link> element. Peach assigned it a default name.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/DevGuide/DataModeling/Cracking_Validator1.png"/>
</imageobject>
<textobject><phrase>Cracking Validator1</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Next, load the sample file <emphasis>snail.png</emphasis> and see the result of the crack.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/DevGuide/DataModeling/Cracking_Validator2.png"/>
</imageobject>
<textobject><phrase>Cracking Validator2</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>The data model now contains data. Click on the <emphasis>DataElement_0</emphasis> item to highlight the corresponding data in the hex view.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/DevGuide/DataModeling/Cracking_Validator3.png"/>
</imageobject>
<textobject><phrase>Cracking Validator3</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>This definition is considered a dumb fuzzing model for PNG. The next step expands the model based on the PNG specification.</simpara>
<simpara><emphasis role="strong">Adding Some Smarts</emphasis></simpara>
<simpara>PNG files consist of a piece of file magic and then multiple T-L-V (type, length, value) blocks that the PNG specification calls <emphasis>chunks</emphasis>. TLV&#8217;s are common structures in data formats. The file magic is a unique marker identifying PNG files. The next revision of the PNG model includes the file magic and a TLV structure set up as an array.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

	&lt;DataModel name="PngModel"&gt;
		&lt;Blob name="Magic" length="8" /&gt;

		&lt;!-- TLV --&gt;
		&lt;Block name="Chunk" maxOccurs="100"&gt;
			&lt;Number name="Length" size="32"&gt;
				&lt;Relation type="size" of="Data" /&gt;
			&lt;/Number&gt;
			&lt;Block name="DataToCrc"&gt;
				&lt;!-- Types: IHDR, IDAT, etc.--&gt;
				&lt;String name="Type" length="4" /&gt;
				&lt;Blob name="Data" /&gt;
			&lt;/Block&gt;
			&lt;Number name="Checksum" size="32"&gt;
				&lt;Fixup class="Crc"&gt;
					&lt;Param name="ref" value="DataToCrc" /&gt;
				&lt;/Fixup&gt;
			&lt;/Number&gt;
		&lt;/Block&gt;
	&lt;/DataModel&gt;

	&lt;StateModel name="State" initialState="Initial"&gt;
		&lt;State name="Initial"&gt;

			&lt;Action type="output"&gt;
				&lt;DataModel ref="PngModel" /&gt;
				&lt;Data fileName="##Peach.Pwd##\samples_png\snail.png" /&gt;
			&lt;/Action&gt;

		&lt;/State&gt;
	&lt;/StateModel&gt;

	&lt;Test name="Default"&gt;
		&lt;StateModel ref="State"/&gt;

		&lt;Publisher class="File"&gt;
			&lt;Param name="FileName" value="fuzzed.png" /&gt;
		&lt;/Publisher&gt;
	&lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>The preceding Pit definition produces the following in Peach Validator before cracking any data.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/DevGuide/DataModeling/Cracking_Validator4.png"/>
</imageobject>
<textobject><phrase>Cracking Validator4</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>When we try and crack the sample, an error message states that cracking failed. An error message also displays that might help in locating and resolving the issue.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/DevGuide/DataModeling/Cracking_Validator5.png"/>
</imageobject>
<textobject><phrase>Cracking Validator5</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>The next step is to review the <literal>--debug</literal> output and see if we can spot the issue.</simpara>
<screen>&gt; peach -1 --debug example.xml

[*] Test 'Default' starting with random seed 44055.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker DataModel 'PngModel' Bytes: 0/33546, Bits: 0/268368
Peach.Core.Cracker.DataCracker getSize: -----&gt; DataModel 'PngModel'
Peach.Core.Cracker.DataCracker scan: DataModel 'PngModel'
Peach.Core.Cracker.DataCracker scan: Blob 'PngModel.Magic' -&gt; Pos: 64, Length: 64
Peach.Core.Cracker.DataCracker getSize: &lt;----- Deterministic: ???
Peach.Core.Cracker.DataCracker Crack: DataModel 'PngModel' Size: &lt;null&gt;, Bytes: 0/33546, Bits: 0/268368
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker Blob 'PngModel.Magic' Bytes: 0/33546, Bits: 0/268368
Peach.Core.Cracker.DataCracker getSize: -----&gt; Blob 'PngModel.Magic'
Peach.Core.Cracker.DataCracker scan: Blob 'PngModel.Magic' -&gt; Pos: 64, Length: 64
Peach.Core.Cracker.DataCracker getSize: &lt;----- Size: 64
Peach.Core.Cracker.DataCracker Crack: Blob 'PngModel.Magic' Size: 64, Bytes: 0/33546, Bits: 0/268368
Peach.Core.Dom.DataElement Blob 'PngModel.Magic' value is: 89 50 4e 47 0d 0a 1a 0a <co xml:id="CO2-1"/>
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker Array 'PngModel.Chunk' Bytes: 8/33546, Bits: 64/268368
Peach.Core.Cracker.DataCracker getSize: -----&gt; Array 'PngModel.Chunk'
Peach.Core.Cracker.DataCracker scanArray: Array 'PngModel.Chunk'
Peach.Core.Cracker.DataCracker scan: Block 'PngModel.Chunk.Chunk'
Peach.Core.Cracker.DataCracker scan: Number 'PngModel.Chunk.Chunk.Length' -&gt; Pos: 32, Length: 32
Peach.Core.Cracker.DataCracker scanArray: Array 'PngModel.Chunk' -&gt; FirstSized
Peach.Core.Cracker.DataCracker getSize: &lt;----- Deterministic: ???
Peach.Core.Cracker.DataCracker Crack: Array 'PngModel.Chunk' Size: &lt;null&gt;, Bytes: 8/33546, Bits: 64/268368
Peach.Core.Dom.Array Crack: ====================== <co xml:id="CO2-2"/>
Peach.Core.Dom.Array Crack: Block 'PngModel.Chunk.Chunk' Trying #1 <co xml:id="CO2-3"/>
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker Block 'PngModel.Chunk.Chunk' Bytes: 8/33546, Bits: 64/268368
Peach.Core.Cracker.DataCracker getSize: -----&gt; Block 'PngModel.Chunk.Chunk'
Peach.Core.Cracker.DataCracker scan: Block 'PngModel.Chunk.Chunk'
Peach.Core.Cracker.DataCracker scan: Number 'PngModel.Chunk.Chunk.Length' -&gt; Pos: 32, Length: 32
Peach.Core.Cracker.DataCracker getSize: &lt;----- Deterministic: ???
Peach.Core.Cracker.DataCracker Crack: Block 'PngModel.Chunk.Chunk' Size: &lt;null&gt;, Bytes: 8/33546, Bits: 64/268368
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker Number 'PngModel.Chunk.Chunk.Length' Bytes: 8/33546, Bits: 64/268368
Peach.Core.Cracker.DataCracker getSize: -----&gt; Number 'PngModel.Chunk.Chunk.Length'
Peach.Core.Cracker.DataCracker scan: Number 'PngModel.Chunk.Chunk.Length' -&gt; Pos: 32, Length: 32
Peach.Core.Cracker.DataCracker getSize: &lt;----- Size: 32
Peach.Core.Cracker.DataCracker Crack: Number 'PngModel.Chunk.Chunk.Length' Size: 32, Bytes: 8/33546, Bits: 64/268368
Peach.Core.Dom.DataElement Number 'PngModel.Chunk.Chunk.Length' value is: 218103808 <co xml:id="CO2-4"/>
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker Block 'PngModel.Chunk.Chunk.DataToCrc' Bytes: 12/33546, Bits: 96/268368
Peach.Core.Cracker.DataCracker getSize: -----&gt; Block 'PngModel.Chunk.Chunk.DataToCrc'
Peach.Core.Cracker.DataCracker scan: Block 'PngModel.Chunk.Chunk.DataToCrc'
Peach.Core.Cracker.DataCracker scan: String 'PngModel.Chunk.Chunk.DataToCrc.Type' -&gt; Pos: 32, Length: 32
Peach.Core.Cracker.DataCracker getSize: &lt;----- Deterministic: ???
Peach.Core.Cracker.DataCracker Crack: Block 'PngModel.Chunk.Chunk.DataToCrc' Size: &lt;null&gt;, Bytes: 12/33546, Bits: 96/268368
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker String 'PngModel.Chunk.Chunk.DataToCrc.Type' Bytes: 12/33546, Bits: 96/268368
Peach.Core.Cracker.DataCracker getSize: -----&gt; String 'PngModel.Chunk.Chunk.DataToCrc.Type'
Peach.Core.Cracker.DataCracker scan: String 'PngModel.Chunk.Chunk.DataToCrc.Type' -&gt; Pos: 32, Length: 32
Peach.Core.Cracker.DataCracker getSize: &lt;----- Size: 32
Peach.Core.Cracker.DataCracker Crack: String 'PngModel.Chunk.Chunk.DataToCrc.Type' Size: 32, Bytes: 12/33546, Bits: 96/268368
Peach.Core.Dom.DataElement String 'PngModel.Chunk.Chunk.DataToCrc.Type' value is: IHDR <co xml:id="CO2-5"/>
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker Blob 'PngModel.Chunk.Chunk.DataToCrc.Data' Bytes: 16/33546, Bits: 128/268368
Peach.Core.Cracker.DataCracker getSize: -----&gt; Blob 'PngModel.Chunk.Chunk.DataToCrc.Data'
Peach.Core.Cracker.DataCracker scan: Blob 'PngModel.Chunk.Chunk.DataToCrc.Data' -&gt; Pos: 1744830464, Size relation: 1744830464
Peach.Core.Cracker.DataCracker getSize: &lt;----- Size: 1744830464
Peach.Core.Cracker.DataCracker Crack: Blob 'PngModel.Chunk.Chunk.DataToCrc.Data' Size: 1744830464, Bytes: 16/33546, Bits: 128/268368
Peach.Core.Cracker.DataCracker Blob 'PngModel.Chunk.Chunk.DataToCrc.Data' failed to crack. <co xml:id="CO2-6"/>
Peach.Core.Cracker.DataCracker Blob 'PngModel.Chunk.Chunk.DataToCrc.Data' has length of 1744830464 bits but buffer only has 268240 bits left.
Peach.Core.Cracker.DataCracker Block 'PngModel.Chunk.Chunk.DataToCrc' failed to crack.
Peach.Core.Cracker.DataCracker Block 'PngModel.Chunk.Chunk' failed to crack.
Peach.Core.Dom.Array Crack: Array 'PngModel.Chunk' Failed on #1
Peach.Core.Cracker.DataCracker Array 'PngModel.Chunk' failed to crack.
Peach.Core.Cracker.DataCracker DataModel 'PngModel' failed to crack.

[*] Test 'Default' finished.
Peach.Core.PeachException: Error, failed to crack "c:\peach\win_x64_release\bin\samples_png\snail.png" into "PngModel":Blob 'PngModel.Chunk.Chunk.DataToCrc.Data' has length of 1744830464 bits but buffer only has 268240 bits left. ---&gt; Peach.Core.Cracker.CrackingFailure: Blob 'PngModel.Chunk.Chunk.DataToCrc.Data' has length of 1744830464 bits but buffer only has 268240 bits left.</screen>
<calloutlist>
<callout arearefs="CO2-1">
<para><emphasis>Magic</emphasis> element cracked correctly.</para>
</callout>
<callout arearefs="CO2-2">
<para>The double line separator indicates an array is being expanded to fit the incoming data.</para>
</callout>
<callout arearefs="CO2-3">
<para>The array position (starting with 1) is indicated along with the name of the element that makes up the array.</para>
</callout>
<callout arearefs="CO2-4">
<para>Notice the very large value cracked into the <emphasis>Length</emphasis> field. This is much larger than the file size.</para>
</callout>
<callout arearefs="CO2-5">
<para>The <emphasis>Type</emphasis> field correctly cracked with a value of <literal>IHDR</literal>.</para>
</callout>
<callout arearefs="CO2-6">
<para>The <emphasis>Data</emphasis> field failed to crack with a huge size (shown in bits) provided by the <emphasis>Length</emphasis> field.</para>
</callout>
</calloutlist>
<simpara>The debug output shows that the elements are cracking at the correct byte offsets and only <emphasis>Length</emphasis> and <emphasis>Data</emphasis> appear to be incorrect. In fact, the <emphasis>Length</emphasis> field is the real issue here. A closer look at the PNG specification shows all numbers should be big endian byte order. By default Peach uses little endian. This can be adjusted using the <emphasis>endian</emphasis> attribute, or a <link linkend="Defaults">Defaults</link> element to change to default endian-ness.</simpara>
<simpara>The following XML has corrected the issue:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

	&lt;Defaults&gt;
		&lt;Number endian="big" /&gt;
	&lt;/Defaults&gt;

	&lt;DataModel name="PngModel"&gt;
		&lt;Blob name="Magic" length="8" /&gt;

		&lt;!-- TLV --&gt;
		&lt;Block name="Chunk" maxOccurs="100"&gt;
			&lt;Number name="Length" size="32"&gt;
				&lt;Relation type="size" of="Data" /&gt;
			&lt;/Number&gt;
			&lt;Block name="DataToCrc"&gt;
				&lt;!-- Types: IHDR, IDAT, etc.--&gt;
				&lt;String name="Type" length="4" /&gt;
				&lt;Blob name="Data" /&gt;
			&lt;/Block&gt;
			&lt;Number name="Checksum" size="32"&gt;
				&lt;Fixup class="Crc"&gt;
					&lt;Param name="ref" value="DataToCrc" /&gt;
				&lt;/Fixup&gt;
			&lt;/Number&gt;
		&lt;/Block&gt;
	&lt;/DataModel&gt;

	&lt;StateModel name="State" initialState="Initial"&gt;
		&lt;State name="Initial"&gt;

			&lt;Action type="output"&gt;
				&lt;DataModel ref="PngModel" /&gt;
				&lt;Data fileName="##Peach.Pwd##\samples_png\snail.png" /&gt;
			&lt;/Action&gt;

		&lt;/State&gt;
	&lt;/StateModel&gt;

	&lt;Test name="Default"&gt;
		&lt;StateModel ref="State"/&gt;

		&lt;Publisher class="File"&gt;
			&lt;Param name="FileName" value="fuzzed.png" /&gt;
		&lt;/Publisher&gt;
	&lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>With this change, let&#8217;s review the <literal>--debug</literal> output again.</simpara>
<screen>&gt; peach -1 --debug example.xml

[*] Test 'Default' starting with random seed 59855.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker DataModel 'PngModel' Bytes: 0/33546, Bits: 0/268368
Peach.Core.Cracker.DataCracker getSize: -----&gt; DataModel 'PngModel'
Peach.Core.Cracker.DataCracker scan: DataModel 'PngModel'
Peach.Core.Cracker.DataCracker scan: Blob 'PngModel.Magic' -&gt; Pos: 64, Length: 64
Peach.Core.Cracker.DataCracker getSize: &lt;----- Deterministic: ???
Peach.Core.Cracker.DataCracker Crack: DataModel 'PngModel' Size: &lt;null&gt;, Bytes: 0/33546, Bits: 0/268368
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker Blob 'PngModel.Magic' Bytes: 0/33546, Bits: 0/268368
Peach.Core.Cracker.DataCracker getSize: -----&gt; Blob 'PngModel.Magic'
Peach.Core.Cracker.DataCracker scan: Blob 'PngModel.Magic' -&gt; Pos: 64, Length: 64
Peach.Core.Cracker.DataCracker getSize: &lt;----- Size: 64
Peach.Core.Cracker.DataCracker Crack: Blob 'PngModel.Magic' Size: 64, Bytes: 0/33546, Bits: 0/268368
Peach.Core.Dom.DataElement Blob 'PngModel.Magic' value is: 89 50 4e 47 0d 0a 1a 0a
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker Array 'PngModel.Chunk' Bytes: 8/33546, Bits: 64/268368
Peach.Core.Cracker.DataCracker getSize: -----&gt; Array 'PngModel.Chunk'
Peach.Core.Cracker.DataCracker scanArray: Array 'PngModel.Chunk'
Peach.Core.Cracker.DataCracker scan: Block 'PngModel.Chunk.Chunk'
Peach.Core.Cracker.DataCracker scan: Number 'PngModel.Chunk.Chunk.Length' -&gt; Pos: 32, Length: 32
Peach.Core.Cracker.DataCracker scanArray: Array 'PngModel.Chunk' -&gt; FirstSized
Peach.Core.Cracker.DataCracker getSize: &lt;----- Deterministic: ???
Peach.Core.Cracker.DataCracker Crack: Array 'PngModel.Chunk' Size: &lt;null&gt;, Bytes: 8/33546, Bits: 64/268368</screen>
<simpara>Next is the first element of the array that caused issues in the prior run.</simpara>
<screen>Peach.Core.Dom.Array Crack: ======================
Peach.Core.Dom.Array Crack: Block 'PngModel.Chunk.Chunk' Trying #1
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker Block 'PngModel.Chunk.Chunk' Bytes: 8/33546, Bits: 64/268368
Peach.Core.Cracker.DataCracker getSize: -----&gt; Block 'PngModel.Chunk.Chunk'
Peach.Core.Cracker.DataCracker scan: Block 'PngModel.Chunk.Chunk'
Peach.Core.Cracker.DataCracker scan: Number 'PngModel.Chunk.Chunk.Length' -&gt; Pos: 32, Length: 32
Peach.Core.Cracker.DataCracker getSize: &lt;----- Deterministic: ???
Peach.Core.Cracker.DataCracker Crack: Block 'PngModel.Chunk.Chunk' Size: &lt;null&gt;, Bytes: 8/33546, Bits: 64/268368
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker Number 'PngModel.Chunk.Chunk.Length' Bytes: 8/33546, Bits: 64/268368
Peach.Core.Cracker.DataCracker getSize: -----&gt; Number 'PngModel.Chunk.Chunk.Length'
Peach.Core.Cracker.DataCracker scan: Number 'PngModel.Chunk.Chunk.Length' -&gt; Pos: 32, Length: 32
Peach.Core.Cracker.DataCracker getSize: &lt;----- Size: 32
Peach.Core.Cracker.DataCracker Crack: Number 'PngModel.Chunk.Chunk.Length' Size: 32, Bytes: 8/33546, Bits: 64/268368
Peach.Core.Dom.DataElement Number 'PngModel.Chunk.Chunk.Length' value is: 13 <co xml:id="CO3-1"/>
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker Block 'PngModel.Chunk.Chunk.DataToCrc' Bytes: 12/33546, Bits: 96/268368
Peach.Core.Cracker.DataCracker getSize: -----&gt; Block 'PngModel.Chunk.Chunk.DataToCrc'
Peach.Core.Cracker.DataCracker scan: Block 'PngModel.Chunk.Chunk.DataToCrc'
Peach.Core.Cracker.DataCracker scan: String 'PngModel.Chunk.Chunk.DataToCrc.Type' -&gt; Pos: 32, Length: 32
Peach.Core.Cracker.DataCracker getSize: &lt;----- Deterministic: ???
Peach.Core.Cracker.DataCracker Crack: Block 'PngModel.Chunk.Chunk.DataToCrc' Size: &lt;null&gt;, Bytes: 12/33546, Bits: 96/268368
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker String 'PngModel.Chunk.Chunk.DataToCrc.Type' Bytes: 12/33546, Bits: 96/268368
Peach.Core.Cracker.DataCracker getSize: -----&gt; String 'PngModel.Chunk.Chunk.DataToCrc.Type'
Peach.Core.Cracker.DataCracker scan: String 'PngModel.Chunk.Chunk.DataToCrc.Type' -&gt; Pos: 32, Length: 32
Peach.Core.Cracker.DataCracker getSize: &lt;----- Size: 32
Peach.Core.Cracker.DataCracker Crack: String 'PngModel.Chunk.Chunk.DataToCrc.Type' Size: 32, Bytes: 12/33546, Bits: 96/268368
Peach.Core.Dom.DataElement String 'PngModel.Chunk.Chunk.DataToCrc.Type' value is: IHDR
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker Blob 'PngModel.Chunk.Chunk.DataToCrc.Data' Bytes: 16/33546, Bits: 128/268368
Peach.Core.Cracker.DataCracker getSize: -----&gt; Blob 'PngModel.Chunk.Chunk.DataToCrc.Data'
Peach.Core.Cracker.DataCracker scan: Blob 'PngModel.Chunk.Chunk.DataToCrc.Data' -&gt; Pos: 104, Size relation: 104
Peach.Core.Cracker.DataCracker getSize: &lt;----- Size: 104
Peach.Core.Cracker.DataCracker Crack: Blob 'PngModel.Chunk.Chunk.DataToCrc.Data' Size: 104, Bytes: 16/33546, Bits: 128/268368
Peach.Core.Dom.DataElement Blob 'PngModel.Chunk.Chunk.DataToCrc.Data' value is: 00 00 01 00 00 00 01 00 08 02 00 00 00 <co xml:id="CO3-2"/>
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker Number 'PngModel.Chunk.Chunk.Checksum' Bytes: 29/33546, Bits: 232/268368
Peach.Core.Cracker.DataCracker getSize: -----&gt; Number 'PngModel.Chunk.Chunk.Checksum'
Peach.Core.Cracker.DataCracker scan: Number 'PngModel.Chunk.Chunk.Checksum' -&gt; Pos: 32, Length: 32
Peach.Core.Cracker.DataCracker getSize: &lt;----- Size: 32
Peach.Core.Cracker.DataCracker Crack: Number 'PngModel.Chunk.Chunk.Checksum' Size: 32, Bytes: 29/33546, Bits: 232/268368
Peach.Core.Dom.DataElement Number 'PngModel.Chunk.Chunk.Checksum' value is: 3541057329</screen>
<calloutlist>
<callout arearefs="CO3-1">
<para>The <emphasis>Length</emphasis> field looks correct with a value of 13.</para>
</callout>
<callout arearefs="CO3-2">
<para>The <emphasis>Data</emphasis> field cracked successfully this time.</para>
</callout>
</calloutlist>
<simpara>Now that the first chunk cracks correctly, it&#8217;s time to expand the array to pick up the other chunks in the file as well.</simpara>
<screen>Peach.Core.Dom.Array Crack: ======================
Peach.Core.Dom.Array Crack: Block 'PngModel.Chunk.Chunk' Trying #2
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker Block 'PngModel.Chunk.Chunk_1' Bytes: 33/33546, Bits: 264/268368
Peach.Core.Cracker.DataCracker getSize: -----&gt; Block 'PngModel.Chunk.Chunk_1'
Peach.Core.Cracker.DataCracker scan: Block 'PngModel.Chunk.Chunk_1'
Peach.Core.Cracker.DataCracker scan: Number 'PngModel.Chunk.Chunk_1.Length' -&gt; Pos: 32, Length: 32
Peach.Core.Cracker.DataCracker getSize: &lt;----- Deterministic: ???
Peach.Core.Cracker.DataCracker Crack: Block 'PngModel.Chunk.Chunk_1' Size: &lt;null&gt;, Bytes: 33/33546, Bits: 264/268368
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker Number 'PngModel.Chunk.Chunk_1.Length' Bytes: 33/33546, Bits: 264/268368
Peach.Core.Cracker.DataCracker getSize: -----&gt; Number 'PngModel.Chunk.Chunk_1.Length'
Peach.Core.Cracker.DataCracker scan: Number 'PngModel.Chunk.Chunk_1.Length' -&gt; Pos: 32, Length: 32
Peach.Core.Cracker.DataCracker getSize: &lt;----- Size: 32
Peach.Core.Cracker.DataCracker Crack: Number 'PngModel.Chunk.Chunk_1.Length' Size: 32, Bytes: 33/33546, Bits: 264/268368
Peach.Core.Dom.DataElement Number 'PngModel.Chunk.Chunk_1.Length' value is: 32768 <co xml:id="CO4-1"/>
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker Block 'PngModel.Chunk.Chunk_1.DataToCrc' Bytes: 37/33546, Bits: 296/268368
Peach.Core.Cracker.DataCracker getSize: -----&gt; Block 'PngModel.Chunk.Chunk_1.DataToCrc'
Peach.Core.Cracker.DataCracker scan: Block 'PngModel.Chunk.Chunk_1.DataToCrc'
Peach.Core.Cracker.DataCracker scan: String 'PngModel.Chunk.Chunk_1.DataToCrc.Type' -&gt; Pos: 32, Length: 32
Peach.Core.Cracker.DataCracker getSize: &lt;----- Deterministic: ???
Peach.Core.Cracker.DataCracker Crack: Block 'PngModel.Chunk.Chunk_1.DataToCrc' Size: &lt;null&gt;, Bytes: 37/33546, Bits: 296/268368
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker String 'PngModel.Chunk.Chunk_1.DataToCrc.Type' Bytes: 37/33546, Bits: 296/268368
Peach.Core.Cracker.DataCracker getSize: -----&gt; String 'PngModel.Chunk.Chunk_1.DataToCrc.Type'
Peach.Core.Cracker.DataCracker scan: String 'PngModel.Chunk.Chunk_1.DataToCrc.Type' -&gt; Pos: 32, Length: 32
Peach.Core.Cracker.DataCracker getSize: &lt;----- Size: 32
Peach.Core.Cracker.DataCracker Crack: String 'PngModel.Chunk.Chunk_1.DataToCrc.Type' Size: 32, Bytes: 37/33546, Bits: 296/268368
Peach.Core.Dom.DataElement String 'PngModel.Chunk.Chunk_1.DataToCrc.Type' value is: IDAT <co xml:id="CO4-2"/>
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker Blob 'PngModel.Chunk.Chunk_1.DataToCrc.Data' Bytes: 41/33546, Bits: 328/268368
Peach.Core.Cracker.DataCracker getSize: -----&gt; Blob 'PngModel.Chunk.Chunk_1.DataToCrc.Data'
Peach.Core.Cracker.DataCracker scan: Blob 'PngModel.Chunk.Chunk_1.DataToCrc.Data' -&gt; Pos: 262144, Size relation: 262144
Peach.Core.Cracker.DataCracker getSize: &lt;----- Size: 262144
Peach.Core.Cracker.DataCracker Crack: Blob 'PngModel.Chunk.Chunk_1.DataToCrc.Data' Size: 262144, Bytes: 41/33546, Bits: 328/268368
Peach.Core.Dom.DataElement Blob 'PngModel.Chunk.Chunk_1.DataToCrc.Data' value is: 78 da ec 9d 65 7c 1e 47 96 af 9f ea ee 97 c5 cc 96 64 90 99 ed 98 13 b3 1d 07 1c 87 39 0e 33 33.. (Len: 32768 bytes) <co xml:id="CO4-3"/>
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker Number 'PngModel.Chunk.Chunk_1.Checksum' Bytes: 32809/33546, Bits: 262472/268368
Peach.Core.Cracker.DataCracker getSize: -----&gt; Number 'PngModel.Chunk.Chunk_1.Checksum'
Peach.Core.Cracker.DataCracker scan: Number 'PngModel.Chunk.Chunk_1.Checksum' -&gt; Pos: 32, Length: 32
Peach.Core.Cracker.DataCracker getSize: &lt;----- Size: 32
Peach.Core.Cracker.DataCracker Crack: Number 'PngModel.Chunk.Chunk_1.Checksum' Size: 32, Bytes: 32809/33546, Bits: 262472/268368
Peach.Core.Dom.DataElement Number 'PngModel.Chunk.Chunk_1.Checksum' value is: 4205918359</screen>
<calloutlist>
<callout arearefs="CO4-1">
<para>The <emphasis>Length</emphasis> value is somewhat large, but is still smaller than the total file size. The type of the next chunk is <literal>IDAT</literal>. This chunk contains the main image data, so the model looks good.</para>
</callout>
<callout arearefs="CO4-2">
<para>The <emphasis>Type</emphasis> field correctly cracks as <literal>IDAT</literal>.</para>
</callout>
<callout arearefs="CO4-3">
<para>The <emphasis>Data</emphasis> field correctly cracks correctly.</para>
</callout>
</calloutlist>
<simpara>Now examine the third chunk.</simpara>
<screen>Peach.Core.Dom.Array Crack: ======================
Peach.Core.Dom.Array Crack: Block 'PngModel.Chunk.Chunk' Trying #3
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker Block 'PngModel.Chunk.Chunk_2' Bytes: 32813/33546, Bits: 262504/268368
Peach.Core.Cracker.DataCracker getSize: -----&gt; Block 'PngModel.Chunk.Chunk_2'
Peach.Core.Cracker.DataCracker scan: Block 'PngModel.Chunk.Chunk_2'
Peach.Core.Cracker.DataCracker scan: Number 'PngModel.Chunk.Chunk_2.Length' -&gt; Pos: 32, Length: 32
Peach.Core.Cracker.DataCracker getSize: &lt;----- Deterministic: ???
Peach.Core.Cracker.DataCracker Crack: Block 'PngModel.Chunk.Chunk_2' Size: &lt;null&gt;, Bytes: 32813/33546, Bits: 262504/268368
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker Number 'PngModel.Chunk.Chunk_2.Length' Bytes: 32813/33546, Bits: 262504/268368
Peach.Core.Cracker.DataCracker getSize: -----&gt; Number 'PngModel.Chunk.Chunk_2.Length'
Peach.Core.Cracker.DataCracker scan: Number 'PngModel.Chunk.Chunk_2.Length' -&gt; Pos: 32, Length: 32
Peach.Core.Cracker.DataCracker getSize: &lt;----- Size: 32
Peach.Core.Cracker.DataCracker Crack: Number 'PngModel.Chunk.Chunk_2.Length' Size: 32, Bytes: 32813/33546, Bits: 262504/268368
Peach.Core.Dom.DataElement Number 'PngModel.Chunk.Chunk_2.Length' value is: 709 <co xml:id="CO5-1"/>
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker Block 'PngModel.Chunk.Chunk_2.DataToCrc' Bytes: 32817/33546, Bits: 262536/268368
Peach.Core.Cracker.DataCracker getSize: -----&gt; Block 'PngModel.Chunk.Chunk_2.DataToCrc'
Peach.Core.Cracker.DataCracker scan: Block 'PngModel.Chunk.Chunk_2.DataToCrc'
Peach.Core.Cracker.DataCracker scan: String 'PngModel.Chunk.Chunk_2.DataToCrc.Type' -&gt; Pos: 32, Length: 32
Peach.Core.Cracker.DataCracker getSize: &lt;----- Deterministic: ???
Peach.Core.Cracker.DataCracker Crack: Block 'PngModel.Chunk.Chunk_2.DataToCrc' Size: &lt;null&gt;, Bytes: 32817/33546, Bits: 262536/268368
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker String 'PngModel.Chunk.Chunk_2.DataToCrc.Type' Bytes: 32817/33546, Bits: 262536/268368
Peach.Core.Cracker.DataCracker getSize: -----&gt; String 'PngModel.Chunk.Chunk_2.DataToCrc.Type'
Peach.Core.Cracker.DataCracker scan: String 'PngModel.Chunk.Chunk_2.DataToCrc.Type' -&gt; Pos: 32, Length: 32
Peach.Core.Cracker.DataCracker getSize: &lt;----- Size: 32
Peach.Core.Cracker.DataCracker Crack: String 'PngModel.Chunk.Chunk_2.DataToCrc.Type' Size: 32, Bytes: 32817/33546, Bits: 262536/268368
Peach.Core.Dom.DataElement String 'PngModel.Chunk.Chunk_2.DataToCrc.Type' value is: IDAT <co xml:id="CO5-2"/>
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker Blob 'PngModel.Chunk.Chunk_2.DataToCrc.Data' Bytes: 32821/33546, Bits: 262568/268368
Peach.Core.Cracker.DataCracker getSize: -----&gt; Blob 'PngModel.Chunk.Chunk_2.DataToCrc.Data'
Peach.Core.Cracker.DataCracker scan: Blob 'PngModel.Chunk.Chunk_2.DataToCrc.Data' -&gt; Pos: 5672, Size relation: 5672
Peach.Core.Cracker.DataCracker getSize: &lt;----- Size: 5672
Peach.Core.Cracker.DataCracker Crack: Blob 'PngModel.Chunk.Chunk_2.DataToCrc.Data' Size: 5672, Bytes: 32821/33546, Bits: 262568/268368
Peach.Core.Dom.DataElement Blob 'PngModel.Chunk.Chunk_2.DataToCrc.Data' value is: ad 2a 41 22 6d a6 b7 29 a7 ac 60 37 cb 5e d3 b4 c7 97 93 bd b3 7c 53 0d ec 6b a0 12 08 99 d9 9d.. (Len: 709 bytes) <co xml:id="CO5-3"/>
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker Number 'PngModel.Chunk.Chunk_2.Checksum' Bytes: 33530/33546, Bits: 268240/268368
Peach.Core.Cracker.DataCracker getSize: -----&gt; Number 'PngModel.Chunk.Chunk_2.Checksum'
Peach.Core.Cracker.DataCracker scan: Number 'PngModel.Chunk.Chunk_2.Checksum' -&gt; Pos: 32, Length: 32
Peach.Core.Cracker.DataCracker getSize: &lt;----- Size: 32
Peach.Core.Cracker.DataCracker Crack: Number 'PngModel.Chunk.Chunk_2.Checksum' Size: 32, Bytes: 33530/33546, Bits: 268240/268368
Peach.Core.Dom.DataElement Number 'PngModel.Chunk.Chunk_2.Checksum' value is: 2357285555</screen>
<calloutlist>
<callout arearefs="CO5-1">
<para>The length again looks good.</para>
</callout>
<callout arearefs="CO5-2">
<para>The type is another <emphasis>IDAT</emphasis> field</para>
</callout>
<callout arearefs="CO5-3">
<para>The data also looks correct.</para>
</callout>
</calloutlist>
<simpara>Now for the final chunk. The type should be <literal>IEND</literal> according to the specification.</simpara>
<screen>Peach.Core.Dom.Array Crack: ======================
Peach.Core.Dom.Array Crack: Block 'PngModel.Chunk.Chunk' Trying #4
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker Block 'PngModel.Chunk.Chunk_3' Bytes: 33534/33546, Bits: 268272/268368
Peach.Core.Cracker.DataCracker getSize: -----&gt; Block 'PngModel.Chunk.Chunk_3'
Peach.Core.Cracker.DataCracker scan: Block 'PngModel.Chunk.Chunk_3'
Peach.Core.Cracker.DataCracker scan: Number 'PngModel.Chunk.Chunk_3.Length' -&gt; Pos: 32, Length: 32
Peach.Core.Cracker.DataCracker getSize: &lt;----- Deterministic: ???
Peach.Core.Cracker.DataCracker Crack: Block 'PngModel.Chunk.Chunk_3' Size: &lt;null&gt;, Bytes: 33534/33546, Bits: 268272/268368
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker Number 'PngModel.Chunk.Chunk_3.Length' Bytes: 33534/33546, Bits: 268272/268368
Peach.Core.Cracker.DataCracker getSize: -----&gt; Number 'PngModel.Chunk.Chunk_3.Length'
Peach.Core.Cracker.DataCracker scan: Number 'PngModel.Chunk.Chunk_3.Length' -&gt; Pos: 32, Length: 32
Peach.Core.Cracker.DataCracker getSize: &lt;----- Size: 32
Peach.Core.Cracker.DataCracker Crack: Number 'PngModel.Chunk.Chunk_3.Length' Size: 32, Bytes: 33534/33546, Bits: 268272/268368
Peach.Core.Dom.DataElement Number 'PngModel.Chunk.Chunk_3.Length' value is: 0 <co xml:id="CO6-1"/>
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker Block 'PngModel.Chunk.Chunk_3.DataToCrc' Bytes: 33538/33546, Bits: 268304/268368
Peach.Core.Cracker.DataCracker getSize: -----&gt; Block 'PngModel.Chunk.Chunk_3.DataToCrc'
Peach.Core.Cracker.DataCracker scan: Block 'PngModel.Chunk.Chunk_3.DataToCrc'
Peach.Core.Cracker.DataCracker scan: String 'PngModel.Chunk.Chunk_3.DataToCrc.Type' -&gt; Pos: 32, Length: 32
Peach.Core.Cracker.DataCracker getSize: &lt;----- Deterministic: ???
Peach.Core.Cracker.DataCracker Crack: Block 'PngModel.Chunk.Chunk_3.DataToCrc' Size: &lt;null&gt;, Bytes: 33538/33546, Bits: 268304/268368
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker String 'PngModel.Chunk.Chunk_3.DataToCrc.Type' Bytes: 33538/33546, Bits: 268304/268368
Peach.Core.Cracker.DataCracker getSize: -----&gt; String 'PngModel.Chunk.Chunk_3.DataToCrc.Type'
Peach.Core.Cracker.DataCracker scan: String 'PngModel.Chunk.Chunk_3.DataToCrc.Type' -&gt; Pos: 32, Length: 32
Peach.Core.Cracker.DataCracker getSize: &lt;----- Size: 32
Peach.Core.Cracker.DataCracker Crack: String 'PngModel.Chunk.Chunk_3.DataToCrc.Type' Size: 32, Bytes: 33538/33546, Bits: 268304/268368
Peach.Core.Dom.DataElement String 'PngModel.Chunk.Chunk_3.DataToCrc.Type' value is: IEND <co xml:id="CO6-2"/>
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker Blob 'PngModel.Chunk.Chunk_3.DataToCrc.Data' Bytes: 33542/33546, Bits: 268336/268368
Peach.Core.Cracker.DataCracker getSize: -----&gt; Blob 'PngModel.Chunk.Chunk_3.DataToCrc.Data'
Peach.Core.Cracker.DataCracker scan: Blob 'PngModel.Chunk.Chunk_3.DataToCrc.Data' -&gt; Pos: 0, Size relation: 0
Peach.Core.Cracker.DataCracker getSize: &lt;----- Size: 0
Peach.Core.Cracker.DataCracker Crack: Blob 'PngModel.Chunk.Chunk_3.DataToCrc.Data' Size: 0, Bytes: 33542/33546, Bits: 268336/268368
Peach.Core.Dom.DataElement Blob 'PngModel.Chunk.Chunk_3.DataToCrc.Data' value is:
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker Number 'PngModel.Chunk.Chunk_3.Checksum' Bytes: 33542/33546, Bits: 268336/268368
Peach.Core.Cracker.DataCracker getSize: -----&gt; Number 'PngModel.Chunk.Chunk_3.Checksum'
Peach.Core.Cracker.DataCracker scan: Number 'PngModel.Chunk.Chunk_3.Checksum' -&gt; Pos: 32, Length: 32
Peach.Core.Cracker.DataCracker getSize: &lt;----- Size: 32
Peach.Core.Cracker.DataCracker Crack: Number 'PngModel.Chunk.Chunk_3.Checksum' Size: 32, Bytes: 33542/33546, Bits: 268336/268368
Peach.Core.Dom.DataElement Number 'PngModel.Chunk.Chunk_3.Checksum' value is: 2923585666
Peach.Core.Dom.Array Crack: ======================
Peach.Core.Dom.Array Crack: Block 'PngModel.Chunk.Chunk' Trying #5
Peach.Core.Dom.Array Crack: Consumed all bytes. Bytes: 33546/33546, Bits: 268368/268368
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.FilePublisher start()
Peach.Core.Publishers.FilePublisher open()
Peach.Core.Publishers.FilePublisher output(33546 bytes) <co xml:id="CO6-3"/>
Peach.Core.Publishers.FilePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.FilePublisher stop()

[*] Test 'Default' finished.</screen>
<calloutlist>
<callout arearefs="CO6-1">
<para><emphasis>Length</emphasis> is zero. This is correct for the <literal>IEND</literal> chunk.</para>
</callout>
<callout arearefs="CO6-2">
<para><emphasis>Type</emphasis> is <literal>IEND</literal>.</para>
</callout>
<callout arearefs="CO6-3">
<para>Output length is the same size as the input file!</para>
</callout>
</calloutlist>
<simpara>The output looks good and the model output the correct number of bytes. Time to review things inside the Peach Validator.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/DevGuide/DataModeling/Cracking_Validator6.png"/>
</imageobject>
<textobject><phrase>Cracking Validator6</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Reviewing the cracked model, it looks like everything is good.</simpara>
<simpara><emphasis role="strong">Next Steps</emphasis></simpara>
<simpara>To complete this fuzzing definition, the following would need to be done:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Finish flushing out the data models. For each chunk type, create a custom <emphasis>Data</emphasis> model.</simpara>
</listitem>
<listitem>
<simpara>Configure logging. For simplicity, this pit does not have logging configured.</simpara>
</listitem>
<listitem>
<simpara>Configure monitoring. Once a target is selected, monitoring is needed to detect faulting conditions.</simpara>
</listitem>
<listitem>
<simpara>Sample sets. Peach needs a large, non-redundant set of PNG images to use. Once the set or collection exists, run <link linkend="Program_PeachMinset">minset</link> on the collection to pare it down to the optimal set of images to use for fuzzing.</simpara>
</listitem>
</orderedlist>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
</section>
</section>
<section xml:id="StateModeling">
<title>State Modeling</title>
<simpara>Once the data model is complete, modeling shifts to describe the flow of that data to the target system. In Peach Fuzzer Professional this is called <emphasis>state modeling</emphasis>. State models can range from very simple to very complex.</simpara>
<tip>
<simpara>Use the minimal amount of state model complexity needed for successful testing.</simpara>
</tip>
<simpara>State models consist of three elements:</simpara>
<variablelist>
<varlistentry>
<term><link linkend="StateModel">StateModel</link></term>
<listitem>
<simpara>Top level element that defines a complete state model. The <emphasis>StateModel</emphasis> element defines the entry state to start the execution.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="State">State</link></term>
<listitem>
<simpara>A child of <emphasis>StateModel</emphasis> that defines a specific state that occurs. The <emphasis>StateModel</emphasis> element defines the entry, or <emphasis>initial</emphasis> state. Execution of a state model begins with the initial state. If the initial state does not trigger other states into occurring using the <link linkend="Action_changeState">changeState action</link>, then the initial state also ends the execution.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action">Action</link></term>
<listitem>
<simpara>Action elements perform an action on a publisher (I/O adapter), agent/monitor, or data model. A State consists of one or more Action elements executed in order. Examples of actions include: sending output, receiving input, and changing to another state.<?asciidoc-br?></simpara>
<simpara>Scripting expressions can be used to indicate whether an action is performed by specifying the <emphasis>when</emphasis> attribute. Actions also support executing scripting expressions before an action begins and after an action completes.</simpara>
</listitem>
</varlistentry>
</variablelist>
<note>
<simpara>Many fuzzing tasks can be accomplished using a single <link linkend="State">State</link> with a series of <link linkend="Action">Actions</link>.</simpara>
</note>
<example>
<title>File State Model</title>
<simpara>This example shows a typical pattern for fuzzing files that are consumed by a target application. The state model produces a fuzzed output file that, in turn, loads into a target application running under a debugger monitor. The debugging monitor is used to trigger faults when the target program crashes.</simpara>
<simpara>This example is configured for Windows and requires an installed copy of Windows Debugger.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

	&lt;!-- TODO: Define a full data model. --&gt;
	&lt;DataModel name="DumbFuzzerModel"&gt;
		&lt;Blob /&gt;
	&lt;/DataModel&gt;

	&lt;!-- Define a simple state machine that will write the file
	     and then launch a program. --&gt;
	&lt;StateModel name="State" initialState="Initial"&gt;
		&lt;State name="Initial"&gt;

			&lt;!-- Write out contents of file --&gt;
			&lt;Action type="output"&gt;
				&lt;DataModel ref="DumbFuzzerModel" /&gt;

				&lt;!-- Provide a sample set using files from the samples_png folder.
				     this folder is located in your Peach folder. The
					 ##Peach.Pwd## provides the path to the peach folder. --&gt;
				&lt;Data fileName="##Peach.Pwd##\samples_png" /&gt;
			&lt;/Action&gt;

			&lt;!-- We must close the file before launching our
			     target process. --&gt;
			&lt;Action type="close" /&gt;

			&lt;!-- Launch the target. This call will send a message to our agent and
			     monitors. The WindowsDebugger monitor is configured to listen
				 for this message and launch our target when received. Notice that
				 the StartOnCall parameter for the monitor matches our method
				 attribute. The publisher attribute of Peach.Agent tells Peach
				 to send this call action out to all agents. --&gt;
			&lt;Action type="call" method="ScoobySnacks" publisher="Peach.Agent"/&gt;

		&lt;/State&gt;
	&lt;/StateModel&gt;

	&lt;!-- Setup a local agent that will monitor for faults --&gt;
	&lt;Agent name="LocalAgent"&gt;
		&lt;Monitor class="WindowsDebugger"&gt;

			&lt;!-- The command line to run.  Notice the filename provided matched up
				to what is provided below in the Publisher configuration --&gt;
			&lt;Param name="Executable" value="c:\windows\system32\mspaint.exe" /&gt;
			&lt;Param name="Arguments" value="fuzzed.png" /&gt;

			&lt;!-- If needed, uncomment this line and provide the path to windbg.exe --&gt;
			&lt;!-- By default peach will try and locate the program in the default locations --&gt;
			&lt;!--&lt;Param name="WinDbgPath" value="C:\Program Files (x86)\Debugging Tools for Windows (x86)" /&gt;--&gt;

			&lt;!-- This parameter will cause the debugger to wait for an action-call in
				the state model with a method="ScoobySnacks" before running
				program.
				--&gt;
			&lt;Param name="StartOnCall" value="ScoobySnacks" /&gt;

		&lt;/Monitor&gt;
	&lt;/Agent&gt;

	&lt;Test name="Default"&gt;

		&lt;Agent ref="LocalAgent" /&gt;
		&lt;StateModel ref="State"/&gt;

		&lt;!-- Configure a publisher to write our file --&gt;
		&lt;Publisher class="File"&gt;
			&lt;Param name="FileName" value="fuzzed.png" /&gt;
		&lt;/Publisher&gt;

	&lt;/Test&gt;

&lt;/Peach&gt;</programlisting>
<simpara>Run the following command line from the command-line interface. You should see mspaint.exe open and close over and over.</simpara>
<screen>&gt; peach example.xml</screen>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
<section xml:id="Providing_Sample_Data">
<title>Providing Sample Data</title>
<simpara>To fuzz effectively with Peach, create a set of sample data to use as a fuzzing mutation base. Peach provides two ways to load sample data into a fuzzing session:</simpara>
<itemizedlist>
<listitem>
<simpara>Specify initial values using the <link linkend="Data">Data</link> element</simpara>
</listitem>
<listitem>
<simpara>Specify initial values in data files</simpara>
</listitem>
</itemizedlist>
<section xml:id="_specifying_initial_values_using_the_data_element">
<title>Specifying Initial Values Using the Data Element</title>
<simpara>You can provide sample data by specifying the information for each element, one at a time. This can be useful when no sample exists with the wanted values or for testing formats with a small number of fields, such as some network protocols. In this case, the <link linkend="Data">Data</link> element is used along with the <emphasis>Field</emphasis> child-element. See the <link linkend="Data">Data</link> reference section for examples.</simpara>
</section>
<section xml:id="_specifying_initial_values_in_data_files">
<title>Specifying Initial Values in Data Files</title>
<simpara>The most common way to provide sample data is via disk files. For example, when fuzzing a graphics format such as PNG you might use a set of 1,000 sample images. This method can also be used for network fuzzing by providing samples of each output as files and referencing them.</simpara>
<simpara>For targets that consume files, perform code coverage metrics to choose the minimum set of sample files needed for the best code coverage.</simpara>
<simpara>Research has shown that using a minimum set of samples increases the likelihood of finding new faults while fuzzing. Peach provides a tool called <link linkend="Program_PeachMinset">minset</link> to help you create a minimum sample set.</simpara>
<important>
<simpara>The minset tool only works for targets that accept a filename from the command line.</simpara>
</important>
<simpara>The minset tool runs each sample file through the target application, collecting code coverage data for each file. It then selects a set of files that use or cover different parts of the code base. No duplicate samples are included in the resulting set of files.</simpara>
<tip>
<simpara>Assume that only the features and code exercised by the provided sample data will be thoroughly fuzzed. While Peach may discover additional paths to code by mutating certain values, those paths will not gain the same level of test coverage compared to fuzzing robust sample data. To achieve the best test coverage, provide data samples that fully exercise all code paths reasonably possible.</simpara>
</tip>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="_scripting_in_peach">
<title>Scripting in Peach</title>
<simpara>Peach provides a number of areas that expose scripting hooks. Python is the primary language used when scripting. Ruby is a second scripting language for Peach; however, support for Ruby is limited.</simpara>
<simpara>The following sections describe how scripting works in Peach and common script uses.</simpara>
<section xml:id="_python_scripting">
<title>Python Scripting</title>
<simpara>Peach supports Python scripts with  IronPython, the .NET framework implementation of Python 2.7. IronPython enables Peach to be flexible when creating fuzzers by allowing a small amount of code to be added to a pit when needed. The scripting engine within Peach has access to all DataModels, StateModels, and Tests.</simpara>
</section>
<section xml:id="_in_line_expressions_vs_importing_external_files">
<title>In-line Expressions vs. Importing External Files</title>
<simpara>Scripting in Peach can be done either by using in-line expressions or importing a Python file into the Peach name space.</simpara>
<simpara>Python functions can be imported into a pit and used for in-line expressions in the StateModel.</simpara>
<formalpara>
<title>Importing the Python module random</title>
<para>
<programlisting language="xml" linenumbering="unnumbered">  &lt;Import import="random"/&gt;

  &lt;StateModel name="TheState" initialState="initial"&gt;
    &lt;State name="initial"&gt;
      &lt;Action type="output" when="random.randrange(10) % 2 is 0"&gt;
        &lt;DataModel ref="DataModel" /&gt;
      &lt;/Action&gt;
    &lt;/State&gt;
  &lt;/StateModel&gt;</programlisting>
</para>
</formalpara>
<simpara>External Python files can be included into a pit so that predefined functions may be called.</simpara>
<formalpara>
<title>Importing a Local Python File</title>
<para>
<programlisting language="xml" linenumbering="unnumbered">  &lt;PythonPath path="Path/To/PyFile"/&gt;
  &lt;Import import="myPyFile" /&gt;

  &lt;StateModel name="TheState" initialState="initial"&gt;
    &lt;State name="initial"&gt;
      &lt;Action type="output" onStart="myPyFile.myAwesomeFunc(self)"&gt;
        &lt;DataModel ref="DataModel" /&gt;
      &lt;/Action&gt;
    &lt;/State&gt;
  &lt;/StateModel&gt;</programlisting>
</para>
</formalpara>
</section>
<section xml:id="_importing_external_files">
<title>Importing External Files</title>
<simpara>When importing Python files into the Peach name space, define both the <link linkend="PythonPath">PythonPath</link> and the <link linkend="Import">Import</link> elements. The <emphasis>PythonPath</emphasis> element defines where to find the Python files. The <emphasis>Import</emphasis> element specifies the file to import; the .py filename extension is not used in the declaration, as it is implied. Multiple files can be imported.</simpara>
<programlisting language="xml" linenumbering="unnumbered">  &lt;PythonPath path="Path/To/PyFile"/&gt;
  &lt;Import import="myPyFile" /&gt; <co xml:id="CO7-1"/>

  &lt;StateModel name="TheState" initialState="initial"&gt;
    &lt;State name="initial"&gt;
      &lt;Action type="output" onStart="myPyFile.myAwesomeFunc(self)"&gt; <co xml:id="CO7-2"/>
        &lt;DataModel ref="DataModel" /&gt;
      &lt;/Action&gt;
    &lt;/State&gt;
  &lt;/StateModel&gt;</programlisting>
<calloutlist>
<callout arearefs="CO7-1">
<para>Notice that the .py extension is missing from the import attribute even though the file is saved on disk as myPyFile.py</para>
</callout>
<callout arearefs="CO7-2">
<para>Calling a function from the myPyFile name space.</para>
</callout>
</calloutlist>
</section>
<section xml:id="_scriptable_areas_in_peach">
<title>Scriptable Areas in Peach</title>
<simpara>When fuzzing, Peach can run a script for a state or for an action. Further, the script can run at the beginning or at the end of the action or state. The <link linkend="State_onStart">onStart</link> and  <link linkend="State_onComplete">onComplete</link> attributes specify when the script runs. Include the attribute in the <emphasis>Action</emphasis> or <emphasis>State</emphasis> definition to associate the script with the <emphasis>action</emphasis> or <emphasis>state</emphasis>. The most common script usages alter data or set a program into an expected state before or after fuzzing.</simpara>
<simpara>You can control when an action executes with the evaluation expression <emphasis><link linkend="Action_when">when</link></emphasis>. The <emphasis>when</emphasis> attribute allows the action to execute when the given expression evaluates to true. This attribute is very useful when state changes depend on received data.</simpara>
<simpara>Other places  evaluation expressions occur in relations:</simpara>
<itemizedlist>
<listitem>
<simpara>expressionSet/expressionGet attributes</simpara>
</listitem>
<listitem>
<simpara><link linkend="constraint">constraint</link> attribute used for cracking</simpara>
</listitem>
<listitem>
<simpara><link linkend="Fixups_ExpressionFixup">ExpressionFixup</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="valueType">valueType</link> literals</simpara>
</listitem>
<listitem>
<simpara><link linkend="Godel">Godel</link> state modeling</simpara>
</listitem>
</itemizedlist>
<formalpara>
<title>Example using onStart and onComplete</title>
<para>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach ../peach.xsd"&gt;

  &lt;Import import="time"/&gt;

  &lt;DataModel name="Ex1"&gt;
    &lt;String name="TransformMe" value="supersupersecret" &gt;
      &lt;Transformer class="Aes128"&gt;
        &lt;Param name="Key" value="ae1234567890aeaffeda214354647586"/&gt;

        &lt;Param name="IV" value="aeaeaeaeaeaeaeaeaeaeaeaeaeaeaeae"/&gt;
      &lt;/Transformer&gt;
    &lt;/String&gt;
  &lt;/DataModel&gt;

  &lt;StateModel name="TheState" initialState="initial"&gt;
    &lt;State name="initial"&gt;
      &lt;!-- Encrypted Output --&gt;
      &lt;Action type="output" publisher="ConsolePub" onStart="time.sleep(2)"&gt; <co xml:id="CO8-1"/>
        &lt;DataModel ref="Ex1" /&gt;
      &lt;/Action&gt;

      &lt;!-- Write Encrypted Output to File --&gt;
      &lt;Action type="output" publisher="FilePubWrite" onComplete="time.sleep(2)"&gt; <co xml:id="CO8-2"/>
        &lt;DataModel ref="Ex1" /&gt;
      &lt;/Action&gt;

      &lt;Action type="close" publisher="FilePubWrite" /&gt;

      &lt;!-- Read and decrypt encrypted file and slurp output to console --&gt;
      &lt;Action type="input" publisher="FilePubRead" &gt;
        &lt;DataModel name="InputModel" ref="Ex1" /&gt;
      &lt;/Action&gt;

      &lt;Action type="slurp" valueXpath="//InputModel//TransformMe" setXpath="//OutputModel//StringValue"/&gt;

      &lt;Action type="output" publisher="ConsolePub"&gt;
        &lt;DataModel name="OutputModel"&gt;
          &lt;String name="StringValue" /&gt;
        &lt;/DataModel&gt;
      &lt;/Action&gt;
    &lt;/State&gt;
  &lt;/StateModel&gt;

  &lt;Test name="Default"&gt;
    &lt;StateModel ref="TheState"/&gt;

    &lt;Publisher class="ConsoleHex" name="ConsolePub"/&gt;

    &lt;Publisher class="File" name="FilePubWrite"&gt;
      &lt;Param name="FileName" value="encrypted.bin" /&gt;
    &lt;/Publisher&gt;

    &lt;Publisher class="File" name="FilePubRead"&gt;
      &lt;Param name="FileName" value="encrypted.bin" /&gt;
      &lt;Param name="Overwrite" value="false" /&gt;
    &lt;/Publisher&gt;  &lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO8-1">
<para>The expression is executed before the output action starts.</para>
</callout>
<callout arearefs="CO8-2">
<para>The expression is executed after the output action completes.</para>
</callout>
</calloutlist>
</section>
<section xml:id="_accessing_data">
<title>Accessing Data</title>
<simpara>Scripts running in Peach have access to all DataModels, StateModels and Tests. Data is accessed by traversing the DOM to locate the target element.</simpara>
<formalpara>
<title>SNMP Python File for Copying Incoming Data</title>
<para>
<programlisting language="python" linenumbering="unnumbered">#!/usr/bin/env python

import clr
clr.AddReferenceByPartialName('Peach.Core')

import Peach.Core <co xml:id="CO9-1"/>

# Sets the type and value for all empty Value fields (The value for the Object Name pair):
def set_variables(ctx): <co xml:id="CO9-2"/>
  vars_block = ctx.parent.actions[0].dataModel.find('VariableBindings') <co xml:id="CO9-3"/>
  output = ctx.dataModel.find('VariableBindings').parent
  if vars_block:
    #Targets the Value field(s) inside of the VariableBindings Value
    #x[0] == Type, x[1] == Size, x[2] == Value
    variable_bindings = vars_block[0][2][0][0][2]
    for x in variable_bindings:
      if x[2].DefaultValue.ToString() == "":
        x[0].DefaultValue = Peach.Core.Variant(0x06) <co xml:id="CO9-4"/>
        x[2].DefaultValue = Peach.Core.Variant((0x2b,0x06, 0x01, 0x04, 0x01, 0x8f, 0x51, 0x01, 0x01, 0x01, 0x82, 0x29, 0x5d, 0x01, 0x1b, 0x02, 0x02, 0x01))
    output['VariableBindings'] = vars_block.Clone()</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO9-1">
<para>The Peach name space is inserted into the file.</para>
</callout>
<callout arearefs="CO9-2">
<para>The ctx variable starts at the action from where it was called.</para>
</callout>
<callout arearefs="CO9-3">
<para>Traversing the DOM to find the target Block element.</para>
</callout>
<callout arearefs="CO9-4">
<para>Setting the DefaultValue of an element to the Peach Variant type.</para>
</callout>
</calloutlist>
<simpara>Data elements expose ways of accessing data associated with a data element.</simpara>
<variablelist>
<varlistentry>
<term>DefaultValue</term>
<listitem>
<simpara>This property provides access to the default, unmutated value. The default value is produced when this element is not being fuzzed.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>InternalValue</term>
<listitem>
<simpara>This property contains the value (fuzzed or default) to use when generating the final value. The field type is a variant of the internal typing, such as "int" or "string". The InternalValue property is used during scripting.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Value</term>
<listitem>
<simpara>This is the final, generated binary value. The Value property is the InternalValue packed into binary form. For a <emphasis>Number</emphasis> element of size 32, this is 4 contiguous bytes of data with correct endian-ness.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>The data and state models in Peach are tree-object graphs with a parent-child relationship. Parents are accessible using the -_parent property.</simpara>
</section>
<section xml:id="_returning_peach_types">
<title>Returning Peach Types</title>
<simpara>When a script overwrites the DefaultValue for any element, the value type must be a Peach Variant. A Peach Variant accepts integers, strings, and arrays.</simpara>
<programlisting language="python" linenumbering="unnumbered">import clr
clr.AddReferenceByPartialName('Peach.Core')
import Peach.Core
import code

def some_func(ctx):
  code.InteractiveConsole(locals=locals()).interact()
  elementOne = ctx.parent.actions[0].dataModel.Find('TargetOne')
  elementOne.DefaultValue = Peach.Core.Variant("Hello")

  element = ctx.parent.actions[0].dataModel.Find('TargetTwo')
  element.DefaultValue = Peach.Core.Variant(31337)</programlisting>
</section>
<section xml:id="_debugging">
<title>Debugging</title>
<simpara>You can debug Python code loaded from a file by using the InteractiveConsole from the code module. When the function executes and reaches the <literal>code.InteractiveConsole</literal> line, control over the function transfers to the user until the function ends. This approach allows each line in the function to be manually entered to ensure the expected behavior is happening.</simpara>
<programlisting language="python" linenumbering="unnumbered">import clr
clr.AddReferenceByPartialName('Peach.Core')
import Peach.Core
import code

def some_func(ctx):
  code.InteractiveConsole(locals=locals()).interact()
  datamodel = ctx.parent.actions[0].dataModel</programlisting>
</section>
<section xml:id="_api_reference">
<title>API Reference</title>
<simpara>The Peach distribution includes HTML API documentation. The elements in the XML map directly to the <literal>Peach.Core.Dom</literal> namespace. All public properties and methods are available to be called.</simpara>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="AgentsMonitors">
<title>Monitoring The Fuzzing Environment</title>
<simpara>Monitoring the fuzzing environment to detect faults, collect interesting information and control the environment is a crucial step in building or configuring a Peach pit. <link linkend="Agent">Agents</link> and <link linkend="Monitors">Monitors</link> provide the means to accomplish this.</simpara>
<itemizedlist>
<listitem>
<simpara>Agents are processes, local or remote, that host Monitors.</simpara>
</listitem>
<listitem>
<simpara>Monitors provide the logic to detect faults, collect information, or control the environment.</simpara>
</listitem>
</itemizedlist>
<simpara>To detect a fault, attach a debugger to a process to monitor it for exceptions. Or ping a device to verify it&#8217;s active.</simpara>
<simpara>The following sections describe how agents and monitors work. Detailed descriptions of each monitor are located in the <link linkend="Monitors">monitors</link> section of the documentations.</simpara>
<simpara>Remote channels are used for both remote agents and remote publishers. Remote channels have two uses:</simpara>
<itemizedlist>
<listitem>
<simpara>Install Peach on the remote device. Remote agents and remote publishers can run and exchange data with the controlling Peach process.</simpara>
</listitem>
<listitem>
<simpara>Install a small remote agent on the target machine that can receive and send communications to Peach. This implementation is necessary when it is not possible for Peach to run on the target machine. The remote agent implementation allows Peach to detect crashes more intelligently, thereby increasing the usefulness of fuzzing.</simpara>
</listitem>
</itemizedlist>
<simpara>Remote publishers run publishers on a remote machine. This is useful when running OS specific publishers (such as <link linkend="Publishers_Com">Com</link>, which only runs on Windows).</simpara>
<simpara>One reason to remote publish is when Peach runs on a local machine that is much faster than the remote target; by using remote publishers, all fuzzing can be done on the local machine and the results sent to the target to be output. Another reason to remote publish is if you fuzz a system that expects to communicate with two different machines.
By having one publisher speaking from the main machine and another from the remote machine you can trick the target application into thinking it was talking to two different systems</simpara>
<simpara>When fuzzing a virtual machine as a remote target, you may want to run a remote Agent on the target to monitor the internal state and a local Agent on the target to monitor the external state and to verify that the target is still alive. The local agent has the ability to start the virtual machine and the remote agent can run monitors from within the virtual machine once it has fully started.</simpara>
<simpara>Your current target may require OS-specific monitors.  If you define an agent for each platform, you can use platform-specific monitors and run the same pit on each of the platforms.</simpara>
<simpara>Agents and monitors run in the order listed in a pit. The order can be very important when multiple agents are used to get the fuzzing target into a working state. An example of this is when one agent starts a virtual machine and the second agent is a remote agent that controls things inside of the virtual machine. If the remote agent tries to run before the first agent starts the virtual machine, the Pit configuration will fail.</simpara>
<simpara>Shutting down monitors should occur in reverse order of their startup sequence. The shutdown sequence is important when you want to complete various actions before restarting a virtual machine.</simpara>
<simpara>Agents automatically try to reconnect when they become disconnected. When a device (like a virtual machine) restarts when a fault occurs, the remote agent will reconnect once the virtual machine is running again.</simpara>
<simpara>When the target opens fuzzing files from a command line, the target process must not open the file until fuzzing completes. To verify that fuzzing is complete, before we start the program, we use the monitor that starts the process and opens the file once we are done fuzzing; that is, fuzzed data file is on disk and has closed. Doing this causes the program to start and stop with every iteration, but it guarantees fuzzing is complete before the target process opens the fuzzed file.</simpara>
<simpara>Monitors are agent child processors; monitors get the target into a working state and monitor the target system. They can execute scripts, run processes, and monitor for crashes.</simpara>
<simpara>A variety of different monitors are supplied with Peach; select those you wish to use based on both the target platform and type of target. Is the target Windows software? Or Linux software? Or an embedded device? They each require different monitors. As an example, if I&#8217;m targeting an image-editing application, it&#8217;s pointless to use a network sniffer.</simpara>
<simpara>Detecting crashes is challenging and important. If you aren&#8217;t properly monitoring the environment, you will miss crashes that occur in unexpected places. In Peach&#8217;s automated fuzzing process, you will need a combination of monitors that set up the environment and monitors that watch for crashes. For remote targets, both local and remote monitors are necessary.</simpara>
<simpara>When fuzzing remote devices, the more items that Peach monitors and the more ways that Peach automates the environment, the better the results will be. Peach can do very basic remote device monitoring (such as pinging a device with the Ping monitor) to make sure the device is still alive, or running a command on the box (via SSH) to check device system status.</simpara>
<tip>
<simpara>The Ping and SSH monitors are basic monitors. When targeting a remote device, use additional monitors whenever possible.</simpara>
</tip>
<simpara>Carefully select the monitors you use to fuzz because when a crash is detected, the monitor in use determines what and how information is logged. Running the target process inside of one of the debugger monitors (such as WindowsDebugger) places crashes into buckets, making it easier to identify crashes that are caused by unique bugs. When debugger monitors are unavailable, all crashes are logged in buckets based on which monitor detected the crashes, making it more difficult to identify unique crashes.</simpara>
<section xml:id="_detecting_faults">
<title>Detecting Faults</title>
<simpara>Faults result from Peach detecting interesting behavior such as an application crashing or entering an unexpected state. The places to look for faults are many; from making sure a program has not crashed, to using optical character recognition (OCR) on a screen for a specific dialog window.</simpara>
<simpara>Peach has two ways to detect faults:</simpara>
<itemizedlist>
<listitem>
<simpara>From Peach monitors that check for irregular behavior such as a program crashing or excessive memory usage.</simpara>
</listitem>
<listitem>
<simpara>With <link linkend="Godel">Godel</link> state modeling, Peach can detect that an application enters an unexpected state such as a login successful state when the expected result is a failed login state.</simpara>
</listitem>
</itemizedlist>
<simpara>You can improve the chances that Peach will uncover faults by having Peach monitor more areas and use an appropriate number of robust tools. For example, many applications contain proper error handling that hide memory leaks from Peach when dumb or very simple fuzzing is done. These memory leaks are vulnerabilities within an application that might not be discovered unless additional tools (such as memory debuggers) are used to monitor multiple areas of application-accessed memory.</simpara>
<simpara>File fuzzing is performed by giving a valid sample file to Peach that produces a fuzzed version of the file. Depending on the target program, different sample files will touch different code paths. For complete code coverage and the best fuzzing results, use multiple sample files to touch all code paths of the target. Once you have a large number of sample files, the <link linkend="Program_PeachMinset">minset</link> tool (included with Peach) can traverse all sample files and trace the code paths they exercise so that Peach does not use redundant samples.</simpara>
<simpara>Sometimes visual cues (such as pop-ups or a blinking LED) are the only way to monitor a system for faults. Peach can be extended to monitor the test target using visual cues (such as  monitors that can use OCR on a screen and fault on a specific pop-up or when a specific LED on a board is lit) when no way exists within the system for Peach to detect the behaviors.</simpara>
<simpara>One example is fuzzing an iPhone application. In some cases, gathering the actual debug data from the iPhone application is very difficult; yet, when the application crashes, a pop-up window displays and notifies the user that a crash occurred. Using the <link xl:href="http://openvisionc.sourceforge.net/">Open Vision Control</link> library, you can detect crashes that Peach can reproduce using only visual screen monitoring.</simpara>
<section xml:id="_memory_debuggers">
<title>Memory debuggers</title>
<simpara>A memory debugger monitors the memory at the boundary of each memory allocation to detect when a program attempts to access memory past what was allocated and forces the application to crash instead of allowing it to handle the error. The use of a memory debugger while fuzzing will greatly increase Peach&#8217;s ability to detect and reproduce faults.</simpara>
<simpara>All the memory debuggers make detecting faults much easier. There are many commonly used memory debuggers [including eFence, DUMA, Page Heap (Windows), and Guard Malloc (OS X)] and they are used in a variety of ways. Page Heap on Windows can be enabled via the GFlags tool for any Windows executable. Guard Malloc on OS X is a debug option in Xcode for both Mac and iOS apps running in the simulator. DUMA (a forked version of eFence) is a cross-platform library that needs to be linked into the target&#8217;s code when it&#8217;s compiled.</simpara>
</section>
</section>
<section xml:id="_instrumenting_the_fuzzing_environment">
<title>Instrumenting the Fuzzing Environment</title>
<simpara>The first step in fuzzing is to send fuzzed data at a target. Peach doesn&#8217;t need to stop here. Peach can orchestrate the entire environment. Controlling the fuzzing environment with Peach can be as simple as starting and stopping an application or as complex as automating external devices such as phones. The key to fully automating the Peach fuzzing environment is two-fold:</simpara>
<itemizedlist>
<listitem>
<simpara>detect all irregular behavior</simpara>
</listitem>
<listitem>
<simpara>reset the environment to a known working state when needed</simpara>
</listitem>
</itemizedlist>
<simpara>When fully configured, Peach can start and stop the target process, monitor the target process and the environment of the target, and restart the process or the entire environment as needed.</simpara>
<simpara>Targeting a single process (such as MS Paint with fuzzed images) is an example of a very basic fuzzing environment. In order to control the target completely, Peach needs to open and close Paint and monitor Paint for crashes. You can supply this level of control to Peach by using two monitors: WindowsDebugger and PageHeap. WindowsDebugger opens and closes Paint with the fuzzed files and monitors the environment for crashes. PageHeap (a memory debugger) makes detecting crashes easier. With both monitors  configured, Peach can fuzz and monitor Paint indefinitely.</simpara>
<simpara>Fuzzing a target within a virtual machine (VM) is more complex. For virtual machine fuzzing, Peach is external to the VM and needs to start and stop the VM. Further, Peach needs to connect to two components within the VM: a remote agent and a publisher. Peach can monitor the environment by using a combination of local agents (to control the state of the VM) and remote agents (to monitor the environment inside of the VM).</simpara>
<simpara>Before using the remote agents, the VM needs to be in a started state; in the pit, call the local agent first so the VM can start fully before attempting to talk to the agents inside of the VM. Once the VM is started, the remote agents can start to control the system within the VM. If the fuzzing target within the VM the Paint application, use both the WindowsDebugger and PageHeap monitors with the remote agent.</simpara>
<simpara>The best way to use VMs with Peach (since rebooting a VM can be a slow process) is to get the VM into a good state and take a snapshot. Peach can use this snapshot to start the VM and to revert to the snapshot on fault, so the system is always in a known, good state. Having the system in a known, good state ensures reliable fault reproduction.</simpara>
<simpara>Another complex example is mobile phone fuzzing. For mobile phone fuzzing, Peach must perform several actions:</simpara>
<itemizedlist>
<listitem>
<simpara>send both touch input and data input to the phone</simpara>
</listitem>
<listitem>
<simpara>monitor the phone</simpara>
</listitem>
<listitem>
<simpara>simulate NFC bumps</simpara>
</listitem>
<listitem>
<simpara>spawn dynamic WIFI direct networks</simpara>
</listitem>
</itemizedlist>
<simpara>Not every mobile application uses all features of the phone, but to fuzz and control any application on a phone, Peach needs to talk to a mobile device on any and all media. In order to fuzz an application that uses NFC to transfer data between phones, Peach needs a configuration that supports the following:</simpara>
<itemizedlist>
<listitem>
<simpara>opening the application on two phones</simpara>
</listitem>
<listitem>
<simpara>touching buttons to get the phones ready to send and receive NFC, and</simpara>
</listitem>
<listitem>
<simpara>transmitting the NFC.</simpara>
</listitem>
</itemizedlist>
<simpara>When fuzzing some battery-powered devices, the target can enter an unresponsive state. To restart the device to a known, good state, the power button on the device has to be pressed. This is not good from a software automation standpoint since Peach needs to continue to fuzz without human interaction. Peach can generate a manual reset (pushing the power button) by issuing commands to a device with arms attached to a servo motor, that in turn, responds to the commands by extending an arm to press the button.</simpara>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="TestConfig">
<title>Test</title>
<simpara>The final step to create a Peach Pit is the <link linkend="Test">Test</link> element section. Here, the state model, agents, publishers, and logger all come together. A Test element represents a fuzzing test session that Peach can run. A Pit can contain one or more Test elements.</simpara>
<simpara>If a Pit contains multiple Test elements, you can specify the Test element to use for a specific fuzzing session at runtime.</simpara>
<simpara>See the references for: <link linkend="Test">Test</link>, <link linkend="Agent">Agent</link>, <link linkend="Test_Include">Include</link>, <link linkend="Test_Exclude">Exclude</link>,
<link linkend="Test_Mutators">Mutators</link>, and <link linkend="Publisher">Publisher</link>.</simpara>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
<section xml:id="PitDefines">
<title>Configuration Files</title>
<simpara>Most Peach pits contain configurable information. For example, a network Pit might store source and destination IP addresses for the network. Some configuration settings apply to a specific operating system.</simpara>
<simpara>Peach uses configuration files that allow different settings based on operating system. The information stored in a configuration file is typically used many times in a single definition and rarely stays the same. The presence of a configuration file eases the burden of supplying configurable settings by hand, an awkward and error-prone task.</simpara>
<simpara>You can create configuration files with default values and reuse them as needed. Peach configuration files use placeholders that are replaced at runtime either through a configuration file or via the command line. Peach automatically tries to load a configuration file along with the Pit file at the start of a fuzzing session. The naming convention of a Pit configuration file is <literal>PIT.xml.config</literal>, where <literal>PIT.xml</literal> is the name of your fuzzing definition.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;PitDefines&gt;
  &lt;All&gt;     <co xml:id="CO10-1"/>
    &lt;Define key="TargetIPv4" value="127.0.0.2"/&gt;
    &lt;Define key="TargetPort" value=22"/&gt;
  &lt;/All&gt;
  &lt;Linux&gt;   <co xml:id="CO10-2"/>
    &lt;Define key="Interface" value="eth0"/&gt;
  &lt;/Linux&gt;
  &lt;OSX&gt;     <co xml:id="CO10-3"/>
    &lt;Define key="Interface" value="em0"/&gt;
  &lt;/OSX&gt;
&lt;/PitDefines&gt;</programlisting>
<calloutlist>
<callout arearefs="CO10-1">
<para>This section is common to all operating systems.</para>
</callout>
<callout arearefs="CO10-2">
<para>This section is only for Linux.</para>
</callout>
<callout arearefs="CO10-3">
<para>This section is only for OS X.</para>
</callout>
</calloutlist>
<simpara>Using a defined key consists of encasing the key with the two-character sequence <literal>\\##</literal>. So, the key <emphasis>Interface</emphasis> becomes <literal>##Interface##</literal>, as shown in the following example.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;Monitor class="NetworkCapture"&gt;
  &lt;Param name="Device" value="##Interface##"/&gt;
&lt;/Monitor&gt;

&lt;Publisher class="Tcp" name="TcpHandler"&gt;
  &lt;Param name="Host" value="##TargetIPv4##"/&gt;
  &lt;Param name="Port" value="##TargetPort##"/&gt;
&lt;/Publisher&gt;</programlisting>
<simpara>Overriding one configuration file with a second (or another) configuration file requires using the <literal>--config</literal> command-line argument. The values in the file specified on the command line override the values listed in the default .config file.</simpara>
<screen>Peach.exe --config=CommonConfig.xml MyPit.xml</screen>
<simpara>You can specify individual configuration items (keys) on the command line by using the <literal>-D</literal> argument. Values provided via the command line override those provided by file.</simpara>
<screen>Peach.exe -DTargetIp=10.1.1.1 MyPit.xml</screen>
<section xml:id="_internally_defined_keys">
<title>Internally-defined Keys</title>
<simpara>Peach includes several predefined configuration keys that can be used in your Pits.</simpara>
<variablelist>
<varlistentry>
<term>Peach.Cwd</term>
<listitem>
<simpara>Peach current working directory. While this directory is usually the
directory containing Peach, the directory can be another location on your system.
The Peach Working Directory is set by launching Peach from the shell command line.
The value is the current working directory of the command shell when you start Peach.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>PitLibraryPath</term>
<listitem>
<simpara>The Pit library path is the full path of the folder in the
Peach installation directory that contains your licensed Peach Pits and Pit Packs.
The folder name is "pits", and contains subdirectories that hold your licensed
Pits, Pit configurations, and Peach-supplied sample files.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Peach.LogRoot</term>
<listitem>
<simpara>Full path of the directory where Peach stores logging information
from each fuzzing session. The default log root location is a subdirectory of
the Peach Installation Directory. The default name of this directory is "Logs".</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Peach.OS</term>
<listitem>
<simpara>Operating system that hosts the Peach Fuzzer platform. The value is
selected when downloading the Peach distribution image.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Peach.Pwd</term>
<listitem>
<simpara>Peach installation directory. This directory contains the Peach executable, and usually is named "peach".</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="DebuggingPitFiles">
<title>Debugging Pit Files</title>
<simpara>A PIT is NOT valid unless&#8230;&#8203;</simpara>
<itemizedlist>
<listitem>
<simpara>The first iteration is successful against the target.</simpara>
</listitem>
<listitem>
<simpara>The target is isolated from other input.</simpara>
</listitem>
<listitem>
<simpara>You can demonstrate the target has parsed your data by checking the following items:</simpara>
<itemizedlist>
<listitem>
<simpara>GUI opens the image data.</simpara>
</listitem>
<listitem>
<simpara>Network service logs your data.</simpara>
</listitem>
<listitem>
<simpara>You get the correct response packet from the target for the packet you sent.</simpara>
</listitem>
<listitem>
<simpara>The status lights blink appropriately.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Logging is enabled.</simpara>
</listitem>
<listitem>
<simpara>Monitoring is enabled.</simpara>
</listitem>
<listitem>
<simpara>Monitoring has been tested and fault on a demo/test fault.</simpara>
</listitem>
</itemizedlist>
<section xml:id="_what_to_do_if_the_pit_doesnt_parse">
<title>What to do if the Pit Doesn&#8217;t Parse</title>
<simpara>Peach provides a tool to perform validation and lint checking that can assist in tracking down basic syntax issues in your pit file.  See <link linkend="PitTool_Compile">PitTool</link> for additional information.</simpara>
<screen>pittool compile pit_file.xml</screen>
</section>
<section xml:id="_the_pit_doesnt_run_properly">
<title>The pit doesn&#8217;t run properly</title>
<simpara>During the testing and building phase, run the first iteration only. The <literal>-1</literal>
command-line argument runs the record iteration on the Pit. No fuzzing occurs.</simpara>
<screen>Peach.exe -1 pit_file.xml</screen>
<simpara>Reduce the pit to basic parts in order make sure the following items are specified correctly:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Test - The references have the right names.</simpara>
</listitem>
<listitem>
<simpara>Log Path - The folder path is valid.</simpara>
</listitem>
<listitem>
<simpara>Publisher - The functionality works:</simpara>
<itemizedlist>
<listitem>
<simpara>Communicating (network Publisher)</simpara>
</listitem>
<listitem>
<simpara>Sending or receiving data or</simpara>
</listitem>
<listitem>
<simpara>Outputting data</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Agent - The Monitor setup is correct and the Monitor has connectivity.</simpara>
</listitem>
<listitem>
<simpara>State Machine (StateModel) - The references to the data models are correct.</simpara>
</listitem>
<listitem>
<simpara>DataModel - Loads and displays the appropriate layout in the Peach Validator.</simpara>
</listitem>
</orderedlist>
<simpara>The Peach debug argument (<literal>--debug</literal> on the command line) provides verbose output that can help in debugging a Pit file.</simpara>
<screen>Peach.exe -1 --debug pit_file.xml</screen>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="_converting_pits_from_peach_v2_3">
<title>Converting Pits from Peach V2.3</title>
<simpara>Fuzzing definitions (pits) from Peach version 2.3 do not run "as-is" in the current
version. The changes needed to enable these pits to run in the current version include
a few global issues; advancements in methodology that translate to changes in the
description language; and product improvements, bug fixes, and enhancements.</simpara>
<simpara>Changing a pit to run in Peach version 3.x means that you can run the pit through
the command-line interface. However, Peach version 3.x introduced a web-based UI
that requires some additional work to have compatibility between a pit and the new
web UI.</simpara>
<simpara>The remainder of this section addresses the global changes, changes to individual
commands, and how to set up a pit to run with the Peach web UI.</simpara>
<section xml:id="_global_changes">
<title>Global Changes</title>
<simpara>The global changes consist of the following items that you need to change for all version 2.3 pits:</simpara>
<itemizedlist>
<listitem>
<simpara>The <literal>&lt;Peach&gt;</literal> element <literal>xmlsns</literal> and <literal>xsi:schemaLocation</literal> attribute values have changed.
The simplest fix is to replace the v2.3 <literal>&lt;Peach&gt;</literal> element with the following:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;!-- Peach v3.x  --&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;</programlisting>
</listitem>
<listitem>
<simpara>The <literal>&lt;Include&gt;</literal> element for <literal>defaults.xml</literal> is no longer used. Remove the include statement from the pit. An example of the statement to remove follows:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;!-- Peach v2.3  --&gt;
&lt;Include ns="default" src="file:defaults.xml"/&gt;</programlisting>
</listitem>
<listitem>
<simpara>The relationship <literal>from</literal> is no longer used. Remove all <literal>from</literal> relations. An example statement follows:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;!-- Peach v2.3  --&gt;
&lt;Relation type="size" from="Length" /&gt;</programlisting>
<simpara>Peach v2.3 provided <literal>from</literal> relations to boost performance by specifying both sides of a relationship using <literal>of</literal> and <literal>from</literal> parameters, as in the following example.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;!-- Peach v2.3  --&gt;
&lt;Number name="Length" size="32" endian="network" signed="false"&gt;
  &lt;Relation type="size" of="Data" /&gt;
&lt;/Number&gt;
&lt;Blob name="Data"&gt;
  &lt;Relation type="size" from="Length" /&gt;
&lt;/Blob&gt;</programlisting>
<simpara>Peach v3.x does not use the <literal>from</literal> parameter. The following example, written for Peach v3.x, provides identical functionality to the previous example.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;!-- Peach v3.x  --&gt;
&lt;Number name="Length" size="32" endian="network" signed="false"&gt;
  &lt;Relation type="size" of="Data" /&gt;
&lt;/Number&gt;
&lt;Blob name="Data" /&gt;</programlisting>
</listitem>
<listitem>
<simpara>The <literal>&lt;Logger&gt;</literal> element is now part of the <literal>&lt;Test&gt;</literal> element. Move the Logger element block into the Test element block. For more information, see the next item.</simpara>
</listitem>
<listitem>
<simpara>The functionality of the <literal>&lt;Run&gt;</literal> element is now part of the <literal>&lt;Test&gt;</literal> element. Upon moving the Logger element block into the Test element block, remove the Run element block from the pit. An example follows.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;!--  Peach v2.3 Test and Run elements sample    --&gt;
&lt;Test name="UdpResp"&gt;
  &lt;Agent ref="LocalAgent" /&gt;
  &lt;StateModel ref="UdpTransaction" /&gt;
  &lt;Publisher class="Udp"&gt;
    &lt;Param name="host" value="192.168.1.3" /&gt;
    &lt;Param name="port" value="53" /&gt;
  &lt;/Publisher&gt;
&lt;/Test&gt;

&lt;Run name="DefaultRun"&gt;
  &lt;Logger class="logger.Filesystem"&gt;
    &lt;Param name="Path" value="logs" /&gt;
  &lt;/Logger&gt;

  &lt;Test ref="UdpResp" /&gt;
&lt;/Run&gt;</programlisting>
<simpara>In Peach v3.x, the Test element block identifies the Agent, StateModel (and, by implication, the DataModel), Publisher, and Logger for a fuzzing session. A v3.x Test element block follows. The block is functionally identical the previous example.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;!--  Peach v3.x Test element sample    --&gt;
  &lt;Test name="Default"&gt;
    &lt;Agent ref="LocalAgent" /&gt;
    &lt;StateModel ref="UdpTransaction" /&gt;
    &lt;Publisher class="Udp"&gt;
      &lt;Param name="Host" value="192.168.1.3" /&gt;
      &lt;Param name="Port" value="53"/&gt;
    &lt;/Publisher&gt;
    &lt;Logger class="logger.Filesystem"&gt;
      &lt;Param name="Path" value="logs" /&gt;
    &lt;/Logger&gt;
&lt;/Test&gt;</programlisting>
<note>
<simpara>In the example, the name for the Test element is <literal>Default</literal>. This is the default name for the Test element. At runtime, Peach v3.x automatically looks for and runs the default Test, unless you specify a Test name on the command line.</simpara>
</note>
</listitem>
<listitem>
<simpara>The parameter names for Monitors and Publishers now use CamelCasing. In the previous example, the parameter names <literal>"Host"</literal> and <literal>"Port"</literal> for the publisher have changed slightly due to CamelCasing. You can use the Peach DOM reference or the developer&#8217;s guide to check parameters that fail validation. Use the following command to generate the DOM reference.</simpara>
<screen>peach --showenv</screen>
</listitem>
<listitem>
<simpara>You can place the data and state model definitions in separate xml files to improve re-use of these definitions. Once defined, you can the pull these definitions into different pits to perform different tests on the same data and state models. Specify the file containing the models using the include xml element.</simpara>
<simpara>The following example shows file fragments of a pit and definition files that contain the state and data models. Two include elements are used: 1) the main pit file includes the state model, and 2) the state model file includes the data model.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;!--  Peach v3.x Pit file   --&gt;
&lt;Peach xmlns=http://peachfuzzer.com/2012/Peach
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation=http://peachfuzzer.com/2012/Peach peach.xsd&gt;

  &lt;!--  Pull the StateModel into the pit.  --&gt;
  &lt;Include ns="FTP" src="file:FTP_State.xml" /&gt;

  &lt;Test name="Default"&gt;
    &lt;StateModel ref="FTP:Client" /&gt;
  &lt;/Test&gt;
&lt;/Peach&gt;

&lt;!--  Peach v3.x StateModel definitions (FTP_State.xml)  --&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

  &lt;!--  Pull the DataModel into the StateModel.  --&gt;
  &lt;Include ns="FTP" src="file:FTP_Data.xml" /&gt;

  &lt;StateModel name="Client" initialState="Initial"&gt;
    &lt;!-- FTP Client State Model --&gt;
  &lt;/StateModel&gt;
&lt;/Peach&gt;</programlisting>
</listitem>
</itemizedlist>
</section>
<section xml:id="_changes_to_individual_xml_elements">
<title>Changes to Individual xml Elements</title>
<simpara>The following Peach v2.3 xml elements require changes when used with Peach v3.x.</simpara>
<variablelist>
<varlistentry>
<term>&lt;Defaults&gt;</term>
<listitem>
<simpara>The Defaults element contains default values for parameter definitions. If an
individual element does not specify an optional parameter, Peach uses the value
specified in this element block. Values for optional attributes and parameters
are defined in this element.</simpara>
<simpara>Note that the <literal>Size</literal> attribute of the number element is a required attribute
that must be specified with each number instance.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>&lt;Import&gt;</term>
<listitem>
<simpara>This xml element has one attribute, import, that names the python file containing
code. Note the <literal>.py</literal> postfix is not used.</simpara>
<simpara>In v3.x, you must specify each python file you want to use. Wild card characters (*)
are not supported.</simpara>
<simpara>The from attribute is now a top-level element named &lt;PythonPath&gt; that specifies
the search path for all python modules. Note that a trailing <literal>\</literal> or <literal>/</literal> for the
path is not used. Use multiple &lt;PythonPath&gt; elements to tell Peach to search in
more than one place.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>&lt;DataModel&gt;</term>
<listitem>
<simpara>Remove all <literal>from</literal> relation statements from all data model elements.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>&lt;Flag&gt;</term>
<listitem>
<simpara>A multiple-bit Flag that uses the value parameter accepts a value expressed as a hexadecimal integer or a sequence of hexadecimal digits.</simpara>
<itemizedlist>
<listitem>
<simpara>A value expressed as a hexadecimal integer must fit into the bits allocated for the flag.</simpara>
</listitem>
<listitem>
<simpara>A value expressed as a sequence of hexadecimal digits must have sufficient length to span the number of bits in the flag.</simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term>&lt;Number&gt;</term>
<listitem>
<simpara><emphasis>value</emphasis> Attribute<?asciidoc-br?>
When specifying a value for a number, you can use an integer value, a hexadecimal integer value or a sequence of hexadecimal digits.
A value expressed as a sequence of hexadecimal digits (where valueType="hex") must match lengthwise with the allocated size of the number or a validation error occurs.
For example, initially setting a 64-bit number to one can be specified as seven digits of zeros and one digit of one:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;!-- Peach v3.x  --&gt;
&lt;Number size="64" valueType="hex" value="00 00 00 00 00 00 00 01" /&gt;</programlisting>
<simpara>For values expressed as hex integers prefix the value with <literal>0x</literal>.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;!-- Peach v3.x  --&gt;
&lt;Number size="64" value="0x01" /&gt;</programlisting>
<simpara>Size is a required attribute. You cannot use a default size specified in the Defaults element block for number elements.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>&lt;StateModel&gt;</term>
<listitem>
<simpara>No changes.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>&lt;Test&gt;</term>
<listitem>
<simpara>Now includes logger definitions, and performs the functionality of the v2.3 Run xml element.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>&lt;Run&gt;</term>
<listitem>
<simpara>This section is obsolete. Move the Logger into the test section.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>&lt;Publisher&gt;</term>
<listitem>
<variablelist>
<varlistentry>
<term>RawIpv4</term>
<listitem>
<itemizedlist>
<listitem>
<simpara><emphasis>Host</emphasis> and <emphasis>Protocol</emphasis> are required parameters.</simpara>
</listitem>
<listitem>
<simpara>The <emphasis>Protocol</emphasis> parameter is required and must have a valid value.</simpara>
<itemizedlist>
<listitem>
<simpara>"17" is the value for UDP.</simpara>
</listitem>
<listitem>
<simpara>"6" is the value for TCP.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>The <emphasis>Host</emphasis> parameter is required and must have a valid value, specified as a hostname or an IP address.</simpara>
</listitem>
<listitem>
<simpara>The <emphasis>Interface</emphasis> parameter now uses CamelCase with a capitalized first letter. This parameter is optional.</simpara>
<note>
<simpara>While the old publisher name is valid, the current name <literal>RawIpv4</literal> is the name used in the documentation and in log messages from the Peach engine.</simpara>
</note>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_how_to_make_a_pit_usable_by_the_peach_web_user_interface">
<title>How to Make a Pit Usable by the Peach Web User Interface</title>
<simpara>In order to use a Peach pit with the Web UI, each pit requires an associated
configuration file. The configuration file contains all parameters considered
configurable. Peach automatically loads the pit and the associated configuration
file. The values contained in the configuration file are exposed in the web UI.</simpara>
<simpara>Here are the steps to follow to make a Pit usable by the web UI. The information
contained in this example is sufficient as a complete configuration file.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara><emphasis role="strong">Create a configuration file and give it a name.</emphasis><?asciidoc-br?>
The name of the configuration file uses the following form:</simpara>
<screen>Name.xml.config</screen>
<simpara><literal>Name</literal> is same as the base name of the pit. <literal>xml</literal> and <literal>config</literal> are literals.
For example, the pit <literal>XXX.xml</literal> would have a configuration file named <literal>XXX.xml.config</literal>.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Add parameter definitions for the pit.</emphasis><?asciidoc-br?>
The target address and port are common values to define.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;Ipv4 key="TargetIPv4"
      value="127.0.0.1"
      name="Target IPv4 Address"
      description="The IPv4 address of the target machine or device." /&gt;</programlisting>
<note>
<simpara>On Windows, run <literal>ipconfig</literal> and look for the <emphasis>IPv4 Address</emphasis> field.<?asciidoc-br?>
On Linux, run <literal>ifconfig</literal> and look for the <emphasis>inet addr</emphasis> field.<?asciidoc-br?>
On OS X, run <literal>ifconfig</literal> and look for the <emphasis>inet</emphasis> field." /&gt;</simpara>
</note>
<programlisting language="xml" linenumbering="unnumbered">&lt;Range key="TargetPort"
       value="21"
       min="0"
       max="65535"
       name="Target Port"
       description="The target or destination port to send the network packet." /&gt;</programlisting>
<simpara>These values are ready for use in the pit as <literal>##TargetIPv4##</literal> and <literal>##TargetPort##</literal>. They can be used anywhere in the pit file. For example, the Publisher definition would be updated as follows:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;Publisher class="Udp"&gt;
  &lt;Param name="Host" value="##TargetIPv4##"/&gt;
  &lt;Param name="Port" value="##TargetPort##"/&gt;
&lt;/Publisher&gt;</programlisting>
</listitem>
<listitem>
<simpara><emphasis role="strong">Remove all agent element blocks from the PIT.</emphasis><?asciidoc-br?>
You can specify the agent and the monitoring options using the web UI.
</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Create a folder to hold the converted pits.</emphasis><?asciidoc-br?>
Create a sub-folder in the pits folder, such as peach/pits/converted.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Place the converted pits and associated configuration files in the newly created folder.</emphasis><?asciidoc-br?>
For example, after placing, the XXX pit and configuration file in the converted folder, the file locations would be as follows:</simpara>
<screen>peach/pits/converted/XXX.xml
peach/pits/converted/XXX.xml.config</screen>
</listitem>
<listitem>
<simpara><emphasis role="strong">Your pit is ready to configure, test, and then use with the Peach web UI.</emphasis></simpara>
<note>
<simpara>If the need arises, using the command-line interface, you can manually override a configuration setting using the <literal>-D</literal> switch. An example follows:
peach.exe XXX.xml -DTargetIPv4=10.0.0.1</simpara>
</note>
</listitem>
</orderedlist>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="RunningPeach">
<title>Running Peach</title>
<simpara>Peach Fuzzer Professional includes a number of executable files.
In most instances,
using the web interface will meet your needs.
Peach can also be used from the command line.
This includes using the Peach Web Interface,
which launches by running Peach from the command line without any parameters or switches.</simpara>
<simpara>The following list identifies the support applications included with Peach Fuzzer Professional.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="33.3333*"/>
<colspec colname="col_3" colwidth="33.3334*"/>
<thead>
<row>
<entry align="left" valign="top">Program</entry>
<entry align="left" valign="top">Executable</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><link linkend="Program_PeachWebIF">Peach Web Interface</link></simpara></entry>
<entry align="left" valign="top"><simpara><literal>Peach.exe</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The Peach Web Interface for Peach Fuzzer.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="Program_Peach">Peach Command Line</link></simpara></entry>
<entry align="left" valign="top"><simpara><literal>Peach.exe</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The Peach Command Line Interface for Peach Fuzzer.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="Program_PeachAgent">Peach Agent</link></simpara></entry>
<entry align="left" valign="top"><simpara><literal>PeachAgent.exe</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The Agent process for Peach Fuzzer.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="Program_PeachMinset">Minset</link></simpara></entry>
<entry align="left" valign="top"><simpara><literal>PeachMinset.exe</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Find the minimal set of sample files for use during fuzzing with the greatest code coverage for a given target.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="Program_PeachValidator">Validator</link></simpara></entry>
<entry align="left" valign="top"><simpara><literal>PeachValidator.exe</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Graphical tool for debugging pit files. Provides a graphical view of the data model graph before and after cracking a file.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="Program_PitTool">PitTool</link></simpara></entry>
<entry align="left" valign="top"><simpara><literal>PitTool.exe</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Utilities useful for Pit development.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="Program_PeachMultiNodeCli">Peach Multi-Node CLI Tool</link></simpara></entry>
<entry align="left" valign="top"><simpara><literal>sdk\tools\peachcli</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Control and coordinate multiple Peach instances.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><?asciidoc-pagebreak?></simpara>
<section xml:id="Program_PeachWebIF">
<title>The Peach Web Interface</title>
<simpara>The Peach Web Interface is an interactive interface to Peach Fuzzer Professional that simplifies monitoring of local and remote fuzzing jobs. Using Peach Web Interface, you can select, configure, and run fuzzing definitions (Pits). The Peach Web Interface is operating system agnostic. This means that you can use the same interface to run Peach, whether on Windows, Linux, or OS X. When a Pit is running, you can view the state of the fuzzing job and see faults that result.</simpara>
<simpara>The Peach Web Interface works with Pits from the included Pit Library. With a little configuration, the Pits will be ready to run. Once you settle on a Pit that you want to use, you can configure the Pit to detect faults, to collect data, or to automate the fuzzing session.</simpara>
<section xml:id="_peach_web_interface_installation_requirements">
<title>Peach Web Interface Installation Requirements</title>
<simpara>The Peach Web Interface uses modern web technologies, such as HTML 5. Yet,  Peach Web Interface requires two things to run:</simpara>
<itemizedlist>
<listitem>
<simpara>JavaScript, enabled in your web browser</simpara>
</listitem>
<listitem>
<simpara>A supported browser</simpara>
<itemizedlist>
<listitem>
<simpara>Internet Explorer: version 9 and newer</simpara>
</listitem>
<listitem>
<simpara>Safari: version 6 and newer</simpara>
</listitem>
<listitem>
<simpara>Firefox: version 4 and newer</simpara>
</listitem>
<listitem>
<simpara>Chrome: version 12 and newer</simpara>
</listitem>
<listitem>
<simpara>Opera: version 12 and newer</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
<note>
<simpara>Other browsers might work; however, they are not officially supported</simpara>
</note>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
<section xml:id="Start_Peach_Web">
<title>Starting the Peach Web Interface</title>
<simpara>You can start the Peach Web Interface using the GUI File Manager or from the command line. Both methods include the same functionality, use the method you prefer.</simpara>
<simpara>We recommend running Peach with heightened or administrative privileges. Some applications that provide monitoring functions, such as debuggers, need heightened access to run.</simpara>
<simpara>You can start Peach from a command line with two actions:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Open a command shell with administrative privileges.</simpara>
</listitem>
<listitem>
<simpara>On the command line, type Peach and press RETURN. The following illustration shows starting Peach in Windows.</simpara>
</listitem>
</orderedlist>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/WebUI/P1_Starting_Peach.png"/>
</imageobject>
<textobject><phrase>P1 Starting Peach</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>The Peach Web Interface is the default mode of operation for the command line. Launching the Peach Web Interface performs the following tasks:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Starts Peach Fuzzer Professional</simpara>
</listitem>
<listitem>
<simpara>Loads your default web browser with the Peach Web Interface URL</simpara>
<simpara>On the first launch of Peach, a licensing page displays.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/WebUI/P2_EULA_Details.png"/>
</imageobject>
<textobject><phrase>P2 EULA Details</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>When you have read and understood the End User License Agreement, click <emphasis>Accept</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Displays the Peach Home Page</simpara>
</listitem>
</orderedlist>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/WebUI/H1_Home.png"/>
</imageobject>
<textobject><phrase>H1 Home</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>From Home, you can use click entries and buttons on the left side of the page to work with your licensed Pits, view reports and details of previous fuzzing sessions, and to interact with the Peach forums.</simpara>
<section xml:id="_parts_of_the_user_interface">
<title>Parts of the User Interface</title>
<simpara>The Web User Interface includes many useful components, the most prominent are called out in the following illustration:</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/WebUI/H1_Annotated.png"/>
</imageobject>
<textobject><phrase>H1 Annotated</phrase></textobject>
</mediaobject>
</informalfigure>
<section xml:id="_1_page_title">
<title>1. Page Title</title>
<simpara>The Page title identifies the page you are on and establishes the context of your current task.</simpara>
</section>
<section xml:id="_2_menu_entries">
<title>2. Menu Entries</title>
<simpara>Menu entries are located along the left edge of the browser window. These buttons identify the functionality immediately at your disposal. Whether you want to explore your Pit Library, investigate a completed fuzzing job, or get some assistance from Help or the Forums, the menu is there for you.</simpara>
<simpara>The entries in the menu change according to the work context. For example, when you start working with a Pit, the menu entries change to accommodate editing a Pit definition. Click an entry in the menu to start working on that item. There is also an option to collapse the menu.</simpara>
</section>
<section xml:id="_3_menu_icons">
<title>3. Menu Icons</title>
<simpara>Located above the menu entries, the menu icons are always present and do not change. The icons are always:</simpara>
<itemizedlist>
<listitem>
<simpara>Home Page</simpara>
</listitem>
<listitem>
<simpara>Your Pit Library</simpara>
</listitem>
<listitem>
<simpara>Your Fuzzing Job Historical Results</simpara>
</listitem>
<listitem>
<simpara>Peach User&#8217;s Guide (HTML Help)</simpara>
</listitem>
</itemizedlist>
<simpara>Click a menu icon to move there.</simpara>
</section>
<section xml:id="_4_breadcrumb_menu">
<title>4. Breadcrumb menu</title>
<simpara>The breadcrumb is located above the Page Title and identifies your position within the Peach Web UI.
Portions of the breadcrumb are links and marked appropriately by color.</simpara>
</section>
</section>
<section xml:id="_a_quick_tour_of_the_peach_web_interface">
<title>A Quick Tour of the Peach Web Interface</title>
<simpara>This section provides a brief glimpse of the main areas of Peach that are accessible from the menu and buttons on the left edge of the page. The tour is quick: about a slide per menu item.</simpara>
<section xml:id="_library">
<title>Library</title>
<simpara>The <emphasis>Library</emphasis> menu is where you select and configure Pits (fuzzing definitions), and run fuzzing jobs. The page lists the licensed Peach Pits first, then follows with the defined configurations that you create.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/WebUI/H2_Library.png"/>
</imageobject>
<textobject><phrase>H2 Library</phrase></textobject>
</mediaobject>
</informalfigure>
</section>
<section xml:id="_jobs">
<title>Jobs</title>
<simpara>The <emphasis>Jobs</emphasis> menu provides access to your fuzzing job results. Click on an entry to see the report status, summary, metrics, and drill down detail of individual findings.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/WebUI/H3_Jobs.png"/>
</imageobject>
<textobject><phrase>H3 Jobs</phrase></textobject>
</mediaobject>
</informalfigure>
</section>
<section xml:id="_help">
<title>Help</title>
<simpara>The <emphasis>Help</emphasis> Menu provides access to the online Peach User Guide. This instructional piece provides workflows for installing Peach, recipes for setting up and running various configurations, and descriptions of the Peach monitors for detecting faults (issues), collecting data, and automating the test environment.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/WebUI/H4_HTMLHelp.png"/>
</imageobject>
<textobject><phrase>H4 HTMLHelp</phrase></textobject>
</mediaobject>
</informalfigure>
<note>
<simpara>Additionally, the <emphasis>User Guide</emphasis> is available in PDF format.</simpara>
</note>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/WebUI/H5_PdfHelp.png"/>
</imageobject>
<textobject><phrase>H5 PdfHelp</phrase></textobject>
</mediaobject>
</informalfigure>
</section>
<section xml:id="_forums">
<title>Forums</title>
<simpara>Peach has user forums that serve as a knowledge base of user questions, and as an active platform to raise questions of current need or interest. Feel free to explore the forums. Note that the professional forum provides a service venue to licensed users of Peach Professional and Peach Enterprise solutions.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/WebUI/H6_PeachForums.png"/>
</imageobject>
<textobject><phrase>H6 PeachForums</phrase></textobject>
</mediaobject>
</informalfigure>
</section>
</section>
</section>
<section xml:id="Program_PeachWebAdvanceConfig">
<title>Configuration Menu</title>
<simpara>You can configure a Pit by using the Configuration menu.
This menu consists of four parts: variables, monitoring, tuning, and test.
Only the Variable and Monitoring parts need to be completed to pass a test of the configuration.</simpara>
<simpara>To begin from the Home Page,</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Click the Library menu entry.</simpara>
</listitem>
<listitem>
<simpara>From the Pit Library, select a Pit or an existing configuration.</simpara>
<itemizedlist>
<listitem>
<simpara>Selecting a configuration means that you are revising the settings of an existing configuration. Peach displays the start screen for the configuration.</simpara>
</listitem>
<listitem>
<simpara>Selecting a Pit means that you are creating a new configuration. You will need to
name the configuration, optionally provide a description, and click "Submit" to reach the start screen for the configuration.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/WebUI/NP2_Config_Start.png"/>
</imageobject>
<textobject><phrase>NP2 Config Start</phrase></textobject>
</mediaobject>
</informalfigure>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Click the "Configure Variables" button to define or edit the variables and their values.</simpara>
</listitem>
</orderedlist>
<note>
<simpara><emphasis role="strong">Switching Pit Configurations</emphasis></simpara>
<simpara>The active Peach Pit configuration can be changed in the Peach Web Interface by clicking on the Home menu icon above the menu along the left side of the screen. Then, click on the Library menu item to choose a Pit or Pit configuration in your library.</simpara>
</note>
<section xml:id="_variables">
<title>Variables</title>
<simpara>The variables data entry screen lists the information needed by the selected pit, as in the following illustration. Some information is pit-specific, such as file names used to fuzz file formats and port addresses used to fuzz network protocols. Other information applies to the Peach environment; two examples are the Peach Installation Directory and the Pit Library Path.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/WebUI/AC01_Variables_Init.png"/>
</imageobject>
<textobject><phrase>AC01 Variables Init</phrase></textobject>
</mediaobject>
</informalfigure>
</section>
<section xml:id="_pit_specific_variables">
<title>Pit-specific Variables</title>
<simpara>In the illustration, three variables are specific to the <literal>BMP</literal> Pit. Because the variables have default values, you can use the supplied values during the fuzzing job.</simpara>
<itemizedlist>
<listitem>
<simpara>If a variable lacks a default value and is not marked optional, you need to supply a value for the variable before you can fuzz the target.</simpara>
</listitem>
<listitem>
<simpara>If a variable is labeled optional or has a default value, you need not supply a value to enable the configuration to run.</simpara>
</listitem>
</itemizedlist>
<simpara>When entering a data value, type the value into the appropriate text box of the form.
If you&#8217;d like to use the value of another variable, type <literal>##</literal>, the name of the
variable that contains the value you want to use, and <literal>##</literal> to end the variable name.</simpara>
<simpara>The default value of the <literal>Sample Path</literal> variable in the previous illustration uses another variable (<literal>PitLibraryPath</literal>) as part of its value.</simpara>
</section>
<section xml:id="_system_defined_variables">
<title>System-defined Variables</title>
<simpara>The Peach environment variables includes the following entries:</simpara>
<variablelist>
<varlistentry>
<term>Peach OS</term>
<listitem>
<simpara>The Peach OS identifies the operating system that the Peach Fuzzer is using. The value is selected when downloading the Peach distribution image.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Peach Installation Directory</term>
<listitem>
<simpara>The Peach Installation Directory is the directory that contains the peach executable file. This directory was created when Peach was installed on the computer system.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Peach Working Directory</term>
<listitem>
<simpara>The Peach working directory is the current working directory for fuzzing. While this directory is usually the directory containing Peach, the directory can be another location on your system. The Peach Working Directory is set by launching Peach from the shell command line. The value is the current working directory of the command shell when you start Peach.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Root Log Directory</term>
<listitem>
<simpara>The default name of this directory is Logs. The default location is a subdirectory of the Peach Installation Directory. You can specify another location for it, such as a subdirectory of the Peach Working Directory.<?asciidoc-br?></simpara>
<tip>
<simpara>Each pit has its own logs that appear as subdirectories of the logger Path.</simpara>
</tip>
</listitem>
</varlistentry>
<varlistentry>
<term>Pit Library Path</term>
<listitem>
<simpara>The Pit library path is the full path of the folder in the Peach installation directory that contains your licensed Peach Pits and Pit Packs. The folder name is "pits", and contains subdirectories that hold your licensed Pits, Pit configurations, and Peach-supplied sample files.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>For descriptions on the pit-specific variables, see the documentation for the individual pit.</simpara>
<section xml:id="_custom_variables">
<title>Custom Variables</title>
<simpara>You can create your own set variables for Peach. Perhaps you want to identify
where the image repository is located. Or, perhaps you want to identify the
MAC addresses, interface names, and IP addresses for the network interfaces on
your system.</simpara>
<simpara>Whatever the resource you&#8217;d like to specify, once you&#8217;ve created a variable and
given it a value, you can use the variable wherever appropriate when supplying
values for Pit variables and monitor variables.</simpara>
<simpara>Additionally, once defined, the custom variable is added to the dropdown variable list. The list of variables displays during data entry when a <literal>#</literal> is typed as the sole character in a data field, as shown in the following illustration.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/WebUI/AC02_Variable_DropList.png"/>
</imageobject>
<textobject><phrase>AC02 Variable DropList</phrase></textobject>
</mediaobject>
</informalfigure>
<section xml:id="_creating_a_custom_variable">
<title>Creating a custom variable</title>
<simpara>Here are the steps to add a custom variable to Peach:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Begin on the Variables page.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/WebUI/AC03_Vars_AddVar.png"/>
</imageobject>
<textobject><phrase>AC03 Vars AddVar</phrase></textobject>
</mediaobject>
</informalfigure>
</listitem>
<listitem>
<simpara>Click the "Add Variable" button immediately above and to the right of list of variables.</simpara>
<simpara>The "Add Variable" pop-up dialog displays.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/WebUI/AC04_AddVar_Popup.png"/>
</imageobject>
<textobject><phrase>AC04 AddVar Popup</phrase></textobject>
</mediaobject>
</informalfigure>
</listitem>
<listitem>
<simpara>Fill in values for the name, key, and value fields. The following illustration shows a variable locating a JPEG repository.</simpara>
<itemizedlist>
<listitem>
<simpara>The <emphasis role="strong">Name</emphasis> parameter is the name of the custom variable, and allows spaces and
punctuation. This is the name to search on if you want to edit the value of the variable.</simpara>
</listitem>
<listitem>
<simpara>The <emphasis role="strong">Key</emphasis> parameter is the value, such as <literal>JPEGs</literal>, that you plug into values in the Peach Web UI. When Peach processes the pit, the fuzzer replaces the key parameter with the value of the <emphasis role="strong">Value</emphasis> parameter.</simpara>
</listitem>
<listitem>
<simpara>The <emphasis role="strong">Value</emphasis> parameter stores the value that Peach uses when processing the pit.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/WebUI/AC05_AddVar_FilledIn.png"/>
</imageobject>
<textobject><phrase>AC05 AddVar FilledIn</phrase></textobject>
</mediaobject>
</informalfigure>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Click OK.</simpara>
</listitem>
<listitem>
<simpara>Click save.<?asciidoc-br?>
The new value is now part of the list, and has been saved for future use.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/WebUI/AC06_Vars_Page_Saved.png"/>
</imageobject>
<textobject><phrase>AC06 Vars Page Saved</phrase></textobject>
</mediaobject>
</informalfigure>
</listitem>
</orderedlist>
</section>
<section xml:id="_using_a_custom_variable">
<title>Using a custom variable</title>
<simpara>Using a custom variable consists of typing <literal>##</literal>, the variable name, and <literal>##</literal> in the value of another variable. In the following illustration, the "Sample Path" variable refers to the "JPEG Sample Pictures". When parsing the configuration information, Peach inserts the value <literal>C:\Samples\JPEG</literal> for the value of the "Sample Path".</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/WebUI/AC07_Vars_Page_Using.png"/>
</imageobject>
<textobject><phrase>AC07 Vars Page Using</phrase></textobject>
</mediaobject>
</informalfigure>
</section>
</section>
</section>
<section xml:id="_monitoring">
<title>Monitoring</title>
<simpara>The Monitoring data entry screen defines one or more Agents and one or more Monitors for the Pit.</simpara>
<simpara>Agents are host processes for monitors and publishers. Local agents can reside on the same machine as Peach, and can control the test environment through monitors and publishers. Remote agents reside on the test target, and can provide remote monitors and publishers.</simpara>
<simpara>Monitors are components that perform one or more of the following functions: detect faults (issues), collect data associated with faults, and help manage the fuzzing job to reduce the level of human interaction throughout the job.</simpara>
<section xml:id="_from_the_home_page">
<title>From the Home Page</title>
<simpara>To begin configuring from the Home Page:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Click the Library menu entry.</simpara>
</listitem>
<listitem>
<simpara>From the Pit Library, select a Pit or an existing configuration.</simpara>
<itemizedlist>
<listitem>
<simpara>Selecting a configuration means that you are revising the settings of an existing configuration. Peach displays the start screen for the configuration.</simpara>
</listitem>
<listitem>
<simpara>Selecting a Pit means that you are creating a new configuration. You will need to name the configuration, optionally provide a description, and click "Submit" to reach the start screen for the configuration.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/WebUI/NP2_Config_Start.png"/>
</imageobject>
<textobject><phrase>NP2 Config Start</phrase></textobject>
</mediaobject>
</informalfigure>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Click the "Configure Monitoring" button to define or edit agents, monitors, and the data values associated with them. The Monitoring data entry screen displays and is initially empty.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/WebUI/AC08_Monitors_Page_Empty.png"/>
</imageobject>
<textobject><phrase>AC08 Monitors Page Empty</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>The workflow for this data entry screen has you declare an Agent. Then, you can branch out and do the following in any order:</simpara>
<itemizedlist>
<listitem>
<simpara>Declare one or more monitors for the agent</simpara>
</listitem>
<listitem>
<simpara>Fill in details for a monitor</simpara>
</listitem>
<listitem>
<simpara>Switch focus from one monitor to another</simpara>
</listitem>
<listitem>
<simpara>Declare additional agents, as needed</simpara>
</listitem>
<listitem>
<simpara>Switch focus from one agent to another</simpara>
</listitem>
</itemizedlist>
</listitem>
</orderedlist>
<simpara>In this instance, we&#8217;re going to complete the agent, then add a monitor and fill in the monitor settings.</simpara>
</section>
<section xml:id="_specifying_an_agent">
<title>Specifying an Agent</title>
<simpara>Here are the steps to add an agent to a configuration:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Click the "Add Agent" button. Peach adds a new agent to the Monitors page, as in the following illustration.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/WebUI/AC09_Mon_Pg_NewAgent.png"/>
</imageobject>
<textobject><phrase>AC09 Mon Pg NewAgent</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>An agent has a name and location. The location can be local or remote.</simpara>
<itemizedlist>
<listitem>
<simpara>Local agents run in the same process space as the Peach fuzzing engine.</simpara>
</listitem>
<listitem>
<simpara>Remote agents are separate processes that can reside on the same hardware as the test target. Remote agents act as intermediaries between Peach and test targets, sending test cases to the test target and replying with test case results and data back to Peach.</simpara>
<simpara>If you use a remote agent, you need to supply location information that conforms to a URL with the following parts: <literal>channel://host:port</literal></simpara>
<variablelist>
<varlistentry>
<term>channel</term>
<listitem>
<simpara>Specify one of the following for the channel type: <emphasis>local</emphasis>, <emphasis>tcp</emphasis>, or <emphasis>http</emphasis>. Typical remote agent configurations should use the <emphasis>tcp</emphasis> channel.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>host</term>
<listitem>
<simpara>Specify the hostname of the agent to be used. This value is not required for the <emphasis>local</emphasis> channel.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>port</term>
<listitem>
<simpara>Specify the port number of the agent to be used. This value is not required for the <emphasis>local</emphasis> channel.</simpara>
</listitem>
</varlistentry>
</variablelist>
</listitem>
<listitem>
<simpara>Example agent using the <literal>tcp</literal> channel: <literal>tcp://192.168.127.128:9001</literal></simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Give the agent a name, such as <literal>LocalAgent</literal> and click "Save".</simpara>
<simpara>Peach saves the Agent information, provides a visual cue with a "Saved successfully." message in a banner near the top of the page.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="_adding_a_monitor">
<title>Adding a Monitor</title>
<orderedlist numeration="arabic">
<listitem>
<simpara>click the "Add a monitor&#8230;&#8203;" button.<?asciidoc-br?>
Peach displays a list of monitors that you can use in your configuration. The monitors are categorized by usage. Fault detection monitors appear first, then data collection, automation, android, and lastly, other monitors.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/WebUI/AC10_Mon_Pg_Monitor_DropList.png"/>
</imageobject>
<textobject><phrase>AC10 Mon Pg Monitor DropList</phrase></textobject>
</mediaobject>
</informalfigure>
</listitem>
<listitem>
<simpara>Select the <literal>WindowsDebugger</literal> entry, located under the <literal>Fault Detection</literal> section, and click "OK".</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/WebUI/AC11_Mon_Pg_Added_WinDbg.png"/>
</imageobject>
<textobject><phrase>AC11 Mon Pg Added WinDbg</phrase></textobject>
</mediaobject>
</informalfigure>
</listitem>
<listitem>
<simpara>Fill in the details of monitor.<?asciidoc-br?>
Configuration information for each monitor is available in the <link linkend="Monitors">Monitors</link> reference section. A list of monitors appears at the start of the section that links to the individual entries.</simpara>
<simpara>The monitor parameters divide into three groups: "Core", "When To Trigger", and "Advanced".</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/WebUI/AC12_Mon_Windbg_Detail.png"/>
</imageobject>
<textobject><phrase>AC12 Mon Windbg Detail</phrase></textobject>
</mediaobject>
</informalfigure>
<itemizedlist>
<listitem>
<simpara>The "Core" parameters consist of parameters that you should check when creating or editing a configuration. This monitor provides a choice of what to monitor: an executable file, a running process, or a service.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/WebUI/AC12A_Mon_WinDbg_Core.png"/>
</imageobject>
<textobject><phrase>AC12A Mon WinDbg Core</phrase></textobject>
</mediaobject>
</informalfigure>
</listitem>
<listitem>
<simpara>The "When To Trigger" addresses timing-related issues, such as restarting the test target at the end of an iteration. This is common for file fuzzing, where Peach creates a fuzzed data file, then starts the target with the fuzzed file as input.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/WebUI/AC12B_Mon_WinDbg_Trigger.png"/>
</imageobject>
<textobject><phrase>AC12B Mon WinDbg Trigger</phrase></textobject>
</mediaobject>
</informalfigure>
</listitem>
<listitem>
<simpara>The "Advanced" parameters are items that seldom need to be specified; the default values of these parameters are usually sufficient as is. Yet, once in a while you might need to access one of these parameters. When fuzzing a network client, the "No Cpu Kill" parameter needs to be set to true to give the client an opportunity to close cleanly.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/WebUI/AC12C_Mon_WinDbg_Advanced.png"/>
</imageobject>
<textobject><phrase>AC12C Mon WinDbg Advanced</phrase></textobject>
</mediaobject>
</informalfigure>
</listitem>
</itemizedlist>
</listitem>
</orderedlist>
</section>
<section xml:id="_sample_agent_with_multiple_monitors">
<title>Sample Agent with Multiple Monitors</title>
<simpara>The following illustration is of an agent with multiple monitors. Note that you can show or hide the details for a monitor by clicking the chevron preceding the monitor name. In fact, this is true for agents, too.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/WebUI/AC13_LocAgnt_n_Mtrs.png"/>
</imageobject>
<textobject><phrase>AC13 LocAgnt n Mtrs</phrase></textobject>
</mediaobject>
</informalfigure>
</section>
<section xml:id="_sample_remote_agent">
<title>Sample Remote Agent</title>
<simpara>The following illustration is of a remote agent. The location of the agent is the IP address of the remote machine, and that the address is stored in a custom variable. The agent manages multiple monitors.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/WebUI/AC14_RemAgnt_n_Mtrs.png"/>
</imageobject>
<textobject><phrase>AC14 RemAgnt n Mtrs</phrase></textobject>
</mediaobject>
</informalfigure>
</section>
</section>
<section xml:id="WebUI_Config_Tuning">
<title>Tuning</title>
<simpara>Tuning allows control of how testing is performed on a field-by-field basis.</simpara>
<simpara>Fields are shown hierarchically below. A search feature is provided to quickly find fields of interest. Each field, or set of fields, can be excluded from testing or have its testing focus turned up or down. As a field&#8217;s focus is turned up (High or Highest), test cases will be generated more often for that field. If a field is turned down (Low, Lowest), fewer test cases will be generated for that field. Fields that are excluded will not have any test cases generated.</simpara>
<simpara>Excluding fields from testing should be used judiciously as it can lead to undiscovered faults.</simpara>
<note>
<simpara>Tuning is not required. In fact it&#8217;s recommended to use the defaults and let Peach decide how often to test fields.</simpara>
</note>
<section xml:id="_from_the_home_page_2">
<title>From the Home Page</title>
<simpara>To begin configuring from the Home Page:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Click the Library menu entry.</simpara>
</listitem>
<listitem>
<simpara>From the Pit Library, select a Pit or an existing configuration.</simpara>
<itemizedlist>
<listitem>
<simpara>Selecting a configuration means that you are revising the settings of an existing configuration. Peach displays the start screen for the configuration.</simpara>
</listitem>
<listitem>
<simpara>Selecting a Pit means that you are creating a new configuration. You will need to name the configuration, optionally provide a description, and click "Submit" to reach the start screen for the configuration.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/WebUI/NP2_Config_Start.png"/>
</imageobject>
<textobject><phrase>NP2 Config Start</phrase></textobject>
</mediaobject>
</informalfigure>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Click the "Configure" menu item on the left of the screen. It will expand to show several configuration options.</simpara>
</listitem>
<listitem>
<simpara>Click the "Tuning" sub-menu item to access the Tuning page.
The Monitoring data entry screen displays and is initially empty.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/WebUI/AC_Tuning.png"/>
</imageobject>
<textobject><phrase>AC Tuning</phrase></textobject>
</mediaobject>
</informalfigure>
</listitem>
</orderedlist>
</section>
<section xml:id="_tuning_fields">
<title>Tuning Fields</title>
<simpara>The Tuning page shows fields in a hierarchy. For file pits such as media formats or application formats, this will be the format of the file being generated.  For network pits, the hierarchy will show different packets or messages being transmitted, assuming the protocol has this concept.  When modifying a field that contains children, by default all of the children will also be changed.  This allows quickly tuning entire messages or sections of a message.</simpara>
<simpara>For each field there are several tuning options:</simpara>
<variablelist>
<varlistentry>
<term>Exclude</term>
<listitem>
<simpara>Don&#8217;t perform any testing of this field.</simpara>
<caution>
<simpara>Excluding fields from testing should be used judiciously, as it may lead to missed faults. It&#8217;s our recommendation that all fields get tested.
Instead of excluding fields, consider tuning them to lower or lowest.</simpara>
</caution>
</listitem>
</varlistentry>
<varlistentry>
<term>Lowest</term>
<listitem>
<simpara>Produce the least number of test cases for this field.
When selected, the field will still receive some testing, but much less than fields marked as normal.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Low</term>
<listitem>
<simpara>Produce fewer test cases for this field.
Fields tuned to low will still be tested, but fewer test cases will be generated compared to fields marked as normal.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Normal</term>
<listitem>
<simpara>No changes to how this field is tested.
Peach will decide how often to generate test cases for fields marked as normal.
This is the recommended setting for all fields.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>High</term>
<listitem>
<simpara>Produce more test cases for this field.
Fields tuned to high will receive more testing than those marked as normal.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Highest</term>
<listitem>
<simpara>Produce even more test cases for this field.
Fields tuned to highest will receive more testing than those marked as high.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>Once you have completed tuning the fields, click the Save button in the upper right of the screen.</simpara>
</section>
</section>
<section xml:id="Test_PitConfiguration">
<title>Test</title>
<simpara>In the Test section, Peach performs a test on the selected Pit configuration using settings provided for variables, agents, and monitors. Peach identifies the readiness of the Pit configuration for testing by tracking and reporting the progress of completing settings for the variables, agents, and monitors.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/WebUI/AC_Test.png"/>
</imageobject>
<textobject><phrase>AC Test</phrase></textobject>
</mediaobject>
</informalfigure>
<note>
<simpara>The Test section runs a single test case without any fuzzing.<?asciidoc-br?>
The test requires that the target device, service, or application be available for use.</simpara>
</note>
<tip>
<simpara>This screen issues a warning if the pit is not configured, but lets the user run the test.</simpara>
</tip>
<itemizedlist>
<listitem>
<simpara>Click the Begin Test button to run the test.<?asciidoc-br?>
When the test completes, Peach reports whether the Pit configuration passes the test. If the configuration passes the test, the following message displays:</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/WebUI/AC_Test_Pass.png"/>
</imageobject>
<textobject><phrase>AC Test Pass</phrase></textobject>
</mediaobject>
</informalfigure>
</listitem>
</itemizedlist>
<simpara>You can start a fuzzing job with your pit.</simpara>
</section>
</section>
<section xml:id="Start_Fuzzing">
<title>Fuzzing Session</title>
<simpara>With your Pit configured and tested, you&#8217;re ready to start fuzzing!</simpara>
<section xml:id="_from_the_home_page_3">
<title>From the Home Page</title>
<orderedlist numeration="arabic">
<listitem>
<simpara>From the Home screen, click the Library menu.</simpara>
</listitem>
<listitem>
<simpara>From your Pits Library screen, select a configuration.<?asciidoc-br?>
The configurations are listed in the section that follows the Pits.</simpara>
<simpara>Once selected, the configured Pit displays, as in the following illustration.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/WebUI/config_selected.png"/>
</imageobject>
<textobject><phrase>config selected</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>If needed, you can change configuration settings or set some other parameters at the button of the page (typically used in replaying a fuzzing session).</simpara>
</listitem>
<listitem>
<simpara>Click Start to begin the fuzzing session. The Peach Dashboard displays.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/WebUI/dashboard_oct2015.png"/>
</imageobject>
<textobject><phrase>dashboard oct2015</phrase></textobject>
</mediaobject>
</informalfigure>
</listitem>
</orderedlist>
<simpara>The dashboard allows you to monitor progress as your fuzzing job runs and from it, you can pause, stop, resume, and replay your fuzzing session. The Peach Dashboard provides the following information:</simpara>
<itemizedlist>
<listitem>
<simpara>The Configuration name, above the colored status bar</simpara>
</listitem>
<listitem>
<simpara>The time the job started</simpara>
</listitem>
<listitem>
<simpara>The duration that the job has been running</simpara>
</listitem>
<listitem>
<simpara>The number of fuzzing test cases per hour</simpara>
</listitem>
<listitem>
<simpara>The seed ID for random number generation, so you can replicate the test, if needed</simpara>
</listitem>
<listitem>
<simpara>Number of test cases completed</simpara>
</listitem>
<listitem>
<simpara>Total number of faults found in this run</simpara>
</listitem>
<listitem>
<simpara>A summary of the most recent faults.</simpara>
</listitem>
</itemizedlist>
<note>
<simpara><emphasis role="strong">NOTES</emphasis></simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>The seed ID influences the fuzzing that occurs during a fuzzing job. If you want to replicate a test, the seed value is required to reproduce the exact sequence of values from the random-number generator used in fuzzing.</simpara>
</listitem>
<listitem>
<simpara>The STOP button does NOT close Peach. The STOP button only allows you to stop the currently running job.</simpara>
</listitem>
<listitem>
<simpara>If you have stopped a job and wish to start a new job using a different pit, choose one of the Pits or Pit configurations in your Pit Library. You&#8217;ll need to re-visit the Home page, and then choose the appropriate entry from the library.</simpara>
</listitem>
<listitem>
<simpara>The fault summary lists the most recent faults. For information about the faults generated during this fuzzing session, click the Metrics menu, then Faults on the left side of the screen.</simpara>
</listitem>
</orderedlist>
</note>
</section>
<section xml:id="PassTest_and_Fuzz">
<title>From a Configuration Test</title>
<simpara>When your Pit configuration passes the validation test, the following screen displays
with the green banner and the message "Testing Passed, click Continue."</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/WebUI/AC_Test_Pass.png"/>
</imageobject>
<textobject><phrase>AC Test Pass</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>From here, you can start a fuzzing session with two clicks of the mouse.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Click Continue. Peach displays the Pit configuration page.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/WebUI/config_selected.png"/>
</imageobject>
<textobject><phrase>config selected</phrase></textobject>
</mediaobject>
</informalfigure>
</listitem>
<listitem>
<simpara>Click Start in the "Start Options" section at the bottom of the page to start a fuzzing job.</simpara>
<simpara>The Peach dashboard displays and the fuzzing job starts.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/WebUI/dashboard_oct2015.png"/>
</imageobject>
<textobject><phrase>dashboard oct2015</phrase></textobject>
</mediaobject>
</informalfigure>
</listitem>
</orderedlist>
</section>
<section xml:id="Re-Fuzzing">
<title>Re-running a Fuzzing Job</title>
<simpara>Peach allows you to re-run fuzzing sessions in whole or in part, meaning that exactly the same tests run using exactly the same data values. If you run an entire fuzzing job, all of the test cases are performed.</simpara>
<simpara>If you run a partial job, the test cases you specify run, again in exactly the same order as in the original fuzzing job using exactly the same data values.</simpara>
<simpara>What is needed to re-run a fuzzing job?</simpara>
<itemizedlist>
<listitem>
<simpara>Seed value</simpara>
</listitem>
<listitem>
<simpara>Start test case number</simpara>
</listitem>
<listitem>
<simpara>Stop test case number</simpara>
</listitem>
</itemizedlist>
<simpara>Supply the seed value and appropriate Start and Stop Test Case values in the "Start Options" on the Pit Configuration page that follows, and click Start to begin a repeat of the fuzzing session.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/WebUI/config_selected.png"/>
</imageobject>
<textobject><phrase>config selected</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>The next two sections provide information about the Seed Value and the Test Case number used in recreating a fuzzing job.</simpara>
<section xml:id="About_SeedValue">
<title>Seed Value</title>
<simpara>The seed value of a fuzzing job is located in the following places:</simpara>
<itemizedlist>
<listitem>
<simpara>For a running job, the seed is part of the dashboard display when a fuzzing job is running. See entry 2 of the right column of the dashboard.</simpara>
</listitem>
<listitem>
<simpara>For a completed job, click on the Jobs menu and again on the entry in the Jobs list. This brings up the dashboard for the fuzzing job, where the seed is entry 2 of the right column.</simpara>
</listitem>
<listitem>
<simpara>For a completed job, view the generated report, a <literal>.pdf</literal> file. The seed is the last table entry in the Summary section (section 1) of the report.</simpara>
</listitem>
</itemizedlist>
<simpara>A seed is a common technique used in scientific and computer experiments to provide reproducible results when a random set of data values is needed. The seed feeds into a random-number generator that produces a sequence of "random numbers". Each time the seed is used, the same sequence of "random numbers" is generated.</simpara>
<simpara>Peach uses the "random numbers" in determining the mutators to use in a test case, the sequence of mutators, the data elements to fuzz, and the fuzzed data values. Having the seed value guarantees that the same sequence of numbers is generated and used throughout a fuzzing job.</simpara>
</section>
<section xml:id="About_TestCaseNumbers">
<title>Start/Stop Test Case</title>
<simpara>The Start Test Case number identifies the first test case to perform in a fuzzing job.
The Stop Test Case number identifies the last test case to perform in a fuzzing job.
Together, the Start and Stop Test Case numbers identify a range or a sequence of fuzzing test cases to run, whether the fuzzing job is new or is a re-run.</simpara>
<simpara>The number of a specific test case is present in the detail or drill-down report for a specific fault. In this report, the value is at the top of the report and is labeled "Iteration". The value represents the iteration number (or test case number) in a fuzzing job.</simpara>
<simpara>Main uses of specifying start and/or stop test case numbers in a fuzzing job are
to confirm that an issue reliably occurs, to assist in tracking down an issue, or
to verify that an issue is fixed.</simpara>
<simpara>If the issue does not reproduce, the issue will be more difficult to solve and might be a HEAP-related memory issue in which the addressable memory layout can have a large impact on the bug occurrence. In short, tracking down the root cause and verifying a fix for an issue will require running Peach for a long time to see whether the issue recurs.
There is no easy way to guarantee an effective fix in this case.</simpara>
<tip>
<simpara>Once a fix is in place, run a new fuzzing job to regress around the fix and to determine whether any residual faults surface.</simpara>
</tip>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
</section>
<section xml:id="Report_Faults">
<title>Faults</title>
<simpara>While Peach Fuzzer Professional is running, you can view all the faults generated during the session by clicking the Faults menu option on the left.</simpara>
<simpara>Faults displays the total number of generated faults. There are two Faults views: the Summary view and the Detail view:</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/WebUI/Fault_summary.png"/>
</imageobject>
<textobject><phrase>Fault summary</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>For each session, the Faults Summary view lists a summary of information about the fault such as:</simpara>
<itemizedlist>
<listitem>
<simpara>Identified fault iteration count</simpara>
</listitem>
<listitem>
<simpara>Time and date</simpara>
</listitem>
<listitem>
<simpara>Monitor that detected the fault</simpara>
</listitem>
<listitem>
<simpara>Risk (if known)</simpara>
</listitem>
<listitem>
<simpara>Unique identifiers of the fault (major and minor hashes), if available</simpara>
</listitem>
</itemizedlist>
<simpara>Clicking on one of the listed faults from the Summary view opens the Details view for the selected fault.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/WebUI/Fault_detail.png"/>
</imageobject>
<textobject><phrase>Fault detail</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Here&#8217;s where you can find details about the selected fault. Additional information (such as any files collected during the data collection phase) are located in the disk log folder.</simpara>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
<section xml:id="Report_Metrics">
<title>Metrics</title>
<simpara>A number of metrics are available for viewing while Peach Fuzzer Professional is running.</simpara>
<tip>
<simpara>The data grids used on many of the metrics displays support multi-column sorting using the <emphasis>shift</emphasis> key and clicking on the different columns to sort.</simpara>
</tip>
<section xml:id="_bucket_timeline">
<title>Bucket Timeline</title>
<simpara>This metric display shows a timeline with new fault buckets listed, and total number of times the bucket was found during the fuzzing session.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/WebUI/metrics_timeline.png"/>
</imageobject>
<textobject><phrase>metrics timeline</phrase></textobject>
</mediaobject>
</informalfigure>
</section>
<section xml:id="_faults_over_time">
<title>Faults Over Time</title>
<simpara>This metric display shows the count of faults found by hour over the course of the fuzzing run. This is the count of all faults found, not just unique buckets.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/WebUI/metrics_faultsovertime.png"/>
</imageobject>
<textobject><phrase>metrics faultsovertime</phrase></textobject>
</mediaobject>
</informalfigure>
</section>
<section xml:id="_mutators">
<title>Mutators</title>
<simpara>This metric display shows statistics for each mutator by arranging the information into columns:</simpara>
<informaltable tabstyle="horizontal" frame="none" colsep="0" rowsep="0">
<tgroup cols="2">
<colspec colwidth="15*"/>
<colspec colwidth="85*"/>
<tbody valign="top">
<row>
<entry>
<simpara>Element Count</simpara>
</entry>
<entry>
<simpara>The number of elements this mutator touched with mutated data.</simpara>
</entry>
</row>
<row>
<entry>
<simpara>Iteration Count</simpara>
</entry>
<entry>
<simpara>The number of iterations this mutator was used during the fuzzing job.</simpara>
</entry>
</row>
<row>
<entry>
<simpara>Bucket Count</simpara>
</entry>
<entry>
<simpara>The number of unique buckets found while this mutator was in use.</simpara>
</entry>
</row>
<row>
<entry>
<simpara>Fault Count</simpara>
</entry>
<entry>
<simpara>The number of faults found while this mutator was in use.</simpara>
</entry>
</row>
</tbody>
</tgroup>
</informaltable>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/WebUI/metrics_mutators.png"/>
</imageobject>
<textobject><phrase>metrics mutators</phrase></textobject>
</mediaobject>
</informalfigure>
</section>
<section xml:id="_elements">
<title>Elements</title>
<simpara>This metric display shows statistics for all of the elements in your Pit.</simpara>
<simpara>This display shows several columns of information:</simpara>
<informaltable tabstyle="horizontal" frame="none" colsep="0" rowsep="0">
<tgroup cols="2">
<colspec colwidth="15*"/>
<colspec colwidth="85*"/>
<tbody valign="top">
<row>
<entry>
<simpara>State</simpara>
</entry>
<entry>
<simpara>The state this element belongs to</simpara>
</entry>
</row>
<row>
<entry>
<simpara>Action</simpara>
</entry>
<entry>
<simpara>The action this element belongs to</simpara>
</entry>
</row>
<row>
<entry>
<simpara>Parameter</simpara>
</entry>
<entry>
<simpara>The parameter this action belongs to (if any). Parameters are used only with actions of type <emphasis>call</emphasis>.</simpara>
</entry>
</row>
<row>
<entry>
<simpara>Element</simpara>
</entry>
<entry>
<simpara>The full name of the element and its associated DataModel.</simpara>
</entry>
</row>
<row>
<entry>
<simpara>Mutations</simpara>
</entry>
<entry>
<simpara>The number of mutations generated from this element.</simpara>
</entry>
</row>
<row>
<entry>
<simpara>Buckets</simpara>
</entry>
<entry>
<simpara>The number of unique buckets found by sending mutating data to this element.</simpara>
</entry>
</row>
<row>
<entry>
<simpara>Faults</simpara>
</entry>
<entry>
<simpara>The number of faults found from the mutated data sent to this element.</simpara>
</entry>
</row>
</tbody>
</tgroup>
</informaltable>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/WebUI/metrics_elements.png"/>
</imageobject>
<textobject><phrase>metrics elements</phrase></textobject>
</mediaobject>
</informalfigure>
</section>
<section xml:id="_states">
<title>States</title>
<simpara>This metric display presents statistics that are relevant for pits that have state models with more than two or more states. This display shows the number of times a specific state occurred during the fuzzing session. Seldom-used states might hide issues or indicate a problem.</simpara>
<simpara>For example, not all states always execute. If an early-occurring state is fuzzed, the outcome of the fuzzing could prevent states that are used late in the state flow from occurring.</simpara>
<note>
<simpara>Over time, the number of occurrences for most states should trend towards equality.</simpara>
</note>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/WebUI/metrics_states.png"/>
</imageobject>
<textobject><phrase>metrics states</phrase></textobject>
</mediaobject>
</informalfigure>
</section>
<section xml:id="_data_sets">
<title>Data Sets</title>
<simpara>This metric display shows statistics related to the use of two or more data sets in the fuzzing session. This is useful to determine the origin of unique buckets and also faults in terms of the data sources used in mutating.</simpara>
<simpara>This display shows several columns of information:</simpara>
<informaltable tabstyle="horizontal" frame="none" colsep="0" rowsep="0">
<tgroup cols="2">
<colspec colwidth="15*"/>
<colspec colwidth="85*"/>
<tbody valign="top">
<row>
<entry>
<simpara>Data Set</simpara>
</entry>
<entry>
<simpara>Name of the data set</simpara>
</entry>
</row>
<row>
<entry>
<simpara>Iterations</simpara>
</entry>
<entry>
<simpara>Number of fuzzing iterations performed using this data set</simpara>
</entry>
</row>
<row>
<entry>
<simpara>Buckets</simpara>
</entry>
<entry>
<simpara>Number of unique buckets found with this data set</simpara>
</entry>
</row>
<row>
<entry>
<simpara>Faults</simpara>
</entry>
<entry>
<simpara>Number of faults found with this data set</simpara>
</entry>
</row>
</tbody>
</tgroup>
</informaltable>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/WebUI/metrics_datasets.png"/>
</imageobject>
<textobject><phrase>metrics datasets</phrase></textobject>
</mediaobject>
</informalfigure>
</section>
<section xml:id="_buckets">
<title>Buckets</title>
<simpara>This metric display shows the buckets encountered during the fuzzing job. Several columns of information show:</simpara>
<informaltable tabstyle="horizontal" frame="none" colsep="0" rowsep="0">
<tgroup cols="2">
<colspec colwidth="15*"/>
<colspec colwidth="85*"/>
<tbody valign="top">
<row>
<entry>
<simpara>Fault bucket</simpara>
</entry>
<entry>
<simpara>Identifier of the fault that occurred</simpara>
</entry>
</row>
<row>
<entry>
<simpara>Mutator</simpara>
</entry>
<entry>
<simpara>The mutator that generated the fault</simpara>
</entry>
</row>
<row>
<entry>
<simpara>Iteration count</simpara>
</entry>
<entry>
<simpara>The number of iterations that used the mutator</simpara>
</entry>
</row>
<row>
<entry>
<simpara>Faults count</simpara>
</entry>
<entry>
<simpara>The number of faults that occurred while using the mutator</simpara>
</entry>
</row>
</tbody>
</tgroup>
</informaltable>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/WebUI/metrics_buckets.png"/>
</imageobject>
<textobject><phrase>metrics buckets</phrase></textobject>
</mediaobject>
</informalfigure>
</section>
<section xml:id="_accessing_raw_metrics_data">
<title>Accessing Raw Metrics Data</title>
<simpara>Each job has its own SQLite database that contains metrics and other information about the job.
The database is stored with other log assets under the logs folder in the peach application folder.
Each job will have its own folder of assets.
While we don&#8217;t document the database schema,
advanced users are welcome to mine the database to utilize the metrics data in different ways.
The database format may change between versions, though typically changes are small.</simpara>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
</section>
<section xml:id="Program_Peach">
<title>The Peach Command Line Interface</title>
<simpara>This is the core Peach application which provides the core fuzzing capabilities and
also some utility functions for the custom pit developer.
This application can be used to start the Peach Web Application and
also to launch fuzzing jobs from the command line.</simpara>
<simpara>Some options may be disabled depending on your Peach License options.</simpara>
<simpara>Please submit any bugs to <link xl:href="mailto:support@peachfuzzer.com">support@peachfuzzer.com</link>.</simpara>
<section xml:id="_peach_web_application">
<title>Peach Web Application</title>
<simpara>Starts Peach and provides a web application for configuring, running, and
viewing results of a fuzzing job.</simpara>
<section xml:id="_syntax">
<title>Syntax</title>
<screen>peach [options]</screen>
<variablelist>
<varlistentry>
<term>--nobrowser</term>
<listitem>
<simpara>Disable launching browser on start.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>--webport=PORT</term>
<listitem>
<simpara>Specified port the web application runs on.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>--plugins=PATH</term>
<listitem>
<simpara>Change the plugins folder location.
Defaults to the <emphasis>Plugins</emphasis> folder relative to the Peach installation.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
</section>
<section xml:id="_fuzzing_from_command_line">
<title>Fuzzing from Command Line</title>
<simpara>A fuzzing run is started by specifying the Peach Pit Configuration or
Peach XML file and the name of a test to perform.</simpara>
<simpara>If a run is interrupted,
it can be restarted by providing the last successful test case and the seed of the test session.
Use the --skipto and --seed parameters to provide this information.</simpara>
<section xml:id="_syntax_2">
<title>Syntax</title>
<screen>peach [options] &lt;PEACH_PIT.xml | PEACH_CONFIG.peach&gt; [test_name]</screen>
<variablelist>
<varlistentry>
<term>PEACH_CONFIG.peach</term>
<listitem>
<simpara>Peach Pit Configuration generated by Peach Application.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>PEACH_PIT.xml</term>
<listitem>
<simpara>The Peach Pit XML file.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>test_name</term>
<listitem>
<simpara>Name of test to run (defaults to <emphasis>Default</emphasis>).</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>-1</term>
<listitem>
<simpara>Perform a single test case</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>--debug</term>
<listitem>
<simpara>Enable debug messages.
Useful when debugging Peach Pit Files.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>-DKEY=VALUE</term>
<listitem>
<simpara>Define a configuration variable via the command line.
Multiple defines can be provided as needed.
Example: -DTargetIPv4=127.0.0.1 -DTargetPort=80</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>--duration=DUR</term>
<listitem>
<simpara>Duration of fuzzing run. Peach will run for DUR length of time.
Commonly integrating Peach into an automated test cycle or continuous integration environment.
Argument format is DD.HH:MM:SS.</simpara>
<variablelist>
<varlistentry>
<term>Examples</term>
<listitem>
<itemizedlist>
<listitem>
<simpara><literal>--duration=12</literal>     Duration of 12 days</simpara>
</listitem>
<listitem>
<simpara><literal>--duration=0:20</literal>   Duration of 20 min</simpara>
</listitem>
<listitem>
<simpara><literal>--duration=5:00</literal>   Duration of 5 hours</simpara>
</listitem>
<listitem>
<simpara><literal>--duration=1.5:00</literal> Duration of 1 day, 5 hrs</simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>
</listitem>
</varlistentry>
<varlistentry>
<term>--noweb</term>
<listitem>
<simpara>Disable the Peach Web Application</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>--plugins=PATH</term>
<listitem>
<simpara>Change the plugins folder location.
Defaults to the <emphasis>Plugins</emphasis> folder relative to the Peach installation.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>--polite</term>
<listitem>
<simpara>Disable interactive console mode</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>--range=S,F</term>
<listitem>
<simpara>Perform a range of test cases starting at test case S and ending with test case F.
Typically combined with the --seed argument.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>--seed=SEED</term>
<listitem>
<simpara>Set the fuzzing jobs seed.
The same seed will always produce the same test case sequence.
Should only be set when reproducing a historical fuzzing job.
Default is a random seed.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>--skipto=NUM</term>
<listitem>
<simpara>Skip to NUM test case and start fuzzing.
Normally combined with --seed to reproduce a specific sequence of test cases.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>--trace</term>
<listitem>
<simpara>Enable even more verbose debug messages.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>--webport=PORT</term>
<listitem>
<simpara>Specified port the web application runs on</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
</section>
<section xml:id="_debug_peach_xml_file">
<title>Debug Peach XML File</title>
<simpara>This will perform a single iteration (-1) of your pit file while
displaying a lot of debugging information (--debug).
The debugging information is intended for custom pit developers.</simpara>
<section xml:id="_syntax_3">
<title>Syntax</title>
<screen>peach -1 --debug &lt;PEACH_PIT.xml | PEACH_CONFIG.peach&gt; [test_name]</screen>
</section>
</section>
<section xml:id="_display_list_of_network_capture_devices">
<title>Display List of Network Capture Devices</title>
<simpara>Display a list of all known devices Peach can perform network capture on.</simpara>
<section xml:id="_syntax_4">
<title>Syntax</title>
<screen>peach --showdevices</screen>
</section>
</section>
<section xml:id="_display_known_elements">
<title>Display Known Elements</title>
<simpara>Print a list of all known:</simpara>
<itemizedlist>
<listitem>
<simpara>Actions</simpara>
</listitem>
<listitem>
<simpara>Agent Channels</simpara>
</listitem>
<listitem>
<simpara>Analyzers</simpara>
</listitem>
<listitem>
<simpara>DataElements</simpara>
</listitem>
<listitem>
<simpara>Fixups</simpara>
</listitem>
<listitem>
<simpara>Loggers</simpara>
</listitem>
<listitem>
<simpara>Monitors</simpara>
</listitem>
<listitem>
<simpara>Mutation Strategies</simpara>
</listitem>
<listitem>
<simpara>Mutators</simpara>
</listitem>
<listitem>
<simpara>Publishers</simpara>
</listitem>
<listitem>
<simpara>Relations</simpara>
</listitem>
<listitem>
<simpara>Transformers</simpara>
</listitem>
</itemizedlist>
<simpara>The list includes any associated parameters along with a description and default values.
This can be used to verify that custom extensions are found.</simpara>
<section xml:id="_syntax_5">
<title>Syntax</title>
<screen>peach --showenv</screen>
</section>
</section>
<section xml:id="_peach_agent">
<title>Peach Agent</title>
<simpara>The Peach Agent functionality has been moved to a separate executable.
See <link linkend="Program_PeachAgent">PeachAgent</link> for more information.</simpara>
</section>
<section xml:id="_running_analyzers_from_command_line">
<title>Running Analyzers from Command Line</title>
<simpara>This functionality has been moved to a separate executable.
See <link linkend="PitTool_Analyzer">PitTool - Analyzer</link> for more information.</simpara>
</section>
<section xml:id="_generate_xml_schema_file">
<title>Generate XML Schema File</title>
<simpara>This functionality has been moved to a separate executable.
See <link linkend="PitTool_Makexsd">PitTool - Makexsd</link> for more information.</simpara>
</section>
<section xml:id="_examples">
<title>Examples</title>
<example>
<title>Running a Pit Configuration (.peach)</title>
<simpara>This example shows how to run a fuzzing job from a configuration file (.peach).
The following command line launches Peach and fuzzes using <literal>pit_config.peach</literal> as the configuration file.</simpara>
<screen>&gt; peach pit_config.peach</screen>
</example>
<example>
<title>Running a Pit</title>
<simpara>This example shows how to run a fuzzing definition.
The following command line launches Peach and fuzzes using <literal>pit.xml</literal> (and if it exists, <literal>pit.xml.config</literal>) as the configuration file.</simpara>
<screen>&gt; peach pit.xml</screen>
</example>
<example>
<title>Single Iteration with Debug Output</title>
<simpara>When testing a definition, we recommend running a single non-mutating iteration with debug output.</simpara>
<simpara>The following command line launches Peach and fuzzes using <literal>pit.xml</literal> (and if it exists, <literal>pit.xml.config</literal>) as the configuration file.
The command line combines the <literal>-1</literal> and <literal>--debug</literal> arguments to run a single iteration;
the debugging information is included in the output.
Even more verbose output can be enabled by using <literal>--trace</literal> instead of <literal>--debug</literal>.</simpara>
<screen>&gt; peach -1 --debug samples\DebuggerWindows.xml

[*] Test 'Default' starting with random seed 27886.
Peach.Core.Agent.Agent StartMonitor: Monitor WindowsDebugger
Peach.Core.Agent.Agent StartMonitor: Monitor_1 PageHeap
Peach.Core.Agent.Agent StartMonitor: Monitor_2 NetworkCapture
Peach.Core.Agent.Agent SessionStarting: Monitor
Peach.Core.Agent.Monitors.WindowsDebuggerHybrid SessionStarting
Peach.Core.Agent.Agent SessionStarting: Monitor_1
Establishing the listener...
Waiting for a connection...
Peach.Core.Agent.Agent SessionStarting: Monitor_2

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.TcpClientPublisher start()
Peach.Core.Publishers.TcpClientPublisher open()
Accepted connection from 127.0.0.1:51466.
Peach.Core.Publishers.TcpClientPublisher output(12 bytes)
Peach.Core.Publishers.TcpClientPublisher

00000000   48 65 6C 6C 6F 20 57 6F  72 6C 64 21               Hello World!

Received 12 bytes from client.
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.TcpClientPublisher output(12 bytes)
Peach.Core.Publishers.TcpClientPublisher

00000000   48 65 6C 6C 6F 20 57 6F  72 6C 64 21               Hello World!

Received 12 bytes from client.
Peach.Core.Publishers.TcpClientPublisher close()
Peach.Core.Publishers.TcpClientPublisher Shutting down connection to 127.0.0.1:4
244
Connection closed by peer.
Shutting connection down...
Connection is down.
Peach.Core.Publishers.TcpClientPublisher Read 0 bytes from 127.0.0.1:4244, closing client connection.
Waiting for a connection...
Peach.Core.Publishers.TcpClientPublisher Closing connection to 127.0.0.1:4244
Peach.Core.Agent.Monitors.WindowsDebuggerHybrid DetectedFault()
Peach.Core.Agent.Monitors.WindowsDebuggerHybrid DetectedFault() - No fault detected
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.TcpClientPublisher stop()
Peach.Core.Agent.Agent SessionFinished: Monitor_2
Peach.Core.Agent.Agent SessionFinished: Monitor_1
Peach.Core.Agent.Agent SessionFinished: Monitor
Peach.Core.Agent.Monitors.WindowsDebuggerHybrid SessionFinished
Peach.Core.Agent.Monitors.WindowsDebuggerHybrid _StopDebugger
Peach.Core.Agent.Monitors.WindowsDebuggerHybrid _FinishDebugger
Peach.Core.Agent.Monitors.WindowsDebuggerHybrid _StopDebugger
Peach.Core.Agent.Monitors.WindowsDebuggerHybrid _StopDebugger
Peach.Core.Agent.Monitors.WindowsDebuggerHybrid _FinishDebugger
Peach.Core.Agent.Monitors.WindowsDebuggerHybrid _StopDebugger

[*] Test 'Default' finished.</screen>
</example>
<example xml:id="Replay_Existing_Test_Sequence">
<title>Replay Existing Test Sequence</title>
<simpara>Once you find a faulting condition,
you may want to replicate the exact test (or sequence of tests) to recreate the issue.
Peach can reproduce exact test sequences given the following information:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Exact version of Peach. This is found in the log file <literal>status.txt</literal>.</simpara>
</listitem>
<listitem>
<simpara>Seed number used. This is also found in the log file <literal>status.txt</literal>.</simpara>
</listitem>
<listitem>
<simpara>Same/similar pit file. Data and state models must be the same.</simpara>
</listitem>
<listitem>
<simpara>If datasets are used, they must be the same set and have the same contents.</simpara>
</listitem>
</orderedlist>
<formalpara>
<title>status.txt</title>
<para>
<screen>Peach Fuzzing Run
=================

Date of run: 3/20/2014 1:58:58 PM
Peach Version: 3.1.40.1              <co xml:id="CO11-1"/>
Seed: 51816                          <co xml:id="CO11-2"/>
Command line: samples\DebuggerWindows.xml
Pit File: samples\DebuggerWindows.xml
. Test starting: Default</screen>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO11-1">
<para>Version of Peach used. Must match when reproducing.</para>
</callout>
<callout arearefs="CO11-2">
<para>Seed used. Must match when reproducing.</para>
</callout>
</calloutlist>
<simpara>We can use the first command line to skip directly to a specific iteration and start fuzzing. This lets you run a series of iterations starting from a certain point.</simpara>
<tip>
<simpara>The <literal>--seed</literal> argument matches the value from the <literal>status.txt</literal> file.</simpara>
</tip>
<screen>&gt; peach --seed 51816 --skipto 37566</screen>
<simpara>We can use the second command line to perform either a specific iteration or a small number of iterations.</simpara>
<screen>&gt; peach --seed 51816 --range 37566,37566</screen>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Program_PeachAgent">
<title>PeachAgent</title>
<simpara>Starts a Peach Agent server process.</simpara>
<simpara>A Peach Agent can be started on a remote machine (remote to Peach) to accept connections from a Peach instance.
Agents run various utility modules called Monitors and also host remote Publishers.
Peach Agents do not need any specific configuration outside of which port to listen on.
All configuration is provided by a Peach instance.</simpara>
<section xml:id="_licensing">
<title>Licensing</title>
<simpara>The Peach Agent server process does not require a license.
In a typical deployment, only the machine running the core Peach process (Peach.exe) requires a license.</simpara>
</section>
<section xml:id="_syntax_6">
<title>Syntax</title>
<screen>peachagent [--port=9001]</screen>
<variablelist>
<varlistentry>
<term>-h, --help</term>
<listitem>
<simpara>Display this help and exit</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>-V, --version</term>
<listitem>
<simpara>Display version information and exit</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>-v, --verbose</term>
<listitem>
<simpara>Increase verbosity, can use multiple times</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>--plugins=VALUE</term>
<listitem>
<simpara>Specify the plugins path</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>--port=VALUE</term>
<listitem>
<simpara>Port to listen for incoming connections on (defaults to 9001).</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>--debug</term>
<listitem>
<simpara>Enable debug messages. Useful when debugging your Peach Pit file. Warning: Messages are very
cryptic sometimes.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>--trace</term>
<listitem>
<simpara>Enable even more verbose debug messages.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Program_PeachMinset">
<title>Minset</title>
<simpara>This tool is used when adding additional samples to an existing Pit or creating a custom file fuzzing Pit.</simpara>
<simpara>Peach Minset is used to identify the minimum number of sample files required to provide the greatest code coverage for a given target.
This process can be distributed across multiple machines to decrease the run time.</simpara>
<simpara>There are two steps to the process:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Collect traces</simpara>
</listitem>
<listitem>
<simpara>Compute minimum set coverage</simpara>
</listitem>
</orderedlist>
<simpara>The first step can be distributed and the results collected for analysis by the second step.</simpara>
<section xml:id="_collect_traces">
<title>Collect Traces</title>
<simpara>Performs code coverage using all files in the <emphasis>samples</emphasis> folder.
Collects the .trace files for later analysis.
This process can be run in parallel across multiple machines or CPU cores.</simpara>
<section xml:id="_syntax_7">
<title>Syntax</title>
<screen>PeachMinset [-k] -s samples -t traces command.exe args %s</screen>
<variablelist>
<varlistentry>
<term>-k</term>
<listitem>
<simpara>Kill target when CPU usage drops to near zero.
This is used when taking traces of GUI programs.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>-s samples</term>
<listitem>
<simpara>Folder to load sample files from</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>-t traces</term>
<listitem>
<simpara>Folder to write traces to</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>command.exe args %s</term>
<listitem>
<simpara>Executable and arguments.
<literal>%s</literal> is replaced with the path and file name of a file from the samples folder.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
</section>
<section xml:id="_compute_minimum_set_coverage">
<title>Compute Minimum Set Coverage</title>
<simpara>Analyzes all .trace files to determine the minimum set of samples to use during fuzzing.
This process cannot be parallelized.</simpara>
<section xml:id="_syntax_8">
<title>Syntax</title>
<screen>PeachMinset -s samples -t traces -m minset</screen>
<variablelist>
<varlistentry>
<term>-s samples</term>
<listitem>
<simpara>Folder to load sample files from</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>-t traces</term>
<listitem>
<simpara>Folder to write traces to</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>-m minset</term>
<listitem>
<simpara>Folder to write minimum set of files to</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
</section>
<section xml:id="_all_in_one">
<title>All-In-One</title>
<simpara>Both tracing and computing can be performed in a single step.</simpara>
<section xml:id="_syntax_9">
<title>Syntax</title>
<screen>PeachMinset [-k] -s samples -m minset -t traces command.exe args %s</screen>
<variablelist>
<varlistentry>
<term>-k</term>
<listitem>
<simpara>Kill target when CPU usage drops to near zero.
This is used when taking traces of GUI programs.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>-s samples</term>
<listitem>
<simpara>Folder to load sample files from</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>-m minset</term>
<listitem>
<simpara>Folder to write minimum set of files to</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>-t traces</term>
<listitem>
<simpara>Folder to write traces to</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>command.exe args %s</term>
<listitem>
<simpara>Executable and arguments.
<literal>%s</literal> is replaced with the path and file name of a file from the samples folder.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
</section>
<section xml:id="_distributing_minset">
<title>Distributing Minset</title>
<simpara>Minset can be distributed by splitting up the sample files and distributing the collecting of traces to multiple machines.
The final compute minimum set coverage cannot be distributed.</simpara>
</section>
<section xml:id="_examples_2">
<title>Examples</title>
<example>
<title>Example Run</title>
<screen>&gt; PeachMinset.exe -s pinsamples -m minset -t traces bin\pngcheck.exe %%s

[*] Running both trace and coverage analysis
[*] Running trace analysis on 15 samples...
[1:15]   Coverage trace of pinsamples\basn0g01.png...done.
[2:15]   Coverage trace of pinsamples\basn0g02.png...done.
[3:15]   Coverage trace of pinsamples\basn0g04.png...done.
[4:15]   Coverage trace of pinsamples\basn0g08.png...done.
[5:15]   Coverage trace of pinsamples\basn0g16.png...done.
[6:15]   Coverage trace of pinsamples\basn2c08.png...done.
[7:15]   Coverage trace of pinsamples\basn2c16.png...done.
[8:15]   Coverage trace of pinsamples\basn3p01.png...done.
[9:15]   Coverage trace of pinsamples\basn3p02.png...done.
[10:15]   Coverage trace of pinsamples\basn3p04.png...done.
[11:15]   Coverage trace of pinsamples\basn3p08.png...done.
[12:15]   Coverage trace of pinsamples\basn4a08.png...done.
[13:15]   Coverage trace of pinsamples\basn4a16.png...done.
[14:15]   Coverage trace of pinsamples\basn6a08.png...done.
[15:15]   Coverage trace of pinsamples\basn6a16.png...done.

[*] Finished
[*] Running coverage analysis...
[-]   3 files were selected from a total of 15.
[*] Copying over selected files...
[-]   pinsamples\basn3p08.png -&gt; minset\basn3p08.png
[-]   pinsamples\basn3p04.png -&gt; minset\basn3p04.png
[-]   pinsamples\basn2c16.png -&gt; minset\basn2c16.png

[*] Finished</screen>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Program_PeachValidator">
<title>Peach Validator</title>
<simpara>The Peach Validator tool provides a visual view of data models before and after data is cracked into them. It&#8217;s a useful to verify data is correctly cracking into your model in a visual manner.</simpara>
<simpara>Peach Validator is used with the <literal>--debug</literal> parameter to debug custom pit files. When an error does occur some debugging information is provided via Peach Validator; for a more complete picture, review the <literal>--debug</literal> output.</simpara>
<simpara>To use Peach Validator:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Open the application</simpara>
</listitem>
<listitem>
<simpara>Using the icons in the toolbar, open the pit file.</simpara>
</listitem>
<listitem>
<simpara>In the drop down menu, use the toolbar to select one of the data models found in the file.</simpara>
</listitem>
<listitem>
<simpara>Once you select the data model, it is displayed in the lower half of the window.</simpara>
</listitem>
<listitem>
<simpara>A sample file can be loaded and cracked by using the right-most file-open icon in the toolbar.</simpara>
</listitem>
</orderedlist>
<simpara>Once the file is loaded, it is automatically cracked into the model. As elements are selected in the lower half of the screen, the byte range is shown in the hex view on top.</simpara>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
<section xml:id="Program_PeachMultiNodeCli">
<title>Peach Multi-Node CLI Tool</title>
<simpara>This tool is used to control multiple Peach instances at once.
The tool can be used via the command line or as an interactive
tool.</simpara>
<simpara>The tool utilizes the Peach REST API to perform all actions.</simpara>
<section xml:id="_installation">
<title>Installation</title>
<simpara>Installation of this tool has two steps.</simpara>
<section xml:id="_install_python_2_7">
<title>Install Python 2.7</title>
<simpara>Python v2.7 is recommended. Other versions may also work.</simpara>
</section>
<section xml:id="_install_dependencies">
<title>Install dependencies</title>
<screen>easy_install requests
easy_install cmd2</screen>
</section>
<section xml:id="_populate_instances_py">
<title>Populate instances.py</title>
<simpara>The instances.py file contains a list of all Peach instances
that will be controlled from this tool.  Instances can be
placed into groups. An instance can be part of more than one
group.</simpara>
<simpara>Configurations are pulled from a master instance configured in instances.py.
Typically the master instance is running locally, but it can
also be one of the fuzzing instances.</simpara>
<warning>
<simpara>Only one master instance can be configured!</simpara>
</warning>
</section>
</section>
<section xml:id="_syntax_10">
<title>Syntax</title>
<screen>peachcli

peachcli "jobs all" quit</screen>
</section>
<section xml:id="_commands">
<title>Commands</title>
<section xml:id="_jobs_view_all_jobs">
<title>jobs: View all jobs</title>
<screen>jobs &lt;group&gt;

jobs all</screen>
<simpara>Show basic job information from each instance in a group.</simpara>
<example>
<title>Example</title>
<screen># peachcli.py

| Peach CLI v0.1
| Copyright (c) Peach Fuzzer, LLC


&gt;&gt; jobs all

-- http://192.168.48.128:8888 --
Name                 Status     Start                Stop                 Count      Faults
-------------------------------------------------------------------------------------------
HTTP Server-Test     stopped    2016-01-12T23:13:11Z 2016-01-12T23:13:30Z 200        -
HTTP Server-Test     stopped    2016-01-13T00:27:02Z 2016-01-13T00:54:05Z 781        -

-- http://192.168.48.129:8888 --
Name                 Status     Start                Stop                 Count      Faults
-------------------------------------------------------------------------------------------
HTTP Server-Test     stopped    2016-01-12T23:13:14Z 2016-01-12T23:13:25Z -          -
HTTP Server-Test     stopped    2016-01-13T00:27:04Z 2016-01-13T00:48:35Z 13400      112

&gt;&gt;</screen>
</example>
</section>
<section xml:id="_pause_pause_a_set_of_jobs">
<title>pause: Pause a set of jobs</title>
<screen>pause &lt;pit-config&gt; &lt;group&gt;

pause HTTP_Server-Test all</screen>
<simpara>Pause pit configuration jobs running on a specified group.</simpara>
</section>
<section xml:id="_pull_pull_fault_details">
<title>pull: Pull fault details</title>
<screen>pull faults &lt;pit-config&gt; &lt;group&gt;

pull faults HTTP_Server-Test all</screen>
<simpara>Pull fault details for a specific pit configuration. Faults from all jobs in group will be
collected.  The resulting faults are placed into a <literal>faults</literal> folder, organized by risk, bucket,
and node/test case number.</simpara>
<example>
<title>Example</title>
<screen># peachcli.py

| Peach CLI v0.1
| Copyright (c) Peach Fuzzer, LLC


&gt;&gt; pull faults HTTP_Server-Test all
Pulling faults of HTTP_Server-Test for group all:

  Pulling 112 faults from http://192.168.48.129:8888...

&gt;&gt; quit

# ls faults\HTTP_Server-Test\EXPLOITABLE\F0FF8D9D\1395E24B\
192.168.48.129_13290  192.168.48.129_13309  192.168.48.129_13328  192.168.48.129_13347  192.168.48.129_13366  192.168.48.129_13385
192.168.48.129_13291  192.168.48.129_13310  192.168.48.129_13329  192.168.48.129_13348  192.168.48.129_13367  192.168.48.129_13386
192.168.48.129_13292  192.168.48.129_13311  192.168.48.129_13330  192.168.48.129_13349  192.168.48.129_13368  192.168.48.129_13387
192.168.48.129_13293  192.168.48.129_13312  192.168.48.129_13331  192.168.48.129_13350  192.168.48.129_13369  192.168.48.129_13388
192.168.48.129_13294  192.168.48.129_13313  192.168.48.129_13332  192.168.48.129_13351  192.168.48.129_13370  192.168.48.129_13389
192.168.48.129_13295  192.168.48.129_13314  192.168.48.129_13333  192.168.48.129_13352  192.168.48.129_13371  192.168.48.129_13390
192.168.48.129_13296  192.168.48.129_13315  192.168.48.129_13334  192.168.48.129_13353  192.168.48.129_13372  192.168.48.129_13391
192.168.48.129_13297  192.168.48.129_13316  192.168.48.129_13335  192.168.48.129_13354  192.168.48.129_13373  192.168.48.129_13392
192.168.48.129_13298  192.168.48.129_13317  192.168.48.129_13336  192.168.48.129_13355  192.168.48.129_13374  192.168.48.129_13393
192.168.48.129_13299  192.168.48.129_13318  192.168.48.129_13337  192.168.48.129_13356  192.168.48.129_13375  192.168.48.129_13394
192.168.48.129_13300  192.168.48.129_13319  192.168.48.129_13338  192.168.48.129_13357  192.168.48.129_13376  192.168.48.129_13395
192.168.48.129_13301  192.168.48.129_13320  192.168.48.129_13339  192.168.48.129_13358  192.168.48.129_13377  192.168.48.129_13396
192.168.48.129_13302  192.168.48.129_13321  192.168.48.129_13340  192.168.48.129_13359  192.168.48.129_13378  192.168.48.129_13397
192.168.48.129_13303  192.168.48.129_13322  192.168.48.129_13341  192.168.48.129_13360  192.168.48.129_13379  192.168.48.129_13398
192.168.48.129_13304  192.168.48.129_13323  192.168.48.129_13342  192.168.48.129_13361  192.168.48.129_13380  192.168.48.129_13399
192.168.48.129_13305  192.168.48.129_13324  192.168.48.129_13343  192.168.48.129_13362  192.168.48.129_13381  192.168.48.129_13400
192.168.48.129_13306  192.168.48.129_13325  192.168.48.129_13344  192.168.48.129_13363  192.168.48.129_13382  192.168.48.129_13401
192.168.48.129_13307  192.168.48.129_13326  192.168.48.129_13345  192.168.48.129_13364  192.168.48.129_13383
192.168.48.129_13308  192.168.48.129_13327  192.168.48.129_13346  192.168.48.129_13365  192.168.48.129_13384</screen>
</example>
</section>
<section xml:id="_push_push_pit_configuration">
<title>push: Push pit configuration</title>
<screen>push &lt;pit-config&gt; &lt;group&gt;

push HTTP_Server-Test all</screen>
<simpara>The push command will copy a configuration from the master instance to a group of remote instances.
The pit configuration name must follow a specific naming convention to use this command. The name
has two parts. The first part is the source pit name, for example "HTTP_Server". The second part
is the configuration name, for example "Test". They are joined with a hyphen (-). The resulting
name would be "HTTP_Server-Test".</simpara>
</section>
<section xml:id="_status_status_of_all_related_jobs">
<title>status: Status of all related jobs</title>
<screen>status &lt;pit-config&gt; &lt;group&gt;

status HTTP_Server-Test all</screen>
<simpara>Collect information about all jobs for a specific pit configuration.</simpara>
<example>
<title>Example</title>
<screen># peachcli.py

| Peach CLI v0.1
| Copyright (c) Peach Fuzzer, LLC


&gt;&gt; status HTTP_Server-Test all
Status of HTTP_Server-Test for group all:

 Nodes    Running  Stopped  Paused   Count    Faults
-----------------------------------------------------
 2        0        4        0        14381    112

&gt;&gt;</screen>
</example>
</section>
<section xml:id="_start_start_a_new_set_of_jobs">
<title>start: Start a new set of jobs</title>
<screen>start &lt;pit-config&gt; &lt;group&gt;

start HTTP_Server-Test all</screen>
<simpara>Start a new job using the specified pit configuration on all instances in the specified group.</simpara>
</section>
<section xml:id="_stop_stop_a_set_of_jobs">
<title>stop: Stop a set of jobs</title>
<screen>stop &lt;pit-config&gt; &lt;group&gt;

stop HTTP_Server-Test all</screen>
<simpara>Stop pit configuration jobs running on a specified group.</simpara>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
</section>
<section xml:id="Program_PitTool">
<title>Pit Tool</title>
<simpara><literal>PitTool</literal> is provided as an additional set of utilities useful for developing Peach pits.</simpara>
<section xml:id="_syntax_11">
<title>Syntax</title>
<screen>Usage:
  PitTool.exe &lt;command&gt; [options]

Commands:
  analyzer                   Run a Peach analyzer.
  compile                    Validate and compile pit into .meta.json and .ninja files.
  crack                      Crack a sample file.
  help                       Show help for commands.
  makexsd                    Generate a peach.xsd file.
  ninja                      Create a sample ninja database.

General Options:
  -h, --help                 Display this help and exit
  -V, --version              Display version information and exit
  -v, --verbose              Increase verbosity, can use multiple times
      --plugins=VALUE        Specify the plugins path
      --pits=VALUE           Specify the PitLibraryPath.</screen>
</section>
<section xml:id="_commands_2">
<title>Commands</title>
<variablelist>
<varlistentry>
<term><link linkend="PitTool_Analyzer">analyzer</link></term>
<listitem>
<simpara>Run a Peach analyzer.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="PitTool_Compile">compile</link></term>
<listitem>
<simpara>Validate and compile pit into .meta.json and .ninja files.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="PitTool_Crack">crack</link></term>
<listitem>
<simpara>Crack a sample file.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="PitTool_Makexsd">makexsd</link></term>
<listitem>
<simpara>Generate a peach.xsd file.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="PitTool_Ninja">ninja</link></term>
<listitem>
<simpara>Create a sample ninja database.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="PitTool_Analyzer">
<title>Pit Tool - Analyzer</title>
<simpara>Run a Peach analyzer.</simpara>
<section xml:id="_syntax_12">
<title>Syntax</title>
<screen>PitTool.exe analyzer &lt;analyzer&gt; [options]</screen>
</section>
<section xml:id="_analyzers">
<title>Analyzers</title>
<variablelist>
<varlistentry>
<term><link linkend="Analyzers_Asn1">Asn1</link></term>
<listitem>
<simpara>Converts ASN.1 data in Blobs into a full data model.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Analyzers_Json">Json</link></term>
<listitem>
<simpara>Generate a data model based on a JSON document.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Analyzers_Postman">Postman (beta)</link></term>
<listitem>
<simpara>Convert Postman API collection to Peach Pit.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Analyzers_Regex">Regex</link></term>
<listitem>
<simpara>Break up a string using a regex.
Each group will become strings.
The group name will be used as the element name.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Analyzers_StringToken">StringToken</link></term>
<listitem>
<simpara>Generate a data model by tokenizing a text document.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Analyzers_Swagger">Swagger (beta)</link></term>
<listitem>
<simpara>Convert Swagger API definition to Peach Pit.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Analyzers_Xml">Xml</link></term>
<listitem>
<simpara>Generate a data model based on an XML document.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="PitTool_Compile">
<title>Pit Tool - Compile</title>
<simpara>The Pit compiler is used by Pit developers to provide the following features:</simpara>
<itemizedlist>
<listitem>
<simpara>Validation of Pit files against the <link linkend="PeachPit">Peach XML Schema</link>.</simpara>
</listitem>
<listitem>
<simpara>Verification of <link linkend="PitDefines">PitDefines</link> in <literal>.xml.config</literal> files.</simpara>
</listitem>
<listitem>
<simpara>Lint checks to enfore basic rules for <literal>.xml</literal> files.</simpara>
</listitem>
<listitem>
<simpara>Generation of <literal>.meta.json</literal> files used for <link linkend="WebUI_Config_Tuning">tuning mutations</link> in the Peach Web Interface.</simpara>
</listitem>
<listitem>
<simpara>Generation of <literal>.ninja</literal> databases used by the <link linkend="Mutators_SampleNinjaMutator">Sample Ninja mutator</link>.</simpara>
</listitem>
</itemizedlist>
<section xml:id="_syntax_13">
<title>Syntax</title>
<screen>Usage:
  PitTool.exe compile [options] &lt;PitPath&gt;

Description:
  Validate and compile pit into .meta.json and .ninja files.

compile Options:
      --no-verify            Don't verify PitDefines.
      --no-lint              Don't perform lint checks.
      --no-meta              Don't generate metadata used for tuning.
      --no-ninja             Don't generate a sample ninja database.

General Options:
  -h, --help                 Display this help and exit
  -V, --version              Display version information and exit
  -v, --verbose              Increase verbosity, can use multiple times
      --plugins=VALUE        Specify the plugins path
      --pits=VALUE           Specify the PitLibraryPath.</screen>
</section>
<section xml:id="_parameters">
<title>Parameters</title>
<variablelist>
<varlistentry>
<term>PitPath</term>
<listitem>
<simpara>The path to a PIT.xml.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>--no-verify</term>
<listitem>
<simpara>Don&#8217;t verify PitDefines.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>--no-lint</term>
<listitem>
<simpara>Don&#8217;t perform lint checks.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>--no-meta</term>
<listitem>
<simpara>Don&#8217;t generate metadata used for tuning.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>--no-ninja</term>
<listitem>
<simpara>Don&#8217;t generate a sample ninja database.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_verify_pitdefines">
<title>Verify PitDefines</title>
<simpara>This step enforces the following rules on each PitDefine:</simpara>
<itemizedlist>
<listitem>
<simpara>A name is defined.</simpara>
</listitem>
<listitem>
<simpara>A description is defined.</simpara>
</listitem>
<listitem>
<simpara>A PitDefine is used by the Pit.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="_pitlint_checks">
<title>PitLint Checks</title>
<simpara>The following lint checks are provided to enforce basic rules on Pits:</simpara>
<itemizedlist>
<listitem>
<simpara>The Pit must have an xml declaration.</simpara>
</listitem>
<listitem>
<simpara>The first xml element must be <literal>&lt;Peach&gt;</literal>.</simpara>
</listitem>
<listitem>
<simpara><literal>&lt;Peach&gt;</literal> must have an <literal>xmlns</literal> attribute.</simpara>
</listitem>
<listitem>
<simpara>The <literal>xmlns</literal> attribute must be equal to <literal><link xl:href="http://peachfuzzer.com/2012/Peach">http://peachfuzzer.com/2012/Peach</link></literal>.</simpara>
</listitem>
<listitem>
<simpara>Only a single <literal>&lt;Test&gt;</literal> element is allowed.</simpara>
</listitem>
<listitem>
<simpara><literal>&lt;Test&gt;</literal> element must have a <literal>maxOutputSize</literal> attribute.</simpara>
</listitem>
<listitem>
<simpara><literal>&lt;Test&gt;</literal> element must have a <literal>targetLifetime</literal> attribute.</simpara>
</listitem>
<listitem>
<simpara><literal>&lt;Publisher&gt;</literal> parameters must not be hard-coded, use a PitDefine (suppress with <emphasis>Allow_HardCodedParamValue</emphasis>)</simpara>
</listitem>
<listitem>
<simpara>The <literal>class</literal> attribute of a <literal>&lt;Publisher&gt;</literal> element must match the known Publisher plugins.</simpara>
</listitem>
<listitem>
<simpara><literal>&lt;Publisher&gt;</literal> must not be referenced with deprecated name.</simpara>
</listitem>
<listitem>
<simpara>All required parameters on a publisher must be configured.</simpara>
</listitem>
<listitem>
<simpara><literal>&lt;StateModel&gt;</literal> must not have unexpected call actions.</simpara>
</listitem>
<listitem>
<simpara><literal>&lt;StateModel&gt;</literal> must have a <emphasis>StartIterationEvent</emphasis> call <literal>&lt;Action&gt;</literal> at the start.</simpara>
</listitem>
<listitem>
<simpara><literal>&lt;StateModel&gt;</literal> must have a <emphasis>ExitIterationEvent</emphasis> call <literal>&lt;Action&gt;</literal> at the end.</simpara>
</listitem>
<listitem>
<simpara><literal>&lt;Action&gt;</literal> with a <literal>when</literal> attribute must not contain <literal>controlIteration</literal>.</simpara>
</listitem>
<listitem>
<simpara><literal>&lt;Action&gt;</literal> with a <literal>when</literal> attribute force <literal>&lt;Test&gt;</literal> to have <literal>nonDeterministicActions</literal> attribute set to <literal>true</literal>.</simpara>
</listitem>
<listitem>
<simpara>Elements with a <literal>value</literal> attribute must not contain embedded newline.</simpara>
</listitem>
</itemizedlist>
<simpara>Some lint checks may be ignored by using an xml comment with the format:</simpara>
<screen>&lt;!-- PitLint: RULE --&gt;</screen>
<simpara>The following rules may be ignored:</simpara>
<itemizedlist>
<listitem>
<simpara>Skip_StartIterationEvent</simpara>
</listitem>
<listitem>
<simpara>Allow_WhenNonDeterministicActions</simpara>
</listitem>
<listitem>
<simpara>Allow_WhenControlIteration</simpara>
</listitem>
<listitem>
<simpara>Allow_MissingParamValue=&lt;ParamName&gt;</simpara>
</listitem>
<listitem>
<simpara>Allow_HardCodedParamValue</simpara>
</listitem>
</itemizedlist>
<simpara>For example,
the following can be used to ignore errors about the
<literal>Timeout</literal> and <literal>Filter</literal> params required by the <literal>RawEther</literal> publisher.</simpara>
<screen>&lt;Publisher class='RawEther'&gt;
	&lt;!-- Pit is send only, don't need to expose timeouts or filter --&gt;
	&lt;!-- PitLint: Allow_MissingParamValue=Timeout --&gt;
	&lt;!-- PitLint: Allow_MissingParamValue=Filter --&gt;
	&lt;Param name='Interface' value='##Interface##'/&gt;
&lt;/Publisher&gt;</screen>
</section>
<section xml:id="_generate_tuning_metadata">
<title>Generate Tuning Metadata</title>
<simpara>Peach offers the ability to tune the fuzzing process by allowing users to manually set a relative
mutation weight on a field-by-field basis.
To accomplish this task, <literal>PitTool compile</literal> is used to generate metadata which includes the
structure of the fields in a Pit.
This metadata is used by the Peach Web Interface so that the tree of fields can be displayed and
manipulated.</simpara>
</section>
<section xml:id="_generate_sample_ninja_database">
<title>Generate Sample Ninja Database</title>
<simpara>For more information on the sample ninja database, see <link linkend="PitTool_Ninja">PitTool - Ninja</link>.</simpara>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="PitTool_Crack">
<title>Pit Tool - Crack</title>
<section xml:id="_syntax_14">
<title>Syntax</title>
<screen>Usage:
  PitTool.exe crack [options] &lt;PitPath&gt; &lt;DataModel&gt; &lt;SamplePath&gt;

Description:
  Crack a sample file.

General Options:
  -h, --help                 Display this help and exit
  -V, --version              Display version information and exit
  -v, --verbose              Increase verbosity, can use multiple times
      --plugins=VALUE        Specify the plugins path
      --pits=VALUE           Specify the PitLibraryPath.</screen>
</section>
<section xml:id="_parameters_2">
<title>Parameters</title>
<variablelist>
<varlistentry>
<term>PitPath</term>
<listitem>
<simpara>Fuzzing definition that refers to sample files.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>DataModel</term>
<listitem>
<simpara>The DataModel used to crack each sample.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>SamplesPath</term>
<listitem>
<simpara>The path to a folder containing the sample files to be used during fuzzing.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_example">
<title>Example</title>
<screen>$ pittool crack \
  pits/Net/HTTP_Client.xml \
  HTTP:HTTP:Request \
  pits/_Common/Samples/Net/HTTP/requests/get.bin
Parsing: 'pits/Net/HTTP_Client.xml'
Looking for data model: 'HTTP:HTTP:Request'
-+ DataModel 'Request'
 |-+ DataModel 'request-line'
 | |-- String 'method' [GET]
 | |-- String 'sep1' [ ]
 | |-- String 'uri' [/]
 | |-- String 'sep2' [ ]
 | |-+ DataModel 'version'
 | | |-- String 'http' [HTTP/]
 | | |-- String 'major-version' [1]
 | | |-- String 'period' [.]
 | | |-- String 'minor-version' [1]
 | |-- String 'crlf' [\r\n]
 |-+ Array 'header-array'
 | |-+ Choice 'header-array_0'
 | | |-+ DataModel 'host-header'
 | | | |-- String 'field-name' [Host]
 | | | |-- String 'delim' [: ]
 | | | |-- String 'field-value' [localhost]
 | | | |-- String 'crlf' [\r\n]
 | |-+ Choice 'header-array_1'
 | | |-+ DataModel 'misc-header-analyzer'
 | | | |-- String 'field-name' [User-Agent]
 | | | |-- String 'delim' [: ]
 | | | |-+ Block 'field-value'
 | | | | |-+ Block 'value'
...
 | | | |-- String 'crlf' [\r\n]
 |-- String 'header-crlf' [\r\n]
 |-+ Block 'end'</screen>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="PitTool_Makexsd">
<title>Pit Tool - Make XSD</title>
<simpara>Generate XML Schema file (peach.xsd).
This file is used for pit file validation and also intelliSense in XML editors.
The XSD only needs to be generated if custom extensions are added to Peach.</simpara>
<simpara>The Peach schema file, <emphasis>peach.xsd</emphasis>, provides intelliSense in supported editors
(like Visual Studio and oXygen XML Editor).
When adding extensions to Peach,
generate a new schema file that includes these extensions.</simpara>
<section xml:id="_syntax_15">
<title>Syntax</title>
<screen>Usage:
  PitTool.exe makexsd

Description:
  Generate a peach.xsd file.

General Options:
  -h, --help                 Display this help and exit
  -V, --version              Display version information and exit
  -v, --verbose              Increase verbosity, can use multiple times
      --plugins=VALUE        Specify the plugins path
      --pits=VALUE           Specify the PitLibraryPath.</screen>
</section>
<section xml:id="_parameters_3">
<title>Parameters</title>
<simpara>None</simpara>
</section>
<section xml:id="_example_2">
<title>Example</title>
<screen>&gt; pittool makexsd
Successfully generated peach.xsd</screen>
<simpara>The output of this command is a new <emphasis>peach.xsd</emphasis> file that contains any custom extensions.</simpara>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="PitTool_Ninja">
<title>Pit Tool - Ninja</title>
<simpara>This tool is used when adding samples to an existing Pit or creating a custom file fuzzing Pit.</simpara>
<simpara>Sample Ninja reads sample files used in fuzzing,
runs them through the Peach data crackers
(which applies sample files to the data models),
and places them into a database.
During fuzzing,
a sample ninja mutator mixes-and-matches file sections to create a new file.</simpara>
<important>
<simpara>Sample Ninja is not available in the Peach Community version.</simpara>
</important>
<simpara>The <literal>pittool ninja</literal> command produces and maintains the Sample Ninja database used by the
Sample Ninja mutator.</simpara>
<simpara>To fuzz using Sample Ninja:</simpara>
<itemizedlist>
<listitem>
<simpara>Generate a Sample Ninja database using <literal>pittool ninja</literal>.</simpara>
</listitem>
<listitem>
<simpara>The Sample Ninja mutator automatically uses the database the next time Peach is run.</simpara>
</listitem>
<listitem>
<simpara>When new or modified sample files are needed, re-run <literal>pittool ninja</literal> to update the database.</simpara>
</listitem>
</itemizedlist>
<simpara>The generated database has a name like <literal>PIT.ninja</literal>.
This means that if your pit file is <literal>png.xml</literal>,
the generated database file is <literal>png.ninja</literal>.</simpara>
<section xml:id="_syntax_16">
<title>Syntax</title>
<screen>Usage:
  PitTool.exe ninja &lt;PitPath&gt; &lt;DataModel&gt; &lt;SamplesPath&gt;

Description:
  Create a sample ninja database.

General Options:
  -h, --help                 Display this help and exit
  -V, --version              Display version information and exit
  -v, --verbose              Increase verbosity, can use multiple times
      --plugins=VALUE        Specify the plugins path
      --pits=VALUE           Specify the PitLibraryPath.</screen>
</section>
<section xml:id="_parameters_4">
<title>Parameters</title>
<variablelist>
<varlistentry>
<term>PitPath</term>
<listitem>
<simpara>Fuzzing definition that refers to sample files.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>DataModel</term>
<listitem>
<simpara>The DataModel used to crack each sample.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>SamplesPath</term>
<listitem>
<simpara>The path to a folder containing the sample files to be used during fuzzing.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_3">
<title>Examples</title>
<example>
<title>Creating a Sample Ninja database</title>
<orderedlist numeration="arabic">
<listitem>
<simpara>Open a new terminal window.</simpara>
</listitem>
<listitem>
<simpara>Run <literal>pittool &lt;PitPath&gt; &lt;DataModel&gt; &lt;SamplesPath&gt;</literal>.</simpara>
</listitem>
<listitem>
<simpara>The Sample Ninja database will be generated.</simpara>
</listitem>
</orderedlist>
<screen>&gt; pittool ninja pits\Image\PNG.xml PNG:PNG:File samples_png
Processing: samples_png\ajou_logo.png
Processing: samples_png\apollonian_gasket.png
Processing: samples_png\aquarium.png
Processing: samples_png\baboon.png
...
Processing: samples_png\z00n2c08.png
Processing: samples_png\z03n2c08.png
Processing: samples_png\z06n2c08.png
Processing: samples_png\z09n2c08.png</screen>
<simpara>Generated database:</simpara>
<screen>03/17/2014  08:39 PM             9,035 PNG.xml
03/20/2014  03:52 PM         9,651,200 PNG.ninja</screen>
</example>
<example>
<title>Adding new samples to an existing Samples Ninja database</title>
<orderedlist numeration="arabic">
<listitem>
<simpara>Put new samples into your samples folder.</simpara>
</listitem>
<listitem>
<simpara>Open a terminal window.</simpara>
</listitem>
<listitem>
<simpara>Run <literal>pittool &lt;PitPath&gt; &lt;DataModel&gt; &lt;SamplesPath&gt;</literal>.</simpara>
</listitem>
<listitem>
<simpara>The new and modified files will be added to the database.</simpara>
</listitem>
</orderedlist>
<screen>&gt; pittool ninja pits\Image\PNG.xml PNG:PNG:File samples_png
Skipping: samples_png\ajou_logo.png
Skipping: samples_png\apollonian_gasket.png
Skipping: samples_png\aquarium.png
Skipping: samples_png\baboon.png
...
Skipping: samples_png\z00n2c08.png
Skipping: samples_png\z03n2c08.png
Skipping: samples_png\z06n2c08.png
Skipping: samples_png\z09n2c08.png
Processing: samples_png\zzzz.png</screen>
<simpara>Generated database:</simpara>
<screen>03/17/2014  08:39 PM             9,035 PNG.xml
03/20/2014  03:52 PM         9,651,200 PNG.ninja</screen>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
</section>
<section xml:id="ReproducingFaults">
<title>Reproducing Faults</title>
<simpara>A fault that occurs in a fuzzing session needs to be reproducible so that it can be investigated, understood, and mitigated.
Peach has the following features that aid in reproducing faults that occur during fuzzing:</simpara>
<itemizedlist>
<listitem>
<simpara>Automatic fault reproduction</simpara>
</listitem>
<listitem>
<simpara>Replay the fuzzing session</simpara>
</listitem>
</itemizedlist>
<simpara>When a fault is detected at the end of a test case, Peach automatically enters reproduction mode.
How Peach implements fault reproduction depends on the type of target being fuzzed.</simpara>
<figure>
<title>Fault Reproduction Flow Chart</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/FaultFlowchart.svg" align="center"/>
</imageobject>
<textobject><phrase>FaultFlowchart</phrase></textobject>
</mediaobject>
</figure>
<section xml:id="_iteration_based_targets">
<title>Iteration Based Targets</title>
<simpara>Iteration based test targets are targets that restart with every test case.
File fuzzing targets are typically iteration based targets.
For example, an image viewer that is started during every test case would be considered an iteration target.
When reproducing a fault found on an iteration target, Peach will only try the initial faulting test case.
Peach will not try and reproduce the fault using previous test cases.</simpara>
<note>
<simpara>There are rare cases in which an iteration based target retains enough state through a data store that a prior test case may impact the crash.  As faults are triaged if you find a significant number of faults that fall into this category it may make sense to reconfigure the Pit to be session based.  Currently this is only possible if you have developer access to the pit in question.</simpara>
</note>
</section>
<section xml:id="_session_based_targets">
<title>Session Based Targets</title>
<simpara>Session based test targets are targets that do not restart with every test case.
Server or service targets are typically session based targets.
For example, an FTP server that is started at the beginning of a fuzzing session would be considered a session target.
With session targets, it is possible that a detected fault is the byproduct of previously executed test cases.
Therefore, when reproducing a fault found on a session target, Peach will replay sequences of previous test cases.
Peach will then locate the exact test case or range of test cases required to reproduce the fault.
If a fault is reproduced on a non-fuzz (control) test case that runs after one or more fuzz test cases,
Peach will record the range of test cases executed and consider the fault to be reproducable.</simpara>
<section xml:id="_searching_for_reproduction">
<title>Searching For Reproduction</title>
<simpara>When Peach detects a fault, it always attempts to reproduce the fault.
This reproduction involves searching through previously executed test cases.
The following steps describe the major elements of the search:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Replay the most recent test. This typically is where the fault surfaces.<?asciidoc-br?>
If the fault reproduces, the system logs the information and the search finishes.<?asciidoc-br?>
If the test target restarts with each fuzzing iteration, the search finishes because the test started in a known, clean state.
Otherwise, continue with step 2.</simpara>
</listitem>
<listitem>
<simpara>Replay the last 10 iterations, running them in the same sequence as in the fuzzing session.<?asciidoc-br?>
If the fault reproduces, the system logs the information and the search finishes. Otherwise, continue with step 3.</simpara>
</listitem>
<listitem>
<simpara>Double the number of iterations, and run them in the same sequence as in the fuzzing session.<?asciidoc-br?>
If the fault reproduces, the system logs the information and the search finishes. If not, continue the search, each time doubling the number of iterations to run. The criteria for stopping follows:<?asciidoc-br?></simpara>
<itemizedlist>
<listitem>
<simpara>Reproduce the fault.</simpara>
</listitem>
<listitem>
<simpara>Encounter a critical point in the data; the effort to recreate the fault encountered another fault that peach found and logged during the test session.</simpara>
</listitem>
<listitem>
<simpara>Encounter a user-specified limit for the search.</simpara>
</listitem>
</itemizedlist>
</listitem>
</orderedlist>
<simpara>Using a search limit of 200, the following sets of iterations would run until the limit is reached:</simpara>
<itemizedlist>
<listitem>
<simpara>1 iteration<?asciidoc-br?></simpara>
</listitem>
<listitem>
<simpara>10 iterations<?asciidoc-br?></simpara>
</listitem>
<listitem>
<simpara>20 iterations<?asciidoc-br?></simpara>
</listitem>
<listitem>
<simpara>40 iterations<?asciidoc-br?></simpara>
</listitem>
<listitem>
<simpara>80 iterations<?asciidoc-br?></simpara>
</listitem>
<listitem>
<simpara>160 iterations<?asciidoc-br?></simpara>
</listitem>
<listitem>
<simpara>200 iterations (greater than 160 iterations and less than 320 iterations, which is the next cutoff point)</simpara>
</listitem>
</itemizedlist>
<simpara>All told, a maximum of 511 iterations would run (1 + 10 + 20 + &#8230;&#8203; + 200) without human intervention; and some of the iterations would be repeated on subsequent passes.</simpara>
<simpara>Some additional considerations about automated fault reproduction include the following:</simpara>
<itemizedlist>
<listitem>
<simpara>Control iterations are treated as in a normal fuzzing session. That is, the results of a control iteration serves as a standard of comparison for the results of record iterations. Also, the frequency of performing a control iteration is determined by the <emphasis>controlIteration</emphasis> attribute of the <emphasis>Test</emphasis> element.</simpara>
</listitem>
<listitem>
<simpara>Record iterations are still compared to control iterations. If the results of a record iteration matches the results of a control iteration, all is well and good, and processing advances to the next iterations. If the results of a record iteration do not match the results of a control iteration, the results are logged and the search to reproduce the fault ends.</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="_how_to_control_the_automated_fault_reproduction">
<title>How to Control the Automated Fault Reproduction</title>
<simpara>If you use a licensed Peach Pit, the appropriate automated settings are already included in the fuzzing definition.</simpara>
<simpara>If you need to change the setting or if you are defining your own pit, the <emphasis>Test</emphasis> element in the pit has two attributes that apply to Automated Fault Reproduction: <emphasis>targetLifetime</emphasis> and <emphasis>maxBackSearch</emphasis>.</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis>targetLifetime</emphasis> is an enumeration that indicates when the test target restarts.<?asciidoc-br?>
<emphasis role="strong">session</emphasis> means that the target restarts at the start of a session; and, when a fault occurs, Peach performs the search to recreate the fault, going back several iterations as needed.<?asciidoc-br?>
<emphasis role="strong">iteration</emphasis> means that the target restarts each iteration and that the search consists of re-running the current iteration.</simpara>
</listitem>
<listitem>
<simpara><emphasis>maxBackSearch</emphasis> indicates the maximum number of iterations to include in the search to reproduce the fault. The default value is 80. In the previous example, the search reaches into the fuzzing session a maximum of 200 iterations that precede the fault in question.</simpara>
</listitem>
</itemizedlist>
<tip>
<simpara>If the test target restarts every iteration (as in file fuzzing), set <emphasis>targetLifetime</emphasis> to "iteration".</simpara>
</tip>
</section>
<section xml:id="_replay_the_fuzzing_session">
<title>Replay the Fuzzing Session</title>
<simpara>Any test case generated by Peach can be replayed.
This allows an engineer to more easily perform root cause analysis of the fault discovered in the device under test.
In order for Peach to replay a test case, you need:</simpara>
<itemizedlist>
<listitem>
<simpara>The exact version of Peach</simpara>
</listitem>
<listitem>
<simpara>The pit used in the fuzzing session (the DataModel and the StateModel must be identical to those used in the fuzzing session)</simpara>
</listitem>
<listitem>
<simpara>The seed value used in the fuzzing job</simpara>
</listitem>
<listitem>
<simpara>The test case that caused the fault</simpara>
</listitem>
</itemizedlist>
<simpara>With this information, you can re-run the appropriate part of the fuzzing session.
For an example, see the <link linkend="Replay_Existing_Test_Sequence">example</link> listed in the <link linkend="Program_Peach">The Peach Command Line Interface</link>.</simpara>
<simpara>If the command line does not specify an iteration range or a starting iteration, the entire fuzzing session runs.</simpara>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="ReferenceSection_Intro">
<title>Reference</title>
<simpara>This section provides reference documentation for Peach.</simpara>
<section xml:id="GeneralConfiguration">
<title>General</title>
<simpara>This section documents general elements used in creating a fuzzing definition.</simpara>
<simpara><?asciidoc-pagebreak?></simpara>
<section xml:id="Ref_Workflow">
<title>Peach Workflow</title>
<simpara>This section will walk through the internal workflow Peach follows when fuzzing. This is provided to give a deeper understanding of how Peach works and when you can expect various activities to occur.</simpara>
<section xml:id="_highlevel_overview">
<title>Highlevel Overview</title>
<simpara>This is the 10,000 ft view of what occurs to perform a fuzzing. This disregards the UI and focus just on the internal workflow.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Parse the XML into a DOM (object model). This is when we create objects to represent elements in the pit such as DataModel, Test, Publisher, etc.  During this parse time any components of your DataModel such as data elements, fixups and transformers are likely to be called.</simpara>
</listitem>
<listitem>
<simpara>Run the requested Test. Here we start the fuzzing job which will:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Find the specified Test</simpara>
</listitem>
<listitem>
<simpara>Connect to all agents and start all monitors</simpara>
</listitem>
<listitem>
<simpara>Initialize some internal context</simpara>
</listitem>
<listitem>
<simpara>Fuzzing loop</simpara>
<orderedlist numeration="lowerroman">
<listitem>
<simpara>Identify mutations that will occur</simpara>
</listitem>
<listitem>
<simpara>Generate copy of DOM for use in this test case</simpara>
</listitem>
<listitem>
<simpara>Run StateModel applying mutations as needed</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>As the state model executes it will run actions. Some actions such as start, stop, open, close, accept, input, output, call, set/getProperty are passed directly to the publisher to handle</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>When job completed or is canceled generate the pdf report</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="_agent_statemodel_and_publisher_workflow">
<title>Agent, StateModel and Publisher Workflow</title>
<simpara>This section covers what happens during the "Run StateModel applying mutations as needed" step from the prior section.</simpara>
<simpara>Peach is for the most part synchronous in operation. The only asynchronous calls occur in the publishers themselves. For instance, a base publisher exists to deal with Stream objects which makes use of the async read/write methods. That async behavior is entirely contained in the publisher itself. All interactions between Agent, StateModel and Publishers are performed via synchronous blocking calls.</simpara>
<simpara>The interaction between the action type <emphasis>input</emphasis> may not appear this way as we offload the actual reading of bytes into the data cracker via the Publishers "WantBytes" call. So for the <emphasis>input</emphasis> action you will see something like this if you are the publisher:</simpara>
<screen>publisher.input()
loop until data cracker done:
   publisher.wantBytes(count)</screen>
<simpara>Because some of the publishers have an async read or a worker thread handling a read loop you may see data coming in and displayed in Hex (with --debug) prior to the <emphasis>input</emphasis> action occurring. In that case the publisher is buffering received data until it is needed.</simpara>
<simpara>A fuzzing iteration would look like this:</simpara>
<screen>agent.iterationStarting()

stateModel.Run()           <co xml:id="CO12-1"/>
   initialState.Run()
      Loop over actions:
         action.Run()

agent.iterationFinished()
agent.detectedFaults()
if fault then
   agent.GetMonitorData()

agent.mustStop()</screen>
<calloutlist>
<callout arearefs="CO12-1">
<para>Once inside of stateModel.Run() the only agent interaction would be broadcasting the events when using action type call where publisher is <literal>Peach.Agent</literal>. In that case you will see an "agent.message(event)" occur.</para>
</callout>
</calloutlist>
</section>
</section>
<section xml:id="Data">
<title>Data</title>
<simpara>At the start of Pit processing, all data sets are empty or have their values defined in the data model (using the <emphasis>value</emphasis> attribute). Peach uses the <emphasis>Data</emphasis> element to override a <emphasis>value</emphasis> attribute or to assign a value to create and load the data into a DataModel.</simpara>
<simpara>Peach uses the cracking subsystem to map the data to the correct elements. This process fails if the data does not fit.</simpara>
<simpara>Data is cracked in a DataModel the same way that we crack an <link linkend="Action_input">input</link> Action in a StateModel. Currently, the cracking subsystem uses three ways to load data:</simpara>
<itemizedlist>
<listitem>
<simpara>using values from a file</simpara>
</listitem>
<listitem>
<simpara>via a python expression</simpara>
</listitem>
<listitem>
<simpara>by setting values field by field</simpara>
</listitem>
</itemizedlist>
<simpara>The <emphasis>Data</emphasis> element is a valid top-level element (child of &lt;Peach&gt;) when defining data sets that will be referenced during later processing.  It is also a valid child of <link linkend="Action">Action</link> and <link linkend="Param">Param</link> when used to define data or to reference an existing top level definition.</simpara>
<section xml:id="_data_and_switchcount">
<title>Data and <emphasis>switchCount</emphasis></title>
<simpara>If you specify multiple XML blocks in a data file, use the <emphasis>switchCount</emphasis> attribute with the <link linkend="MutationStrategies">random strategy</link> to specify the number of iterations performed before switching to the next data file.</simpara>
<simpara>If there are multiple <emphasis>Data</emphasis> elements, after a specified number of fuzzing iterations (using <emphasis>switchCount</emphasis>), Peach switches the data element that it uses to populate the fuzzing file.</simpara>
<simpara>The following example illustrates this using two <emphasis>Data</emphasis> elements. Peach fuzzes with the first <emphasis>Data</emphasis> element for the <emphasis>switchCount</emphasis> number of iterations. Then, Peach switches <emphasis>Data</emphasis> elements and continues fuzzing using the second <emphasis>Data</emphasis> element.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;DataModel name="MyDataModel"&gt;
   &lt;Block name="FooBlock"&gt;
      &lt;String name="Value" /&gt;
   &lt;/Block&gt;
&lt;/DataModel&gt;

&lt;Data name="HelloWorldDataSet"&gt;
  &lt;Field name="FooBlock.Value" value="Hello World!" /&gt;
&lt;/Data&gt;

&lt;Data name="LoadFromFile" fileName="sample.bin" /&gt;</programlisting>
</section>
<section xml:id="_attributes">
<title>Attributes</title>
<simpara><emphasis>Required:</emphasis></simpara>
<simpara>None.</simpara>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term><link linkend="name">name</link></term>
<listitem>
<simpara>Name of the Data.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="fileName">fileName</link></term>
<listitem>
<simpara>Name of file to load, or folder with files to cycle through.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_child_elements">
<title>Child Elements</title>
<itemizedlist>
<listitem>
<simpara><link linkend="Field">Field</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="_examples_4">
<title>Examples</title>
<example>
<title>Basic Usage Example</title>
<simpara>Multiple Data elements switch after <emphasis>switchCount</emphasis> iterations.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;StateModel name="TheState"&gt;
  &lt;State name="initial"&gt;
    &lt;Action type="output"&gt;
      &lt;DataModel ref="TheDataModel" /&gt;
      &lt;Data name="SampleData1"&gt;
        &lt;Field name="Block1.Value" value="Hello World!" /&gt;
      &lt;/Data&gt;
      &lt;Data name="SampleData2"&gt;
        &lt;Field name="Block1.Value" value="Good Afternoon World!" /&gt;
      &lt;/Data&gt;
    &lt;/Action&gt;
  &lt;/State&gt;
&lt;/StateModel&gt;</programlisting>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Defaults">
<title>Defaults</title>
<simpara>The <emphasis>Defaults</emphasis> element changes the default values of the specified data-element attributes.</simpara>
<note>
<simpara>Items specified in the <emphasis>Defaults</emphasis> section must be optional element attributes.</simpara>
</note>
<warning>
<simpara>Required attributes do not belong in the <emphasis>Defaults</emphasis> section. Instead,
place required attribute values in the definition of each element.</simpara>
</warning>
<section xml:id="_syntax_17">
<title>Syntax</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;Defaults&gt;
	&lt;Number endian="big" signed="false" /&gt;
&lt;/Defaults&gt;</programlisting>
</section>
<section xml:id="_examples_5">
<title>Examples</title>
<example>
<title>Changing default Byte Order</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
			 xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

	&lt;Defaults&gt;
		&lt;Number endian="big" signed="false" /&gt;
	&lt;/Defaults&gt;

	&lt;DataModel name="TheDataModel"&gt;
		&lt;Number size="32" value="0xffff" /&gt;
	&lt;/DataModel&gt;

	&lt;StateModel name="TheStateModel" initialState="InitialState"&gt;
		&lt;State name="InitialState"&gt;
			&lt;Action type="output"&gt;
				&lt;DataModel ref="TheDataModel" /&gt;
			&lt;/Action&gt;
		&lt;/State&gt;
	&lt;/StateModel&gt;

	&lt;Test name="Default"&gt;
		&lt;StateModel ref="TheStateModel" /&gt;
		&lt;Publisher class="ConsoleHex"/&gt;
	&lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Produces the following output:</simpara>
<programlisting language="xml" linenumbering="unnumbered">[*] Test 'Default' starting with random seed 54950.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher start()
Peach.Core.Publishers.ConsolePublisher open()
Peach.Core.Publishers.ConsolePublisher output(4 bytes)
00000000   00 00 FF FF                                        ????
Peach.Core.Publishers.ConsolePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.ConsolePublisher stop()

[*] Test 'Default' finished.</programlisting>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Import">
<title>Import</title>
<simpara>The Import element applies to only Python files. It allows you to import custom Python modules to use in your Pit file.</simpara>
<simpara><emphasis>Import</emphasis> works like the Python import keyword.</simpara>
<section xml:id="_syntax_18">
<title>Syntax</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;Import import="MyCode" /&gt;</programlisting>
</section>
<section xml:id="_attributes_2">
<title>Attributes</title>
<simpara><emphasis>Required:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>import</term>
<listitem>
<simpara>Same as python import keyword. A file must exist with a <literal>.py</literal> postfix.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Optional:</emphasis></simpara>
<simpara>None.</simpara>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Include">
<title>Include</title>
<simpara>The Include element allows you to include other Pit files in namespaces (the name that is pre-appended to everything in the pit) so they can be used by the current Pit file.</simpara>
<simpara>When referencing included Pit files, prefix element names with the namespace and a colon (:) <emphasis>foo:datamodel</emphasis>.</simpara>
<section xml:id="_syntax_19">
<title>Syntax</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;Include ns="foo" src="file:foo.xml" /&gt;</programlisting>
</section>
<section xml:id="_attributes_3">
<title>Attributes</title>
<simpara><emphasis>Required:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>ns</term>
<listitem>
<simpara>Namespace prefix.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>src</term>
<listitem>
<simpara>Source URL, use "<literal>file:</literal>" prefix for filenames.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Optional:</emphasis></simpara>
<simpara>None.</simpara>
</section>
<section xml:id="_examples_6">
<title>Examples</title>
<example>
<title>Basic Include Example</title>
<simpara>This example uses the Include element to use a data model defined in another file.</simpara>
<formalpara>
<title>example_include.xml</title>
<para>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
			 xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

	&lt;DataModel name="TheDataModel"&gt;
		&lt;String value="Hello From Example_Include.xml!\n" /&gt;
	&lt;/DataModel&gt;
&lt;/Peach&gt;</programlisting>
</para>
</formalpara>
<formalpara>
<title>example.xml</title>
<para>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
			 xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

	&lt;Include ns="ex" src="example_include.xml" /&gt;

	&lt;StateModel name="TheStateModel" initialState="InitialState"&gt;
		&lt;State name="InitialState"&gt;
			&lt;Action type="output"&gt;
				&lt;DataModel ref="ex:TheDataModel" /&gt;
			&lt;/Action&gt;
		&lt;/State&gt;
	&lt;/StateModel&gt;

	&lt;Test name="Default"&gt;
		&lt;StateModel ref="TheStateModel" /&gt;
		&lt;Publisher class="Console"/&gt;
	&lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
</para>
</formalpara>
<simpara>Produces the following output:</simpara>
<screen>&gt; peach -1 --debug example.xml

[*] Test 'Default' starting with random seed 35703.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher start()
Peach.Core.Publishers.ConsolePublisher open()
Peach.Core.Publishers.ConsolePublisher output(32 bytes)
Hello From Example_Include.xml!
Peach.Core.Publishers.ConsolePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.ConsolePublisher stop()

[*] Test 'Default' finished.</screen>
</example>
</section>
</section>
<section xml:id="Logger">
<title>Loggers</title>
<simpara>Loggers allow adding additional logging methods into Peach.  Every Peach fuzzing job will always receive the default Peach logger.  Typical reasons for adding custom loggers include:</simpara>
<itemizedlist>
<listitem>
<simpara>Integration into end-user systems</simpara>
</listitem>
<listitem>
<simpara>Custom notification (SMS, Email, Pager)</simpara>
</listitem>
</itemizedlist>
<note>
<simpara>It may be easier to use the Peach REST API for performing integration work.</simpara>
</note>
<section xml:id="Loggers_File">
<title>File</title>
<simpara>The file system logger needs a specified path.  Peach creates a folder containing the run name and time stamp.  Inside of this folder are the actual logs.  Until the first fault emerges, Peach logs very little information to conserve disk space.</simpara>
<tip>
<simpara>The source to this monitor is provided in the SDK as an example.</simpara>
</tip>
<programlisting language="xml" linenumbering="unnumbered">&lt;Logger class="File"&gt;
    &lt;Param name="Path" value="logfolder" /&gt;
&lt;/Logger&gt;</programlisting>
<section xml:id="_parameters_5">
<title>Parameters</title>
<simpara><emphasis>Required:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>Path</term>
<listitem>
<simpara>The relative or absolute path to create log files.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Optional:</emphasis></simpara>
<simpara>None.</simpara>
</section>
</section>
</section>
<section xml:id="MutationStrategies">
<title>Pluggable Mutation Strategies</title>
<simpara>Peach has pluggable mutation strategies to deal with two common situations:</simpara>
<itemizedlist>
<listitem>
<simpara>Peach usually fuzzes DataModels using a top-down, sequential method.  While this guarantees that every data element is fuzzed with each test case, this may not be the best solution for larger, complex systems that can produce millions of test case variations.</simpara>
</listitem>
<listitem>
<simpara>Peach needs a simple mechanism to allow you to change how fuzzing is performed. This helps you determine the best fuzzing methods and strategies for your situation.</simpara>
</listitem>
</itemizedlist>
<simpara>If you implement a single C# class, you can fully control how Peach fuzzes a target (including state transitions) because:</simpara>
<itemizedlist>
<listitem>
<simpara>The C# class has full control over data mutations and state transition mutations.</simpara>
</listitem>
<listitem>
<simpara>Data mutations are changing the value of a data element.</simpara>
</listitem>
<listitem>
<simpara>You can easily change the state. If the pit says to transition to state named "RxPacket1," the mutation strategy can change the state so Peach transitions to the state named "TxPacket4" instead of state "RxPacket1".</simpara>
</listitem>
</itemizedlist>
<simpara>Peach supplies three user-extensible mutation strategies:</simpara>
<itemizedlist>
<listitem>
<simpara>Random (default)</simpara>
</listitem>
<listitem>
<simpara>Sequential</simpara>
</listitem>
<listitem>
<simpara>RandomDeterministic</simpara>
</listitem>
</itemizedlist>
<section xml:id="_random">
<title>Random</title>
<simpara>Random is the default fuzzing strategy.</simpara>
<simpara>This strategy selects one or more elements to mutate at a time. For each selected element, Peach randomly selects a mutator appropriate for that element.
The <emphasis>MaxFieldsToMutate</emphasis> sets the maximum number of elements that simultaneously receive mutations.</simpara>
<note>
<simpara>Peach derives the randomness of these selections from a randomly-generated seed.</simpara>
</note>
<simpara>You can repeat a test a test run using identical values and mutations in sequence by passing the same <emphasis role="strong">seed</emphasis> value with the Peach <emphasis>--seed</emphasis> command line option.  This option is useful for replaying fuzzing iterations to reproduce a previous Fault.</simpara>
<simpara>This strategy is most useful for larger data models or for use after performing a sequential fuzzing run.</simpara>
<important>
<simpara>The random strategy can have an infinite number of fuzzing iterations; it can run forever.</simpara>
</important>
<section xml:id="_parameters_6">
<title>Parameters</title>
<variablelist>
<varlistentry>
<term>MaxFieldsToMutate</term>
<listitem>
<simpara>Maximum fields to mutate at once. The default value is 6.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>SwitchCount</term>
<listitem>
<simpara>Number of iterations to perform before switching <link linkend="Data">Data</link> sets. The default value is 200.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis role="strong">Examples</emphasis></simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;Test name="Default"&gt;
	&lt;StateModel ref="TheStateModel"/&gt;

	&lt;Publisher name="writer" class="File"&gt;
		&lt;Param name="FileName" value="fuzzed.tmp"/&gt;
	&lt;/Publisher&gt;

	&lt;Strategy class="Random"&gt;
		&lt;Param name="MaxFieldsToMutate" value="15" /&gt;
		&lt;Param name="SwitchCount" value="100" /&gt;
	&lt;/Strategy&gt;
&lt;/Test&gt;</programlisting>
</section>
</section>
<section xml:id="_sequential">
<title>Sequential</title>
<simpara>If you select the sequential strategy, Peach fuzzes each element in the DataModel in order, one at a time. Peach starts from the top of the DataModel and applies all valid mutations to each data element until all possible mutations have been used.</simpara>
<simpara>The sequential strategy has a finite number of fuzzing iterations.</simpara>
<tip>
<simpara>The seed for this strategy is not configurable and is always 31337.</simpara>
</tip>
<section xml:id="_examples_7">
<title>Examples</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;Test name="Default"&gt;
  &lt;!-- ... --&gt;
  &lt;Strategy class="Sequential" /&gt;
&lt;/Test&gt;</programlisting>
</section>
</section>
<section xml:id="_randomdeterministic">
<title>RandomDeterministic</title>
<simpara>This fuzzing strategy is deterministic (has a start and end).  It is similar to the Sequential strategy in that Peach systematically works through the DataModel from top to bottom, and for each data element, Peach applies all valid mutations before moving to the next data element. Unlike the Sequential strategy, the RandomDeterministic strategy shuffles the order of mutations for each element.</simpara>
<simpara>The RandomDeterministic strategy provides consistent repeatability using a seed value that is useful for repeating a previous fuzzing session with identical fuzzing.</simpara>
</section>
</section>
<section xml:id="Param">
<title>Param</title>
<simpara>The <emphasis>Param</emphasis> child element specifies a configuration setting for its parent element. The structure of a <emphasis>Param</emphasis> is a key-value parameter pair. <emphasis>Params</emphasis> are common elements used by <link linkend="AgentsMonitors">Monitors</link>, <link linkend="Publisher">Publishers</link>, and <link linkend="Fixup">Fixups</link>.</simpara>
<note>
<simpara>A second usage of Param is with the Action_Call statement. This usage follows the attribute descriptions.</simpara>
</note>
<programlisting language="xml" linenumbering="unnumbered">&lt;Publisher class="Tcp"&gt;
  &lt;Param name="Host" value="127.0.0.1" /&gt;
  &lt;Param name="Port" value="80" /&gt;
&lt;/Publisher&gt;

&lt;Fixup class="Crc32Fixup"&gt;
  &lt;Param name="ref" value="MyDataStuff" /&gt;
&lt;/Fixup&gt;

&lt;Monitor class="WindowsDebugger"&gt;
  &lt;Param name="Executable" value="CrashableServer.exe" /&gt;
  &lt;Param name="Arguments" value="127.0.0.1 4244" /&gt;
&lt;/Monitor&gt;</programlisting>
<simpara><emphasis>Attributes:</emphasis></simpara>
<simpara><emphasis>Required:</emphasis></simpara>
<variablelist>
<varlistentry>
<term><link linkend="name">name</link></term>
<listitem>
<simpara>Name of parameter.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="value">value</link></term>
<listitem>
<simpara>Default value.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term><link linkend="valueType">valueType</link></term>
<listitem>
<simpara>Format of value attribute.</simpara>
</listitem>
</varlistentry>
</variablelist>
<section xml:id="_child_elements_2">
<title>Child Elements</title>
<simpara>None.</simpara>
</section>
<section xml:id="_param_and_the_call_action">
<title><emphasis>Param</emphasis> and the Call Action</title>
<simpara><emphasis>Param</emphasis> can also be an argument to the <link linkend="Action_call">call</link> Action. Call actions can have an array of parameters (defined by Param) used in different ways by the Publisher.</simpara>
<simpara>In this usage, the element is solely a container for a DataModel and Data. The Data described in Param is fuzzed by Peach.</simpara>
<section xml:id="_syntax_20">
<title>Syntax</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;Action type="call" method="Players[1].OpenUrl"&gt;
  &lt;Param name="P1"&gt;
    &lt;DataModel ref="TheDataModel" /&gt;
    &lt;Data&gt;
      &lt;Field name="Value" value="video.mov"/&gt;
    &lt;/Data&gt;
  &lt;/Param&gt;
&lt;/Action&gt;</programlisting>
</section>
<section xml:id="_attributes_4">
<title>Attributes</title>
<simpara><emphasis>Required:</emphasis></simpara>
<variablelist>
<varlistentry>
<term><link linkend="name">name</link></term>
<listitem>
<simpara>Name of parameter</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Optional:</emphasis></simpara>
<simpara>None.</simpara>
</section>
<section xml:id="_child_elements_3">
<title>Child Elements</title>
<variablelist>
<varlistentry>
<term><link linkend="DataModel">DataModel</link></term>
<listitem>
<simpara>Reference to a DataModel that acts as a source for fuzzed data.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Data">Data</link></term>
<listitem>
<simpara>Set of initial data to be cracked into the above DataModel before fuzzing.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
</section>
<section xml:id="PythonPath">
<title>PythonPath</title>
<simpara>The <emphasis>PythonPath</emphasis> top-level element adds a path to the Python module search path list. It extends Peach and includes custom code locations.</simpara>
<section xml:id="_syntax_21">
<title>Syntax</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;PythonPath path="c:/peach/mycode"&gt;</programlisting>
</section>
<section xml:id="_attributes_5">
<title>Attributes</title>
<simpara><emphasis>Required:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>path</term>
<listitem>
<simpara>The path to add.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Optional:</emphasis></simpara>
<simpara>None.</simpara>
</section>
</section>
<section xml:id="Test">
<title>Test</title>
<simpara>The Test element defines the tests that Peach runs during a fuzzing session. Peach requires at least one Test element for fuzzing to occur.</simpara>
<simpara>Test configures a specific fuzzing occurrence that combines a StateModel with a Publisher and other configuration options (such as including/excluding elements from being mutated, Agents, and fuzzing strategies).</simpara>
<simpara>One pit can contain multiple Test elements; simply provide the test element names on the Peach command line.</simpara>
<note>
<simpara>If the command-line for launching Peach does not include a test name, Peach uses the Test element named "Default" for the fuzzing session.</simpara>
</note>
<section xml:id="_syntax_22">
<title>Syntax</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;Test name="Default"&gt;

  &lt;!-- Optionally exclude some elements from mutation --&gt;
  &lt;Exclude xpath="//Reserved" /&gt;
  &lt;Exclude xpath="//Magic" /&gt;

  &lt;!-- Optional agent references --&gt;
  &lt;Agent ref="LocalWindowsAgent" platform="windows" /&gt;
  &lt;Agent ref="LocalOsxAgent" platform="osx" /&gt;
  &lt;Agent ref="LocalLinuxAgent" platform="linux" /&gt;

  &lt;Agent ref="RemoteAgent" /&gt;

  &lt;!-- Indicate which state model to use (required) --&gt;
  &lt;StateModel ref="TheState" /&gt;

  &lt;!-- Configure the publisher to use (required) --&gt;
  &lt;Publisher class="Tcp"&gt;
     &lt;Param name="Host" value="127.0.0.1" /&gt;
     &lt;Param name="Port" value="9001" /&gt;
  &lt;/Publisher&gt;

  &lt;!-- Use a different fuzzing strategy --&gt;
  &lt;Strategy class="Random" /&gt;

  &lt;!-- Log output to disk --&gt;
&lt;/Test&gt;</programlisting>
</section>
<section xml:id="_attributes_6">
<title>Attributes</title>
<simpara><emphasis>Required:</emphasis></simpara>
<variablelist>
<varlistentry>
<term><link linkend="name">name</link></term>
<listitem>
<simpara>Name of the test, use "Default" for the default test.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>waitTime</term>
<listitem>
<simpara>Time to wait between adjacent test cases&#8212;&#8203;The default value is zero (0).</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>faultWaitTime</term>
<listitem>
<simpara>Time to wait for a fault to occur before starting next iteration. The default value is zero (0).</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>controlIteration</term>
<listitem>
<simpara>Specifies the number of test cases that run before Peach performs the next control iteration. The default value is 0, a special value that means Peach is not using control iterations.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>targetLifetime</term>
<listitem>
<simpara>Specifies when the target restarts to a known, stable state.<?asciidoc-br?></simpara>
<itemizedlist>
<listitem>
<simpara>"session" indicates the original target is used throughout the entire fuzzing session. This is the default value.</simpara>
</listitem>
<listitem>
<simpara>"iteration" indicates the target restarts every iteration. This is common in file fuzzing.</simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term>maxBackSearch</term>
<listitem>
<simpara>Sets the maximum number of iterations to include in the search to reproduce a fault. This attribute is used when <emphasis>targetLifeTime</emphasis> is "session". The default value is 80.</simpara>
<simpara>For example, if the default value is used, the search potentially re-runs the 80 iterations that precede the most recent fault.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>maxOutputSize</term>
<listitem>
<simpara>Sets the maximum size of data that Peach generates. This is on an Action by Action basis, meaning that if your StateModel contains two actions, each action can produce data up to maxOutputSize. The default value is unlimited.</simpara>
<simpara>When using Publishers that have a maximum output size, such as UDP, it&#8217;s recommended this attribute be used to set maximum size to correspond with this limit.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>nonDeterministicActions</term>
<listitem>
<simpara>If true, checks actions in the state model flow for exceptions.<?asciidoc-br?>
If false, checks actions in the state model flow for exceptions and fully analyzes
the state model for consistency. The value false specifies legacy behavior and is the
default.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_child_elements_4">
<title>Child Elements</title>
<simpara><emphasis>Required:</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara><link linkend="StateModel">StateModel</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="Publisher">Publisher</link></simpara>
</listitem>
</itemizedlist>
<simpara><emphasis>Optional:</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara><link linkend="AgentsMonitors">Agent</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="Test_Include">Include</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="Test_Exclude">Exclude</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="MutationStrategies">Strategy</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="Logger">Logger</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="Test_Mutators">Mutators</link></simpara>
</listitem>
</itemizedlist>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Test_Exclude">
<title>Exclude</title>
<simpara>When used in the <emphasis>Test</emphasis> element of a Pit, the Exclude and <link linkend="Test_Include">Include</link>
elements allows for including or excluding various data elements from mutation.
One use case of these elements is to fuzz encapsulated data without fuzzing the container.</simpara>
<simpara>By default, Peach fuzzes all data elements.  Exclude prevents Peach from fuzzing all or specific data elements. XPath is used to identify the excluded elements.</simpara>
<note>
<simpara>Even though a data element is excluded, it still may appear to be fuzzed. This is due to other elements being fuzzed. However, the excluded element does not have any specific mutations performed directly to it.</simpara>
</note>
<sidebar>
<title>XPath Further Reading</title>
<simpara>The following links provide additional information regarding XPath.</simpara>
<itemizedlist>
<listitem>
<simpara><link xl:href="http://www.w3schools.com/xpath/">XPath Tutorial</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="http://www.w3schools.com/xpath/xpath_syntax.asp">XPath Syntax</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="http://www.w3.org/TR/xpath/">XPath Specification</link></simpara>
</listitem>
</itemizedlist>
</sidebar>
<section xml:id="_syntax_23">
<title>Syntax</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;!-- Exclude all data elements --&gt;
&lt;Exclude /&gt;

&lt;!-- Exclude specific elements --&gt;
&lt;Exclude xpath="//Value" /&gt;</programlisting>
</section>
<section xml:id="_attributes_7">
<title>Attributes</title>
<simpara><emphasis>Required:</emphasis></simpara>
<simpara>None.</simpara>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>xpath</term>
<listitem>
<simpara>Provides an xpath query to select elements to exclude.</simpara>
</listitem>
</varlistentry>
</variablelist>
<tip>
<simpara>Peach interprets the statement <emphasis>&lt;Exclude /&gt;</emphasis> as all exclusive, and fuzzes no data elements.</simpara>
</tip>
</section>
<section xml:id="_examples_8">
<title>Examples</title>
<example>
<title>Exclude via xpath</title>
<simpara>This example selects elements to exclude based on an xpath.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
			 xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

	&lt;DataModel name="TheDataModel"&gt;
		&lt;String value="1" /&gt;
		&lt;String value="2" /&gt;
		&lt;String value="3" /&gt;
		&lt;String value="4" /&gt;
		&lt;String value="5" /&gt;

		&lt;Block name="NotThese"&gt;
			&lt;String value="6" /&gt;
			&lt;String value="7" /&gt;
			&lt;String value="8" /&gt;
		&lt;/Block&gt;
	&lt;/DataModel&gt;

	&lt;StateModel name="TheStateModel" initialState="InitialState"&gt;
		&lt;State name="InitialState"&gt;
			&lt;Action type="output"&gt;
				&lt;DataModel ref="TheDataModel" /&gt;
			&lt;/Action&gt;
		&lt;/State&gt;
	&lt;/StateModel&gt;

	&lt;Test name="Default"&gt;
		&lt;StateModel ref="TheStateModel" /&gt;
		&lt;Publisher class="ConsoleHex"/&gt;S

		&lt;Exclude xpath="//NotThese"  /&gt;
	&lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
</example>
<example>
<title>Exclude and Include</title>
<simpara>This example excludes all data elements, then includes specific ones.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
			 xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

	&lt;DataModel name="TheDataModel"&gt;
		&lt;String value="1" /&gt;
		&lt;String value="2" /&gt;
		&lt;String value="3" /&gt;
		&lt;String value="4" /&gt;
		&lt;String value="5" /&gt;

		&lt;Block name="FuzzJustThese"&gt;
			&lt;String value="6" /&gt;
			&lt;String value="7" /&gt;
			&lt;String value="8" /&gt;
		&lt;/Block&gt;
	&lt;/DataModel&gt;

	&lt;StateModel name="TheStateModel" initialState="InitialState"&gt;
		&lt;State name="InitialState"&gt;
			&lt;Action type="output"&gt;
				&lt;DataModel ref="TheDataModel" /&gt;
			&lt;/Action&gt;
		&lt;/State&gt;
	&lt;/StateModel&gt;

	&lt;Test name="Default"&gt;
		&lt;StateModel ref="TheStateModel" /&gt;
		&lt;Publisher class="ConsoleHex"/&gt;

		&lt;Exclude /&gt;
		&lt;Include xpath="//FuzzJustThese" /&gt;
	&lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Test_Include">
<title>Include</title>
<simpara>When used in the <emphasis>Test</emphasis> element of a Pit, the Include and <link linkend="Test_Exclude">Exclude</link>
elements allows for including or excluding various data elements from mutation.
One use case of these elements is to fuzz encapsulated data without fuzzing the container.</simpara>
<simpara>XPath is used to identify the included elements.</simpara>
<sidebar>
<title>XPath Further Reading</title>
<simpara>The following links provide additional information regarding XPath.</simpara>
<itemizedlist>
<listitem>
<simpara><link xl:href="http://www.w3schools.com/xpath/">XPath Tutorial</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="http://www.w3schools.com/xpath/xpath_syntax.asp">XPath Syntax</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="http://www.w3.org/TR/xpath/">XPath Specification</link></simpara>
</listitem>
</itemizedlist>
</sidebar>
<section xml:id="_syntax_24">
<title>Syntax</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;!-- Include all data elements --&gt;
&lt;Include /&gt;

&lt;!-- Include specific elements --&gt;
&lt;Include xpath="//Value" /&gt;</programlisting>
</section>
<section xml:id="_attributes_8">
<title>Attributes</title>
<simpara><emphasis>Required:</emphasis></simpara>
<simpara>None.</simpara>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>xpath</term>
<listitem>
<simpara>Provide an xpath query to select elements to include.</simpara>
</listitem>
</varlistentry>
</variablelist>
<tip>
<simpara>Peach interprets the statement <emphasis>&lt;Include /&gt;</emphasis> as all-inclusive, and fuzzes all data elements.
=== Examples</simpara>
</tip>
<example>
<title>Include via xpath</title>
<simpara>This example excludes all data elements, then includes specific ones.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
			 xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

	&lt;DataModel name="TheDataModel"&gt;
		&lt;String value="1" /&gt;
		&lt;String value="2" /&gt;
		&lt;String value="3" /&gt;
		&lt;String value="4" /&gt;
		&lt;String value="5" /&gt;

		&lt;Block name="FuzzJustThese"&gt;
			&lt;String value="6" /&gt;
			&lt;String value="7" /&gt;
			&lt;String value="8" /&gt;
		&lt;/Block&gt;
	&lt;/DataModel&gt;

	&lt;StateModel name="TheStateModel" initialState="InitialState"&gt;
		&lt;State name="InitialState"&gt;
			&lt;Action type="output"&gt;
				&lt;DataModel ref="TheDataModel" /&gt;
			&lt;/Action&gt;
		&lt;/State&gt;
	&lt;/StateModel&gt;

	&lt;Test name="Default"&gt;
		&lt;StateModel ref="TheStateModel" /&gt;
		&lt;Publisher class="ConsoleHex"/&gt;

		&lt;Exclude /&gt;
		&lt;Include xpath="//FuzzJustThese" /&gt;
	&lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Test_Mutators">
<title>Mutators</title>
<simpara>The Mutators element, a child element of Test, specifies either a list of mutators to include in a fuzzing test run or a list of mutators to exclude from a fuzzing test run.</simpara>
<simpara>By default, Peach includes all mutations in a fuzzing run.</simpara>
<simpara>When specifying mutators to include in a test, Peach uses the supplied list of mutators
in the test. If a mutator name is not listed, peach does not include that mutator in the test run.</simpara>
<simpara>When specifying the mutators to exclude from a test, Peach uses all mutators in the test except those
supplied in the list. If a mutator name is not listed, peach keeps the mutator included in the test session.</simpara>
<note>
<simpara>A test can include at most one list of mutators: an include list or an exclude list.</simpara>
</note>
<tip>
<simpara>The mutator names are listed in the Peach DOM, accessible by running the <emphasis role="strong">peach --showenv</emphasis> command.</simpara>
</tip>
<section xml:id="_syntax_25">
<title>Syntax</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;Test&gt;
    &lt;Mutators mode="include_or_exclude"&gt;
        &lt;Mutator class="Xyz" /&gt;
    &lt;/Mutators&gt;
&lt;/Test&gt;</programlisting>
</section>
<section xml:id="_attributes_9">
<title>Attributes</title>
<simpara><emphasis>Required:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>mode</term>
<listitem>
<simpara>Either "include" or "exclude" must be specified. The list of mutators must contain at least one mutator entry.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Optional:</emphasis></simpara>
<simpara>None.</simpara>
</section>
<section xml:id="_examples_9">
<title>Examples</title>
<example>
<title>Test a single mutator</title>
<simpara>This example uses a single mutator in the test run.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
			 xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

	&lt;DataModel name="TheDataModel"&gt;
		&lt;String  type="utf16" value="1" /&gt;
	&lt;/DataModel&gt;

	&lt;StateModel name="TheStateModel" initialState="InitialState"&gt;
		&lt;State name="InitialState"&gt;
			&lt;Action type="output"&gt;
				&lt;DataModel ref="TheDataModel" /&gt;
			&lt;/Action&gt;
		&lt;/State&gt;
	&lt;/StateModel&gt;

    &lt;Test name="Default"&gt;
		&lt;StateModel ref="TheStateModel" /&gt;
		&lt;Publisher class="ConsoleHex"/&gt;

        &lt;!-- Use StringUtf16BomLength mutator in the test.  --&gt;
        &lt;!-- No other mutator is in the test run.  --&gt;

        &lt;Mutators mode="include"&gt;
            &lt;Mutator class="StringUtf16BomLength" /&gt;
        &lt;/Mutators&gt;
    &lt;/Test&gt;

&lt;/Peach&gt;</programlisting>
</example>
<example>
<title>Omit a single mutator from testing</title>
<simpara>This example excludes one mutator from the test run.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
			 xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

	&lt;DataModel name="TheDataModel"&gt;
		&lt;String  type="utf16" value="2" /&gt;
	&lt;/DataModel&gt;

	&lt;StateModel name="TheStateModel" initialState="InitialState"&gt;
		&lt;State name="InitialState"&gt;
			&lt;Action type="output"&gt;
				&lt;DataModel ref="TheDataModel" /&gt;
			&lt;/Action&gt;
		&lt;/State&gt;
	&lt;/StateModel&gt;

    &lt;Test name="Default"&gt;
		&lt;StateModel ref="TheStateModel" /&gt;
		&lt;Publisher class="ConsoleHex"/&gt;

        &lt;!-- Exclude the StringCaseLower mutator from the test. --&gt;
        &lt;!-- All other mutators are in the test run.   --&gt;

        &lt;Mutators mode="exclude"&gt;
            &lt;Mutator class="StringCaseLower" /&gt;
        &lt;/Mutators&gt;
    &lt;/Test&gt;

&lt;/Peach&gt;</programlisting>
</example>
</section>
</section>
<section xml:id="web_Path">
<title>Web Path</title>
<simpara>The <emphasis>Path</emphasis> child element specifies an HTTP path identifier used by the parent <link linkend="Action_web">web</link> action. All <emphasis>Path</emphasis> elements must have a matching subsitution identifier in the <emphasis>web</emphasis> action URL. The identifier must match the value of the <emphasis>Path</emphasis> <emphasis>id</emphasis> attribute.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;Action type="web" method="GET" url="http://www.google.com/product/{id}"&gt;
    &lt;Path key="id" value="100"/&gt;
&lt;/Action&gt;</programlisting>
<simpara><emphasis>Attributes:</emphasis></simpara>
<simpara><emphasis>Required:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>key</term>
<listitem>
<simpara>Subsitution identifier</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>name</term>
<listitem>
<simpara>Name of parameter.
When not specified, a sanitized version of <emphasis>key</emphasis> will be used to generate a name.
The <emphasis>name</emphasis> field is shown in the job metrics.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="value">value</link></term>
<listitem>
<simpara>Default value.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="valueType">valueType</link></term>
<listitem>
<simpara>Format of value attribute.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="mutable">mutable</link></term>
<listitem>
<simpara>Mutable</simpara>
</listitem>
</varlistentry>
</variablelist>
<section xml:id="_child_elements_5">
<title>Child Elements</title>
<variablelist>
<varlistentry>
<term><link linkend="DataModel">DataModel</link></term>
<listitem>
<simpara>Reference to a DataModel that acts as a source for fuzzed data.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Data">Data</link></term>
<listitem>
<simpara>Set of initial data to be cracked into the above DataModel before fuzzing.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_10">
<title>Examples</title>
<example>
<title>Simple Example</title>
<simpara>A simple web api request with a single <emphasis>Path</emphasis> element.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

&lt;StateModel name="Default" initialState="FirstState"&gt;
    &lt;State name="FirstState"&gt;

        &lt;Action type="web" method="GET" url="http://www.example.com/product/{id}"&gt;
            &lt;Path key="id" value="1"/&gt;

            &lt;Response /&gt;
        &lt;/Action&gt;

    &lt;/State&gt;
&lt;/StateModel&gt;

&lt;Test name="Default"&gt;
    &lt;StateModel ref="Default" /&gt;
    &lt;Publisher class="WebApi" /&gt;
&lt;/Test&gt;

&lt;/Peach&gt;</programlisting>
</example>
<example>
<title>Path with DataModel</title>
<simpara>A simple web api request with a single <emphasis>Path</emphasis> element.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

&lt;DataModel name="PathValue"&gt;
    &lt;String value="foo"/&gt;
    &lt;String value="-" /&gt;
    &lt;String value="bar" /&gt;
&lt;/DataModel&gt;

&lt;StateModel name="Default" initialState="FirstState"&gt;
    &lt;State name="FirstState"&gt;

        &lt;Action type="web" method="GET" url="http://www.example.com/product/{id}"&gt;
            &lt;Path key="id"&gt;
                &lt;DataModel ref="PathValue" /&gt;
            &lt;/Path&gt;
            &lt;Response /&gt;
        &lt;/Action&gt;

    &lt;/State&gt;
&lt;/StateModel&gt;

&lt;Test name="Default"&gt;
    &lt;StateModel ref="Default" /&gt;
    &lt;Publisher class="WebApi" /&gt;
&lt;/Test&gt;

&lt;/Peach&gt;</programlisting>
</example>
<example>
<title>Path with Data sets</title>
<simpara>A simple web api request with a single <emphasis>Path</emphasis> element.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

&lt;DataModel name="PathValue"&gt;
    &lt;String name="Value"/&gt;
&lt;/DataModel&gt;

&lt;StateModel name="Default" initialState="FirstState"&gt;
    &lt;State name="FirstState"&gt;

        &lt;Action type="web" method="GET" url="http://www.example.com/product/{id}"&gt;
            &lt;Path key="id"&gt;
                &lt;DataModel ref="PathValue" /&gt;
                &lt;Data&gt;
                    &lt;Field name="Value" value="100" /&gt;
                &lt;/Data&gt;
                &lt;Data&gt;
                    &lt;Field name="Value" value="101" /&gt;
                &lt;/Data&gt;
                &lt;Data&gt;
                    &lt;Field name="Value" value="102" /&gt;
                &lt;/Data&gt;
            &lt;/Path&gt;
            &lt;Response /&gt;
        &lt;/Action&gt;

    &lt;/State&gt;
&lt;/StateModel&gt;

&lt;Test name="Default"&gt;
    &lt;StateModel ref="Default" /&gt;
    &lt;Publisher class="WebApi" /&gt;
&lt;/Test&gt;

&lt;/Peach&gt;</programlisting>
</example>
</section>
</section>
<section xml:id="web_Query">
<title>Web Query</title>
<simpara>The <emphasis>Query</emphasis> element models an HTTP querystring parameter. This element is only valid when used with a parent element of <link linkend="Action_web">web</link>.</simpara>
<section xml:id="_syntax_26">
<title>Syntax</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;Action type="web" method="GET" url="http://www.google.com/users"&gt;
    &lt;Query key="first" value="John"/&gt;
    &lt;Query key="last" value="Smith"/&gt;
&lt;/Action&gt;</programlisting>
</section>
<section xml:id="_attributes_10">
<title>Attributes</title>
<simpara><emphasis>Required:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>key</term>
<listitem>
<simpara>Subsitution identifier</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>name</term>
<listitem>
<simpara>Name of parameter.
When not specified, a sanitized version of <emphasis>key</emphasis> will be used to generate a name.
The <emphasis>name</emphasis> field is shown in the job metrics.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="value">value</link></term>
<listitem>
<simpara>Default value. When used, a DataModel is automatically created and attached to this element.
Cannot be used in conjunction with a DataModel child element.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="valueType">valueType</link></term>
<listitem>
<simpara>Format of value attribute.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="mutable">mutable</link></term>
<listitem>
<simpara>When <emphasis>value</emphasis> attribute is used, this attribute will mark all elements in the automatically generated model with this mutable value.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_child_elements_6">
<title>Child Elements</title>
<variablelist>
<varlistentry>
<term><link linkend="DataModel">DataModel</link></term>
<listitem>
<simpara>Reference to a DataModel that acts as a source for fuzzed data.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Data">Data</link></term>
<listitem>
<simpara>Set of initial data to be cracked into the above DataModel before fuzzing.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_11">
<title>Examples</title>
<example>
<title>Simple Example</title>
<simpara>A simple web api request with a two <emphasis>Query</emphasis> elements.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

&lt;DataModel name="LastName"&gt;
	&lt;String name="value" value="Smith"&gt;
		&lt;Hint name="Peach.TypeTransform" value="false" /&gt;
	&lt;/String&gt;
&lt;/DataModel&gt;

&lt;StateModel name="Default" initialState="FirstState"&gt;
    &lt;State name="FirstState"&gt;

        &lt;Action type="web" method="GET" url="http://www.example.com/users"&gt;

            &lt;Query key="first" value="John"/&gt;

            &lt;Query key="last"&gt;
                &lt;DataModel ref="LastName" /&gt;
            &lt;/Query&gt;

            &lt;Response /&gt;
        &lt;/Action&gt;

    &lt;/State&gt;
&lt;/StateModel&gt;

&lt;Test name="Default"&gt;
    &lt;StateModel ref="Default" /&gt;
    &lt;Publisher class="WebApi" /&gt;
&lt;/Test&gt;

&lt;/Peach&gt;</programlisting>
</example>
</section>
</section>
<section xml:id="web_Header">
<title>Web Header</title>
<simpara>The <emphasis>Header</emphasis> element models an HTTP header key-value pair. This element is only valid when used with a parent element of <link linkend="Action_web">web</link>.</simpara>
<section xml:id="_syntax_27">
<title>Syntax</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;Action type="web" method="GET" url="http://www.google.com/users"&gt;
    &lt;Header key="Content-Type" value="application/json"/&gt;

    &lt;Body name="json"&gt;
        &lt;DataModel ref="JsonBody" /&gt;
    &lt;/Body&gt;
&lt;/Action&gt;</programlisting>
</section>
<section xml:id="_attributes_11">
<title>Attributes</title>
<simpara><emphasis>Required:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>key</term>
<listitem>
<simpara>Subsitution identifier</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>name</term>
<listitem>
<simpara>Name of parameter.
When not specified, a sanitized version of <emphasis>key</emphasis> will be used to generate a name.
The <emphasis>name</emphasis> field is shown in the job metrics.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="value">value</link></term>
<listitem>
<simpara>Default value. When used, a DataModel is automatically created and attached to this element.
Cannot be used in conjunction with a DataModel child element.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="valueType">valueType</link></term>
<listitem>
<simpara>Format of value attribute.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="mutable">mutable</link></term>
<listitem>
<simpara>When <emphasis>value</emphasis> attribute is used, this attribute will mark all elements in the automatically generated model with this mutable value.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_child_elements_7">
<title>Child Elements</title>
<variablelist>
<varlistentry>
<term><link linkend="DataModel">DataModel</link></term>
<listitem>
<simpara>Reference to a DataModel that acts as a source for fuzzed data.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Data">Data</link></term>
<listitem>
<simpara>Set of initial data to be cracked into the above DataModel before fuzzing.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_12">
<title>Examples</title>
<example>
<title>Simple Example</title>
<simpara>Example setting the Content-Type header field.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

&lt;DataModel name="NewUser"&gt;
    &lt;JsonObject&gt;
        &lt;JsonString propertyName="user" value="jsmith"/&gt;
        &lt;JsonString propertyName="name" value="John Smith" /&gt;
    &lt;/JsonObject&gt;
&lt;/DataModel&gt;

&lt;StateModel name="Default" initialState="FirstState"&gt;
    &lt;State name="FirstState"&gt;

        &lt;Action type="web" method="POST" url="http://www.example.com/users"&gt;

            &lt;Header key="Content-Type" value="application/json"/&gt;

            &lt;Body name="json"&gt;
                &lt;DataModel ref="NewUser" /&gt;
            &lt;/Body&gt;

            &lt;Response /&gt;
        &lt;/Action&gt;

    &lt;/State&gt;
&lt;/StateModel&gt;

&lt;Test name="Default"&gt;
    &lt;StateModel ref="Default" /&gt;
    &lt;Publisher class="WebApi" /&gt;
&lt;/Test&gt;

&lt;/Peach&gt;</programlisting>
</example>
</section>
</section>
<section xml:id="web_FormData">
<title>Web FormData</title>
<simpara>The <emphasis>FormData</emphasis> element models a key-value pair sent via the HTTP body. Normally this is paired with a content type of <emphasis>application/x-www-form-urlencoded</emphasis>. This element is only valid when used with a parent element of <link linkend="Action_web">web</link>. Multiple <emphasis>FormData</emphasis> elements can be used, but cannot be mixed with <emphasis>Body</emphasis> elements.</simpara>
<section xml:id="_syntax_28">
<title>Syntax</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;Action type="web" method="GET" url="http://www.google.com/users"&gt;
    &lt;Header key="Content-Type" value="application/x-www-form-urlencoded"/&gt;
    &lt;FormData key="first" value="John"/&gt;
    &lt;FormData key="last" value="Smith"/&gt;
&lt;/Action&gt;</programlisting>
</section>
<section xml:id="_attributes_12">
<title>Attributes</title>
<simpara><emphasis>Required:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>key</term>
<listitem>
<simpara>Subsitution identifier</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>name</term>
<listitem>
<simpara>Name of parameter.
When not specified, a sanitized version of <emphasis>key</emphasis> will be used to generate a name.
The <emphasis>name</emphasis> field is shown in the job metrics.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="value">value</link></term>
<listitem>
<simpara>Default value. When used, a DataModel is automatically created and attached to this element.
Cannot be used in conjunction with a DataModel child element.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="valueType">valueType</link></term>
<listitem>
<simpara>Format of value attribute.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="mutable">mutable</link></term>
<listitem>
<simpara>When <emphasis>value</emphasis> attribute is used, this attribute will mark all elements in the automatically generated model with this mutable value.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_child_elements_8">
<title>Child Elements</title>
<variablelist>
<varlistentry>
<term><link linkend="DataModel">DataModel</link></term>
<listitem>
<simpara>Reference to a DataModel that acts as a source for fuzzed data.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Data">Data</link></term>
<listitem>
<simpara>Set of initial data to be cracked into the above DataModel before fuzzing.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_13">
<title>Examples</title>
<example>
<title>Simple Example</title>
<simpara>Example setting the Content-Type header field.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

&lt;StateModel name="Default" initialState="FirstState"&gt;
    &lt;State name="FirstState"&gt;

        &lt;Action type="web" method="POST" url="http://www.example.com/users"&gt;

            &lt;Header key="Content-Type" value="application/x-www-form-urlencoded"/&gt;

            &lt;FormData key="user" value="jsmith"/&gt;
            &lt;FormData key="first" value="John"/&gt;
            &lt;FormData key="last" value="Smith"/&gt;

            &lt;Response /&gt;
        &lt;/Action&gt;

    &lt;/State&gt;
&lt;/StateModel&gt;

&lt;Test name="Default"&gt;
    &lt;StateModel ref="Default" /&gt;
    &lt;Publisher class="WebApi" /&gt;
&lt;/Test&gt;

&lt;/Peach&gt;</programlisting>
</example>
</section>
</section>
<section xml:id="web_Body">
<title>Web Body</title>
<simpara>The <emphasis>Body</emphasis> element models the web api/HTTP request body.  Typically it is paired with a <emphasis>Header</emphasis> element to define the <emphasis>Content-Type</emphasis> of the request.  <emphasis>Body</emphasis> elements can only be used with method verbs that allow request bodies such as <emphasis>POST</emphasis> and <emphasis>PUT</emphasis>. This element is only valid when used with a parent element of <link linkend="Action_web">web</link>. <emphasis>Body</emphasis> and <emphasis>FormData</emphasis> elements cannot be used together.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;Action type="web" method="GET" url="http://www.google.com/users"&gt;
    &lt;Header name="ct" key="Content-Type" value="application/x-www-form-urlencoded"/&gt;
    &lt;Body name="JsonBody"&gt;
        &lt;DataModel ref="JsonBody" /&gt;
    &lt;/Body&gt;
&lt;/Action&gt;</programlisting>
<section xml:id="_attributes_13">
<title>Attributes</title>
<simpara><emphasis>Required:</emphasis></simpara>
<variablelist>
<varlistentry>
<term><link linkend="name">name</link></term>
<listitem>
<simpara>Name of parameter.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Optional:</emphasis></simpara>
<simpara>None.</simpara>
</section>
<section xml:id="_child_elements_9">
<title>Child Elements</title>
<variablelist>
<varlistentry>
<term><link linkend="DataModel">DataModel</link></term>
<listitem>
<simpara>Reference to a DataModel that acts as a source for fuzzed data.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Data">Data</link></term>
<listitem>
<simpara>Set of initial data to be cracked into the above DataModel before fuzzing.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_14">
<title>Examples</title>
<example>
<title>Simple Example</title>
<simpara>Example setting the Content-Type header field.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

&lt;DataModel name="NewUser"&gt;
    &lt;JsonObject&gt;
        &lt;JsonString propertyName="user" value="jsmith"/&gt;
        &lt;JsonString propertyName="name" value="John Smith" /&gt;
    &lt;/JsonObject&gt;
&lt;/DataModel&gt;

&lt;StateModel name="Default" initialState="FirstState"&gt;
    &lt;State name="FirstState"&gt;

        &lt;Action type="web" method="POST" url="http://www.example.com/users"&gt;

            &lt;Header name="ct" key="Content-Type" value="application/json"/&gt;

            &lt;Body name="json"&gt;
                &lt;DataModel ref="NewUser" /&gt;
            &lt;/Body&gt;

            &lt;Response /&gt;
        &lt;/Action&gt;

    &lt;/State&gt;
&lt;/StateModel&gt;

&lt;Test name="Default"&gt;
    &lt;StateModel ref="Default" /&gt;
    &lt;Publisher class="WebApi" /&gt;
&lt;/Test&gt;

&lt;/Peach&gt;</programlisting>
</example>
</section>
</section>
<section xml:id="web_Part">
<title>Web Part</title>
<simpara>The <emphasis>Part</emphasis> element allows modeling of HTTP multipart requests.
Each section of a multipart request can include it&#8217;s own set of HTTP headers and a body composed of <link linkend="web_FormData">FormData</link> elements or a single <link linkend="web_Body">Body</link> element.
This element is only valid when used with a parent element of <link linkend="Action_web">web</link>.</simpara>
<note>
<simpara>A <emphasis>Content-Type</emphasis> header does not need to be provided when modeling a multipart HTTP request. Peach will automatically set the correct content-type header when a child of <emphasis>Part</emphasis> is used.</simpara>
</note>
<section xml:id="_syntax_29">
<title>Syntax</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;Action type="web" method="POST" url="http://api.company.com/api/v1/resource"&gt;

    &lt;Part name="metadata"&gt;
        &lt;Header key="Content-Disposition" value="form-data; name=&amp;quot;metadata&amp;quot" /&gt;
        &lt;Header key="Content-Type" value="application/json"/&gt;
        &lt;Body name="json"&gt;
            &lt;DataModel ref="JsonBody" /&gt;
        &lt;/Body&gt;
    &lt;/Part&gt;

    &lt;Part name="file"&gt;
        &lt;Header key="Content-Disposition" value="form-data; name=&amp;quot;file&amp;quot; filename=&amp;quot;filename.zip%quot" /&gt;
        &lt;Header key="Content-Type" value="binary/octet-stream" /&gt;
        &lt;Body name="fileContents"&gt;
            &lt;DefaModel ref="FileData" /&gt;
        &lt;/Body&gt;
    &lt;/Part&gt;

&lt;/Action&gt;</programlisting>
</section>
<section xml:id="_attributes_14">
<title>Attributes</title>
<simpara><emphasis>Required:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>name</term>
<listitem>
<simpara>Name of parameter.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term><link linkend="value">value</link></term>
<listitem>
<simpara>Default value. When used, a DataModel is automatically created and attached to this element.
Cannot be used in conjunction with a DataModel child element.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="valueType">valueType</link></term>
<listitem>
<simpara>Format of value attribute.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="mutable">mutable</link></term>
<listitem>
<simpara>When <emphasis>value</emphasis> attribute is used, this attribute will mark all elements in the automatically generated model with this mutable value.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_child_elements_10">
<title>Child Elements</title>
<variablelist>
<varlistentry>
<term><link linkend="web_Header">Header</link></term>
<listitem>
<simpara>Define an HTTP header.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="web_FormData">FormData</link></term>
<listitem>
<simpara>Define a key/value pair of form data. These values are transmitted via the request body. It is not possible to combine FormData with a Body child.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="web_Body">Body</link></term>
<listitem>
<simpara>Define the request body. Only one Body child element is allowed.  Body elements cannot be mixed with FormData elements.  Only one type of body is allowed.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_15">
<title>Examples</title>
<example>
<title>Uploading a file with JSON metadata</title>
<simpara>The following example models a request that uploads a file along with some metadata in JSON format.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

&lt;StateModel name="Default" initialState="FirstState"&gt;
    &lt;State name="FirstState"&gt;
        &lt;Action type="web" method="POST" url="http://api.company.com/api/user/{id}"&gt;

            &lt;Path key="id" value="1" /&gt;

            &lt;Part name="UserPictureMeta"&gt;
                &lt;Header key="Content-Disposition" value="form-data; name=&amp;quot;metadata&amp;quot" /&gt;
                &lt;Header key="Content-Type" value="application/json"/&gt;

                &lt;Body name="json"&gt;
                    &lt;DataModel ref="JsonBody" /&gt;
                &lt;/Body&gt;
            &lt;/Part&gt;

            &lt;Part name="File"&gt;
                &lt;Header key="Content-Disposition" value="form-data; name=&amp;quot;file&amp;quot; filename=&amp;quot;filename.zip%quot" /&gt;
                &lt;Header key="Content-Type" value="binary/octet-stream" /&gt;

                &lt;Body name="fileContents"&gt;
                    &lt;DefaModel ref="FileData" /&gt;
                &lt;/Body&gt;
            &lt;/Part&gt;

        &lt;/Action&gt;
    &lt;/State&gt;
&lt;/StateModel&gt;

&lt;Test name="Default"&gt;
    &lt;StateModel ref="Default" /&gt;
    &lt;Publisher class="WebApi" /&gt;
&lt;/Test&gt;

&lt;/Peach&gt;</programlisting>
</example>
<example>
<title>Uploading file with form data</title>
<simpara>The following example models a request that uploads a file along with some metadata as form data.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

&lt;StateModel name="Default" initialState="FirstState"&gt;
    &lt;State name="FirstState"&gt;
        &lt;Action type="web" method="POST" url="http://api.company.com/api/user/{id}"&gt;

            &lt;Path key="id" value="1" /&gt;

            &lt;Part name="UserPictureMeta"&gt;
                &lt;Header key="Content-Disposition" value="form-data; name=&amp;quot;metadata&amp;quot" /&gt;
                &lt;Header key="Content-Type" value="application/x-www-form-urlencoded"/&gt;

                &lt;FormData key="createor" value="Josh Smith" /&gt;
                &lt;FormData key="category" value="misc" /&gt;
                &lt;FormData key="icon" value="zip" /&gt;
            &lt;/Part&gt;

            &lt;Part name="File"&gt;
                &lt;Header key="Content-Disposition" value="form-data; name=&amp;quot;file&amp;quot; filename=&amp;quot;filename.zip%quot" /&gt;
                &lt;Header key="Content-Type" value="binary/octet-stream" /&gt;

                &lt;Body name="fileContents"&gt;
                    &lt;DefaModel ref="FileData" /&gt;
                &lt;/Body&gt;
            &lt;/Part&gt;

        &lt;/Action&gt;
    &lt;/State&gt;
&lt;/StateModel&gt;

&lt;Test name="Default"&gt;
    &lt;StateModel ref="Default" /&gt;
    &lt;Publisher class="WebApi" /&gt;
&lt;/Test&gt;

&lt;/Peach&gt;</programlisting>
</example>
</section>
</section>
<section xml:id="web_Response">
<title>Web Response</title>
<simpara>The <emphasis>Response</emphasis> element is used to model HTTP response bodies. It&#8217;s an optional child element of the <link linkend="Action_web">web</link> action. If a <emphasis>Response</emphasis> element is not specified, the <emphasis>web</emphasis> action will automatically create a default one. When manually specifying a <emphasis>Response</emphasis> element a child DataModel is typically specified to capture the body.</simpara>
<simpara>A <emphasis>Response</emphasis> element will modify the resulting DataModel to also contian the status code, status message and headers.  The resulting data model will look as follows:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;Response&gt;
    &lt;DataModel name="Response"&gt;
        &lt;String name="StatusCode" /&gt;
        &lt;String name="StatusDescription"/&gt;
        &lt;Block name="Headers"&gt;
            &lt;String name="Content-Type" value="application/json"/&gt;
        &lt;/Block&gt;
        &lt;Block name="Body"&gt;
            &lt;!-- Custom DataModel contents here --&gt;
            &lt;!-- ... OR ... --&gt;
            &lt;!-- Auto generated Data Model --&gt;
        &lt;/Block&gt;
    &lt;/DataModel&gt;
&lt;/Response&gt;</programlisting>
<simpara>The automatically generated will be one of the following:</simpara>
<simpara>Model generated for text based content types:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;DataModel name="WebApiResponse"&gt;
    &lt;Choice name="ResultOfEmpty"&gt;
        &lt;String name="Result"&gt;
            &lt;!-- Analyzer is only added for known content-types --&gt;
            &lt;Analyzer class="Json|Xml"/&gt;
        &lt;/String&gt;
        &lt;Block name="Empty" /&gt;
    &lt;/Choice&gt;
&lt;/DataModel&gt;</programlisting>
<simpara>Model generated for unknown content types:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;DataModel name="WebApiResponse"&gt;
    &lt;Choice name="ResultOfEmpty"&gt;
        &lt;Blob name="Result" /&gt;
        &lt;Block name="Empty" /&gt;
    &lt;/Choice&gt;
&lt;/DataModel&gt;</programlisting>
<section xml:id="_syntax_30">
<title>Syntax:</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;Action type="web" method="GET" url="http://www.google.com/users"&gt;
    &lt;Response&gt;
        &lt;DataModel ref="CustomBody" /&gt;
    &lt;/Response&gt;
&lt;/Action&gt;</programlisting>
</section>
<section xml:id="_attributes_15">
<title>Attributes</title>
<simpara><emphasis>Required:</emphasis></simpara>
<variablelist>
<varlistentry>
<term><link linkend="name">name</link></term>
<listitem>
<simpara>Name of parameter.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Optional:</emphasis></simpara>
<simpara>None.</simpara>
</section>
<section xml:id="_child_elements_11">
<title>Child Elements</title>
<variablelist>
<varlistentry>
<term><link linkend="DataModel">DataModel</link></term>
<listitem>
<simpara>Reference to a DataModel that acts as a source for fuzzed data.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Data">Data</link></term>
<listitem>
<simpara>Set of initial data to be cracked into the above DataModel before fuzzing.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_16">
<title>Examples</title>
<example>
<title>Simple Example</title>
<simpara>Example setting the Content-Type header field.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

&lt;DataModel name="User"&gt;
    &lt;JsonObject&gt;
        &lt;JsonString propertyName="user" value="jsmith"/&gt;
        &lt;JsonString propertyName="name" value="John Smith" /&gt;
    &lt;/JsonObject&gt;
&lt;/DataModel&gt;

&lt;StateModel name="Default" initialState="FirstState"&gt;
    &lt;State name="FirstState"&gt;

        &lt;Action type="web" method="GET" url="http://www.example.com/user/1"&gt;

            &lt;Response&gt;
                &lt;DataModel ref="User" /&gt;
            &lt;/Response&gt;

        &lt;/Action&gt;

    &lt;/State&gt;
&lt;/StateModel&gt;

&lt;Test name="Default"&gt;
    &lt;StateModel ref="Default" /&gt;
    &lt;Publisher class="WebApi" /&gt;
&lt;/Test&gt;

&lt;/Peach&gt;</programlisting>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
</section>
<section xml:id="Analyzers">
<title>Analyzers</title>
<simpara><emphasis>Analyzers</emphasis> are classes that parse some form of data and build a Peach Document Object Model (DOM) or a partial <emphasis>DataModel</emphasis>.  Examples of data that can be easily parsed are XML and ASN.1.</simpara>
<simpara>Using an <emphasis>Analyzer</emphasis> can incredibly reduce the time needed to begin smart fuzzing since the time spent creating a precise <emphasis>DataModel</emphasis> can be avoided.</simpara>
<variablelist>
<varlistentry>
<term><link linkend="Analyzers_Asn1">Asn1</link></term>
<listitem>
<simpara>Converts ASN.1 data in <emphasis>Blobs</emphasis> into a full data model.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Analyzers_Binary">Binary</link></term>
<listitem>
<simpara>Breaks up unknown data when strings are found.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Analyzers_Json">JSON</link></term>
<listitem>
<simpara>Converts JSON data in a <emphasis>String</emphasis> into a full data model.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Analyzers_Postman">Postman</link></term>
<listitem>
<simpara>Converts Postman API Catalog into Pit.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Analyzers_Regex">Regex</link></term>
<listitem>
<simpara>Use regular expressions to parse strings. Supports regular expression named groups.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Analyzers_StringToken">StringToken</link></term>
<listitem>
<simpara>Separates strings using a precedence based list of punctuation. The strings are used to form the resulting <emphasis>DataModel</emphasis>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Analyzers_Swagger">Swagger</link></term>
<listitem>
<simpara>Converts Swagger API JSON into Pit.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Analyzers_Vcr">Vcr</link></term>
<listitem>
<simpara>Converts Vcr JSON cassette into Pit.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Analyzers_Xml">Xml</link></term>
<listitem>
<simpara>Converts XML contained in a <emphasis>string</emphasis> element into a data model of <emphasis>XmlElement</emphasis> and <emphasis>XmlAttribute</emphasis> types.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Analyzers_WebRecordProxy">WebRecordProxy</link></term>
<listitem>
<simpara>Record HTTP requests and generate Peach Pit.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Analyzers_Zip">Zip</link></term>
<listitem>
<simpara>Converts zipped data in a <emphasis>blob</emphasis> into a data model of <emphasis>stream</emphasis> elements.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><?asciidoc-pagebreak?></simpara>
<section xml:id="Analyzers_Asn1">
<title>ASN.1 Analyzer</title>
<simpara>This analyzer converts the Abstract Syntax Notation One (ASN.1) specification into a full data model. This analyzer includes the following parts of the ASN.1 specification in the data model:</simpara>
<itemizedlist>
<listitem>
<simpara>Basic Encoding Rules (BER)</simpara>
</listitem>
<listitem>
<simpara>Canonical Encoding Rules (CER)</simpara>
</listitem>
<listitem>
<simpara>Distinguished Encoding Rules (DER)</simpara>
</listitem>
</itemizedlist>
<simpara>When used in the DataModel section of a Peach Pit, the Fuzzer walks the ASN.1 data and creates the appropriate elements.</simpara>
<simpara>When used from the command line, the Fuzzer walks the ASN.1 data, creates the appropriate elements, and saves the results of the generated model to disk. Once saved, you can use and modify the results as needed.</simpara>
<important>
<simpara>The ASN.1 analyzer requires data from a Blob data type.</simpara>
</important>
<section xml:id="_syntax_31">
<title>Syntax</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;Blob name="BinaryData"&gt;
	&lt;Analyzer class="Asn1" /&gt;
&lt;/Blob&gt;</programlisting>
<screen>pittool analyzer Asn1 input.bin output.xml</screen>
</section>
<section xml:id="_command_line_syntax">
<title>Command Line Syntax</title>
<screen>pittool analyzer Asn1 &lt;input file&gt; &lt;output file&gt;</screen>
<variablelist>
<varlistentry>
<term>input file</term>
<listitem>
<simpara>File containing ASN.1 structured data.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>output file</term>
<listitem>
<simpara>File creating containing generated data model</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_attributes_16">
<title>Attributes</title>
<simpara><emphasis>Required:</emphasis></simpara>
<simpara>None</simpara>
<simpara><emphasis>Optional:</emphasis></simpara>
<simpara>None</simpara>
</section>
<section xml:id="_examples_17">
<title>Examples</title>
<example>
<title>Command line data model generation</title>
<simpara>This example uses the Asn.1 analyzer on the command line to automatically generate a data model.
The sample file contains an ASN.1 bit string that is comprised of two concatenated ASN.1 bit strings.</simpara>
<simpara>Hex dump of sample file <literal>asn1.bin</literal></simpara>
<screen>00000000: 2380 0303 000a 3b03 0504 5f29 1cd0 0000  #.....;..._)....</screen>
<simpara>Output from running peach on the command line</simpara>
<screen>&gt; pittool analyzer Asn1 asn1.bin asn1.xml

[*] Starting Analyzer</screen>
<simpara>Contents of generated pit <literal>asn1.xml</literal></simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;Peach&gt;
  &lt;DataModel name="example_asn1"&gt;
    &lt;Asn1Type class="0" pc="1" tag="3" name="BIT_STRING"&gt;
      &lt;Block name="Value"&gt;
        &lt;Asn1Type class="0" pc="0" tag="3" name="BIT_STRING"&gt;
          &lt;Block name="Value"&gt;
            &lt;Number size="8" signed="false" name="UnusedLen" value="0"&gt;
              &lt;Relation type="size" of="UnusedBits" /&gt;
            &lt;/Number&gt;
            &lt;Blob name="Value" valueType="hex" value="0a3b" /&gt;
            &lt;Blob name="UnusedBits" valueType="hex" value="" /&gt;
            &lt;Padding name="Padding" /&gt;
          &lt;/Block&gt;
        &lt;/Asn1Type&gt;
        &lt;Asn1Type class="0" pc="0" tag="3" name="BIT_STRING_1"&gt;
          &lt;Block name="Value"&gt;
            &lt;Number size="8" signed="false" name="UnusedLen" value="4"&gt;
              &lt;Relation type="size" of="UnusedBits" /&gt;
            &lt;/Number&gt;
            &lt;Blob name="Value" valueType="hex" value="5f291c" /&gt;
            &lt;Blob name="UnusedBits" valueType="hex" value="" /&gt;
            &lt;Padding name="Padding" /&gt;
          &lt;/Block&gt;
        &lt;/Asn1Type&gt;
        &lt;Asn1Type class="0" pc="0" tag="0" name="EOC"&gt;
          &lt;Blob name="Value" valueType="hex" value="" /&gt;
        &lt;/Asn1Type&gt;
      &lt;/Block&gt;
    &lt;/Asn1Type&gt;
  &lt;/DataModel&gt;
&lt;/Peach&gt;</programlisting>
</example>
<example>
<title>Certificate Inline Example</title>
<simpara>This example uses the Asn.1 analyzer on inline Blob data.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach ../peach.xsd"&gt;

	&lt;DataModel name="TheModel"&gt;
		&lt;Blob valueType="hex" value="30 82 03 85 30 82 02 6D A0 03 02 01 02 02 09 00 E2 5B 91 05 F2 8F AB AA 30 0D 06 09 2A 86 48 86 F7 0D 01 01 05 05 00 30 59 31 0B 30 09 06 03 55 04 06 13 02 55 53 31 13 30 11 06 03 55 04 08 0C 0A 57 61 73 68 69 6E 67 74 6F 6E 31 10 30 0E 06 03 55 04 07 0C 07 53 65 61 74 74 6C 65 31 0D 30 0B 06 03 55 04 0A 0C 04 44 65 6A 61 31 14 30 12 06 03 55 04 03 0C 0B 74 65 73 74 69 6E 67 2E 63 6F 6D 30 1E 17 0D 31 34 30 33 31 37 30 30 32 32 32 30 5A 17 0D 31 35 30 33 31 37 30 30 32 32 32 30 5A 30 59 31 0B 30 09 06 03 55 04 06 13 02 55 53 31 13 30 11 06 03 55 04 08 0C 0A 57 61 73 68 69 6E 67 74 6F 6E 31 10 30 0E 06 03 55 04 07 0C 07 53 65 61 74 74 6C 65 31 0D 30 0B 06 03 55 04 0A 0C 04 44 65 6A 61 31 14 30 12 06 03 55 04 03 0C 0B 74 65 73 74 69 6E 67 2E 63 6F 6D 30 82 01 22 30 0D 06 09 2A 86 48 86 F7 0D 01 01 01 05 00 03 82 01 0F 00 30 82 01 0A 02 82 01 01 00 A2 9F 5E 21 EE 45 4A 0A AB CB D9 35 42 7C A9 5C 9C 59 8D 72 78 0A A0 49 63 C2 FE 36 42 9B 43 CC 05 41 49 26 3B 37 2D BC 10 10 B8 57 43 AF 6B 2B 7E 97 87 FC CB 00 EC 03 0B D6 58 55 71 C1 B0 6A 1D 38 9E EB 4C 5F D0 25 2E C6 20 AF 68 92 0E DB 8B 3D 97 61 89 3B 6A 0D 50 77 26 0A 60 0D 11 B3 82 F7 DF 30 8D F9 45 7F CD C0 88 B8 82 3F 24 A3 86 17 0E 19 60 E7 98 71 27 CE 63 49 F9 E0 95 47 E3 A6 A6 CC 9B DB 19 92 C0 58 23 90 11 C1 A6 F5 34 02 9A DD 09 FF D7 59 E7 E4 48 91 92 5C 17 EA 86 84 1D A9 57 26 13 76 F4 F7 8F 29 5A 10 FD E4 BD AE E3 CC AD 5E 64 03 E7 B6 A1 48 0E 2A D2 6B 24 95 EC 42 AE FB 79 B9 C0 9F 49 5C 2B 10 D8 A1 CE 44 8C 89 97 9B 97 45 96 5D 24 C6 3E E6 79 9F 2B 25 4A C5 21 41 0B 55 18 90 15 A7 56 C1 69 A9 90 B2 73 C6 35 47 53 4D F4 88 6F D7 E2 59 90 DB 02 03 01 00 01 A3 50 30 4E 30 1D 06 03 55 1D 0E 04 16 04 14 36 F2 B5 D1 62 F1 F8 BF B7 1C F7 70 DD B6 D9 32 2E B6 99 5E 30 1F 06 03 55 1D 23 04 18 30 16 80 14 36 F2 B5 D1 62 F1 F8 BF B7 1C F7 70 DD B6 D9 32 2E B6 99 5E 30 0C 06 03 55 1D 13 04 05 30 03 01 01 FF 30 0D 06 09 2A 86 48 86 F7 0D 01 01 05 05 00 03 82 01 01 00 4F C7 70 55 D7 74 7F 12 50 78 D1 14 77 4D 05 6C D3 5E 56 F2 84 1A D8 BC 59 BC D3 B7 63 4D F3 5F 44 1C 2C 8C A9 66 89 07 23 4D 5A 1D F8 C0 DD E7 D2 38 9A 0F 1C 56 B6 F9 FF 50 85 BA C6 09 2C 80 A6 A9 B0 47 ED 9B DF 8E 53 B6 DB 4A 4A 05 58 DC 7E 98 E5 DF B0 C7 6B A2 01 67 DA AE 6A 1E 26 8D 33 B0 17 BD 5D C3 B6 12 D5 80 A8 16 CA B6 A2 AF DD D1 80 32 89 6E 1A 7A C3 9F 7A 15 1F 35 36 EC 85 D6 B2 84 91 AD 8D 7D 40 51 8B 5A 3B 5D C9 89 9D 74 13 77 86 7A ED 59 60 89 D0 35 71 07 3E 84 2B 44 5D 26 D3 19 EE 92 F9 49 FF C9 76 BA 43 6B A7 A9 0C 2C A1 6D C3 0B 98 AB 92 99 3C C8 76 DE 7D 14 50 45 68 84 7F E9 B0 FE 90 7B 10 A7 9C 9A 40 9F 0A 49 B5 0D 0C 86 21 9B F3 49 B1 9E 55 88 9B 76 6F DC 00 F5 35 11 A0 F2 EB 49 9D 8C 5A 78 2F 98 CB FE 77 E8 C2 91 95 FA C4 87 88 E3 F5 D7 "&gt;
			&lt;Analyzer class="Asn1" /&gt;
		&lt;/Blob&gt;
	&lt;/DataModel&gt;

	&lt;StateModel name="TheState" initialState="initial"&gt;
		&lt;State name="initial"&gt;
			&lt;Action type="output"&gt;
				&lt;DataModel ref="TheModel" /&gt;
			&lt;/Action&gt;
		&lt;/State&gt;
	&lt;/StateModel&gt;

	&lt;Test name="Default"&gt;
		&lt;StateModel ref="TheState"/&gt;
		&lt;Publisher class="ConsoleHex" /&gt;
	&lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Output from inline Blob data example.</simpara>
<screen>&gt; peach -1 --debug example.xml

[*] Test 'Default' starting with random seed 62676.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher start()
Peach.Core.Publishers.ConsolePublisher open()
Peach.Core.Publishers.ConsolePublisher output(905 bytes)
00000000   30 82 03 85 30 82 02 6D  A0 03 02 01 02 02 09 00
00000010   E2 5B 91 05 F2 8F AB AA  30 0D 06 09 2A 86 48 86
00000020   F7 0D 01 01 05 05 00 30  59 31 0B 30 09 06 03 55
00000030   04 06 13 02 55 53 31 13  30 11 06 03 55 04 08 0C
00000040   0A 57 61 73 68 69 6E 67  74 6F 6E 31 10 30 0E 06
00000050   03 55 04 07 0C 07 53 65  61 74 74 6C 65 31 0D 30
00000060   0B 06 03 55 04 0A 0C 04  44 65 6A 61 31 14 30 12
00000070   06 03 55 04 03 0C 0B 74  65 73 74 69 6E 67 2E 63
00000080   6F 6D 30 1E 17 0D 31 34  30 33 31 37 30 30 32 32
00000090   32 30 5A 17 0D 31 35 30  33 31 37 30 30 32 32 32
000000A0   30 5A 30 59 31 0B 30 09  06 03 55 04 06 13 02 55
000000B0   53 31 13 30 11 06 03 55  04 08 0C 0A 57 61 73 68
000000C0   69 6E 67 74 6F 6E 31 10  30 0E 06 03 55 04 07 0C
000000D0   07 53 65 61 74 74 6C 65  31 0D 30 0B 06 03 55 04
000000E0   0A 0C 04 44 65 6A 61 31  14 30 12 06 03 55 04 03
000000F0   0C 0B 74 65 73 74 69 6E  67 2E 63 6F 6D 30 82 01
00000100   22 30 0D 06 09 2A 86 48  86 F7 0D 01 01 01 05 00
00000110   03 82 01 0F 00 30 82 01  0A 02 82 01 01 00 A2 9F
00000120   5E 21 EE 45 4A 0A AB CB  D9 35 42 7C A9 5C 9C 59
00000130   8D 72 78 0A A0 49 63 C2  FE 36 42 9B 43 CC 05 41
00000140   49 26 3B 37 2D BC 10 10  B8 57 43 AF 6B 2B 7E 97
00000150   87 FC CB 00 EC 03 0B D6  58 55 71 C1 B0 6A 1D 38
00000160   9E EB 4C 5F D0 25 2E C6  20 AF 68 92 0E DB 8B 3D
00000170   97 61 89 3B 6A 0D 50 77  26 0A 60 0D 11 B3 82 F7
00000180   DF 30 8D F9 45 7F CD C0  88 B8 82 3F 24 A3 86 17
00000190   0E 19 60 E7 98 71 27 CE  63 49 F9 E0 95 47 E3 A6
000001A0   A6 CC 9B DB 19 92 C0 58  23 90 11 C1 A6 F5 34 02
000001B0   9A DD 09 FF D7 59 E7 E4  48 91 92 5C 17 EA 86 84
000001C0   1D A9 57 26 13 76 F4 F7  8F 29 5A 10 FD E4 BD AE
000001D0   E3 CC AD 5E 64 03 E7 B6  A1 48 0E 2A D2 6B 24 95
000001E0   EC 42 AE FB 79 B9 C0 9F  49 5C 2B 10 D8 A1 CE 44
000001F0   8C 89 97 9B 97 45 96 5D  24 C6 3E E6 79 9F 2B 25
00000200   4A C5 21 41 0B 55 18 90  15 A7 56 C1 69 A9 90 B2
00000210   73 C6 35 47 53 4D F4 88  6F D7 E2 59 90 DB 02 03
00000220   01 00 01 A3 50 30 4E 30  1D 06 03 55 1D 0E 04 16
00000230   04 14 36 F2 B5 D1 62 F1  F8 BF B7 1C F7 70 DD B6
00000240   D9 32 2E B6 99 5E 30 1F  06 03 55 1D 23 04 18 30
00000250   16 80 14 36 F2 B5 D1 62  F1 F8 BF B7 1C F7 70 DD
00000260   B6 D9 32 2E B6 99 5E 30  0C 06 03 55 1D 13 04 05
00000270   30 03 01 01 FF 30 0D 06  09 2A 86 48 86 F7 0D 01
00000280   01 05 05 00 03 82 01 01  00 4F C7 70 55 D7 74 7F
00000290   12 50 78 D1 14 77 4D 05  6C D3 5E 56 F2 84 1A D8
000002A0   BC 59 BC D3 B7 63 4D F3  5F 44 1C 2C 8C A9 66 89
000002B0   07 23 4D 5A 1D F8 C0 DD  E7 D2 38 9A 0F 1C 56 B6
000002C0   F9 FF 50 85 BA C6 09 2C  80 A6 A9 B0 47 ED 9B DF
000002D0   8E 53 B6 DB 4A 4A 05 58  DC 7E 98 E5 DF B0 C7 6B
000002E0   A2 01 67 DA AE 6A 1E 26  8D 33 B0 17 BD 5D C3 B6
000002F0   12 D5 80 A8 16 CA B6 A2  AF DD D1 80 32 89 6E 1A
00000300   7A C3 9F 7A 15 1F 35 36  EC 85 D6 B2 84 91 AD 8D
00000310   7D 40 51 8B 5A 3B 5D C9  89 9D 74 13 77 86 7A ED
00000320   59 60 89 D0 35 71 07 3E  84 2B 44 5D 26 D3 19 EE
00000330   92 F9 49 FF C9 76 BA 43  6B A7 A9 0C 2C A1 6D C3
00000340   0B 98 AB 92 99 3C C8 76  DE 7D 14 50 45 68 84 7F
00000350   E9 B0 FE 90 7B 10 A7 9C  9A 40 9F 0A 49 B5 0D 0C
00000360   86 21 9B F3 49 B1 9E 55  88 9B 76 6F DC 00 F5 35
00000370   11 A0 F2 EB 49 9D 8C 5A  78 2F 98 CB FE 77 E8 C2
00000380   91 95 FA C4 87 88 E3 F5  D7
Peach.Core.Publishers.ConsolePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.ConsolePublisher stop()

[*] Test 'Default' finished.</screen>
<simpara>Output in Peach Validator</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/DevGuide/Analyzers/Asn1_Output.png"/>
</imageobject>
<textobject><phrase>Asn1 Output</phrase></textobject>
</mediaobject>
</informalfigure>
</example>
<example>
<title>Certificate From File Example</title>
<simpara>This example uses the Asn.1 analyzer on an external file of Blob data (Cert.der).</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach ../peach.xsd"&gt;

	&lt;DataModel name="TheModel"&gt;
		&lt;Blob&gt;
			&lt;Analyzer class="Asn1" /&gt;
		&lt;/Blob&gt;
	&lt;/DataModel&gt;

	&lt;StateModel name="TheState" initialState="initial"&gt;
		&lt;State name="initial"&gt;
			&lt;Action type="output"&gt;
				&lt;DataModel ref="TheModel" /&gt;
				&lt;Data name="Cert" fileName="Cert.der"/&gt;
			&lt;/Action&gt;
		&lt;/State&gt;
	&lt;/StateModel&gt;

	&lt;Test name="Default"&gt;
		&lt;StateModel ref="TheState"/&gt;
		&lt;Publisher class="ConsoleHex" /&gt;
	&lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Output from the Blob data file example.</simpara>
<screen>&gt; peach -1 --debug example.xml

[*] Test 'Default' starting with random seed 18200.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker DataModel 'TheModel' Bytes: 0/905, Bits: 0/7240
Peach.Core.Cracker.DataCracker getSize: -----&gt; DataModel 'TheModel'
Peach.Core.Cracker.DataCracker scan: DataModel 'TheModel'
Peach.Core.Cracker.DataCracker scan: Blob 'TheModel.DataElement_0' -&gt; Offset: 0
 Unsized element
Peach.Core.Cracker.DataCracker getSize: &lt;----- Deterministic: ???
Peach.Core.Cracker.DataCracker Crack: DataModel 'TheModel' Size: &lt;null&gt;, Bytes:
0/905, Bits: 0/7240
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker Blob 'TheModel.DataElement_0' Bytes: 0/905, Bits
 0/7240
Peach.Core.Cracker.DataCracker getSize: -----&gt; Blob 'TheModel.DataElement_0'
Peach.Core.Cracker.DataCracker scan: Blob 'TheModel.DataElement_0' -&gt; Offset: 0
 Unsized element
Peach.Core.Cracker.DataCracker lookahead: Blob 'TheModel.DataElement_0'
Peach.Core.Cracker.DataCracker getSize: &lt;----- Last Unsized: 7240
Peach.Core.Cracker.DataCracker Crack: Blob 'TheModel.DataElement_0' Size: 7240,
Bytes: 0/905, Bits: 0/7240
Peach.Core.Dom.DataElement Blob 'TheModel.DataElement_0' value is: 30 82 03 85
0 82 02 6d a0 03 02 01 02 02 09 00 e2 5b 91 05 f2 8f ab aa 30 0d 06 09 2a 86 48
86.. (Len: 905 bytes)
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher start()
Peach.Core.Publishers.ConsolePublisher open()
Peach.Core.Publishers.ConsolePublisher output(905 bytes)
00000000   30 82 03 85 30 82 02 6D  A0 03 02 01 02 02 09 00
00000010   E2 5B 91 05 F2 8F AB AA  30 0D 06 09 2A 86 48 86
00000020   F7 0D 01 01 05 05 00 30  59 31 0B 30 09 06 03 55
00000030   04 06 13 02 55 53 31 13  30 11 06 03 55 04 08 0C
00000040   0A 57 61 73 68 69 6E 67  74 6F 6E 31 10 30 0E 06
00000050   03 55 04 07 0C 07 53 65  61 74 74 6C 65 31 0D 30
00000060   0B 06 03 55 04 0A 0C 04  44 65 6A 61 31 14 30 12
00000070   06 03 55 04 03 0C 0B 74  65 73 74 69 6E 67 2E 63
00000080   6F 6D 30 1E 17 0D 31 34  30 33 31 37 30 30 32 32
00000090   32 30 5A 17 0D 31 35 30  33 31 37 30 30 32 32 32
000000A0   30 5A 30 59 31 0B 30 09  06 03 55 04 06 13 02 55
000000B0   53 31 13 30 11 06 03 55  04 08 0C 0A 57 61 73 68
000000C0   69 6E 67 74 6F 6E 31 10  30 0E 06 03 55 04 07 0C
000000D0   07 53 65 61 74 74 6C 65  31 0D 30 0B 06 03 55 04
000000E0   0A 0C 04 44 65 6A 61 31  14 30 12 06 03 55 04 03
000000F0   0C 0B 74 65 73 74 69 6E  67 2E 63 6F 6D 30 82 01
00000100   22 30 0D 06 09 2A 86 48  86 F7 0D 01 01 01 05 00
00000110   03 82 01 0F 00 30 82 01  0A 02 82 01 01 00 A2 9F
00000120   5E 21 EE 45 4A 0A AB CB  D9 35 42 7C A9 5C 9C 59
00000130   8D 72 78 0A A0 49 63 C2  FE 36 42 9B 43 CC 05 41
00000140   49 26 3B 37 2D BC 10 10  B8 57 43 AF 6B 2B 7E 97
00000150   87 FC CB 00 EC 03 0B D6  58 55 71 C1 B0 6A 1D 38
00000160   9E EB 4C 5F D0 25 2E C6  20 AF 68 92 0E DB 8B 3D
00000170   97 61 89 3B 6A 0D 50 77  26 0A 60 0D 11 B3 82 F7
00000180   DF 30 8D F9 45 7F CD C0  88 B8 82 3F 24 A3 86 17
00000190   0E 19 60 E7 98 71 27 CE  63 49 F9 E0 95 47 E3 A6
000001A0   A6 CC 9B DB 19 92 C0 58  23 90 11 C1 A6 F5 34 02
000001B0   9A DD 09 FF D7 59 E7 E4  48 91 92 5C 17 EA 86 84
000001C0   1D A9 57 26 13 76 F4 F7  8F 29 5A 10 FD E4 BD AE
000001D0   E3 CC AD 5E 64 03 E7 B6  A1 48 0E 2A D2 6B 24 95
000001E0   EC 42 AE FB 79 B9 C0 9F  49 5C 2B 10 D8 A1 CE 44
000001F0   8C 89 97 9B 97 45 96 5D  24 C6 3E E6 79 9F 2B 25
00000200   4A C5 21 41 0B 55 18 90  15 A7 56 C1 69 A9 90 B2
00000210   73 C6 35 47 53 4D F4 88  6F D7 E2 59 90 DB 02 03
00000220   01 00 01 A3 50 30 4E 30  1D 06 03 55 1D 0E 04 16
00000230   04 14 36 F2 B5 D1 62 F1  F8 BF B7 1C F7 70 DD B6
00000240   D9 32 2E B6 99 5E 30 1F  06 03 55 1D 23 04 18 30
00000250   16 80 14 36 F2 B5 D1 62  F1 F8 BF B7 1C F7 70 DD
00000260   B6 D9 32 2E B6 99 5E 30  0C 06 03 55 1D 13 04 05
00000270   30 03 01 01 FF 30 0D 06  09 2A 86 48 86 F7 0D 01
00000280   01 05 05 00 03 82 01 01  00 4F C7 70 55 D7 74 7F
00000290   12 50 78 D1 14 77 4D 05  6C D3 5E 56 F2 84 1A D8
000002A0   BC 59 BC D3 B7 63 4D F3  5F 44 1C 2C 8C A9 66 89
000002B0   07 23 4D 5A 1D F8 C0 DD  E7 D2 38 9A 0F 1C 56 B6
000002C0   F9 FF 50 85 BA C6 09 2C  80 A6 A9 B0 47 ED 9B DF
000002D0   8E 53 B6 DB 4A 4A 05 58  DC 7E 98 E5 DF B0 C7 6B
000002E0   A2 01 67 DA AE 6A 1E 26  8D 33 B0 17 BD 5D C3 B6
000002F0   12 D5 80 A8 16 CA B6 A2  AF DD D1 80 32 89 6E 1A
00000300   7A C3 9F 7A 15 1F 35 36  EC 85 D6 B2 84 91 AD 8D
00000310   7D 40 51 8B 5A 3B 5D C9  89 9D 74 13 77 86 7A ED
00000320   59 60 89 D0 35 71 07 3E  84 2B 44 5D 26 D3 19 EE
00000330   92 F9 49 FF C9 76 BA 43  6B A7 A9 0C 2C A1 6D C3
00000340   0B 98 AB 92 99 3C C8 76  DE 7D 14 50 45 68 84 7F
00000350   E9 B0 FE 90 7B 10 A7 9C  9A 40 9F 0A 49 B5 0D 0C
00000360   86 21 9B F3 49 B1 9E 55  88 9B 76 6F DC 00 F5 35
00000370   11 A0 F2 EB 49 9D 8C 5A  78 2F 98 CB FE 77 E8 C2
00000380   91 95 FA C4 87 88 E3 F5  D7
Peach.Core.Publishers.ConsolePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.ConsolePublisher stop()

[*] Test 'Default' finished.</screen>
<simpara>Output in Peach Validator</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/DevGuide/Analyzers/Asn1_Output.png"/>
</imageobject>
<textobject><phrase>Asn1 Output</phrase></textobject>
</mediaobject>
</informalfigure>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Analyzers_Binary">
<title>Binary Analyzer</title>
<simpara>The Binary analyzer applies to Blob data elements and provides an easy way to improve fuzzing of unknown binary data.</simpara>
<simpara>The analyzer searches for known types (such as strings) in the Blob data and constructs a DataModel of the Blob. If a string type occurs in the Blob data, Peach runs the StringToken analyzer on each string found.</simpara>
<important>
<simpara>The Binary analyzer requires data from a Blob data type.</simpara>
</important>
<section xml:id="_syntax_32">
<title>Syntax</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;Blob name="BinaryData"&gt;
	&lt;Analyzer class="Binary" /&gt;
&lt;/Blob&gt;</programlisting>
</section>
<section xml:id="_attributes_17">
<title>Attributes</title>
<simpara><emphasis>Required:</emphasis></simpara>
<simpara>None.</simpara>
<simpara><emphasis>Optional:</emphasis></simpara>
<simpara>None.</simpara>
</section>
<section xml:id="_parameters_7">
<title>Parameters</title>
<variablelist>
<varlistentry>
<term>Tokens</term>
<listitem>
<simpara>List of characters to pass to the StringToken analyzer.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>AnalyzeStrings</term>
<listitem>
<simpara>Calls the StringToken analyzer on string elements. The default value is true.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_18">
<title>Examples</title>
<example>
<title>Simple Hello World Example</title>
<simpara>This example uses the binary analyzer on inline Blob data.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://peachfuzzer.com/2012/Peach ../peach.xsd"&gt;

	&lt;DataModel name="TheModel"&gt;
		&lt;Blob valueType="hex" value="54 65 73 74 69 6E 67 20 48 65 6C 6C 6F 57 6F 72 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F 50 65 61 63 68 46 75 7A 7A 65 72 21 FF AA BB CC"&gt;
			&lt;Analyzer class="Binary" /&gt;
		&lt;/Blob&gt;
	&lt;/DataModel&gt;

	&lt;StateModel name="TheState" initialState="initial"&gt;
		&lt;State name="initial"&gt;
			&lt;Action type="output"&gt;
				&lt;DataModel ref="TheModel" /&gt;
			&lt;/Action&gt;
		&lt;/State&gt;
	&lt;/StateModel&gt;

	&lt;Test name="Default"&gt;
		&lt;StateModel ref="TheState"/&gt;
		&lt;Publisher class="ConsoleHex" /&gt;
	&lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Output from the inline Blob data example.</simpara>
<screen>&gt; peach -1 --debug example.xml

Peach.Core.Analyzers.Binary Created 12 data elements from binary data.
Peach.Core.Analyzers.Binary Created 12 data elements from binary data.

[*] Test 'Default' starting with random seed 61927.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher start()
Peach.Core.Publishers.ConsolePublisher open()
Peach.Core.Publishers.ConsolePublisher output(48 bytes)
00000000   54 65 73 74 69 6E 67 20  48 65 6C 6C 6F 57 6F 72   Testing HelloWor
00000010   00 01 02 03 04 05 06 07  08 09 0A 0B 0C 0D 0E 0F   ????????????????
00000020   50 65 61 63 68 46 75 7A  7A 65 72 21 FF AA BB CC   PeachFuzzer!????
Peach.Core.Publishers.ConsolePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.ConsolePublisher stop()

[*] Test 'Default' finished.</screen>
<simpara>Output in Peach Validator</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/DevGuide/Analyzers/Binary_Output.png"/>
</imageobject>
<textobject><phrase>Binary Output</phrase></textobject>
</mediaobject>
</informalfigure>
</example>
<example>
<title>Load From File Example</title>
<simpara>This example uses the binary analyzer on an external file of Blob data (example.bin).</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://peachfuzzer.com/2012/Peach ../peach.xsd"&gt;

	&lt;DataModel name="TheModel"&gt;
		&lt;Blob name="BinaryData"&gt;
			&lt;Analyzer class="Binary" /&gt;
		&lt;/Blob&gt;
	&lt;/DataModel&gt;

	&lt;StateModel name="TheState" initialState="initial"&gt;
		&lt;State name="initial"&gt;
			&lt;Action type="output"&gt;
				&lt;DataModel ref="TheModel" /&gt;
				&lt;Data name="SampleData1" fileName="example.bin"/&gt;
			&lt;/Action&gt;
		&lt;/State&gt;
	&lt;/StateModel&gt;

	&lt;Test name="Default"&gt;
		&lt;StateModel ref="TheState"/&gt;
		&lt;Publisher class="ConsoleHex" /&gt;
	&lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Output from the Blob data file example.</simpara>
<screen>&gt; peach -1 --debug example.xml

[*] Test 'Default' starting with random seed 48471.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker DataModel 'TheModel' Bytes: 0/48, Bits: 0/384
Peach.Core.Cracker.DataCracker getSize: -----&gt; DataModel 'TheModel'
Peach.Core.Cracker.DataCracker scan: DataModel 'TheModel'
Peach.Core.Cracker.DataCracker scan: Blob 'TheModel.BinaryData' -&gt; Offset: 0, Un
sized element
Peach.Core.Cracker.DataCracker getSize: &lt;----- Deterministic: ???
Peach.Core.Cracker.DataCracker Crack: DataModel 'TheModel' Size: &lt;null&gt;, Bytes:
0/48, Bits: 0/384
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker Blob 'TheModel.BinaryData' Bytes: 0/48, Bits: 0/3
84
Peach.Core.Cracker.DataCracker getSize: -----&gt; Blob 'TheModel.BinaryData'
Peach.Core.Cracker.DataCracker scan: Blob 'TheModel.BinaryData' -&gt; Offset: 0, Un
sized element
Peach.Core.Cracker.DataCracker lookahead: Blob 'TheModel.BinaryData'
Peach.Core.Cracker.DataCracker getSize: &lt;----- Last Unsized: 384
Peach.Core.Cracker.DataCracker Crack: Blob 'TheModel.BinaryData' Size: 384, Byte
s: 0/48, Bits: 0/384
Peach.Core.Dom.DataElement Blob 'TheModel.BinaryData' value is: 54 65 73 74 69 6
e 67 20 48 65 6c 6c 6f 57 6f 72 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f.
. (Len: 48 bytes)
Peach.Core.Analyzers.Binary Created 12 data elements from binary data.
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher start()
Peach.Core.Publishers.ConsolePublisher open()
Peach.Core.Publishers.ConsolePublisher output(48 bytes)
00000000   54 65 73 74 69 6E 67 20  48 65 6C 6C 6F 57 6F 72   Testing HelloWor
00000010   00 01 02 03 04 05 06 07  08 09 0A 0B 0C 0D 0E 0F   ????????????????
00000020   50 65 61 63 68 46 75 7A  7A 65 72 21 FF AA BB CC   PeachFuzzer!????
Peach.Core.Publishers.ConsolePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.ConsolePublisher stop()

[*] Test 'Default' finished.</screen>
<simpara>Output in Peach Validator</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/DevGuide/Analyzers/Binary_Output.png"/>
</imageobject>
<textobject><phrase>Binary Output</phrase></textobject>
</mediaobject>
</informalfigure>
</example>
<example>
<title>Custom String Tokens Example</title>
<simpara>This example uses the binary analyzer on a value with a custom set of tokens defined.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://peachfuzzer.com/2012/Peach ../peach.xsd"&gt;

  &lt;DataModel name="TheModel"&gt;
    &lt;Blob name="BinaryData" valueType="hex" value="28 54 65 73 74 69 6E 67 20 48 65 6C 6C 6F 57 29 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F 7B 50 65 61 63 68 46 75 7A 7A 65 72 7D BB CC "&gt;
      &lt;Analyzer class="Binary"&gt;
        &lt;Param name="Tokens" value="(){}"/&gt;
      &lt;/Analyzer&gt;
    &lt;/Blob&gt;
  &lt;/DataModel&gt;

  &lt;StateModel name="TheState" initialState="initial"&gt;
    &lt;State name="initial"&gt;
      &lt;Action type="output"&gt;
        &lt;DataModel ref="TheModel" /&gt;
      &lt;/Action&gt;
    &lt;/State&gt;
  &lt;/StateModel&gt;

  &lt;Test name="Default"&gt;
    &lt;StateModel ref="TheState"/&gt;
    &lt;Publisher class="ConsoleHex" /&gt;
  &lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Output from the example that uses custom tokens.</simpara>
<screen>&gt; peach -1 --debug example.xml

Peach.Core.Analyzers.Binary Created 18 data elements from binary data.
Peach.Core.Analyzers.Binary Created 18 data elements from binary data.

[*] Test 'Default' starting with random seed 9875.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher start()
Peach.Core.Publishers.ConsolePublisher open()
Peach.Core.Publishers.ConsolePublisher output(47 bytes)
00000000   28 54 65 73 74 69 6E 67  20 48 65 6C 6C 6F 57 29   (Testing HelloW)
00000010   00 01 02 03 04 05 06 07  08 09 0A 0B 0C 0D 0E 0F   ????????????????
00000020   7B 50 65 61 63 68 46 75  7A 7A 65 72 7D BB CC      {PeachFuzzer}??
Peach.Core.Publishers.ConsolePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.ConsolePublisher stop()

[*] Test 'Default' finished.</screen>
<simpara>Output in Peach Validator</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/DevGuide/Analyzers/Binary_TokensOutput.png"/>
</imageobject>
<textobject><phrase>Binary TokensOutput</phrase></textobject>
</mediaobject>
</informalfigure>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Analyzers_Bson">
<title>BSON Analyzer</title>
<simpara>This analyzer converts BSON documented into data models.</simpara>
<simpara>When used in the DataModel section of a Peach Pit, the Fuzzer walks the BSON data and creates the appropriate elements.</simpara>
<simpara>When used from the command line, the Fuzzer walks the BSON data, creates the appropriate elements, and saves the results of the generated model to disk. Once saved, the results can be added to a PIT or serve as the basis for a new PIT.</simpara>
<important>
<simpara>The BSON analyzer requires data from a Blob data type.</simpara>
</important>
<section xml:id="_syntax_33">
<title>Syntax</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;Blob name="BsonData"&gt;
	&lt;Analyzer class="Bson" /&gt;
&lt;/Blob&gt;</programlisting>
<screen>pittool analyzer Bson input.bin output.xml</screen>
</section>
<section xml:id="_command_line_syntax_2">
<title>Command Line Syntax</title>
<screen>pittool analyzer Bson &lt;input file&gt; &lt;output file&gt;</screen>
<variablelist>
<varlistentry>
<term>input file</term>
<listitem>
<simpara>File containing BSON encoded data.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>output file</term>
<listitem>
<simpara>File creating containing generated data model</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_attributes_18">
<title>Attributes</title>
<simpara><emphasis>Required:</emphasis></simpara>
<simpara>There are no required attributes.</simpara>
<simpara><emphasis>Optional:</emphasis></simpara>
<simpara>There are no optional attributes.</simpara>
</section>
<section xml:id="_examples_19">
<title>Examples</title>
<example>
<title>BSON Inline Example</title>
<simpara>This example uses the BSON analyzer on inline data.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach ../peach.xsd"&gt;

	&lt;DataModel name="TheModel"&gt;
		&lt;Blob valueType="hex" value='\x16\x00\x00\x00\x02\x68\x65\x6c\x6c\x6f\x00\x06\x00\x00\x00\x77\x6f\x72\x6c\x64\x00\x00'&gt;
			&lt;Analyzer class="Bson" /&gt;
		&lt;/Blob&gt;
	&lt;/DataModel&gt;

	&lt;StateModel name="TheState" initialState="initial"&gt;
		&lt;State name="initial"&gt;
			&lt;Action type="output"&gt;
				&lt;DataModel ref="TheModel" /&gt;
			&lt;/Action&gt;
		&lt;/State&gt;
	&lt;/StateModel&gt;

	&lt;Test name="Default"&gt;
		&lt;StateModel ref="TheState"/&gt;
		&lt;Publisher class="ConsoleHex" /&gt;
	&lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Output from inline example.</simpara>
<screen>&gt; peach -1 --debug example.xml

[*] Test 'Default' starting with random seed 49484.
2018-03-28 12:36:39.4049 Peach.Core.Engine runTest: Iteration Starting: 1,  =============================

[R1,-,-] Performing iteration
2018-03-28 12:36:39.4370 Peach.Core.Engine runTest: Performing control recording iteration.
2018-03-28 12:36:39.5127 Peach.Core.Dom.StateModel Run(): Changing to state "initial".
2018-03-28 12:36:39.5192 Peach.Core.Dom.Action Run(Action): Output
2018-03-28 12:36:39.6926 Peach.Pro.Core.Publishers.ConsolePublisher start()
2018-03-28 12:36:39.6926 Peach.Pro.Core.Publishers.ConsolePublisher open()
2018-03-28 12:36:39.6926 Peach.Pro.Core.Publishers.ConsolePublisher output(22 bytes)
00000000   16 00 00 00 02 68 65 6C  6C 6F 00 06 00 00 00 77   .....hello.....w
00000010   6F 72 6C 64 00 00                                  orld..
2018-03-28 12:36:39.6926 Peach.Pro.Core.Publishers.ConsolePublisher close()
2018-03-28 12:36:39.7086 Peach.Core.Engine runTest: context.config.singleIteration == true
2018-03-28 12:36:39.7086 Peach.Core.Engine All test cases executed, stopping engine.
2018-03-28 12:36:39.7086 Peach.Pro.Core.Publishers.ConsolePublisher stop()
2018-03-28 12:36:39.7086 Peach.Core.Engine EndTest: Stopping all agents and monitors

[*] Test 'Default' finished.</screen>
</example>
<simpara>This example uses the BSON analyzer on an external file containing BSON encoded data.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach ../peach.xsd"&gt;

	&lt;DataModel name="TheModel"&gt;
		&lt;Blob&gt;
			&lt;Analyzer class="Bson" /&gt;
		&lt;/Blob&gt;
	&lt;/DataModel&gt;

	&lt;StateModel name="TheState" initialState="initial"&gt;
		&lt;State name="initial"&gt;
			&lt;Action type="output"&gt;
				&lt;DataModel ref="TheModel" /&gt;
				&lt;Data fileName="example.bson"/&gt;
			&lt;/Action&gt;
		&lt;/State&gt;
	&lt;/StateModel&gt;

	&lt;Test name="Default"&gt;
		&lt;StateModel ref="TheState"/&gt;
		&lt;Publisher class="ConsoleHex" /&gt;
	&lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Output from BSON data file example.</simpara>
<screen>&gt; peach -1 --debug example.xml

[*] Test 'Default' starting with random seed 36094.
2018-03-28 12:41:03.4793 Peach.Core.Engine runTest: Iteration Starting: 1,  =============================

[R1,-,-] Performing iteration
2018-03-28 12:41:03.5129 Peach.Core.Engine runTest: Performing control recording iteration.
2018-03-28 12:41:03.5329 DataCracker -+ DataModel 'TheModel', Bytes: 0/22, Bits: 0/176
2018-03-28 12:41:03.5329 DataCracker  | Size: ??? (Deterministic)
2018-03-28 12:41:03.5329 DataCracker  |-- Blob 'DataElement_0', Bytes: 0/22, Bits: 0/176
2018-03-28 12:41:03.5464 DataCracker  |   Size: 22 bytes | 176 bits (Last Unsized)
2018-03-28 12:41:03.5464 DataCracker  |   Value: 16 00 00 00 02 68 65 6c 6c 6f 00 06 00 00 00 77 6f 72 6c 64 00 00
2018-03-28 12:41:03.5464 DataCracker  /
2018-03-28 12:41:03.6427 Peach.Core.Dom.StateModel Run(): Changing to state "initial".
2018-03-28 12:41:03.6427 Peach.Core.Dom.Action Run(Action): Output
2018-03-28 12:41:03.7630 Peach.Pro.Core.Publishers.ConsolePublisher start()
2018-03-28 12:41:03.7630 Peach.Pro.Core.Publishers.ConsolePublisher open()
2018-03-28 12:41:03.7655 Peach.Pro.Core.Publishers.ConsolePublisher output(22 bytes)
00000000   16 00 00 00 02 68 65 6C  6C 6F 00 06 00 00 00 77   .....hello.....w
00000010   6F 72 6C 64 00 00                                  orld..
2018-03-28 12:41:03.7655 Peach.Pro.Core.Publishers.ConsolePublisher close()
2018-03-28 12:41:03.7655 Peach.Core.Engine runTest: context.config.singleIteration == true
2018-03-28 12:41:03.7655 Peach.Core.Engine All test cases executed, stopping engine.
2018-03-28 12:41:03.7806 Peach.Pro.Core.Publishers.ConsolePublisher stop()
2018-03-28 12:41:03.7806 Peach.Core.Engine EndTest: Stopping all agents and monitors

[*] Test 'Default' finished.</screen>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Analyzers_Json">
<title>JSON Analyzer</title>
<simpara>This analyzer converts JSON strings into a full data model.</simpara>
<simpara>When used in the DataModel section of a Peach Pit, the Fuzzer walks the JSON data and creates the appropriate elements.</simpara>
<simpara>When used from the command line, the Fuzzer walks the JSON data, creates the appropriate elements, and saves the results of the generated model to disk. Once saved, you can use and modify the results as needed.</simpara>
<important>
<simpara>The JSON analyzer requires data from a String data type.</simpara>
</important>
<section xml:id="_syntax_34">
<title>Syntax</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;String name="JsonData"&gt;
	&lt;Analyzer class="Json" /&gt;
&lt;/String&gt;</programlisting>
<screen>pittool analyzer Json input.txt output.xml</screen>
</section>
<section xml:id="_command_line_syntax_3">
<title>Command Line Syntax</title>
<screen>pittool analyzer Json &lt;input file&gt; &lt;output file&gt;</screen>
<variablelist>
<varlistentry>
<term>input file</term>
<listitem>
<simpara>File containing JSON encoded data.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>output file</term>
<listitem>
<simpara>File creating containing generated data model</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_attributes_19">
<title>Attributes</title>
<simpara><emphasis>Required:</emphasis></simpara>
<simpara>There are no required attributes.</simpara>
<simpara><emphasis>Optional:</emphasis></simpara>
<simpara>There are no optional attributes.</simpara>
</section>
<section xml:id="_examples_20">
<title>Examples</title>
<example>
<title>JSON Inline Example</title>
<simpara>This example uses the JSON analyzer on inline data.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach ../peach.xsd"&gt;

	&lt;DataModel name="TheModel"&gt;
		&lt;String value='{"Foo":["Bar",1,null],"Null":null,"Bool":false,"Obj":{"Num":1,"Str":"StringValue"},"Double":1.2}'&gt;
			&lt;Analyzer class="Json" /&gt;
		&lt;/String&gt;
	&lt;/DataModel&gt;

	&lt;StateModel name="TheState" initialState="initial"&gt;
		&lt;State name="initial"&gt;
			&lt;Action type="output"&gt;
				&lt;DataModel ref="TheModel" /&gt;
			&lt;/Action&gt;
		&lt;/State&gt;
	&lt;/StateModel&gt;

	&lt;Test name="Default"&gt;
		&lt;StateModel ref="TheState"/&gt;
		&lt;Publisher class="ConsoleHex" /&gt;
	&lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Output from inline example.</simpara>
<screen>&gt; peach -1 --debug example.xml

[*] Test 'Default' starting with random seed 56481.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.StateModel Run(): Changing to state "initial".
Peach.Core.Dom.Action Run(Action): Output
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Publishers.ConsolePublisher start()
Peach.Core.Publishers.ConsolePublisher open()
Peach.Core.Publishers.ConsolePublisher output(96 bytes)
00000000   7B 22 46 6F 6F 22 3A 5B  22 42 61 72 22 2C 31 2C   {"Foo":["Bar",1,
00000010   6E 75 6C 6C 5D 2C 22 4E  75 6C 6C 22 3A 6E 75 6C   null],"Null":nul
00000020   6C 2C 22 42 6F 6F 6C 22  3A 66 61 6C 73 65 2C 22   l,"Bool":false,"
00000030   4F 62 6A 22 3A 7B 22 4E  75 6D 22 3A 31 2C 22 53   Obj":{"Num":1,"S
00000040   74 72 22 3A 22 53 74 72  69 6E 67 56 61 6C 75 65   tr":"StringValue
00000050   22 7D 2C 22 44 6F 75 62  6C 65 22 3A 31 2E 32 7D   "},"Double":1.2}
Peach.Core.Publishers.ConsolePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.ConsolePublisher stop()

[*] Test 'Default' finished.</screen>
</example>
<simpara>This example uses the JSON analyzer on an external file containing JSON encoded data.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach ../peach.xsd"&gt;

	&lt;DataModel name="TheModel"&gt;
		&lt;String&gt;
			&lt;Analyzer class="Json" /&gt;
		&lt;/String&gt;
	&lt;/DataModel&gt;

	&lt;StateModel name="TheState" initialState="initial"&gt;
		&lt;State name="initial"&gt;
			&lt;Action type="output"&gt;
				&lt;DataModel ref="TheModel" /&gt;
				&lt;Data name="Json" fileName="json.json"/&gt;
			&lt;/Action&gt;
		&lt;/State&gt;
	&lt;/StateModel&gt;

	&lt;Test name="Default"&gt;
		&lt;StateModel ref="TheState"/&gt;
		&lt;Publisher class="ConsoleHex" /&gt;
	&lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Output from JSON data file example.</simpara>
<screen>&gt; peach -1 --debug example.xml

[*] Test 'Default' starting with random seed 33175.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker DataModel 'TheModel' Bytes: 0/96, Bits: 0/768
Peach.Core.Cracker.DataCracker getSize: -----&gt; DataModel 'TheModel'
Peach.Core.Cracker.DataCracker scan: DataModel 'TheModel'
Peach.Core.Cracker.DataCracker scan: String 'TheModel.DataElement_0' -&gt; Offset: 0, Unsized element
Peach.Core.Cracker.DataCracker getSize: &lt;----- Deterministic: ???
Peach.Core.Cracker.DataCracker Crack: DataModel 'TheModel' Size: &lt;null&gt;, Bytes: 0/96, Bits: 0/768
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker String 'TheModel.DataElement_0' Bytes: 0/96, Bits: 0/768
Peach.Core.Cracker.DataCracker getSize: -----&gt; String 'TheModel.DataElement_0'
Peach.Core.Cracker.DataCracker scan: String 'TheModel.DataElement_0' -&gt; Offset: 0, Unsized element
Peach.Core.Cracker.DataCracker lookahead: String 'TheModel.DataElement_0'
Peach.Core.Cracker.DataCracker getSize: &lt;----- Last Unsized: 768
Peach.Core.Cracker.DataCracker Crack: String 'TheModel.DataElement_0' Size: 768, Bytes: 0/96, Bits: 0/768
Peach.Core.Dom.DataElement String 'TheModel.DataElement_0' value is: {"Foo":["Bar",1,null],"Null":null,"Bool":false,"Obj":{"Num":1,"S.. (Len: 96 chars)
Peach.Core.Dom.StateModel Run(): Changing to state "initial".
Peach.Core.Dom.Action Run(Action): Output
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Publishers.ConsolePublisher start()
Peach.Core.Publishers.ConsolePublisher open()
Peach.Core.Publishers.ConsolePublisher output(96 bytes)
00000000   7B 22 46 6F 6F 22 3A 5B  22 42 61 72 22 2C 31 2C   {"Foo":["Bar",1,
00000010   6E 75 6C 6C 5D 2C 22 4E  75 6C 6C 22 3A 6E 75 6C   null],"Null":nul
00000020   6C 2C 22 42 6F 6F 6C 22  3A 66 61 6C 73 65 2C 22   l,"Bool":false,"
00000030   4F 62 6A 22 3A 7B 22 4E  75 6D 22 3A 31 2C 22 53   Obj":{"Num":1,"S
00000040   74 72 22 3A 22 53 74 72  69 6E 67 56 61 6C 75 65   tr":"StringValue
00000050   22 7D 2C 22 44 6F 75 62  6C 65 22 3A 31 2E 32 7D   "},"Double":1.2}
Peach.Core.Publishers.ConsolePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.ConsolePublisher stop()

[*] Test 'Default' finished.</screen>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Analyzers_Postman">
<title>Postman Analyzer</title>
<simpara>This analyzer converts Postman Collections into Peach Pits for fuzzing WebApi style web service endpoints.</simpara>
<simpara><link xl:href="https://www.getpostman.com">Postman</link> is a popular app used during development and testing of WebApi style web services. APIs are organized into Collections which can be converted into fuzzers using this analyzer.</simpara>
<simpara>After converting, some manual work is usually needed to have a fully working pit.  This includes:</simpara>
<itemizedlist>
<listitem>
<simpara>Hooking up any authentication/authorization</simpara>
</listitem>
<listitem>
<simpara>Adding slurps for resource identifiers</simpara>
</listitem>
<listitem>
<simpara>Adding cleanup states to remove created resources</simpara>
</listitem>
<listitem>
<simpara>Testing to verify it all works</simpara>
</listitem>
</itemizedlist>
<note>
<simpara>This analyzer is intended to always be run from the command line.</simpara>
</note>
<section xml:id="_syntax_35">
<title>Syntax</title>
<screen>pittool analyzer Postman catalog.json web_api_pit.xml</screen>
</section>
<section xml:id="_command_line_syntax_4">
<title>Command Line Syntax</title>
<screen>pittool analyzer Postman &lt;input file&gt; &lt;output file&gt;</screen>
<variablelist>
<varlistentry>
<term>input file</term>
<listitem>
<simpara>Postman Catalog file to covnert</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>output file</term>
<listitem>
<simpara>Generated PIT file</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_attributes_20">
<title>Attributes</title>
<simpara><emphasis>Required:</emphasis></simpara>
<simpara>There are no required attributes.</simpara>
<simpara><emphasis>Optional:</emphasis></simpara>
<simpara>There are no optional attributes.</simpara>
</section>
<section xml:id="_examples_21">
<title>Examples</title>
<simpara>No examples.</simpara>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Analyzers_Regex">
<title>Regex Analyzer</title>
<simpara>The Regex Analyzer parses a string and breaks it into substrings using a regular expression to define parsing details. This analyzer provides a quick way to parse string-based data.</simpara>
<simpara>A regular expression provides a pattern that the parser attempts to match while walking through the input string data. A pattern can consist of a single specification. Or, a pattern can consist of groups where each group describes a substring or a part of the overall pattern. With Peach, if a group is named, you can optionally name the corresponding substring.</simpara>
<simpara>When used in the DataModel section of a Peach Pit, the Fuzzer walks the input string data and creates the appropriate substrings.</simpara>
<simpara>When used from the command line, the Fuzzer walks the input string data, creates the appropriate substrings, and saves the results of the generated model to disk. Once saved, you can use and modify the results as needed.</simpara>
<note>
<simpara>The regular expression syntax is consistent with the regular expression parser used by Microsoft.NET. For more information, see the <link xl:href="http://msdn.microsoft.com/en-us/library/az24scfc(v=vs.110).aspx">quick reference</link>.</simpara>
</note>
<section xml:id="_syntax_36">
<title>Syntax</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;String name="Value" value="http://www.google.com/q?q=kitty"&gt;
  &lt;Analyzer class="Regex"&gt;
    &lt;!-- (?&lt;protocol&gt;\w+)(://)(?&lt;host&gt;[^/?]+)(?&lt;path&gt;[^?]+)(\?)(?&lt;query&gt;.*) --&gt;
    &lt;Param name="Regex" value="(?&amp;lt;protocol&amp;gt;\w+)(://)(?&amp;lt;host&amp;gt;[^/?]+)(?&amp;lt;path&amp;gt;[^?]+)(\?)(?&amp;lt;query&amp;gt;.*)"/&gt;
  &lt;/Analyzer&gt;
&lt;/String&gt;</programlisting>
<screen>pittool analyzer Regex "(\w+)(.)" input.txt output.xml</screen>
</section>
<section xml:id="_command_line_syntax_5">
<title>Command Line Syntax</title>
<screen>pittool analyzer Regex &lt;regex&gt; &lt;input file&gt; &lt;output file&gt;</screen>
<variablelist>
<varlistentry>
<term>regex</term>
<listitem>
<simpara>Regular Expression to base tokens on</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>input file</term>
<listitem>
<simpara>Text file</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>output file</term>
<listitem>
<simpara>Generated PIT file</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_attributes_21">
<title>Attributes</title>
<simpara><emphasis>Required:</emphasis></simpara>
<simpara>None.</simpara>
<simpara><emphasis>Optional:</emphasis></simpara>
<simpara>None.</simpara>
</section>
<section xml:id="_parameters_8">
<title>Parameters</title>
<variablelist>
<varlistentry>
<term>Regex</term>
<listitem>
<simpara>Regular expression. Only groups are kept. Group names are used to name specific
elements and cannot be duplicated.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_22">
<title>Examples</title>
<example>
<title>Simple HTTP GET URL Example</title>
<simpara>This example uses the string tokenizer on an inline value.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://peachfuzzer.com/2012/Peach /peach/peach.xsd"&gt;

  &lt;DataModel name="TheDataModel"&gt;
    &lt;String name="Value" value="http://www.google.com/q?q=kitty"&gt;
      &lt;Analyzer class="Regex"&gt;
        &lt;!-- (?&lt;protocol&gt;\w+)(://)(?&lt;host&gt;[^/?]+)(?&lt;path&gt;[^?]+)(\?)(?&lt;query&gt;.*) --&gt;
        &lt;Param name="Regex" value="(?&amp;lt;protocol&amp;gt;\w+)(://)(?&amp;lt;host&amp;gt;[^/?]+)(?&amp;lt;path&amp;gt;[^?]+)(\?)(?&amp;lt;query&amp;gt;.*)"/&gt;
      &lt;/Analyzer&gt;
    &lt;/String&gt;
  &lt;/DataModel&gt;

  &lt;StateModel name="State" initialState="State1" &gt;
    &lt;State name="State1"  &gt;
      &lt;Action type="output" &gt;
        &lt;DataModel ref="TheDataModel"/&gt;
      &lt;/Action&gt;
    &lt;/State&gt;
  &lt;/StateModel&gt;

  &lt;Test name="Default"&gt;
    &lt;StateModel ref="State"/&gt;

    &lt;Publisher class="Console" /&gt;
  &lt;/Test&gt;
&lt;/Peach&gt;
&lt;!-- end --&gt;</programlisting>
<simpara>Output from the example using the string tokenizer and an inline value.</simpara>
<screen>&gt; peach -1 --debug RegexAnalyzer.xml

[*] Web site running at: http://localhost:8889/

[*] Test 'Default' starting with random seed 43577.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.StateModel Run(): Changing to state "State1".
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher start()
Peach.Core.Publishers.ConsolePublisher open()
Peach.Core.Publishers.ConsolePublisher output(31 bytes)
00000000   68 74 74 70 3A 2F 2F 77  77 77 2E 67 6F 6F 67 6C   http://www.googl
00000010   65 2E 63 6F 6D 2F 71 3F  71 3D 6B 69 74 74 79      e.com/q?q=kitty
Peach.Core.Publishers.ConsolePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.ConsolePublisher stop()

[*] Test 'Default' finished.</screen>
<simpara>Output in Peach Validator</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/DevGuide/Analyzers/Regex_Output.png"/>
</imageobject>
<textobject><phrase>Regex Output</phrase></textobject>
</mediaobject>
</informalfigure>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Analyzers_StringToken">
<title>String Token Analyzer</title>
<simpara>The String Token Analyzer creates a tokenized tree from an input string based on special characters and punctuation in the string. For example, the string "?key=value&amp;key2=value2" creates a tree similar to the following:</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/DevGuide/Analyzers/StringToken_ParseExample.png"/>
</imageobject>
<textobject><phrase>StringToken ParseExample</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>The tree allows Peach to perform mutations that can expose bugs in parsers.</simpara>
<simpara>When run using the command line, the results of the generated model are saved to disk. Once saved, you can use and modify the results as needed.</simpara>
<section xml:id="_syntax_37">
<title>Syntax</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;String value="GET /index.html?name=peach&amp;amp;testing=true&amp;amp;admin=false&amp;amp;debug=1" /&gt;
  &lt;Analyzer class="StringToken" /&gt;
&lt;/String&gt;</programlisting>
<screen>pittool analyzer StringToken input.txt output.xml</screen>
</section>
<section xml:id="_command_line_syntax_6">
<title>Command Line Syntax</title>
<screen>pittool analyzer StringToken &lt;input file&gt; &lt;output file&gt;</screen>
<variablelist>
<varlistentry>
<term>input file</term>
<listitem>
<simpara>Text file</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>output file</term>
<listitem>
<simpara>Generated PIT file</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_attributes_22">
<title>Attributes</title>
<simpara><emphasis>Required:</emphasis></simpara>
<simpara>None.</simpara>
<simpara><emphasis>Optional:</emphasis></simpara>
<simpara>None.</simpara>
</section>
<section xml:id="_parameters_9">
<title>Parameters</title>
<variablelist>
<varlistentry>
<term>Tokens</term>
<listitem>
<simpara>List of characters to pass to the StringToken analyzer.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_23">
<title>Examples</title>
<example>
<title>Simple HTTP GET URL Example</title>
<simpara>This example uses the string tokenizer on an inline value.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://peachfuzzer.com/2012/Peach ../peach.xsd"&gt;

  &lt;DataModel name="TheModel"&gt;
    &lt;String value="GET /index.html?name=peach&amp;amp;testing=true&amp;amp;admin=false&amp;amp;debug=1" /&gt;
      &lt;Analyzer class="StringToken" /&gt;
    &lt;/String&gt;
  &lt;/DataModel&gt;

  &lt;StateModel name="TheState" initialState="initial"&gt;
    &lt;State name="initial"&gt;
      &lt;Action type="output"&gt;
        &lt;DataModel ref="TheModel" /&gt;
      &lt;/Action&gt;
    &lt;/State&gt;
  &lt;/StateModel&gt;

  &lt;Test name="Default"&gt;
    &lt;StateModel ref="TheState"/&gt;
    &lt;Publisher class="ConsoleHex" /&gt;
  &lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Output from the example that uses the string tokenizer on an inline value.</simpara>
<screen>&gt; peach -1 --debug example.xml

[*] Test 'Default' starting with random seed 26956.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher start()
Peach.Core.Publishers.ConsolePublisher open()
Peach.Core.Publishers.ConsolePublisher output(59 bytes)
00000000   47 45 54 20 2F 69 6E 64  65 78 2E 68 74 6D 6C 3F   GET /index.html?
00000010   6E 61 6D 65 3D 70 65 61  63 68 26 74 65 73 74 69   name=peach&amp;testi
00000020   6E 67 3D 74 72 75 65 26  61 64 6D 69 6E 3D 66 61   ng=true&amp;admin=fa
00000030   6C 73 65 26 64 65 62 75  67 3D 31                  lse&amp;debug=1
Peach.Core.Publishers.ConsolePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.ConsolePublisher stop()

[*] Test 'Default' finished.</screen>
<simpara>Output in Peach Validator</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/DevGuide/Analyzers/StringToken_Output.png"/>
</imageobject>
<textobject><phrase>StringToken Output</phrase></textobject>
</mediaobject>
</informalfigure>
</example>
<example>
<title>Custom String Tokens Example</title>
<simpara>This example uses the StringToken analyzer on a string with a custom set of tokens.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://peachfuzzer.com/2012/Peach ../peach.xsd"&gt;

  &lt;DataModel name="TheModel"&gt;
    &lt;String name="TheString"  value="(abc:{123,xyz}, def:{456})"&gt;
      &lt;Analyzer class="StringToken"&gt;
        &lt;Param name="Tokens" value="(){},:"/&gt;
      &lt;/Analyzer&gt;
    &lt;/String&gt;
  &lt;/DataModel&gt;

  &lt;StateModel name="TheState" initialState="initial"&gt;
    &lt;State name="initial"&gt;
      &lt;Action type="output"&gt;
        &lt;DataModel ref="TheModel" /&gt;
      &lt;/Action&gt;
    &lt;/State&gt;
  &lt;/StateModel&gt;

  &lt;Test name="Default"&gt;
    &lt;StateModel ref="TheState"/&gt;
    &lt;Publisher class="ConsoleHex" /&gt;
  &lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Output from the example of the string that contains custom tokens.</simpara>
<screen>&gt; peach -1 --debug example.xml

[*] Test 'Default' starting with random seed 56835.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher start()
Peach.Core.Publishers.ConsolePublisher open()
Peach.Core.Publishers.ConsolePublisher output(26 bytes)
00000000   28 61 62 63 3A 7B 31 32  33 2C 78 79 7A 7D 2C 20   (abc:{123,xyz},
00000010   64 65 66 3A 7B 34 35 36  7D 29                     def:{456})
Peach.Core.Publishers.ConsolePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.ConsolePublisher stop()

[*] Test 'Default' finished.</screen>
<simpara>Output in Peach Validator</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/DevGuide/Analyzers/StringToken_TokensOutput.png"/>
</imageobject>
<textobject><phrase>StringToken TokensOutput</phrase></textobject>
</mediaobject>
</informalfigure>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Analyzers_Swagger">
<title>Swagger Analyzer</title>
<simpara>This analyzer converts Swagger API JSON into Peach Pits for fuzzing WebApi style web service endpoints.</simpara>
<simpara><link xl:href="http://swagger.io">Swagger</link> is a popular method for representing your RESTful API, especially for documentation purposes. Many frameworks can export Swagger API representations which can then be converted into partial pits using this analyzer.</simpara>
<simpara>After converting, some manual work is usually needed to have a fully working pit.  This includes:</simpara>
<itemizedlist>
<listitem>
<simpara>Adding default values to models</simpara>
</listitem>
<listitem>
<simpara>Hooking up any authentication/authorization</simpara>
</listitem>
<listitem>
<simpara>Adding slurps for resource identifiers</simpara>
</listitem>
<listitem>
<simpara>Adding cleanup states to remove created resources</simpara>
</listitem>
<listitem>
<simpara>Testing to verify it all works</simpara>
</listitem>
</itemizedlist>
<note>
<simpara>This analyzer is intended to always be run from the command line.</simpara>
</note>
<section xml:id="_syntax_38">
<title>Syntax</title>
<screen>pittool analyzer Swagger swagger.json web_api_pit.xml</screen>
</section>
<section xml:id="_command_line_syntax_7">
<title>Command Line Syntax</title>
<screen>pittool analyzer Swagger &lt;input file&gt; &lt;output file&gt;</screen>
<variablelist>
<varlistentry>
<term>input file</term>
<listitem>
<simpara>Swagger API JSON</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>output file</term>
<listitem>
<simpara>Generated PIT file</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_attributes_23">
<title>Attributes</title>
<simpara><emphasis>Required:</emphasis></simpara>
<simpara>There are no required attributes.</simpara>
<simpara><emphasis>Optional:</emphasis></simpara>
<simpara>There are no optional attributes.</simpara>
</section>
<section xml:id="_examples_24">
<title>Examples</title>
<simpara>No examples.</simpara>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Analyzers_Vcr">
<title>Vcr Analyzer</title>
<simpara>This analyzer converts Vcr cassettes into Peach Pits for fuzzing HTTP requests.</simpara>
<simpara>A cassette is a set of recorded interactions serialized to a specific format. A cassette has a list (or array) or interactions and information about the library that recorded it.</simpara>
<simpara>After converting, some manual work is usually needed to have a fully working pit.  This includes:</simpara>
<itemizedlist>
<listitem>
<simpara>Adding default values to models</simpara>
</listitem>
<listitem>
<simpara>Hooking up any authentication/authorization</simpara>
</listitem>
<listitem>
<simpara>Adding slurps for resource identifiers</simpara>
</listitem>
<listitem>
<simpara>Adding cleanup states to remove created resources</simpara>
</listitem>
<listitem>
<simpara>Testing to verify it all works</simpara>
</listitem>
</itemizedlist>
<note>
<simpara>This analyzer is intended to always be run from the command line.</simpara>
</note>
<section xml:id="_syntax_39">
<title>Syntax</title>
<screen>pittool analyzer Vcr cassette.json http_pit.xml</screen>
</section>
<section xml:id="_command_line_syntax_8">
<title>Command Line Syntax</title>
<screen>pittool analyzer Vcr &lt;input file&gt; &lt;output file&gt;</screen>
<variablelist>
<varlistentry>
<term>input file</term>
<listitem>
<simpara>Vcr cassette JSON</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>output file</term>
<listitem>
<simpara>Generated PIT file</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_attributes_24">
<title>Attributes</title>
<simpara><emphasis>Required:</emphasis></simpara>
<simpara>There are no required attributes.</simpara>
<simpara><emphasis>Optional:</emphasis></simpara>
<simpara>There are no optional attributes.</simpara>
</section>
<section xml:id="_examples_25">
<title>Examples</title>
<simpara>No examples.</simpara>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Analyzers_Xml">
<title>Xml Analyzer</title>
<simpara>The XML Analyzer consumes an XML document or fragment and converts it into a tree structure of <link linkend="XmlElement">XmlElement</link> and <link linkend="XmlAttribute">XmlAttribute</link> elements.</simpara>
<simpara>When run using the command line, the results of the generated model are saved to disk. Once saved, you can use and modify the results as needed.</simpara>
<simpara>This analyzer can be attached to a string.</simpara>
<tip>
<simpara>The following XML special characters need to be encoded if they are inline values.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="33.3333*"/>
<colspec colname="col_3" colwidth="33.3334*"/>
<thead>
<row>
<entry align="left" valign="top">Symbol</entry>
<entry align="left" valign="top">Name</entry>
<entry align="left" valign="top">Escape Sequence</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>&quot;</simpara></entry>
<entry align="left" valign="top"><simpara>double-quote</simpara></entry>
<entry align="left" valign="top"><simpara><literal>&amp;quot;</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>&apos;</simpara></entry>
<entry align="left" valign="top"><simpara>single-quote</simpara></entry>
<entry align="left" valign="top"><simpara><literal>&amp;apos;</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>&lt;</simpara></entry>
<entry align="left" valign="top"><simpara>less-than</simpara></entry>
<entry align="left" valign="top"><simpara><literal>&amp;lt;</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>&gt;</simpara></entry>
<entry align="left" valign="top"><simpara>greater-than</simpara></entry>
<entry align="left" valign="top"><simpara><literal>&amp;gt;</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>&amp;</simpara></entry>
<entry align="left" valign="top"><simpara>ampersand</simpara></entry>
<entry align="left" valign="top"><simpara><literal>&amp;amp;</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</tip>
<section xml:id="_syntax_40">
<title>Syntax</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;String  value="&amp;lt;Root&amp;gt;HelloWorld!&amp;lt;/Root&amp;gt;"&gt;
	&lt;Analyzer class="Xml" /&gt;
&lt;/String&gt;</programlisting>
<screen>pittool analyzer Xml input.xml output.xml</screen>
</section>
<section xml:id="_command_line_syntax_9">
<title>Command Line Syntax</title>
<screen>pittool analyzer Xml &lt;input file&gt; &lt;output file&gt;</screen>
<variablelist>
<varlistentry>
<term>input file</term>
<listitem>
<simpara>XML file</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>output file</term>
<listitem>
<simpara>Generated PIT file</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_attributes_25">
<title>Attributes</title>
<simpara><emphasis>Required:</emphasis></simpara>
<simpara>None.</simpara>
<section xml:id="_examples_26">
<title>Examples</title>
<example>
<title>Simple Hello World Example</title>
<simpara>This example uses the XML analyzer on an inline value.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://peachfuzzer.com/2012/Peach ../peach.xsd"&gt;

	&lt;DataModel name="TheModel"&gt;
		&lt;String  value="&amp;lt;Root&amp;gt;HelloWorld!&amp;lt;/Root&amp;gt;"&gt;
			&lt;Analyzer class="Xml" /&gt;
		&lt;/String&gt;
	&lt;/DataModel&gt;

	&lt;StateModel name="TheState" initialState="initial"&gt;
		&lt;State name="initial"&gt;
			&lt;Action type="output"&gt;
				&lt;DataModel ref="TheModel" /&gt;
			&lt;/Action&gt;
		&lt;/State&gt;
	&lt;/StateModel&gt;

	&lt;Test name="Default"&gt;
		&lt;StateModel ref="TheState"/&gt;
		&lt;Publisher class="ConsoleHex" /&gt;
	&lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Output of the example using an inline value.</simpara>
<screen>&gt;peach -1 --debug example.xml

[*] Test 'Default' starting with random seed 22910.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher start()
Peach.Core.Publishers.ConsolePublisher open()
Peach.Core.Publishers.ConsolePublisher output(24 bytes)
00000000   3C 52 6F 6F 74 3E 48 65  6C 6C 6F 57 6F 72 6C 64   &lt;Root&gt;HelloWorld
00000010   21 3C 2F 52 6F 6F 74 3E                            !&lt;/Root&gt;
Peach.Core.Publishers.ConsolePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.ConsolePublisher stop()

[*] Test 'Default' finished.</screen>
<simpara>Output in Peach Validator</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/DevGuide/Analyzers/Xml_HelloWorld.png"/>
</imageobject>
<textobject><phrase>Xml HelloWorld</phrase></textobject>
</mediaobject>
</informalfigure>
</example>
<example>
<title>Inline XML Inline Encoding Example</title>
<simpara>This example uses the Xml analyzer on an inline value with encoded Xml characters.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://peachfuzzer.com/2012/Peach ../peach.xsd"&gt;

	&lt;DataModel name="TheModel"&gt;
		&lt;String  value="&amp;lt;Root test=&amp;quot;true&amp;quot;&amp;gt;HelloWorld!&amp;amp;amp;&amp;lt;/Root&amp;gt;"&gt;
			&lt;Analyzer class="Xml" /&gt;
		&lt;/String&gt;
	&lt;/DataModel&gt;

	&lt;StateModel name="TheState" initialState="initial"&gt;
		&lt;State name="initial"&gt;
			&lt;Action type="output"&gt;
				&lt;DataModel ref="TheModel" /&gt;
			&lt;/Action&gt;
		&lt;/State&gt;
	&lt;/StateModel&gt;

	&lt;Test name="Default"&gt;
		&lt;StateModel ref="TheState"/&gt;
		&lt;Publisher class="ConsoleHex" /&gt;
	&lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Output from the example using an inline value with encoded Xml characters.</simpara>
<screen>&gt;peach -1 --debug example.xml

[*] Test 'Default' starting with random seed 44192.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher start()
Peach.Core.Publishers.ConsolePublisher open()
Peach.Core.Publishers.ConsolePublisher output(37 bytes)
00000000   3C 52 6F 6F 74 20 74 65  73 74 3D 22 74 72 75 65   &lt;Root test="true
00000010   22 3E 48 65 6C 6C 6F 57  6F 72 6C 64 21 26 3C 2F   "&gt;HelloWorld!&amp;&lt;/
00000020   52 6F 6F 74 3E                                     Root&gt;
Peach.Core.Publishers.ConsolePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.ConsolePublisher stop()

[*] Test 'Default' finished.</screen>
<simpara>Output in Peach Validator</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/DevGuide/Analyzers/Xml_EncodingExample.png"/>
</imageobject>
<textobject><phrase>Xml EncodingExample</phrase></textobject>
</mediaobject>
</informalfigure>
</example>
<example>
<title>Load XML From File Example</title>
<simpara>This example uses the Xml analyzer on itself.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://peachfuzzer.com/2012/Peach ../peach.xsd"&gt;

	&lt;DataModel name="TheModel"&gt;
		&lt;String&gt;
			&lt;Analyzer class="Xml" /&gt;
		&lt;/String&gt;
	&lt;/DataModel&gt;

	&lt;StateModel name="TheState" initialState="initial"&gt;
		&lt;State name="initial"&gt;
			&lt;Action type="output"&gt;
				&lt;DataModel ref="TheModel" /&gt;
				&lt;Data name="TheData" fileName="example.xml"/&gt;
			&lt;/Action&gt;
		&lt;/State&gt;
	&lt;/StateModel&gt;

	&lt;Test name="Default"&gt;
		&lt;StateModel ref="TheState"/&gt;
		&lt;Publisher class="ConsoleHex" /&gt;
	&lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Output from the example that uses the Xml analyzer on itself.</simpara>
<screen>&gt;peach -1 --debug example.xml

[*] Test 'Default' starting with random seed 10150.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker DataModel 'TheModel' Bytes: 0/787, Bits: 0/6296
Peach.Core.Cracker.DataCracker getSize: -----&gt; DataModel 'TheModel'
Peach.Core.Cracker.DataCracker scan: DataModel 'TheModel'
Peach.Core.Cracker.DataCracker scan: String 'TheModel.DataElement_0' -&gt; Offset: 0, Unsized element
Peach.Core.Cracker.DataCracker getSize: &lt;----- Deterministic: ???
Peach.Core.Cracker.DataCracker Crack: DataModel 'TheModel' Size: &lt;null&gt;, Bytes: 0/787, Bits: 0/6296
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker String 'TheModel.DataElement_0' Bytes: 0/787, Bit s: 0/6296
Peach.Core.Cracker.DataCracker getSize: -----&gt; String 'TheModel.DataElement_0'
Peach.Core.Cracker.DataCracker scan: String 'TheModel.DataElement_0' -&gt; Offset: 0, Unsized element
Peach.Core.Cracker.DataCracker lookahead: String 'TheModel.DataElement_0'
Peach.Core.Cracker.DataCracker getSize: &lt;----- Last Unsized: 6296
Peach.Core.Cracker.DataCracker Crack: String 'TheModel.DataElement_0' Size: 6296 , Bytes: 0/787, Bits: 0/6296
Peach.Core.Dom.DataElement String 'TheModel.DataElement_0' value is: &lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;Peach xmlns="http://pea.. (Len: 787 chars)
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher start()
Peach.Core.Publishers.ConsolePublisher open()
Peach.Core.Publishers.ConsolePublisher output(669 bytes)
00000000   3C 50 65 61 63 68 20 78  6D 6C 6E 73 3D 22 68 74   &lt;Peach xmlns="ht
00000010   74 70 3A 2F 2F 70 65 61  63 68 66 75 7A 7A 65 72   tp://peachfuzzer
00000020   2E 63 6F 6D 2F 32 30 31  32 2F 50 65 61 63 68 22   .com/2012/Peach"
00000030   20 78 6D 6C 6E 73 3A 78  73 69 3D 22 68 74 74 70    xmlns:xsi="http
00000040   3A 2F 2F 77 77 77 2E 77  33 2E 6F 72 67 2F 32 30   ://www.w3.org/20
00000050   30 31 2F 58 4D 4C 53 63  68 65 6D 61 2D 69 6E 73   01/XMLSchema-ins
00000060   74 61 6E 63 65 22 20 64  31 70 31 3A 73 63 68 65   tance" d1p1:sche
00000070   6D 61 4C 6F 63 61 74 69  6F 6E 3D 22 68 74 74 70   maLocation="http
00000080   3A 2F 2F 70 65 61 63 68  66 75 7A 7A 65 72 2E 63   ://peachfuzzer.c
00000090   6F 6D 2F 32 30 31 32 2F  50 65 61 63 68 20 2E 2E   om/2012/Peach ..
000000A0   2F 70 65 61 63 68 2E 78  73 64 22 20 78 6D 6C 6E   /peach.xsd" xmln
000000B0   73 3A 64 31 70 31 3D 22  68 74 74 70 3A 2F 2F 77   s:d1p1="http://w
000000C0   77 77 2E 77 33 2E 6F 72  67 2F 32 30 30 31 2F 58   ww.w3.org/2001/X
000000D0   4D 4C 53 63 68 65 6D 61  2D 69 6E 73 74 61 6E 63   MLSchema-instanc
000000E0   65 22 3E 3C 44 61 74 61  4D 6F 64 65 6C 20 6E 61   e"&gt;&lt;DataModel na
000000F0   6D 65 3D 22 54 68 65 4D  6F 64 65 6C 22 3E 3C 53   me="TheModel"&gt;&lt;S
00000100   74 72 69 6E 67 3E 3C 41  6E 61 6C 79 7A 65 72 20   tring&gt;&lt;Analyzer
00000110   63 6C 61 73 73 3D 22 58  6D 6C 22 20 2F 3E 3C 2F   class="Xml" /&gt;&lt;/
00000120   53 74 72 69 6E 67 3E 3C  2F 44 61 74 61 4D 6F 64   String&gt;&lt;/DataMod
00000130   65 6C 3E 3C 53 74 61 74  65 4D 6F 64 65 6C 20 6E   el&gt;&lt;StateModel n
00000140   61 6D 65 3D 22 54 68 65  53 74 61 74 65 22 20 69   ame="TheState" i
00000150   6E 69 74 69 61 6C 53 74  61 74 65 3D 22 69 6E 69   nitialState="ini
00000160   74 69 61 6C 22 3E 3C 53  74 61 74 65 20 6E 61 6D   tial"&gt;&lt;State nam
00000170   65 3D 22 69 6E 69 74 69  61 6C 22 3E 3C 41 63 74   e="initial"&gt;&lt;Act
00000180   69 6F 6E 20 74 79 70 65  3D 22 6F 75 74 70 75 74   ion type="output
00000190   22 3E 3C 44 61 74 61 4D  6F 64 65 6C 20 72 65 66   "&gt;&lt;DataModel ref
000001A0   3D 22 54 68 65 4D 6F 64  65 6C 22 20 2F 3E 3C 44   ="TheModel" /&gt;&lt;D
000001B0   61 74 61 20 6E 61 6D 65  3D 22 45 78 61 6D 70 6C   ata name="Exampl
000001C0   65 22 20 66 69 6C 65 4E  61 6D 65 3D 22 74 65 73   e" fileName="tes
000001D0   74 70 65 61 63 68 2E 78  6D 6C 22 20 2F 3E 3C 2F   tpeach.xml" /&gt;&lt;/
000001E0   41 63 74 69 6F 6E 3E 3C  2F 53 74 61 74 65 3E 3C   Action&gt;&lt;/State&gt;&lt;
000001F0   2F 53 74 61 74 65 4D 6F  64 65 6C 3E 3C 54 65 73   /StateModel&gt;&lt;Tes
00000200   74 20 6E 61 6D 65 3D 22  44 65 66 61 75 6C 74 22   t name="Default"
00000210   3E 3C 53 74 61 74 65 4D  6F 64 65 6C 20 72 65 66   &gt;&lt;StateModel ref
00000220   3D 22 54 68 65 53 74 61  74 65 22 20 2F 3E 3C 50   ="TheState" /&gt;&lt;P
00000230   75 62 6C 69 73 68 65 72  20 63 6C 61 73 73 3D 22   ublisher class="
00000240   43 6F 6E 73 6F 6C 65 48  65 78 22 20 2F 3E 3C 4C   ConsoleHex" /&gt;&lt;L
00000250   6F 67 67 65 72 20 63 6C  61 73 73 3D 22 46 69 6C   ogger class="Fil
00000260   65 22 3E 3C 50 61 72 61  6D 20 6E 61 6D 65 3D 22   e"&gt;&lt;Param name="
00000270   50 61 74 68 22 20 76 61  6C 75 65 3D 22 6C 6F 67   Path" value="log
00000280   73 22 20 2F 3E 3C 2F 4C  6F 67 67 65 72 3E 3C 2F   s" /&gt;&lt;/Logger&gt;&lt;/
00000290   54 65 73 74 3E 3C 2F 50  65 61 63 68 3E            Test&gt;&lt;/Peach&gt;
Peach.Core.Publishers.ConsolePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.ConsolePublisher stop()

[*] Test 'Default' finished.</screen>
<simpara>Output in Peach Validator</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/DevGuide/Analyzers/Xml_FileExample.png"/>
</imageobject>
<textobject><phrase>Xml FileExample</phrase></textobject>
</mediaobject>
</informalfigure>
</example>
<simpara>&lt;&lt;</simpara>
</section>
</section>
</section>
<section xml:id="Analyzers_WebRecordProxy">
<title>WebRecordProxy Analyzer</title>
<simpara>This analyzer starts an HTTP proxy and records all HTTP requests. The recorded requests are then converted into a Peach Pit and written to disk for future use. This analyzer produces pits using the <link linkend="Publishers_WebApi">WebApi</link> publisher and <link linkend="Action_web">web</link> action.</simpara>
<simpara>After converting, some manual work is usually needed to have a fully working pit.  This includes:</simpara>
<itemizedlist>
<listitem>
<simpara>Hooking up any authentication/authorization</simpara>
</listitem>
<listitem>
<simpara>Adding slurps for resource identifiers</simpara>
</listitem>
<listitem>
<simpara>Adding cleanup states to remove created resources</simpara>
</listitem>
<listitem>
<simpara>Testing to verify it all works</simpara>
</listitem>
</itemizedlist>
<note>
<simpara>This analyzer is intended to always be run from the command line.</simpara>
</note>
<section xml:id="_syntax_41">
<title>Syntax</title>
<screen>pittool analyzer WebRecordProxy 8080 web_api_pit.xml</screen>
</section>
<section xml:id="_command_line_syntax_10">
<title>Command Line Syntax</title>
<screen>pittool analyzer WebRecordProxy &lt;proxy port&gt; &lt;output file&gt;</screen>
<variablelist>
<varlistentry>
<term>proxy port</term>
<listitem>
<simpara>TCP port used for incoming requests</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>output file</term>
<listitem>
<simpara>Filename of generated Peach Pit</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_attributes_26">
<title>Attributes</title>
<simpara><emphasis>Required:</emphasis></simpara>
<simpara>There are no required attributes.</simpara>
<simpara><emphasis>Optional:</emphasis></simpara>
<simpara>There are no optional attributes.</simpara>
</section>
<section xml:id="_examples_27">
<title>Examples</title>
<simpara>No examples.</simpara>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Analyzers_Zip">
<title>Zip Analyzer</title>
<simpara>The Zip Analyzer consumes a zip compressed archive and converts it into a sequence of <link linkend="Stream">Stream</link> elements.</simpara>
<simpara>The analyzer creates a <link linkend="Stream">Stream</link> element for each file in the zip archive.
The name of the stream element corresponds to the name of the file in the zip archive.
The content of a stream element corresponds to the content of the file in the zip archive.</simpara>
<simpara>The Zip Analyzer allows the content of each file in the zip archive to map to a <link linkend="DataModel">DataModel</link>.
Using a file and the corresponding data model, Peach can further decompose the contents of a file in a zip archive instead of just treating the contents as a <link linkend="Blob">Blob</link>.
The <literal>Map</literal> parameter of this element defines the mappings for the streams in the zip files and the associated  data models.</simpara>
<simpara>You can attach this analyzer to a blob.</simpara>
<section xml:id="_syntax_42">
<title>Syntax</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;Blob&gt;
	&lt;Analyzer class="Zip" /&gt;
&lt;/Blob&gt;</programlisting>
</section>
<section xml:id="_attributes_27">
<title>Attributes</title>
<simpara><emphasis>Required:</emphasis></simpara>
<simpara>None.</simpara>
<simpara><emphasis>Optional:</emphasis></simpara>
<simpara>None.</simpara>
</section>
<section xml:id="_parameters_10">
<title>Parameters</title>
<variablelist>
<varlistentry>
<term>Map</term>
<listitem>
<simpara>Controls mapping of stream names to the corresponding data models.
This parameter consists of a comma-separated list of mappings. Each mapping consists of a tuple containing a regular expression and a corresponding DataModel name. The parts of a tuple are delineated with a forward slash character, similar to the substitution regular expression pattern.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>When the regular expression matches the file name in the zip archive, Peach uses the corresponding DataModel on the file contents.</simpara>
<simpara>For example, to use the data model <literal>TextModel</literal> for all files ending in <literal>.txt</literal>, set the value of the parameter to <literal>/.txt$/TextModel/</literal>.</simpara>
<section xml:id="_examples_28">
<title>Examples</title>
<example>
<title>Analyzing a .docx file</title>
<simpara>This example uses the zip analyzer to decompose a .docx file into its underlying streams.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://peachfuzzer.com/2012/Peach ../peach.xsd"&gt;

	&lt;DataModel name="WordDoc"&gt;
		&lt;Blob name="Data"&gt;
			&lt;Analyzer class="Zip"/&gt;
		&lt;/Blob&gt;
	&lt;/DataModel&gt;

	&lt;StateModel name="TheState" initialState="initial"&gt;
		&lt;State name="initial"&gt;
			&lt;Action type="output"&gt;
				&lt;DataModel ref="WordDoc"/&gt;
				&lt;Data fileName="example.docx"/&gt;
			&lt;/Action&gt;
		&lt;/State&gt;
	&lt;/StateModel&gt;

	&lt;Test name="Default"&gt;
		&lt;StateModel ref="TheState"/&gt;

		&lt;Publisher class="Zip"&gt;
			&lt;Param name="FileName" value="fuzzed.docx" /&gt;
		&lt;/Publisher&gt;
	&lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Output from the example that decomposes a .docx file into its underlying streams.</simpara>
<screen>&gt;peach -1 --debug example.xml

[*] Test 'Default' starting with random seed 22910.


[*] Test 'Default' starting with random seed 48751.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker DataModel 'WordDoc' Bytes: 0/11272, Bits: 0/90176
Peach.Core.Cracker.DataCracker getSize: -----&gt; DataModel 'WordDoc'
Peach.Core.Cracker.DataCracker scan: DataModel 'WordDoc'
Peach.Core.Cracker.DataCracker scan: Blob 'WordDoc.Data' -&gt; Offset: 0, Unsized element
Peach.Core.Cracker.DataCracker getSize: &lt;----- Deterministic: ???
Peach.Core.Cracker.DataCracker Crack: DataModel 'WordDoc' Size: &lt;null&gt;, Bytes: 0/11272, Bits: 0/90176
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker Blob 'WordDoc.Data' Bytes: 0/11272, Bits: 0/90176
Peach.Core.Cracker.DataCracker getSize: -----&gt; Blob 'WordDoc.Data'
Peach.Core.Cracker.DataCracker scan: Blob 'WordDoc.Data' -&gt; Offset: 0, Unsized element
Peach.Core.Cracker.DataCracker lookahead: Blob 'WordDoc.Data'
Peach.Core.Cracker.DataCracker getSize: &lt;----- Last Unsized: 90176
Peach.Core.Cracker.DataCracker Crack: Blob 'WordDoc.Data' Size: 90176, Bytes: 0/11272, Bits: 0/90176
Peach.Core.Dom.DataElement Blob 'WordDoc.Data' value is: 50 4b 03 04 14 00 06 00 08 00 00 00 21 00 df a4 d2 6c 5a 01 00 00 20 05 00 00 13 00 08 02 5b 43.. (Len: 11272 bytes)
Peach.Enterprise.Analyzers.ZipAnalyzer Attempting to parse: [Content_Types].xml
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker Block 'Content' Bytes: 0/1312, Bits: 0/10496
Peach.Core.Cracker.DataCracker getSize: -----&gt; Block 'Content'
Peach.Core.Cracker.DataCracker scan: Block 'Content'
Peach.Core.Cracker.DataCracker scan: Blob 'Content.Data' -&gt; Offset: 0, Unsized element
Peach.Core.Cracker.DataCracker getSize: &lt;----- Deterministic: ???
Peach.Core.Cracker.DataCracker Crack: Block 'Content' Size: &lt;null&gt;, Bytes: 0/1312, Bits: 0/10496
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker Blob 'Content.Data' Bytes: 0/1312, Bits: 0/10496
Peach.Core.Cracker.DataCracker getSize: -----&gt; Blob 'Content.Data'
Peach.Core.Cracker.DataCracker scan: Blob 'Content.Data' -&gt; Offset: 0, Unsized element
Peach.Core.Cracker.DataCracker lookahead: Blob 'Content.Data'
Peach.Core.Cracker.DataCracker getSize: &lt;----- Last Unsized: 10496
Peach.Core.Cracker.DataCracker Crack: Blob 'Content.Data' Size: 10496, Bytes: 0/1312, Bits: 0/10496
Peach.Core.Dom.DataElement Blob 'Content.Data' value is: 3c 3f 78 6d 6c 20 76 65 72 73 69 6f 6e 3d 22 31 2e 30 22 20 65 6e 63 6f 64 69 6e 67 3d 22 55 54.. (Len: 1312 bytes)
Peach.Enterprise.Analyzers.ZipAnalyzer Successfully parsed: [Content_Types].xml
Peach.Enterprise.Analyzers.ZipAnalyzer Attempting to parse: _rels/.rels
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker Block 'Content' Bytes: 0/590, Bits: 0/4720
Peach.Core.Cracker.DataCracker getSize: -----&gt; Block 'Content'
Peach.Core.Cracker.DataCracker scan: Block 'Content'
Peach.Core.Cracker.DataCracker scan: Blob 'Content.Data' -&gt; Offset: 0, Unsized element
Peach.Core.Cracker.DataCracker getSize: &lt;----- Deterministic: ???
Peach.Core.Cracker.DataCracker Crack: Block 'Content' Size: &lt;null&gt;, Bytes: 0/590, Bits: 0/4720
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker Blob 'Content.Data' Bytes: 0/590, Bits: 0/4720
Peach.Core.Cracker.DataCracker getSize: -----&gt; Blob 'Content.Data'
Peach.Core.Cracker.DataCracker scan: Blob 'Content.Data' -&gt; Offset: 0, Unsized element
Peach.Core.Cracker.DataCracker lookahead: Blob 'Content.Data'
Peach.Core.Cracker.DataCracker getSize: &lt;----- Last Unsized: 4720
Peach.Core.Cracker.DataCracker Crack: Blob 'Content.Data' Size: 4720, Bytes: 0/590, Bits: 0/4720
Peach.Core.Dom.DataElement Blob 'Content.Data' value is: 3c 3f 78 6d 6c 20 76 65 72 73 69 6f 6e 3d 22 31 2e 30 22 20 65 6e 63 6f 64 69 6e 67 3d 22 55 54.. (Len: 590 bytes)
Peach.Enterprise.Analyzers.ZipAnalyzer Successfully parsed: _rels/.rels
Peach.Enterprise.Analyzers.ZipAnalyzer Attempting to parse: word/_rels/document.xml.rels
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker Block 'Content' Bytes: 0/817, Bits: 0/6536
Peach.Core.Cracker.DataCracker getSize: -----&gt; Block 'Content'
Peach.Core.Cracker.DataCracker scan: Block 'Content'
Peach.Core.Cracker.DataCracker scan: Blob 'Content.Data' -&gt; Offset: 0, Unsized element
Peach.Core.Cracker.DataCracker getSize: &lt;----- Deterministic: ???
Peach.Core.Cracker.DataCracker Crack: Block 'Content' Size: &lt;null&gt;, Bytes: 0/817, Bits: 0/6536
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker Blob 'Content.Data' Bytes: 0/817, Bits: 0/6536
Peach.Core.Cracker.DataCracker getSize: -----&gt; Blob 'Content.Data'
Peach.Core.Cracker.DataCracker scan: Blob 'Content.Data' -&gt; Offset: 0, Unsized element
Peach.Core.Cracker.DataCracker lookahead: Blob 'Content.Data'
Peach.Core.Cracker.DataCracker getSize: &lt;----- Last Unsized: 6536
Peach.Core.Cracker.DataCracker Crack: Blob 'Content.Data' Size: 6536, Bytes: 0/817, Bits: 0/6536
Peach.Core.Dom.DataElement Blob 'Content.Data' value is: 3c 3f 78 6d 6c 20 76 65 72 73 69 6f 6e 3d 22 31 2e 30 22 20 65 6e 63 6f 64 69 6e 67 3d 22 55 54.. (Len: 817 bytes)
Peach.Enterprise.Analyzers.ZipAnalyzer Successfully parsed: word/_rels/document.xml.rels
Peach.Enterprise.Analyzers.ZipAnalyzer Attempting to parse: word/document.xml
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker Block 'Content' Bytes: 0/1620, Bits: 0/12960
Peach.Core.Cracker.DataCracker getSize: -----&gt; Block 'Content'
Peach.Core.Cracker.DataCracker scan: Block 'Content'
Peach.Core.Cracker.DataCracker scan: Blob 'Content.Data' -&gt; Offset: 0, Unsized element
Peach.Core.Cracker.DataCracker getSize: &lt;----- Deterministic: ???
Peach.Core.Cracker.DataCracker Crack: Block 'Content' Size: &lt;null&gt;, Bytes: 0/1620, Bits: 0/12960
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker Blob 'Content.Data' Bytes: 0/1620, Bits: 0/12960
Peach.Core.Cracker.DataCracker getSize: -----&gt; Blob 'Content.Data'
Peach.Core.Cracker.DataCracker scan: Blob 'Content.Data' -&gt; Offset: 0, Unsized element
Peach.Core.Cracker.DataCracker lookahead: Blob 'Content.Data'
Peach.Core.Cracker.DataCracker getSize: &lt;----- Last Unsized: 12960
Peach.Core.Cracker.DataCracker Crack: Blob 'Content.Data' Size: 12960, Bytes: 0/1620, Bits: 0/12960
Peach.Core.Dom.DataElement Blob 'Content.Data' value is: 3c 3f 78 6d 6c 20 76 65 72 73 69 6f 6e 3d 22 31 2e 30 22 20 65 6e 63 6f 64 69 6e 67 3d 22 55 54.. (Len: 1620 bytes)
Peach.Enterprise.Analyzers.ZipAnalyzer Successfully parsed: word/document.xml
Peach.Enterprise.Analyzers.ZipAnalyzer Attempting to parse: word/theme/theme1.xml
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker Block 'Content' Bytes: 0/6795, Bits: 0/54360
Peach.Core.Cracker.DataCracker getSize: -----&gt; Block 'Content'
Peach.Core.Cracker.DataCracker scan: Block 'Content'
Peach.Core.Cracker.DataCracker scan: Blob 'Content.Data' -&gt; Offset: 0, Unsized element
Peach.Core.Cracker.DataCracker getSize: &lt;----- Deterministic: ???
Peach.Core.Cracker.DataCracker Crack: Block 'Content' Size: &lt;null&gt;, Bytes: 0/6795, Bits: 0/54360
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker Blob 'Content.Data' Bytes: 0/6795, Bits: 0/54360
Peach.Core.Cracker.DataCracker getSize: -----&gt; Blob 'Content.Data'
Peach.Core.Cracker.DataCracker scan: Blob 'Content.Data' -&gt; Offset: 0, Unsized element
Peach.Core.Cracker.DataCracker lookahead: Blob 'Content.Data'
Peach.Core.Cracker.DataCracker getSize: &lt;----- Last Unsized: 54360
Peach.Core.Cracker.DataCracker Crack: Blob 'Content.Data' Size: 54360, Bytes: 0/6795, Bits: 0/54360
Peach.Core.Dom.DataElement Blob 'Content.Data' value is: 3c 3f 78 6d 6c 20 76 65 72 73 69 6f 6e 3d 22 31 2e 30 22 20 65 6e 63 6f 64 69 6e 67 3d 22 55 54.. (Len: 6795 bytes)
Peach.Enterprise.Analyzers.ZipAnalyzer Successfully parsed: word/theme/theme1.xml
Peach.Enterprise.Analyzers.ZipAnalyzer Attempting to parse: word/settings.xml
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker Block 'Content' Bytes: 0/2477, Bits: 0/19816
Peach.Core.Cracker.DataCracker getSize: -----&gt; Block 'Content'
Peach.Core.Cracker.DataCracker scan: Block 'Content'
Peach.Core.Cracker.DataCracker scan: Blob 'Content.Data' -&gt; Offset: 0, Unsized element
Peach.Core.Cracker.DataCracker getSize: &lt;----- Deterministic: ???
Peach.Core.Cracker.DataCracker Crack: Block 'Content' Size: &lt;null&gt;, Bytes: 0/2477, Bits: 0/19816
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker Blob 'Content.Data' Bytes: 0/2477, Bits: 0/19816
Peach.Core.Cracker.DataCracker getSize: -----&gt; Blob 'Content.Data'
Peach.Core.Cracker.DataCracker scan: Blob 'Content.Data' -&gt; Offset: 0, Unsized element
Peach.Core.Cracker.DataCracker lookahead: Blob 'Content.Data'
Peach.Core.Cracker.DataCracker getSize: &lt;----- Last Unsized: 19816
Peach.Core.Cracker.DataCracker Crack: Blob 'Content.Data' Size: 19816, Bytes: 0/2477, Bits: 0/19816
Peach.Core.Dom.DataElement Blob 'Content.Data' value is: 3c 3f 78 6d 6c 20 76 65 72 73 69 6f 6e 3d 22 31 2e 30 22 20 65 6e 63 6f 64 69 6e 67 3d 22 55 54.. (Len: 2477 bytes)
Peach.Enterprise.Analyzers.ZipAnalyzer Successfully parsed: word/settings.xml
Peach.Enterprise.Analyzers.ZipAnalyzer Attempting to parse: word/fontTable.xml
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker Block 'Content' Bytes: 0/1261, Bits: 0/10088
Peach.Core.Cracker.DataCracker getSize: -----&gt; Block 'Content'
Peach.Core.Cracker.DataCracker scan: Block 'Content'
Peach.Core.Cracker.DataCracker scan: Blob 'Content.Data' -&gt; Offset: 0, Unsized element
Peach.Core.Cracker.DataCracker getSize: &lt;----- Deterministic: ???
Peach.Core.Cracker.DataCracker Crack: Block 'Content' Size: &lt;null&gt;, Bytes: 0/1261, Bits: 0/10088
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker Blob 'Content.Data' Bytes: 0/1261, Bits: 0/10088
Peach.Core.Cracker.DataCracker getSize: -----&gt; Blob 'Content.Data'
Peach.Core.Cracker.DataCracker scan: Blob 'Content.Data' -&gt; Offset: 0, Unsized element
Peach.Core.Cracker.DataCracker lookahead: Blob 'Content.Data'
Peach.Core.Cracker.DataCracker getSize: &lt;----- Last Unsized: 10088
Peach.Core.Cracker.DataCracker Crack: Blob 'Content.Data' Size: 10088, Bytes: 0/1261, Bits: 0/10088
Peach.Core.Dom.DataElement Blob 'Content.Data' value is: 3c 3f 78 6d 6c 20 76 65 72 73 69 6f 6e 3d 22 31 2e 30 22 20 65 6e 63 6f 64 69 6e 67 3d 22 55 54.. (Len: 1261 bytes)
Peach.Enterprise.Analyzers.ZipAnalyzer Successfully parsed: word/fontTable.xml
Peach.Enterprise.Analyzers.ZipAnalyzer Attempting to parse: word/webSettings.xml
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker Block 'Content' Bytes: 0/497, Bits: 0/3976
Peach.Core.Cracker.DataCracker getSize: -----&gt; Block 'Content'
Peach.Core.Cracker.DataCracker scan: Block 'Content'
Peach.Core.Cracker.DataCracker scan: Blob 'Content.Data' -&gt; Offset: 0, Unsized element
Peach.Core.Cracker.DataCracker getSize: &lt;----- Deterministic: ???
Peach.Core.Cracker.DataCracker Crack: Block 'Content' Size: &lt;null&gt;, Bytes: 0/497, Bits: 0/3976
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker Blob 'Content.Data' Bytes: 0/497, Bits: 0/3976
Peach.Core.Cracker.DataCracker getSize: -----&gt; Blob 'Content.Data'
Peach.Core.Cracker.DataCracker scan: Blob 'Content.Data' -&gt; Offset: 0, Unsized element
Peach.Core.Cracker.DataCracker lookahead: Blob 'Content.Data'
Peach.Core.Cracker.DataCracker getSize: &lt;----- Last Unsized: 3976
Peach.Core.Cracker.DataCracker Crack: Blob 'Content.Data' Size: 3976, Bytes: 0/497, Bits: 0/3976
Peach.Core.Dom.DataElement Blob 'Content.Data' value is: 3c 3f 78 6d 6c 20 76 65 72 73 69 6f 6e 3d 22 31 2e 30 22 20 65 6e 63 6f 64 69 6e 67 3d 22 55 54.. (Len: 497 bytes)
Peach.Enterprise.Analyzers.ZipAnalyzer Successfully parsed: word/webSettings.xml
Peach.Enterprise.Analyzers.ZipAnalyzer Attempting to parse: docProps/app.xml
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker Block 'Content' Bytes: 0/711, Bits: 0/5688
Peach.Core.Cracker.DataCracker getSize: -----&gt; Block 'Content'
Peach.Core.Cracker.DataCracker scan: Block 'Content'
Peach.Core.Cracker.DataCracker scan: Blob 'Content.Data' -&gt; Offset: 0, Unsized element
Peach.Core.Cracker.DataCracker getSize: &lt;----- Deterministic: ???
Peach.Core.Cracker.DataCracker Crack: Block 'Content' Size: &lt;null&gt;, Bytes: 0/711, Bits: 0/5688
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker Blob 'Content.Data' Bytes: 0/711, Bits: 0/5688
Peach.Core.Cracker.DataCracker getSize: -----&gt; Blob 'Content.Data'
Peach.Core.Cracker.DataCracker scan: Blob 'Content.Data' -&gt; Offset: 0, Unsized element
Peach.Core.Cracker.DataCracker lookahead: Blob 'Content.Data'
Peach.Core.Cracker.DataCracker getSize: &lt;----- Last Unsized: 5688
Peach.Core.Cracker.DataCracker Crack: Blob 'Content.Data' Size: 5688, Bytes: 0/711, Bits: 0/5688
Peach.Core.Dom.DataElement Blob 'Content.Data' value is: 3c 3f 78 6d 6c 20 76 65 72 73 69 6f 6e 3d 22 31 2e 30 22 20 65 6e 63 6f 64 69 6e 67 3d 22 55 54.. (Len: 711 bytes)
Peach.Enterprise.Analyzers.ZipAnalyzer Successfully parsed: docProps/app.xml
Peach.Enterprise.Analyzers.ZipAnalyzer Attempting to parse: docProps/core.xml
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker Block 'Content' Bytes: 0/747, Bits: 0/5976
Peach.Core.Cracker.DataCracker getSize: -----&gt; Block 'Content'
Peach.Core.Cracker.DataCracker scan: Block 'Content'
Peach.Core.Cracker.DataCracker scan: Blob 'Content.Data' -&gt; Offset: 0, Unsized element
Peach.Core.Cracker.DataCracker getSize: &lt;----- Deterministic: ???
Peach.Core.Cracker.DataCracker Crack: Block 'Content' Size: &lt;null&gt;, Bytes: 0/747, Bits: 0/5976
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker Blob 'Content.Data' Bytes: 0/747, Bits: 0/5976
Peach.Core.Cracker.DataCracker getSize: -----&gt; Blob 'Content.Data'
Peach.Core.Cracker.DataCracker scan: Blob 'Content.Data' -&gt; Offset: 0, Unsized element
Peach.Core.Cracker.DataCracker lookahead: Blob 'Content.Data'
Peach.Core.Cracker.DataCracker getSize: &lt;----- Last Unsized: 5976
Peach.Core.Cracker.DataCracker Crack: Blob 'Content.Data' Size: 5976, Bytes: 0/747, Bits: 0/5976
Peach.Core.Dom.DataElement Blob 'Content.Data' value is: 3c 3f 78 6d 6c 20 76 65 72 73 69 6f 6e 3d 22 31 2e 30 22 20 65 6e 63 6f 64 69 6e 67 3d 22 55 54.. (Len: 747 bytes)
Peach.Enterprise.Analyzers.ZipAnalyzer Successfully parsed: docProps/core.xml
Peach.Enterprise.Analyzers.ZipAnalyzer Attempting to parse: word/styles.xml
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker Block 'Content' Bytes: 0/28676, Bits: 0/229408
Peach.Core.Cracker.DataCracker getSize: -----&gt; Block 'Content'
Peach.Core.Cracker.DataCracker scan: Block 'Content'
Peach.Core.Cracker.DataCracker scan: Blob 'Content.Data' -&gt; Offset: 0, Unsized element
Peach.Core.Cracker.DataCracker getSize: &lt;----- Deterministic: ???
Peach.Core.Cracker.DataCracker Crack: Block 'Content' Size: &lt;null&gt;, Bytes: 0/28676, Bits: 0/229408
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker Blob 'Content.Data' Bytes: 0/28676, Bits: 0/229408
Peach.Core.Cracker.DataCracker getSize: -----&gt; Blob 'Content.Data'
Peach.Core.Cracker.DataCracker scan: Blob 'Content.Data' -&gt; Offset: 0, Unsized element
Peach.Core.Cracker.DataCracker lookahead: Blob 'Content.Data'
Peach.Core.Cracker.DataCracker getSize: &lt;----- Last Unsized: 229408
Peach.Core.Cracker.DataCracker Crack: Blob 'Content.Data' Size: 229408, Bytes: 0/28676, Bits: 0/229408
Peach.Core.Dom.DataElement Blob 'Content.Data' value is: 3c 3f 78 6d 6c 20 76 65 72 73 69 6f 6e 3d 22 31 2e 30 22 20 65 6e 63 6f 64 69 6e 67 3d 22 55 54.. (Len: 28676 bytes)
Peach.Enterprise.Analyzers.ZipAnalyzer Successfully parsed: word/styles.xml
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Enterprise.Publishers.ZipPublisher start()
Peach.Enterprise.Publishers.ZipPublisher open()
Peach.Enterprise.Publishers.ZipPublisher Added 11 entries to zip file.
Peach.Enterprise.Publishers.ZipPublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Enterprise.Publishers.ZipPublisher stop()

[*] Test 'Default' finished.</screen>
<simpara>View of example in Peach Validator</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/DevGuide/Analyzers/Zip_Simple.png"/>
</imageobject>
<textobject><phrase>Zip Simple</phrase></textobject>
</mediaobject>
</informalfigure>
</example>
<example>
<title>Analyzing a .docx file with mappings</title>
<simpara>This example uses the zip analyzer to decompose a .docx file into its underlying streams.
This example also maps all <emphasis>.xml</emphasis> files to the data model <emphasis>XmlModel</emphasis> that further decomposes the data using the <link linkend="Analyzers_Xml">Xml</link> analyzer.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://peachfuzzer.com/2012/Peach ../peach.xsd"&gt;

	&lt;DataModel name="XmlModel"&gt;
		&lt;String type="utf8" name="Xml"&gt;
			&lt;Analyzer class="Xml"/&gt;
		&lt;/String&gt;
	&lt;/DataModel&gt;

	&lt;DataModel name="WordDoc"&gt;
		&lt;Blob name="Data"&gt;
			&lt;Analyzer class="Zip"&gt;
				&lt;Param name="Map" value="/.xml$/XmlModel/"/&gt;
			&lt;/Analyzer&gt;
		&lt;/Blob&gt;
	&lt;/DataModel&gt;

	&lt;StateModel name="TheState" initialState="initial"&gt;
		&lt;State name="initial"&gt;
			&lt;Action type="output"&gt;
				&lt;DataModel ref="WordDoc"/&gt;
				&lt;Data fileName="example.docx"/&gt;
			&lt;/Action&gt;
		&lt;/State&gt;
	&lt;/StateModel&gt;

	&lt;Test name="Default"&gt;
		&lt;StateModel ref="TheState"/&gt;

		&lt;Publisher class="Zip"&gt;
			&lt;Param name="FileName" value="fuzzed.docx" /&gt;
		&lt;/Publisher&gt;
	&lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Output from the example that decomposes a .docx file into its underlying streams and maps all <emphasis>.xml</emphasis> files to the data model <emphasis>XmlModel</emphasis>.</simpara>
<screen>[*] Test 'Default' starting with random seed 6071.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker DataModel 'WordDoc' Bytes: 0/11272, Bits: 0/90176
Peach.Core.Cracker.DataCracker getSize: -----&gt; DataModel 'WordDoc'
Peach.Core.Cracker.DataCracker scan: DataModel 'WordDoc'
Peach.Core.Cracker.DataCracker scan: Blob 'WordDoc.Data' -&gt; Offset: 0, Unsized element
Peach.Core.Cracker.DataCracker getSize: &lt;----- Deterministic: ???
Peach.Core.Cracker.DataCracker Crack: DataModel 'WordDoc' Size: &lt;null&gt;, Bytes: 0/11272, Bits: 0/90176
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker Blob 'WordDoc.Data' Bytes: 0/11272, Bits: 0/90176
Peach.Core.Cracker.DataCracker getSize: -----&gt; Blob 'WordDoc.Data'
Peach.Core.Cracker.DataCracker scan: Blob 'WordDoc.Data' -&gt; Offset: 0, Unsized element
Peach.Core.Cracker.DataCracker lookahead: Blob 'WordDoc.Data'
Peach.Core.Cracker.DataCracker getSize: &lt;----- Last Unsized: 90176
Peach.Core.Cracker.DataCracker Crack: Blob 'WordDoc.Data' Size: 90176, Bytes: 0/11272, Bits: 0/90176
Peach.Core.Dom.DataElement Blob 'WordDoc.Data' value is: 50 4b 03 04 14 00 06 00 08 00 00 00 21 00 df a4 d2 6c 5a 01 00 00 20 05 00 00 13 00 08 02 5b 43.. (Len: 11272 bytes)
Peach.Enterprise.Analyzers.ZipAnalyzer Attempting to parse: [Content_Types].xml
Peach.Enterprise.Analyzers.ZipAnalyzer Resolved entry '[Content_Types].xml' to data model 'XmlModel'.
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker DataModel 'Content' Bytes: 0/1312, Bits: 0/10496
Peach.Core.Cracker.DataCracker getSize: -----&gt; DataModel 'Content'
Peach.Core.Cracker.DataCracker scan: DataModel 'Content'
Peach.Core.Cracker.DataCracker scan: String 'Content.Xml' -&gt; Offset: 0, Unsized element
Peach.Core.Cracker.DataCracker getSize: &lt;----- Deterministic: ???
Peach.Core.Cracker.DataCracker Crack: DataModel 'Content' Size: &lt;null&gt;, Bytes: 0/1312, Bits: 0/10496
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker String 'Content.Xml' Bytes: 0/1312, Bits: 0/10496
Peach.Core.Cracker.DataCracker getSize: -----&gt; String 'Content.Xml'
Peach.Core.Cracker.DataCracker scan: String 'Content.Xml' -&gt; Offset: 0, Unsized element
Peach.Core.Cracker.DataCracker lookahead: String 'Content.Xml'
Peach.Core.Cracker.DataCracker getSize: &lt;----- Last Unsized: 10496
Peach.Core.Cracker.DataCracker Crack: String 'Content.Xml' Size: 10496, Bytes: 0/1312, Bits: 0/10496
Peach.Core.Dom.DataElement String 'Content.Xml' value is: &lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;
&lt;Types .. (Len: 1312 chars)
Peach.Enterprise.Analyzers.ZipAnalyzer Successfully parsed: [Content_Types].xml
Peach.Enterprise.Analyzers.ZipAnalyzer Attempting to parse: _rels/.rels
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker Block 'Content' Bytes: 0/590, Bits: 0/4720
Peach.Core.Cracker.DataCracker getSize: -----&gt; Block 'Content'
Peach.Core.Cracker.DataCracker scan: Block 'Content'
Peach.Core.Cracker.DataCracker scan: Blob 'Content.Data' -&gt; Offset: 0, Unsized element
Peach.Core.Cracker.DataCracker getSize: &lt;----- Deterministic: ???
Peach.Core.Cracker.DataCracker Crack: Block 'Content' Size: &lt;null&gt;, Bytes: 0/590, Bits: 0/4720
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker Blob 'Content.Data' Bytes: 0/590, Bits: 0/4720
Peach.Core.Cracker.DataCracker getSize: -----&gt; Blob 'Content.Data'
Peach.Core.Cracker.DataCracker scan: Blob 'Content.Data' -&gt; Offset: 0, Unsized element
Peach.Core.Cracker.DataCracker lookahead: Blob 'Content.Data'
Peach.Core.Cracker.DataCracker getSize: &lt;----- Last Unsized: 4720
Peach.Core.Cracker.DataCracker Crack: Blob 'Content.Data' Size: 4720, Bytes: 0/590, Bits: 0/4720
Peach.Core.Dom.DataElement Blob 'Content.Data' value is: 3c 3f 78 6d 6c 20 76 65 72 73 69 6f 6e 3d 22 31 2e 30 22 20 65 6e 63 6f 64 69 6e 67 3d 22 55 54.. (Len: 590 bytes)
Peach.Enterprise.Analyzers.ZipAnalyzer Successfully parsed: _rels/.rels
Peach.Enterprise.Analyzers.ZipAnalyzer Attempting to parse: word/_rels/document.xml.rels
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker Block 'Content' Bytes: 0/817, Bits: 0/6536
Peach.Core.Cracker.DataCracker getSize: -----&gt; Block 'Content'
Peach.Core.Cracker.DataCracker scan: Block 'Content'
Peach.Core.Cracker.DataCracker scan: Blob 'Content.Data' -&gt; Offset: 0, Unsized element
Peach.Core.Cracker.DataCracker getSize: &lt;----- Deterministic: ???
Peach.Core.Cracker.DataCracker Crack: Block 'Content' Size: &lt;null&gt;, Bytes: 0/817, Bits: 0/6536
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker Blob 'Content.Data' Bytes: 0/817, Bits: 0/6536
Peach.Core.Cracker.DataCracker getSize: -----&gt; Blob 'Content.Data'
Peach.Core.Cracker.DataCracker scan: Blob 'Content.Data' -&gt; Offset: 0, Unsized element
Peach.Core.Cracker.DataCracker lookahead: Blob 'Content.Data'
Peach.Core.Cracker.DataCracker getSize: &lt;----- Last Unsized: 6536
Peach.Core.Cracker.DataCracker Crack: Blob 'Content.Data' Size: 6536, Bytes: 0/817, Bits: 0/6536
Peach.Core.Dom.DataElement Blob 'Content.Data' value is: 3c 3f 78 6d 6c 20 76 65 72 73 69 6f 6e 3d 22 31 2e 30 22 20 65 6e 63 6f 64 69 6e 67 3d 22 55 54.. (Len: 817 bytes)
Peach.Enterprise.Analyzers.ZipAnalyzer Successfully parsed: word/_rels/document.xml.rels
Peach.Enterprise.Analyzers.ZipAnalyzer Attempting to parse: word/document.xml
Peach.Enterprise.Analyzers.ZipAnalyzer Resolved entry 'word/document.xml' to data model 'XmlModel'.
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker DataModel 'Content' Bytes: 0/1620, Bits: 0/12960
Peach.Core.Cracker.DataCracker getSize: -----&gt; DataModel 'Content'
Peach.Core.Cracker.DataCracker scan: DataModel 'Content'
Peach.Core.Cracker.DataCracker scan: String 'Content.Xml' -&gt; Offset: 0, Unsized element
Peach.Core.Cracker.DataCracker getSize: &lt;----- Deterministic: ???
Peach.Core.Cracker.DataCracker Crack: DataModel 'Content' Size: &lt;null&gt;, Bytes: 0/1620, Bits: 0/12960
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker String 'Content.Xml' Bytes: 0/1620, Bits: 0/12960
Peach.Core.Cracker.DataCracker getSize: -----&gt; String 'Content.Xml'
Peach.Core.Cracker.DataCracker scan: String 'Content.Xml' -&gt; Offset: 0, Unsized element
Peach.Core.Cracker.DataCracker lookahead: String 'Content.Xml'
Peach.Core.Cracker.DataCracker getSize: &lt;----- Last Unsized: 12960
Peach.Core.Cracker.DataCracker Crack: String 'Content.Xml' Size: 12960, Bytes: 0/1620, Bits: 0/12960
Peach.Core.Dom.DataElement String 'Content.Xml' value is: &lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;
&lt;w:docu.. (Len: 1620 chars)
Peach.Enterprise.Analyzers.ZipAnalyzer Successfully parsed: word/document.xml
Peach.Enterprise.Analyzers.ZipAnalyzer Attempting to parse: word/theme/theme1.xml
Peach.Enterprise.Analyzers.ZipAnalyzer Resolved entry 'word/theme/theme1.xml' to data model 'XmlModel'.
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker DataModel 'Content' Bytes: 0/6795, Bits: 0/54360
Peach.Core.Cracker.DataCracker getSize: -----&gt; DataModel 'Content'
Peach.Core.Cracker.DataCracker scan: DataModel 'Content'
Peach.Core.Cracker.DataCracker scan: String 'Content.Xml' -&gt; Offset: 0, Unsized element
Peach.Core.Cracker.DataCracker getSize: &lt;----- Deterministic: ???
Peach.Core.Cracker.DataCracker Crack: DataModel 'Content' Size: &lt;null&gt;, Bytes: 0/6795, Bits: 0/54360
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker String 'Content.Xml' Bytes: 0/6795, Bits: 0/54360
Peach.Core.Cracker.DataCracker getSize: -----&gt; String 'Content.Xml'
Peach.Core.Cracker.DataCracker scan: String 'Content.Xml' -&gt; Offset: 0, Unsized element
Peach.Core.Cracker.DataCracker lookahead: String 'Content.Xml'
Peach.Core.Cracker.DataCracker getSize: &lt;----- Last Unsized: 54360
Peach.Core.Cracker.DataCracker Crack: String 'Content.Xml' Size: 54360, Bytes: 0/6795, Bits: 0/54360
Peach.Core.Dom.DataElement String 'Content.Xml' value is: &lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;
&lt;a:them.. (Len: 6735 chars)
Peach.Enterprise.Analyzers.ZipAnalyzer Successfully parsed: word/theme/theme1.xml
Peach.Enterprise.Analyzers.ZipAnalyzer Attempting to parse: word/settings.xml
Peach.Enterprise.Analyzers.ZipAnalyzer Resolved entry 'word/settings.xml' to data model 'XmlModel'.
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker DataModel 'Content' Bytes: 0/2477, Bits: 0/19816
Peach.Core.Cracker.DataCracker getSize: -----&gt; DataModel 'Content'
Peach.Core.Cracker.DataCracker scan: DataModel 'Content'
Peach.Core.Cracker.DataCracker scan: String 'Content.Xml' -&gt; Offset: 0, Unsized element
Peach.Core.Cracker.DataCracker getSize: &lt;----- Deterministic: ???
Peach.Core.Cracker.DataCracker Crack: DataModel 'Content' Size: &lt;null&gt;, Bytes: 0/2477, Bits: 0/19816
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker String 'Content.Xml' Bytes: 0/2477, Bits: 0/19816
Peach.Core.Cracker.DataCracker getSize: -----&gt; String 'Content.Xml'
Peach.Core.Cracker.DataCracker scan: String 'Content.Xml' -&gt; Offset: 0, Unsized element
Peach.Core.Cracker.DataCracker lookahead: String 'Content.Xml'
Peach.Core.Cracker.DataCracker getSize: &lt;----- Last Unsized: 19816
Peach.Core.Cracker.DataCracker Crack: String 'Content.Xml' Size: 19816, Bytes: 0/2477, Bits: 0/19816
Peach.Core.Dom.DataElement String 'Content.Xml' value is: &lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;
&lt;w:sett.. (Len: 2477 chars)
Peach.Enterprise.Analyzers.ZipAnalyzer Successfully parsed: word/settings.xml
Peach.Enterprise.Analyzers.ZipAnalyzer Attempting to parse: word/fontTable.xml
Peach.Enterprise.Analyzers.ZipAnalyzer Resolved entry 'word/fontTable.xml' to data model 'XmlModel'.
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker DataModel 'Content' Bytes: 0/1261, Bits: 0/10088
Peach.Core.Cracker.DataCracker getSize: -----&gt; DataModel 'Content'
Peach.Core.Cracker.DataCracker scan: DataModel 'Content'
Peach.Core.Cracker.DataCracker scan: String 'Content.Xml' -&gt; Offset: 0, Unsized element
Peach.Core.Cracker.DataCracker getSize: &lt;----- Deterministic: ???
Peach.Core.Cracker.DataCracker Crack: DataModel 'Content' Size: &lt;null&gt;, Bytes: 0/1261, Bits: 0/10088
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker String 'Content.Xml' Bytes: 0/1261, Bits: 0/10088
Peach.Core.Cracker.DataCracker getSize: -----&gt; String 'Content.Xml'
Peach.Core.Cracker.DataCracker scan: String 'Content.Xml' -&gt; Offset: 0, Unsized element
Peach.Core.Cracker.DataCracker lookahead: String 'Content.Xml'
Peach.Core.Cracker.DataCracker getSize: &lt;----- Last Unsized: 10088
Peach.Core.Cracker.DataCracker Crack: String 'Content.Xml' Size: 10088, Bytes: 0/1261, Bits: 0/10088
Peach.Core.Dom.DataElement String 'Content.Xml' value is: &lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;
&lt;w:font.. (Len: 1261 chars)
Peach.Enterprise.Analyzers.ZipAnalyzer Successfully parsed: word/fontTable.xml
Peach.Enterprise.Analyzers.ZipAnalyzer Attempting to parse: word/webSettings.xml
Peach.Enterprise.Analyzers.ZipAnalyzer Resolved entry 'word/webSettings.xml' to data model 'XmlModel'.
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker DataModel 'Content' Bytes: 0/497, Bits: 0/3976
Peach.Core.Cracker.DataCracker getSize: -----&gt; DataModel 'Content'
Peach.Core.Cracker.DataCracker scan: DataModel 'Content'
Peach.Core.Cracker.DataCracker scan: String 'Content.Xml' -&gt; Offset: 0, Unsized element
Peach.Core.Cracker.DataCracker getSize: &lt;----- Deterministic: ???
Peach.Core.Cracker.DataCracker Crack: DataModel 'Content' Size: &lt;null&gt;, Bytes: 0/497, Bits: 0/3976
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker String 'Content.Xml' Bytes: 0/497, Bits: 0/3976
Peach.Core.Cracker.DataCracker getSize: -----&gt; String 'Content.Xml'
Peach.Core.Cracker.DataCracker scan: String 'Content.Xml' -&gt; Offset: 0, Unsized element
Peach.Core.Cracker.DataCracker lookahead: String 'Content.Xml'
Peach.Core.Cracker.DataCracker getSize: &lt;----- Last Unsized: 3976
Peach.Core.Cracker.DataCracker Crack: String 'Content.Xml' Size: 3976, Bytes: 0/497, Bits: 0/3976
Peach.Core.Dom.DataElement String 'Content.Xml' value is: &lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;
&lt;w:webS.. (Len: 497 chars)
Peach.Enterprise.Analyzers.ZipAnalyzer Successfully parsed: word/webSettings.xml
Peach.Enterprise.Analyzers.ZipAnalyzer Attempting to parse: docProps/app.xml
Peach.Enterprise.Analyzers.ZipAnalyzer Resolved entry 'docProps/app.xml' to data model 'XmlModel'.
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker DataModel 'Content' Bytes: 0/711, Bits: 0/5688
Peach.Core.Cracker.DataCracker getSize: -----&gt; DataModel 'Content'
Peach.Core.Cracker.DataCracker scan: DataModel 'Content'
Peach.Core.Cracker.DataCracker scan: String 'Content.Xml' -&gt; Offset: 0, Unsized element
Peach.Core.Cracker.DataCracker getSize: &lt;----- Deterministic: ???
Peach.Core.Cracker.DataCracker Crack: DataModel 'Content' Size: &lt;null&gt;, Bytes: 0/711, Bits: 0/5688
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker String 'Content.Xml' Bytes: 0/711, Bits: 0/5688
Peach.Core.Cracker.DataCracker getSize: -----&gt; String 'Content.Xml'
Peach.Core.Cracker.DataCracker scan: String 'Content.Xml' -&gt; Offset: 0, Unsized element
Peach.Core.Cracker.DataCracker lookahead: String 'Content.Xml'
Peach.Core.Cracker.DataCracker getSize: &lt;----- Last Unsized: 5688
Peach.Core.Cracker.DataCracker Crack: String 'Content.Xml' Size: 5688, Bytes: 0/711, Bits: 0/5688
Peach.Core.Dom.DataElement String 'Content.Xml' value is: &lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;
&lt;Proper.. (Len: 711 chars)
Peach.Enterprise.Analyzers.ZipAnalyzer Successfully parsed: docProps/app.xml
Peach.Enterprise.Analyzers.ZipAnalyzer Attempting to parse: docProps/core.xml
Peach.Enterprise.Analyzers.ZipAnalyzer Resolved entry 'docProps/core.xml' to data model 'XmlModel'.
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker DataModel 'Content' Bytes: 0/747, Bits: 0/5976
Peach.Core.Cracker.DataCracker getSize: -----&gt; DataModel 'Content'
Peach.Core.Cracker.DataCracker scan: DataModel 'Content'
Peach.Core.Cracker.DataCracker scan: String 'Content.Xml' -&gt; Offset: 0, Unsized element
Peach.Core.Cracker.DataCracker getSize: &lt;----- Deterministic: ???
Peach.Core.Cracker.DataCracker Crack: DataModel 'Content' Size: &lt;null&gt;, Bytes: 0/747, Bits: 0/5976
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker String 'Content.Xml' Bytes: 0/747, Bits: 0/5976
Peach.Core.Cracker.DataCracker getSize: -----&gt; String 'Content.Xml'
Peach.Core.Cracker.DataCracker scan: String 'Content.Xml' -&gt; Offset: 0, Unsized element
Peach.Core.Cracker.DataCracker lookahead: String 'Content.Xml'
Peach.Core.Cracker.DataCracker getSize: &lt;----- Last Unsized: 5976
Peach.Core.Cracker.DataCracker Crack: String 'Content.Xml' Size: 5976, Bytes: 0/747, Bits: 0/5976
Peach.Core.Dom.DataElement String 'Content.Xml' value is: &lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;
&lt;cp:cor.. (Len: 747 chars)
Peach.Enterprise.Analyzers.ZipAnalyzer Successfully parsed: docProps/core.xml
Peach.Enterprise.Analyzers.ZipAnalyzer Attempting to parse: word/styles.xml
Peach.Enterprise.Analyzers.ZipAnalyzer Resolved entry 'word/styles.xml' to data model 'XmlModel'.
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker DataModel 'Content' Bytes: 0/28676, Bits: 0/229408
Peach.Core.Cracker.DataCracker getSize: -----&gt; DataModel 'Content'
Peach.Core.Cracker.DataCracker scan: DataModel 'Content'
Peach.Core.Cracker.DataCracker scan: String 'Content.Xml' -&gt; Offset: 0, Unsized element
Peach.Core.Cracker.DataCracker getSize: &lt;----- Deterministic: ???
Peach.Core.Cracker.DataCracker Crack: DataModel 'Content' Size: &lt;null&gt;, Bytes: 0/28676, Bits: 0/229408
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker String 'Content.Xml' Bytes: 0/28676, Bits: 0/229408
Peach.Core.Cracker.DataCracker getSize: -----&gt; String 'Content.Xml'
Peach.Core.Cracker.DataCracker scan: String 'Content.Xml' -&gt; Offset: 0, Unsized element
Peach.Core.Cracker.DataCracker lookahead: String 'Content.Xml'
Peach.Core.Cracker.DataCracker getSize: &lt;----- Last Unsized: 229408
Peach.Core.Cracker.DataCracker Crack: String 'Content.Xml' Size: 229408, Bytes: 0/28676, Bits: 0/229408
Peach.Core.Dom.DataElement String 'Content.Xml' value is: &lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;
&lt;w:styl.. (Len: 28676 chars)
Peach.Enterprise.Analyzers.ZipAnalyzer Successfully parsed: word/styles.xml
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Enterprise.Publishers.ZipPublisher start()
Peach.Enterprise.Publishers.ZipPublisher open()
Peach.Enterprise.Publishers.ZipPublisher Added 11 entries to zip file.
Peach.Enterprise.Publishers.ZipPublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Enterprise.Publishers.ZipPublisher stop()

[*] Test 'Default' finished.</screen>
<simpara>View of example in Peach Validator</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/DevGuide/Analyzers/Zip_Map.png"/>
</imageobject>
<textobject><phrase>Zip Map</phrase></textobject>
</mediaobject>
</informalfigure>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
</section>
</section>
<section xml:id="_data_elements">
<title>Data Elements</title>
<simpara>The following items comprise the data elements in Peach.</simpara>
<variablelist>
<varlistentry>
<term><xref linkend="Blob"/></term>
<listitem>
<simpara><emphasis>Blob</emphasis> elements are containers for unstructured data (think byte arrays).
A <emphasis>Blob</emphasis> is a term used in the relational database field for a column that holds raw binary data.
Data contained in a <emphasis>Blob</emphasis> will be dumb fuzzed.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><xref linkend="Block"/></term>
<listitem>
<simpara>The <emphasis>Block</emphasis> element is a container for other data elements.
By itself, a <emphasis>Block</emphasis> does not have any size or contain other data.
It simply groups other data elements and,
by using the Block name,
provides a mechanism to reference or operate on the group as a single unit.</simpara>
<simpara>For example,
if two data elements are included in a checksum calculation,
they can be placed in a <emphasis>Block</emphasis> element
and then the fixup can perform its function by referencing the <emphasis>Block</emphasis>.
Both items in the group will be included in the fixup operation.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><xref linkend="Choice"/></term>
<listitem>
<simpara>The <emphasis>Choice</emphasis> element allows constructing switch-like statements in Peach data models.
The <emphasis>Choice</emphasis> element is useful when modeling type-length-value (TLV) metaphors
and in other situations where the data format changes.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><xref linkend="DataModel"/></term>
<listitem>
<simpara>The <emphasis>DataModel</emphasis> element is a top-level element that defines a data model.
Multiple <emphasis>DataModel</emphasis> elements can exist in a pit file.
A <emphasis>DataModel</emphasis> element by itself has no size and is a container for other data elements.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><xref linkend="Double"/></term>
<listitem>
<simpara><emphasis>Double</emphasis> defines a floating-point number of 32 or 64 bits conforming to the IEEE 754 standard.
Floating point values are packed into a byte representation with a byte order of little or big endian.</simpara>
<simpara><emphasis>Double</emphasis> elements are always packed to bit/byte representation with byte order (endian-ness).
For ASCII strings, use the <emphasis>String</emphasis> element instead of a <emphasis>Double</emphasis>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><xref linkend="Flags"/></term>
<listitem>
<simpara><emphasis>Flags</emphasis> defines a set of flags and is a container for <emphasis>Flag</emphasis> elements.
The <emphasis>Flags</emphasis> container can provide a nice shortcut when dealing with a flag set that has many unused positions.</simpara>
<simpara>Tip: The <emphasis>Number</emphasis> element supports unaligned sizes and can be used to define flags.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><xref linkend="Flag"/></term>
<listitem>
<simpara><emphasis>Flag</emphasis> defines a specific <emphasis>Flag</emphasis> in a flag set.
<emphasis>Flag</emphasis> elements have a bit position and bit length.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><xref linkend="Frag"/></term>
<listitem>
<simpara>Used to model protocol fragmentation</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><xref linkend="JsonArray"/></term>
<listitem>
<simpara><emphasis>JsonArray</emphasis> is used to represent a JSON array.
It&#8217;s similar in operation to <xref linkend="Sequence"/>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><xref linkend="JsonBool"/></term>
<listitem>
<simpara>The <emphasis>JsonBool</emphasis> element defines a Boolean value (values 0 or 1) that represents either true or false.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><xref linkend="JsonBlob"/></term>
<listitem>
<simpara>A JsonBlob <footnote><simpara>Blob stands for "binary large object" a term used by databases to represent a column of binary data.</simpara></footnote> is used to represent binary JSON data (array of bytes).
JsonBlobs are base64 encoded.</simpara>
<simpara>By definition, the internal contents of a JsonBlob is unknown.
Consequently, Blobs are dumb fuzzed, as the list of applicable mutators below indicates.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><xref linkend="JsonDouble"/></term>
<listitem>
<simpara>The <emphasis>JsonDouble</emphasis> element defines a JSON floating-point number of up to 64-bits.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><xref linkend="JsonInteger"/></term>
<listitem>
<simpara>The JsonInteger element defines a binary number of any arbitrary bit size from 1 to 64.
Binary numbers are packed into a byte representation with a byte order of little-endian or big-endian.</simpara>
<simpara>The Number element should not be used for character-based numbers, or ASCII numbers.
Instead, use a <xref linkend="String"/> element.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><xref linkend="JsonObject"/></term>
<listitem>
<simpara>The <emphasis>JsonObject</emphasis> element is used to model <link xl:href="http://www.json.org/">JavaScript Object Notation (JSON)</link> objects.</simpara>
<simpara><emphasis>JsonObject</emphasis> elements are containers that group JSON elements in a logical structure.
For example,
a <emphasis>JsonString</emphasis> element,
a <emphasis>JsonInteger</emphasis> element,
and a <emphasis>JsonBlob</emphasis> element can exist in the same <emphasis>JsonObject</emphasis>.
A <emphasis>JsonObject</emphasis> can contain other <emphasis>JsonObjects</emphasis>, or nest, as deeply as needed.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><xref linkend="JsonRaw"/></term>
<listitem>
<simpara>The <emphasis>JsonRaw</emphasis> element is used to embeded raw string or binary data into a JSON document.
This allows creation of json that does not adhere to the JSON specification.</simpara>
<simpara>This is a container element that is able to host other data elements.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><xref linkend="JsonString"/></term>
<listitem>
<simpara>Represents a JSON string of Unicode characters.</simpara>
<simpara>All strings are encoded prior to output according to the JSON specification.</simpara>
<simpara>Strings can hold numbers that are stored in a string format.
When strings contain a number,
Peach additionally uses numerical mutators to mutate the strings.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><xref linkend="Number"/></term>
<listitem>
<simpara><emphasis>Number</emphasis> defines a binary integer type.
A <emphasis>Number</emphasis> is always packed to bit/byte representation with byte order (endian-ness).
For ASCII strings, use the <emphasis>String</emphasis> element instead of a <emphasis>Number</emphasis>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><xref linkend="Padding"/></term>
<listitem>
<simpara><emphasis>Padding</emphasis> defines padding of one or more characters for a <emphasis>Block</emphasis> or a <emphasis>DataModel</emphasis>.
The attributes of the <emphasis>Padding</emphasis> element specify things such as a reference to start the alignment calculation, a size, and the <emphasis>Padding</emphasis> element name.
The most common use of <emphasis>Padding</emphasis> is to ensure a consistent length of a <emphasis>Block</emphasis> or <emphasis>DataModel</emphasis> that contains variable length data elements,
such as padding a <emphasis>DataModel</emphasis> for a 64-byte packet.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><xref linkend="Sequence"/></term>
<listitem>
<simpara><emphasis>Sequence</emphasis> elements are used to construct arrays consisting of predefined data elements.
A <emphasis>Sequence</emphasis> is able to contain multiple data types at once.
Unlike regular arrays in Peach,
the size of the Sequence is determined by the number of elements within the sequence.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><xref linkend="Stream"/></term>
<listitem>
<simpara><emphasis>Stream</emphasis> defines a <emphasis>Stream</emphasis> element with a name, attributes and content.
<emphasis>Streams</emphasis> group one or more data elements into a logical structure.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><xref linkend="String"/></term>
<listitem>
<simpara>A <emphasis>string</emphasis> defines a contiguous sequence of characters with encoding.
Encodings include ASCII and many Unicode formats.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><xref linkend="VarNumber"/></term>
<listitem>
<simpara>Allows modeling variable width <emphasis>Numbers</emphasis>. Size must be constrained using a size-of relationship or other method.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><xref linkend="XmlAttribute"/></term>
<listitem>
<simpara>The <emphasis>XmlAttribute</emphasis> defines an XML attribute.
This element is only valid as a child of <xref linkend="XmlElement"/>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><xref linkend="XmlCharacterData"/></term>
<listitem>
<simpara>The <emphasis>XmlCharacterData</emphasis> element defines an XML CDATA section.
This element is only valid as a child of <xref linkend="XmlElement"/>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><xref linkend="XmlElement"/></term>
<listitem>
<simpara><emphasis>XmlElement</emphasis> defines an XML element.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><?asciidoc-pagebreak?></simpara>
<section xml:id="Asn1Type">
<title>Asn1Type</title>
<simpara><emphasis>Asn1Type</emphasis> is used to model Abstract Syntax Notation One (ASN.1) structures.</simpara>
<simpara>The <emphasis>Asn1Type</emphasis> specifies the information of ASN.1 fields. ASN.1 data elements can be primitive (pre-defined) or constructed. ASN.1 structures can be very deep. It&#8217;s recommended to use the ASN.1 analyzer to generate data models that can then be modified.</simpara>
<tip>
<simpara>This element exists for manually coding ASN.1 data elements. An alternative is to use the ASN.1 analyzer that can generate an ASN.1 data model, and produces instances of this element in the resulting data model.</simpara>
</tip>
<section xml:id="_syntax_43">
<title>Syntax</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;Asn1Type class="0" pc="1" tag="16" name="TerminationID"&gt;
    &lt;Block name="Value"&gt;
        &lt;Asn1Type class="2" pc="1" tag="0" name="wildcard"&gt;
            &lt;Block name="Value" /&gt;
        &lt;/Asn1Type&gt;
        &lt;Asn1Type class="2" pc="0" tag="1" name="id"&gt;
            &lt;Blob name="terminationIDValue" valueType="hex" value="00000000300015c1" /&gt;
        &lt;/Asn1Type&gt;
    &lt;/Block&gt;
&lt;/Asn1Type&gt;</programlisting>
</section>
<section xml:id="_attributes_28">
<title>Attributes</title>
<simpara><emphasis>Required:</emphasis></simpara>
<variablelist>
<varlistentry>
<term><emphasis role="strong">tag</emphasis></term>
<listitem>
<simpara>ASN.1 tag identifier (numeric)</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term><emphasis role="strong">class</emphasis></term>
<listitem>
<simpara>ASN.1 Class value, default is "0".<?asciidoc-br?></simpara>
</listitem>
</varlistentry>
</variablelist>
<informaltable tabstyle="horizontal" frame="none" colsep="0" rowsep="0">
<tgroup cols="2">
<colspec colwidth="15*"/>
<colspec colwidth="85*"/>
<tbody valign="top">
<row>
<entry>
<simpara>0</simpara>
</entry>
<entry>
<simpara>Universal class.</simpara>
</entry>
</row>
<row>
<entry>
<simpara>1</simpara>
</entry>
<entry>
<simpara>Application class.</simpara>
</entry>
</row>
<row>
<entry>
<simpara>2</simpara>
</entry>
<entry>
<simpara>Context-specific class.</simpara>
</entry>
</row>
<row>
<entry>
<simpara>3</simpara>
</entry>
<entry>
<simpara>Private class.</simpara>
</entry>
</row>
</tbody>
</tgroup>
</informaltable>
<variablelist>
<varlistentry>
<term><link linkend="constraint">constraint</link></term>
<listitem>
<simpara>Scripting expression that evaluates to true or false, default is "".</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><emphasis role="strong">forceMultiByteIdentifier</emphasis></term>
<listitem>
<simpara>If "true", force long encoding of ASN.1 tags. The default is "false".</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><emphasis role="strong">indefiniteLength</emphasis></term>
<listitem>
<simpara>If "true", use the indefinite encoding form of the ASN.1 element.
If "false", use definite encoding form.
The default is "false".</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><emphasis role="strong">longLength</emphasis></term>
<listitem>
<simpara>If "true", always use the long encoding form (that is, multiple length octets) to express the length of the ASN.1 element.
If "false", also allow the short encoding form where the number of content octets is expressed in 7 bits (127 or less).
The default is "false".</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="minOccurs">minOccurs</link></term>
<listitem>
<simpara>The minimum number of times this blob must occur. Defaults to 1. <?asciidoc-br?></simpara>
<itemizedlist>
<listitem>
<simpara>Used to define arrays with variable size. Arrays defined by min/maxOccurs generally have a relation
defined.</simpara>
</listitem>
<listitem>
<simpara>Adding this attribute, even with a value of 1, converts the element to an array.</simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="maxOccurs">maxOccurs</link></term>
<listitem>
<simpara>The maximum number of times this blob can occur. Defaults to 1. <?asciidoc-br?></simpara>
<itemizedlist>
<listitem>
<simpara>Used to define arrays with static size.</simpara>
</listitem>
<listitem>
<simpara>Adding this attribute, even with a value of 1, converts the element to an array.</simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="mutable">mutable</link></term>
<listitem>
<simpara>Is this element mutable, default is "true".</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="name">name</link></term>
<listitem>
<simpara>Element name, default is "true".</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><emphasis role="strong">pc</emphasis></term>
<listitem>
<simpara>Integer that specifies whether the ASN.1 element is a primitive or a constructed element.
The default is "0" which indicates a primitive element.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="token">token</link></term>
<listitem>
<simpara>Is this element a token for parsing, default is "false".</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_child_elements_12">
<title>Child Elements</title>
<variablelist>
<varlistentry>
<term><link linkend="Asn1Type">Asn1Type</link></term>
<listitem>
<simpara>Asn1Type of a child ASN.1 data element.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Blob">Blob</link></term>
<listitem>
<simpara>Represents binary data (array of bytes) to create simple dumb fuzzers in Peach.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Block">Block</link></term>
<listitem>
<simpara>Groups one or more data elements in a logical structure.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Choice">Choice</link></term>
<listitem>
<simpara>Indicates that all of the sub-elements are valid; but, only one
sub-element should be selected.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Flags">Flags</link></term>
<listitem>
<simpara>Defines a set of bit-sized flags.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Number">Number</link></term>
<listitem>
<simpara>Defines a binary number of arbitrary bit size.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Padding">Padding</link></term>
<listitem>
<simpara>Pads variably sized blocks or data models provide size uniformity or consistency.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Placement">Placement</link></term>
<listitem>
<simpara>Relocates an element after it has been cracked.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Stream">Stream</link></term>
<listitem>
<simpara>Groups one or more data elements in a logical structure.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="String">String</link></term>
<listitem>
<simpara>Character sequence consisting of ASCII or Unicode characters.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="XmlAttribute">XmlAttribute</link></term>
<listitem>
<simpara>Performs static transformations such as compression or encoding.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="XmlElement">XmlElement</link></term>
<listitem>
<simpara>Defines an XML element, the basic building block of XML documents.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Fixup">Fixup</link></term>
<listitem>
<simpara>Performs dynamic transformations such as checksums and CRCs.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Hint">Hint</link></term>
<listitem>
<simpara>Provides information to mutators.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Transformer">Transformer</link></term>
<listitem>
<simpara>Performs static transformations such as compression or encoding.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Relation">Relation</link></term>
<listitem>
<simpara>Identifies a type of relationship with another data element, such as count.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Analyzers">Analyzer</link></term>
<listitem>
<simpara>Analyzes current element post cracking, can dynamically change model.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_mutators_2">
<title>Mutators</title>
<simpara>This data element is a container element with several hidden internal elements of Number type, plus any value for the ASN.1 field.  This data element will get fuzzed with all mutators from Block and Number.</simpara>
<simpara>&#160;</simpara>
</section>
<section xml:id="Asn1Type_Examples">
<title>Examples</title>
<example>
<title>Example of ASN.1 Model</title>
<simpara>Example of modeling an ASN.1 specification fragment.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach&gt;

	&lt;DataModel name="TheDataModel"&gt;
        &lt;Asn1Type class="2" pc="1" tag="0" name="terminationId"&gt;
            &lt;Asn1Type class="0" pc="1" tag="16" name="TerminationID"&gt;
                &lt;Block name="Value"&gt;
                    &lt;Asn1Type class="2" pc="1" tag="0" name="wildcard"&gt;
                        &lt;Block name="Value" /&gt;
                    &lt;/Asn1Type&gt;
                    &lt;Asn1Type class="2" pc="0" tag="1" name="id"&gt;
                        &lt;Blob name="terminationIDValue" valueType="hex" value="00000000300015c1" /&gt;
                    &lt;/Asn1Type&gt;
                &lt;/Block&gt;
            &lt;/Asn1Type&gt;
        &lt;/Asn1Type&gt;
	&lt;/DataModel&gt;

&lt;/Peach&gt;</programlisting>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Blob">
<title>Blob</title>
<simpara>A Blob <footnote><simpara>Blob stands for "binary large object" a term used by databases to represent a column of binary data.</simpara></footnote> is used to represent binary data (array of bytes). Blobs are sized in bytes.</simpara>
<simpara>A Blob is always a child of a data element container such as <link linkend="DataModel">DataModel</link> or <link linkend="Block">Block</link>. By definition, the internal contents of a Blob is unknown. Consequently, Blobs are dumb fuzzed, as the list of applicable mutators below indicates.</simpara>
<simpara>Blobs can be used to create simple dumb fuzzers in Peach, see <link linkend="Blob_Examples">examples</link>.</simpara>
<section xml:id="_syntax_44">
<title>Syntax</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;Blob valueType="hex" value="01 06 22 03" /&gt;</programlisting>
</section>
<section xml:id="_attributes_29">
<title>Attributes</title>
<simpara><emphasis>Required:</emphasis></simpara>
<simpara>There are no required attributes.</simpara>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term><link linkend="name">name</link></term>
<listitem>
<simpara>Element name</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="length">length</link></term>
<listitem>
<simpara>The length of data in this element.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="lengthType">lengthType</link></term>
<listitem>
<simpara>Units of the length attribute. Defaults to "bytes". Can also be "chars", or "bits" where the number of bits is a multiple of 8.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="value">value</link></term>
<listitem>
<simpara>Default value.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="valueType">valueType</link></term>
<listitem>
<simpara>Format of value attribute.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="occurs">occurs</link></term>
<listitem>
<simpara>Actual occurrences of element. Defaults to 1. <?asciidoc-br?></simpara>
<itemizedlist>
<listitem>
<simpara>Used to define arrays with static size.</simpara>
</listitem>
<listitem>
<simpara>Adding this attribute, even with a value of 1, converts the element to an array.</simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="minOccurs">minOccurs</link></term>
<listitem>
<simpara>The minimum number of times this blob must occur. Defaults to 1. <?asciidoc-br?></simpara>
<itemizedlist>
<listitem>
<simpara>Used to define arrays with variable size. Arrays defined by min/maxOccurs generally have a relation
defined.</simpara>
</listitem>
<listitem>
<simpara>Adding this attribute, even with a value of 1, converts the element to an array.</simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="maxOccurs">maxOccurs</link></term>
<listitem>
<simpara>The maximum number of times this blob can occur. Defaults to 1. <?asciidoc-br?></simpara>
<itemizedlist>
<listitem>
<simpara>Used to define arrays with static size.</simpara>
</listitem>
<listitem>
<simpara>Adding this attribute, even with a value of 1, converts the element to an array.</simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="constraint">constraint</link></term>
<listitem>
<simpara>A constraint in the form of an expression.  Used during data cracking.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="mutable">mutable</link></term>
<listitem>
<simpara>Is the blob changeable (should it be fuzzed). Defaults to true.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="token">token</link></term>
<listitem>
<simpara>This element should be treated as a token when parsing. Defaults to false.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_child_elements_13">
<title>Child Elements</title>
<variablelist>
<varlistentry>
<term><link linkend="Analyzers">Analyzer</link></term>
<listitem>
<simpara>Analyzes current element post cracking, can dynamically change model.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Fixup">Fixup</link></term>
<listitem>
<simpara>Performs dynamic transformations such as checksums and CRCs.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Hint">Hint</link></term>
<listitem>
<simpara>Provides information to mutators.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Placement">Placement</link></term>
<listitem>
<simpara>Relocates an element after it has been cracked.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Transformer">Transformer</link></term>
<listitem>
<simpara>Performs static transformations such as compression or encoding.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_mutators_3">
<title>Mutators</title>
<simpara>The following mutators operate on this element type.</simpara>
<simpara><emphasis>Enabled when element is marked as an array</emphasis></simpara>
<variablelist>
<varlistentry>
<term><link linkend="Mutators_ArrayNumericalEdgeCasesMutator">ArrayNumericalEdgeCasesMutator</link></term>
<listitem>
<simpara>This mutator grows and shrinks an array to counts based on numerical edge cases.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_ArrayRandomizeOrderMutator">ArrayRandomizeOrderMutator</link></term>
<listitem>
<simpara>This mutator randomizes the order of items in an array.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_ArrayReverseOrderMutator">ArrayReverseOrderMutator</link></term>
<listitem>
<simpara>This mutator reverses the order of items in an array.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_ArrayVarianceMutator">ArrayVarianceMutator</link></term>
<listitem>
<simpara>This mutator grows and shrinks an array to a variance of counts based on the current size.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Used for all data elements</emphasis></simpara>
<variablelist>
<varlistentry>
<term><link linkend="Mutators_DataElementBitFlipper">DataElementBitFlipper</link></term>
<listitem>
<simpara>This mutator produces test cases by flipping bits in the output value.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_DataElementDuplicate">DataElementDuplicate</link></term>
<listitem>
<simpara>This mutator duplicates data elements.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_DataElementRemove">DataElementRemove</link></term>
<listitem>
<simpara>This mutator removes data elements.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_DataElementSwapNear">DataElementSwapNear</link></term>
<listitem>
<simpara>This mutator swaps data elements.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_SampleNinjaMutator">SampleNinjaMutator</link></term>
<listitem>
<simpara>This mutator combines data elements from different data sets.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Enabled when element is part of a size relation</emphasis></simpara>
<variablelist>
<varlistentry>
<term><link linkend="Mutators_SizedDataEdgeCase">SizedDataEdgeCase</link></term>
<listitem>
<simpara>This mutator causes the data portion of a relation to be sized as numerical edge cases.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_SizedDataVariance">SizedDataVariance</link></term>
<listitem>
<simpara>This mutator causes the data portion of a relation to be sized as numerical variances.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_SizedEdgeCase">SizedEdgeCase</link></term>
<listitem>
<simpara>This mutator changes both sides of the relation (data and value) to match numerical edge cases.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_SizedVariance">SizedVariance</link></term>
<listitem>
<simpara>This mutator changes both sides of the relation (data and value) to match numerical variances of the current size.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Specific to this element type</emphasis></simpara>
<variablelist>
<varlistentry>
<term><link linkend="Mutators_BlobChangeFromNull">BlobChangeFromNull</link></term>
<listitem>
<simpara>This mutator produces test cases in which null bytes in a <link linkend="Blob">Blob</link> element are changed to a non-null value.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_BlobChangeRandom">BlobChangeRandom</link></term>
<listitem>
<simpara>This mutator produces test cases by changing random selections of bytes to random value.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_BlobChangeSpecial">BlobChangeSpecial</link></term>
<listitem>
<simpara>This mutator produces test cases by changing random selections of bytes to one of 0x00, 0x01, 0xFE, 0xFF.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_BlobChangeToNull">BlobChangeToNull</link></term>
<listitem>
<simpara>This mutator produces test cases by changing a random number of bytes to 0x00.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_BlobExpandSingleIncrementing">BlobExpandSingleIncrementing</link></term>
<listitem>
<simpara>This mutator produces test cases by expanding the size of the blob using incrementing values.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_BlobExpandAllRandom">BlobExpandAllRandom</link></term>
<listitem>
<simpara>This mutator produces test cases by expanding the size of the blob using random values.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_BlobExpandSingleRandom">BlobExpandSingleRandom</link></term>
<listitem>
<simpara>This mutator produces test cases by expanding the size of the blob using a single random byte (repeated as needed).</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_BlobExpandZero">BlobExpandZero</link></term>
<listitem>
<simpara>This mutator produces test cases by expanding the blob using null values.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_BlobReduce">BlobReduce</link></term>
<listitem>
<simpara>This mutator produces test cases by reducing the size of the blob by a random amount.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_ExtraValues">ExtraValues</link></term>
<listitem>
<simpara>This mutator allows providing extra test case values on a per-data element basis.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="Blob_Examples">
<title>Examples</title>
<example>
<title>Dumb file fuzzing</title>
<simpara>This is an example of dumb file fuzzing. Peach cracks the data from <emphasis>sample.png</emphasis> into a Blob. This is considered dumb fuzzing because the data model does not fully describe the structure of the data being fuzzed.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach&gt;

	&lt;DataModel name="TheDataModel"&gt;
		&lt;Blob /&gt;
	&lt;/DataModel&gt;

	&lt;!-- Define a simple state machine that will write the file and
		then launch a program using the FileWriter and DebuggerLaucher publishers --&gt;
	&lt;StateModel name="State" initialState="Initial"&gt;
		&lt;State name="Initial"&gt;

			&lt;!-- Write out contents of file. --&gt;
			&lt;Action type="output"&gt;
				&lt;DataModel ref="TestTemplate" /&gt;
				&lt;Data fileName="sample.png" /&gt;
			&lt;/Action&gt;

			&lt;!-- Close file --&gt;
			&lt;Action type="close" /&gt;

			&lt;!-- Launch the file consumer --&gt;
			&lt;Action type="call" method="ScoobySnacks" publisher="Peach.Agent"/&gt;

		&lt;/State&gt;
	&lt;/StateModel&gt;

	&lt;!-- Setup a local agent that will monitor for faults --&gt;
	&lt;Agent name="LocalAgent"&gt;
		&lt;Monitor class="WindowsDebugger"&gt;

			&lt;!-- The command line to run.  Notice the filename provided matched up
				to what is provided below in the Publisher configuration --&gt;
			&lt;Param name="Executable" value="c:\windows\system32\mspaint.exe" /&gt;
			&lt;Param name="Arguments" value="fuzzfile.bin" /&gt;

			&lt;!-- This parameter will cause the debugger to wait for an action-call in
				the state model with a method="ScoobySnacks" before running
				program.

				Note: You will also need to add a parameter to the publisher called
				    "debugger" and set it to "true"!
				--&gt;
			&lt;Param name="StartOnCall" value="ScoobySnacks" /&gt;

		&lt;/Monitor&gt;
	&lt;/Agent&gt;

	&lt;Test name="Default"&gt;
		&lt;Agent ref="LocalAgent" /&gt;
		&lt;StateModel ref="State"/&gt;

		&lt;!-- Configure our publisher with correct filename to write too --&gt;
		&lt;Publisher class="File"&gt;
			&lt;Param name="FileName" value="fuzzfile.bin" /&gt;
		&lt;/Publisher&gt;

		&lt;!-- Configure a logger to store collected information --&gt;	&lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
</example>
<example>
<title>Defining a Blob with a default value</title>
<simpara>A blob with a default value. Providing a default value does not set a fixed length unless the token="true" attribute is used.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach ../peach.xsd"&gt;

  &lt;DataModel name="Ex1"&gt;
    &lt;Blob name="Unknown1" valueType="hex" value="AA BB CC DD" /&gt;
  &lt;/DataModel&gt;

  &lt;StateModel name="TheState" initialState="initial"&gt;
    &lt;State name="initial"&gt;
      &lt;Action type="output" publisher="ConsolePub"&gt;
        &lt;DataModel ref="Ex1" /&gt;
      &lt;/Action&gt;
    &lt;/State&gt;
  &lt;/StateModel&gt;

  &lt;Test name="Default"&gt;
    &lt;StateModel ref="TheState"/&gt;

    &lt;Publisher class="ConsoleHex" name="ConsolePub"/&gt;  &lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Output from this example.</simpara>
<screen>&gt;peach -1 --debug example.xml

[*] Test 'Default' starting with random seed 46616.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher start()
Peach.Core.Publishers.ConsolePublisher open()
Peach.Core.Publishers.ConsolePublisher output(4 bytes)
00000000   AA BB CC DD                                        ????
Peach.Core.Publishers.ConsolePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.ConsolePublisher stop()

[*] Test 'Default' finished.</screen>
<formalpara>
<title>Using a Blob as part of a size relationship</title>
<para>A blob with size-of relationship:</para>
</formalpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach ../peach.xsd"&gt;

  &lt;DataModel name="Ex1"&gt;
    &lt;Number name="LengthOfData" size="32"&gt;
      &lt;Relation type="size" of="Data" /&gt;
    &lt;/Number&gt;

    &lt;Blob name="Data" valueType="hex" value="AA BB CC DD" /&gt;
  &lt;/DataModel&gt;

  &lt;StateModel name="TheState" initialState="initial"&gt;
    &lt;State name="initial"&gt;
      &lt;Action type="output" publisher="ConsolePub"&gt;
        &lt;DataModel ref="Ex1" /&gt;
      &lt;/Action&gt;
    &lt;/State&gt;
  &lt;/StateModel&gt;

  &lt;Test name="Default"&gt;
    &lt;StateModel ref="TheState"/&gt;

    &lt;Publisher class="ConsoleHex" name="ConsolePub"/&gt;  &lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Output from this example.</simpara>
<screen>&gt;peach -1 --debug example.xml

[*] Test 'Default' starting with random seed 18508.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher start()
Peach.Core.Publishers.ConsolePublisher open()
Peach.Core.Publishers.ConsolePublisher output(8 bytes)
00000000   04 00 00 00 AA BB CC DD                            ????????
Peach.Core.Publishers.ConsolePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.ConsolePublisher stop()

[*] Test 'Default' finished.</screen>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Block">
<title>Block</title>
<simpara><emphasis>Blocks</emphasis> are container elements that group data elements in a logical structure. For example, a <emphasis>string</emphasis> element, a <emphasis>number</emphasis> element, and a <emphasis>blob</emphasis> element can exist in the same <emphasis>block</emphasis>. <emphasis>Blocks</emphasis> can contain other blocks, or nest, as deeply as needed.</simpara>
<simpara><emphasis>Blocks</emphasis> and <link linkend="DataModel">DataModels</link> are very similar; both can be used as the template for other Blocks or <link linkend="DataModel">DataModels</link>. The only difference is the positioning of these elements.</simpara>
<itemizedlist>
<listitem>
<simpara>A <emphasis>DataModel</emphasis> is a top level element</simpara>
</listitem>
<listitem>
<simpara>A <emphasis>Block</emphasis> is a child element of <link linkend="DataModel">DataModel</link></simpara>
</listitem>
</itemizedlist>
<section xml:id="_syntax_45">
<title>Syntax</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;Block name="HelloWorld"&gt;
  &lt;String value="Hello world!" /&gt;
&lt;/Block&gt;</programlisting>
</section>
<section xml:id="_attributes_30">
<title>Attributes</title>
<simpara><emphasis>Required:</emphasis></simpara>
<simpara>None.</simpara>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term><link linkend="name">name</link></term>
<listitem>
<simpara>Name of the block.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="ref">ref</link></term>
<listitem>
<simpara>Reference to a <link linkend="DataModel">DataModel</link> to use as a template.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="length">length</link></term>
<listitem>
<simpara>Data element length.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="lengthType">lengthType</link></term>
<listitem>
<simpara>The unit of measure attribute for the Length attribute. Default is bytes.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="constraint">constraint</link></term>
<listitem>
<simpara>Scripting expression that evaluates to true or false. Default is null.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="minOccurs">minOccurs</link></term>
<listitem>
<simpara>The minimum number of times this element must occur. Defaults to 1. <?asciidoc-br?></simpara>
<itemizedlist>
<listitem>
<simpara>Used to define arrays with variable size. Arrays defined by min/maxOccurs generally have a relation
defined.</simpara>
</listitem>
<listitem>
<simpara>Adding this attribute, even with a value of 1, converts the element to an array.</simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="maxOccurs">maxOccurs</link></term>
<listitem>
<simpara>The maximum number of times this element can occur. Defaults to 1. <?asciidoc-br?></simpara>
<itemizedlist>
<listitem>
<simpara>Used to define arrays with static size.</simpara>
</listitem>
<listitem>
<simpara>Adding this attribute, even with a value of 1, converts the element to an array.</simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="occurs">occurs</link></term>
<listitem>
<simpara>Actual occurrences of element. Defaults to 1. <?asciidoc-br?></simpara>
<itemizedlist>
<listitem>
<simpara>Used to define arrays with static size.</simpara>
</listitem>
<listitem>
<simpara>Adding this attribute, even with a value of 1, converts the element to an array.</simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="mutable">mutable</link></term>
<listitem>
<simpara>Is data element changeable (should it be mutated), defaults to false.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_child_elements_14">
<title>Child Elements</title>
<variablelist>
<varlistentry>
<term><link linkend="Analyzers">Analyzer</link></term>
<listitem>
<simpara>Analyzes current element post cracking, can dynamically change model.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Blob">Blob</link></term>
<listitem>
<simpara>Represents binary data (array of bytes) to create simple dumb fuzzers in Peach.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Block">Block</link></term>
<listitem>
<simpara>Groups one or more data elements in a logical structure.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Choice">Choice</link></term>
<listitem>
<simpara>Indicates that all of the sub-elements are valid; but, only one sub-element should be selected.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Fixup">Fixup</link></term>
<listitem>
<simpara>Are dynamic transformations such as checksums and CRCs.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Flags">Flags</link></term>
<listitem>
<simpara>Defines a set of bit-sized flags.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Hint">Hint</link></term>
<listitem>
<simpara>Provides information to mutators.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Number">Number</link></term>
<listitem>
<simpara>Defines a binary number of arbitrary bit size.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Padding">Padding</link></term>
<listitem>
<simpara>Pads variably sized blocks or data models provide size uniformity or consistency.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Placement">Placement</link></term>
<listitem>
<simpara>Relocates an element after it has been cracked.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Stream">Stream</link></term>
<listitem>
<simpara>Groups one or more data elements in a logical structure.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="String">String</link></term>
<listitem>
<simpara>Character sequence consisting of ASCII or Unicode characters.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Transformer">Transformer</link></term>
<listitem>
<simpara>Performs static transformations such as compression or encoding.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="XmlElement">XmlElement</link></term>
<listitem>
<simpara>Defines an XML element, the basic building block of XML documents.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_mutators_4">
<title>Mutators</title>
<simpara>The following mutators operate on this element type:</simpara>
<simpara><emphasis>Enabled when element is marked as an array</emphasis></simpara>
<variablelist>
<varlistentry>
<term><link linkend="Mutators_ArrayNumericalEdgeCasesMutator">ArrayNumericalEdgeCasesMutator</link></term>
<listitem>
<simpara>This mutator grows and shrinks an array to counts based on numerical edge cases.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_ArrayRandomizeOrderMutator">ArrayRandomizeOrderMutator</link></term>
<listitem>
<simpara>This mutator randomizes the order of items in an array.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_ArrayReverseOrderMutator">ArrayReverseOrderMutator</link></term>
<listitem>
<simpara>This mutator reverses the order of items in an array.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_ArrayVarianceMutator">ArrayVarianceMutator</link></term>
<listitem>
<simpara>This mutator grows and shrinks an array to a variance of counts based on the current size.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Used for all data elements</emphasis></simpara>
<variablelist>
<varlistentry>
<term><link linkend="Mutators_DataElementBitFlipper">DataElementBitFlipper</link></term>
<listitem>
<simpara>This mutator produces test cases by flipping bits in the output value.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_DataElementDuplicate">DataElementDuplicate</link></term>
<listitem>
<simpara>This mutator duplicates data elements.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_DataElementRemove">DataElementRemove</link></term>
<listitem>
<simpara>This mutator removes data elements.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_DataElementSwapNear">DataElementSwapNear</link></term>
<listitem>
<simpara>This mutator swaps data elements.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_SampleNinjaMutator">SampleNinjaMutator</link></term>
<listitem>
<simpara>This mutator combines data elements from different data sets.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Enabled when element is part of a size relation</emphasis></simpara>
<variablelist>
<varlistentry>
<term><link linkend="Mutators_SizedDataEdgeCase">SizedDataEdgeCase</link></term>
<listitem>
<simpara>This mutator causes the data portion of a relation to be sized as numerical edge cases.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_SizedDataVariance">SizedDataVariance</link></term>
<listitem>
<simpara>This mutator causes the data portion of a relation to be sized as numerical variances.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_SizedEdgeCase">SizedEdgeCase</link></term>
<listitem>
<simpara>This mutator changes both sides of the relation (data and value) to match numerical edge cases.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_SizedVariance">SizedVariance</link></term>
<listitem>
<simpara>This mutator changes both sides of the relation (data and value) to match numerical variances of the current size.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_29">
<title>Examples</title>
<example>
<title>Empty Block</title>
<simpara>The simplest block is an empty block. This definition produces no output.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach ../peach.xsd"&gt;

  &lt;DataModel name="BlockExample1"&gt;
    &lt;Block&gt;
    &lt;/Block&gt;
  &lt;/DataModel&gt;

  &lt;StateModel name="TheState" initialState="initial"&gt;
    &lt;State name="initial"&gt;
      &lt;Action type="output" publisher="ConsolePub"&gt;
        &lt;DataModel ref="BlockExample1" /&gt;
      &lt;/Action&gt;
    &lt;/State&gt;
  &lt;/StateModel&gt;

  &lt;Test name="Default"&gt;
    &lt;StateModel ref="TheState"/&gt;

    &lt;Publisher class="ConsoleHex" name="ConsolePub"/&gt;
  &lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Output from this example.</simpara>
<screen>&gt;peach -1 --debug example.xml

[*] Test 'Default' starting with random seed 59388.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher start()
Peach.Core.Publishers.ConsolePublisher open()
Peach.Core.Publishers.ConsolePublisher output(0 bytes)
Peach.Core.Publishers.ConsolePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.ConsolePublisher stop()

[*] Test 'Default' finished.</screen>
</example>
<example>
<title>Nested Blocks</title>
<simpara>Blocks can be nested as deep as required. Blocks help create logical structure and do not change the data contained within.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach ../peach.xsd"&gt;

  &lt;DataModel name="BlockExample2"&gt;
    &lt;Block&gt;
      &lt;Block&gt;
        &lt;Block&gt;
          &lt;String value="1" /&gt;
        &lt;/Block&gt;

        &lt;Block&gt;
          &lt;String value="2" /&gt;
        &lt;/Block&gt;

        &lt;String value="3" /&gt;
      &lt;/Block&gt;
      &lt;String value="4" /&gt;
    &lt;/Block&gt;
  &lt;/DataModel&gt;

  &lt;StateModel name="TheState" initialState="initial"&gt;
    &lt;State name="initial"&gt;
      &lt;Action type="output" publisher="ConsolePub"&gt;
        &lt;DataModel ref="BlockExample2" /&gt;
      &lt;/Action&gt;
    &lt;/State&gt;
  &lt;/StateModel&gt;

  &lt;Test name="Default"&gt;
    &lt;StateModel ref="TheState"/&gt;

    &lt;Publisher class="ConsoleHex" name="ConsolePub"/&gt;
  &lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Output from this example.</simpara>
<screen>&gt;peach -1 --debug example.xml

[*] Test 'Default' starting with random seed 30169.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher start()
Peach.Core.Publishers.ConsolePublisher open()
Peach.Core.Publishers.ConsolePublisher output(4 bytes)
00000000   31 32 33 34                                        1234
Peach.Core.Publishers.ConsolePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.ConsolePublisher stop()

[*] Test 'Default' finished.</screen>
</example>
<example>
<title>Naming A Block</title>
<simpara>Assign blocks a friendly name to make them easier to understand and debug.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach ../peach.xsd"&gt;

  &lt;DataModel name="BlockExample2"&gt;
   &lt;Block name="HeaderDef"&gt;
    &lt;String name="Header" /&gt;
    &lt;String name="Colon" value=":"/&gt;
    &lt;String name="Val"/&gt;
   &lt;/Block&gt;

   &lt;Block name="DataDef"&gt;
     &lt;Number name="Type"  size="8" value="4"/&gt;
     &lt;Number name="Data" size="8" value="32"/&gt;
   &lt;/Block&gt;
 &lt;/DataModel&gt;

  &lt;StateModel name="TheState" initialState="initial"&gt;
    &lt;State name="initial"&gt;
      &lt;Action type="output" publisher="ConsolePub"&gt;
        &lt;DataModel ref="BlockExample2" /&gt;
      &lt;/Action&gt;
    &lt;/State&gt;
  &lt;/StateModel&gt;

  &lt;Test name="Default"&gt;
    &lt;StateModel ref="TheState"/&gt;

    &lt;Publisher class="ConsoleHex" name="ConsolePub"/&gt;
  &lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Output from this example.</simpara>
<screen>&gt;peach -1 --debug example.xml

[*] Test 'Default' starting with random seed 58326.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher start()
Peach.Core.Publishers.ConsolePublisher open()
Peach.Core.Publishers.ConsolePublisher output(3 bytes)
00000000   3A 04 20                                           :?
Peach.Core.Publishers.ConsolePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.ConsolePublisher stop()

[*] Test 'Default' finished.</screen>
</example>
<example>
<title>Referencing A Block</title>
<simpara>A Block can use a reference definition from another container element to form its base definition. In this example, the Block <emphasis>MyName</emphasis> gets its base definition from the DataModel named <emphasis>OtherDataModel</emphasis>. All child elements declared in <emphasis>MyName</emphasis> become part of the block.</simpara>
<note>
<simpara>If a declared child element and a child element from the referenced contain have the same name, the definition of the declared child element is used. In other words, if a naming collision occurs, the declared child element definition overrides the definition from the referenced container element.</simpara>
</note>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach ../peach.xsd"&gt;

  &lt;DataModel name="OtherDataModel"&gt;
   &lt;String value="Hello World"/&gt;
  &lt;/DataModel&gt;

  &lt;DataModel name="ThisDataModel"&gt;
    &lt;Block name="MyName" ref="OtherDataModel"/&gt; <co xml:id="CO13-1"/>
  &lt;/DataModel&gt;

  &lt;StateModel name="TheState" initialState="initial"&gt;
    &lt;State name="initial"&gt;
      &lt;Action type="output" publisher="ConsolePub"&gt;
        &lt;DataModel ref="ThisDataModel" /&gt;
      &lt;/Action&gt;
    &lt;/State&gt;
  &lt;/StateModel&gt;

  &lt;Test name="Default"&gt;
    &lt;StateModel ref="TheState"/&gt;

    &lt;Publisher class="ConsoleHex" name="ConsolePub"/&gt;
  &lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>The Block "MyName" is defined using the referenced block "OtherDataModel". When parsed, the resulting data structure will look like this. &lt;1&gt;</simpara>
<programlisting language="xml" linenumbering="unnumbered"> &lt;DataModel name="ThisDataModel"&gt;
   &lt;Block name="MyName"&gt;
    &lt;String value="Hello World"/&gt;
   &lt;/Block&gt;
 &lt;/DataModel&gt;</programlisting>
<simpara>Output from this example.</simpara>
<screen>&gt;peach -1 --debug example.xml

[*] Test 'Default' starting with random seed 61348.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher start()
Peach.Core.Publishers.ConsolePublisher open()
Peach.Core.Publishers.ConsolePublisher output(11 bytes)
00000000   48 65 6C 6C 6F 20 57 6F  72 6C 64                  Hello World
Peach.Core.Publishers.ConsolePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.ConsolePublisher stop()

[*] Test 'Default' finished.</screen>
<simpara>Referencing allows for powerful templates to be built. This is a template for a Key: Value\r\n.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;DataModel name="Template"&gt;
  &lt;String name="Key" /&gt;
  &lt;String value=": " token="true" /&gt;
  &lt;String name="Value" /&gt;
  &lt;String value="\r\n" token="true" /&gt;
&lt;/DataModel&gt;</programlisting>
<simpara>To use this template as a reference.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach ../peach.xsd"&gt;

  &lt;DataModel name="Template"&gt;
    &lt;String name="Key" /&gt;
    &lt;String value=": " token="true" /&gt;
    &lt;String name="Value" /&gt;
    &lt;String value="\r\n" token="true" /&gt;
  &lt;/DataModel&gt;

  &lt;DataModel name="OtherModel"&gt;
    &lt;String value="Before Block\r\n" /&gt;

    &lt;Block name="Customized" ref="Template"&gt; <co xml:id="CO13-2"/>
      &lt;String name="Key" value="Content-Length" /&gt;
      &lt;String name="Value" value="55"/&gt;
    &lt;/Block&gt;
  &lt;/DataModel&gt;

  &lt;StateModel name="TheState" initialState="initial"&gt;
    &lt;State name="initial"&gt;
      &lt;Action type="output" publisher="ConsolePub"&gt;
        &lt;DataModel ref="OtherModel" /&gt;
      &lt;/Action&gt;
    &lt;/State&gt;
  &lt;/StateModel&gt;

  &lt;Test name="Default"&gt;
    &lt;StateModel ref="TheState"/&gt;

    &lt;Publisher class="ConsoleHex" name="ConsolePub"/&gt;
  &lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Output from this example.</simpara>
<screen>&gt;peach -1 --debug example.xml

[*] Test 'Default' starting with random seed 64782.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher start()
Peach.Core.Publishers.ConsolePublisher open()
Peach.Core.Publishers.ConsolePublisher output(34 bytes)
00000000   42 65 66 6F 72 65 20 42  6C 6F 63 6B 0D 0A 43 6F   Before Block??Co
00000010   6E 74 65 6E 74 2D 4C 65  6E 67 74 68 3A 20 35 35   ntent-Length: 55
00000020   0D 0A                                              ??
Peach.Core.Publishers.ConsolePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.ConsolePublisher stop()

[*] Test 'Default' finished.</screen>
<simpara>Two key things happened here. When parsed, the Customized Block replaced its structure with the DataModel of Template, adding the string values of ":" and "\r\n".</simpara>
<simpara>At the same time, the "Customized" block overwrote the values of the String elements for Key and Value, replacing them with "Content-Length" and 55. The final DataModel would be parsed as so. &lt;1&gt;</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;DataModel name="OtherModel"&gt;
  &lt;String value="BeforeBlock" /&gt;

  &lt;Block name="Customized" ref="Template"&gt;
    &lt;String name="Key" value="Content-Length" /&gt;
    &lt;String value=": " token="true" /&gt;
    &lt;String name="Value" value="55" /&gt;
    &lt;String value="\r\n" token="true" /&gt;
  &lt;/Block&gt;
&lt;/DataModel&gt;</programlisting>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Bool">
<title>Bool</title>
<simpara>The <emphasis>Bool</emphasis> element defines a Boolean value (values 0 or 1) that represents either true or false. The intended use of <emphasis>Bool</emphasis> is in JSON strings, where the values <literal>true</literal> and <literal>false</literal> are assigned to variables upon parsing with the JSON analyzer.</simpara>
<simpara>When not used in JSON strings, <emphasis>Bool</emphasis> is a one-bit number with a value of 0 or 1.</simpara>
<simpara>The Bool element is a child element of <link linkend="DataModel">DataModel</link>, <link linkend="Block">Block</link>, <link linkend="Sequence">Sequence</link> or <link linkend="Choice">Choice</link>.</simpara>
<section xml:id="_syntax_46">
<title>Syntax</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;Bool name="Boolean" value="1"/&gt;</programlisting>
</section>
<section xml:id="_attributes_31">
<title>Attributes</title>
<simpara><emphasis>Required:</emphasis></simpara>
<simpara>No required attributes.</simpara>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term><link linkend="name">name</link></term>
<listitem>
<simpara>Name of the boolean value.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="value">value</link></term>
<listitem>
<simpara>The default value to assign to the boolean.
Valid options are integer values 0 or 1.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="constraint">constraint</link></term>
<listitem>
<simpara>A constraint in the form of a python expression.
Used during data cracking.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="mutable">mutable</link></term>
<listitem>
<simpara>Is data element changeable (should it be mutated during fuzzing), defaults to true.
Valid options true and false.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="minOccurs">minOccurs</link></term>
<listitem>
<simpara>The minimum number of times this number must occur.
Defaults to 1.
Valid options are a positive integer value.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="maxOccurs">maxOccurs</link></term>
<listitem>
<simpara>The maximum number of times this number can occur.
Defaults to 1.
Valid options are a positive integer value.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="occurs">occurs</link></term>
<listitem>
<simpara>The actual number of times this number occurs.
Defaults to 1.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_child_elements_15">
<title>Child Elements</title>
<variablelist>
<varlistentry>
<term><link linkend="Hint">Hint</link></term>
<listitem>
<simpara>Provide information to mutators.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Placement">Placement</link></term>
<listitem>
<simpara>Relocate an element after it has been cracked.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_mutators_5">
<title>Mutators</title>
<simpara>The following mutators will operate on this element type:</simpara>
<simpara><emphasis>Enabled when element is marked as an array</emphasis></simpara>
<variablelist>
<varlistentry>
<term><link linkend="Mutators_ArrayNumericalEdgeCasesMutator">ArrayNumericalEdgeCasesMutator</link></term>
<listitem>
<simpara>This mutator will grow and shrink an array to counts based on numerical edge cases.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_ArrayRandomizeOrderMutator">ArrayRandomizeOrderMutator</link></term>
<listitem>
<simpara>This mutator will randomize the order of items in an array.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_ArrayReverseOrderMutator">ArrayReverseOrderMutator</link></term>
<listitem>
<simpara>This mutator will reverse the order of items in an array.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_ArrayVarianceMutator">ArrayVarianceMutator</link></term>
<listitem>
<simpara>This mutator will grow and shrink an array to a variance of counts based on the current size.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Used for all data elements</emphasis></simpara>
<variablelist>
<varlistentry>
<term><link linkend="Mutators_DataElementBitFlipper">DataElementBitFlipper</link></term>
<listitem>
<simpara>This mutator will produce test cases by flipping bits in the output value.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_DataElementDuplicate">DataElementDuplicate</link></term>
<listitem>
<simpara>This mutator will duplicate data elements.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_DataElementRemove">DataElementRemove</link></term>
<listitem>
<simpara>This mutator will remove data elements.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_DataElementSwapNear">DataElementSwapNear</link></term>
<listitem>
<simpara>This mutator will swap data elements.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_SampleNinjaMutator">SampleNinjaMutator</link></term>
<listitem>
<simpara>This mutator will combine data elements from different data sets.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Enabled when element is part of a size relation</emphasis></simpara>
<variablelist>
<varlistentry>
<term><link linkend="Mutators_SizedDataEdgeCase">SizedDataEdgeCase</link></term>
<listitem>
<simpara>This mutator will cause the data portion of a relation to be sized as numerical edge cases.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_SizedDataVariance">SizedDataVariance</link></term>
<listitem>
<simpara>This mutator will cause the data portion of a relation to be sized as numerical variances.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_SizedEdgeCase">SizedEdgeCase</link></term>
<listitem>
<simpara>This mutator will change both sides of the relation (data and value) to match numerical edge cases.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_SizedVariance">SizedVariance</link></term>
<listitem>
<simpara>This mutator will change both sides of the relation (data and value) to match numerical variances of the current size.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_30">
<title>Examples</title>
<example>
<title>Size</title>
<simpara>Produce Json string with a boolean value of true.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
			 xsi:schemaLocation="http://peachfuzzer.com/2012/Peach /peach/peach.xsd"&gt;
	&lt;DataModel name="BoolExample"&gt;
		&lt;Json&gt;
			&lt;Bool name="bool" value="1"/&gt;
		&lt;/Json&gt;
	&lt;/DataModel&gt;

	&lt;StateModel name="TheState" initialState="Initial"&gt;
		&lt;State name="Initial"&gt;
			&lt;Action type="output"&gt;
				&lt;DataModel ref="BoolExample"/&gt;
			&lt;/Action&gt;
		&lt;/State&gt;
	&lt;/StateModel&gt;

	&lt;Agent name="TheAgent" /&gt;

	&lt;Test name="Default"&gt;
		&lt;Agent ref="TheAgent"/&gt;

		&lt;StateModel ref="TheState"/&gt;

		&lt;Publisher class="ConsoleHex"/&gt;
	&lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Output from this example.</simpara>
<screen>&gt;peach -1 --debug BoolExample1.xml

[*] Test 'Default' starting with random seed 28925.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.StateModel Run(): Changing to state "Initial".
Peach.Core.Dom.Action Run(Action): Output
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Publishers.ConsolePublisher start()
Peach.Core.Publishers.ConsolePublisher open()
Peach.Core.Publishers.ConsolePublisher output(13 bytes)
00000000   7B 22 62 6F 6F 6C 22 3A  74 72 75 65 7D            {"bool":true}
Peach.Core.Publishers.ConsolePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.ConsolePublisher stop()

[*] Test 'Default' finished.</screen>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Choice">
<title>Choice</title>
<simpara>The Choice element acts like a switch statement in programming languages.</simpara>
<simpara>The Choice element is a child element of <link linkend="DataModel">DataModel</link> or <link linkend="Block">Block</link>.  Choice elements are expected to have valid sub-elements; Peach will select a sub-element to fuzz.</simpara>
<section xml:id="_syntax_47">
<title>Syntax</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;Choice name="ChoiceBlock"&gt;
  &lt;Block name="Type1"&gt;
    &lt;!-- ... --&gt;
  &lt;/Block&gt;
  &lt;Block name="Type2"&gt;
    &lt;!-- ... --&gt;
  &lt;/Block&gt;
  &lt;Block name="Type3"&gt;
    &lt;!-- ... --&gt;
  &lt;/Block&gt;
&lt;/Choice&gt;</programlisting>
</section>
<section xml:id="_attributes_32">
<title>Attributes</title>
<simpara><emphasis>Required:</emphasis></simpara>
<simpara>None.</simpara>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term><link linkend="name">name</link></term>
<listitem>
<simpara>Name of the choice section.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="length">length</link></term>
<listitem>
<simpara>Data element length.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="lengthType">lengthType</link></term>
<listitem>
<simpara>Length attribute unit of measure. Defaults to bytes.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="mutable">mutable</link></term>
<listitem>
<simpara>Element mutability. Defaults to false.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="constraint">constraint</link></term>
<listitem>
<simpara>Scripting expression that evaluates to true or false. Defaults to null.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="minOccurs">minOccurs</link></term>
<listitem>
<simpara>The minimum number of times this element must occur. Defaults to 1. <?asciidoc-br?></simpara>
<itemizedlist>
<listitem>
<simpara>Used to define arrays with variable size. Arrays defined by min/maxOccurs generally have a relation
defined.</simpara>
</listitem>
<listitem>
<simpara>Adding this attribute, even with a value of 1, converts the element to an array.</simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="maxOccurs">maxOccurs</link></term>
<listitem>
<simpara>The maximum number of times this element can occur. Defaults to 1. <?asciidoc-br?></simpara>
<itemizedlist>
<listitem>
<simpara>Used to define arrays with static size.</simpara>
</listitem>
<listitem>
<simpara>Adding this attribute, even with a value of 1, converts the element to an array.</simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="occurs">occurs</link></term>
<listitem>
<simpara>Actual occurrences of element. Defaults to 1. <?asciidoc-br?></simpara>
<itemizedlist>
<listitem>
<simpara>Used to define arrays with static size.</simpara>
</listitem>
<listitem>
<simpara>Adding this attribute, even with a value of 1, converts the element to an array.</simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_child_elements_16">
<title>Child Elements</title>
<variablelist>
<varlistentry>
<term><link linkend="Analyzers">Analyzer</link></term>
<listitem>
<simpara>Analyze current element post cracking, can dynamically change model.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Blob">Blob</link></term>
<listitem>
<simpara>Represents binary data (array of bytes) to create simple dumb fuzzers in Peach.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Block">Block</link></term>
<listitem>
<simpara>Group one or more data elements in a logical structure.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Choice">Choice</link></term>
<listitem>
<simpara>Indicate all of the sub-elements are valid; however, only one sub-element should be selected.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Fixup">Fixup</link></term>
<listitem>
<simpara>Are dynamic transformations such as checksums and CRCs.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Flags">Flags</link></term>
<listitem>
<simpara>Defines a set of bit sized flags.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Hint">Hint</link></term>
<listitem>
<simpara>Provides information to mutators.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Number">Number</link></term>
<listitem>
<simpara>Defines a binary number of lengths 8, 16, 24, 32, or 64 bits.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Padding">Padding</link></term>
<listitem>
<simpara>Pads variably sized blocks or data models to provide uniformity or consistency.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Placement">Placement</link></term>
<listitem>
<simpara>Relocates an element after it has been cracked.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Transformer">Transformer</link></term>
<listitem>
<simpara>Performs static transformations such as compression or encoding.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="XmlElement">XmlElement</link></term>
<listitem>
<simpara>Defines an XML element, the basic building block of XML documents.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_mutators_6">
<title>Mutators</title>
<simpara>The following mutators operate on this element type:</simpara>
<simpara><emphasis>Enabled when an element is marked as an array</emphasis></simpara>
<variablelist>
<varlistentry>
<term><link linkend="Mutators_ArrayNumericalEdgeCasesMutator">ArrayNumericalEdgeCasesMutator</link></term>
<listitem>
<simpara>This mutator grows and shrinks an array to counts based on numerical edge cases.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_ArrayRandomizeOrderMutator">ArrayRandomizeOrderMutator</link></term>
<listitem>
<simpara>This mutator randomizes the order of items in an array.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_ArrayReverseOrderMutator">ArrayReverseOrderMutator</link></term>
<listitem>
<simpara>This mutator reverses the order of items in an array.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_ArrayVarianceMutator">ArrayVarianceMutator</link></term>
<listitem>
<simpara>This mutator grows and shrinks an array to a variance of counts based on the current size.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Used for all data elements</emphasis></simpara>
<variablelist>
<varlistentry>
<term><link linkend="Mutators_DataElementBitFlipper">DataElementBitFlipper</link></term>
<listitem>
<simpara>This mutator produces test cases by flipping bits in the output value.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_DataElementDuplicate">DataElementDuplicate</link></term>
<listitem>
<simpara>This mutator duplicates data elements.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_DataElementRemove">DataElementRemove</link></term>
<listitem>
<simpara>This mutator removes data elements.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_DataElementSwapNear">DataElementSwapNear</link></term>
<listitem>
<simpara>This mutator swaps data elements.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_SampleNinjaMutator">SampleNinjaMutator</link></term>
<listitem>
<simpara>This mutator combines data elements from different data sets.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Enabled when element is part of a size relation</emphasis></simpara>
<variablelist>
<varlistentry>
<term><link linkend="Mutators_SizedDataEdgeCase">SizedDataEdgeCase</link></term>
<listitem>
<simpara>This mutator causes the data portion of a relation to be sized as numerical edge cases.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_SizedDataVariance">SizedDataVariance</link></term>
<listitem>
<simpara>This mutator causes the data portion of a relation to be sized as numerical variances.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_SizedEdgeCase">SizedEdgeCase</link></term>
<listitem>
<simpara>This mutator changes both sides of the relation (data and value) to match numerical edge cases.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_SizedVariance">SizedVariance</link></term>
<listitem>
<simpara>This mutator changes both sides of the relation (data and value) to match numerical variances of the current size.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Specific to this element type</emphasis></simpara>
<variablelist>
<varlistentry>
<term><link linkend="Mutators_ChoiceSwitch">ChoiceSwitch</link></term>
<listitem>
<simpara>This mutator produces test cases by arbitrarily changing the selected sub-element of a Choice.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_31">
<title>Examples</title>
<example>
<title>Basic Example</title>
<simpara>A basic Choice block. This choice example cracks or consumes data of type 1, 2, and 3. Much like a regular switch statement, a decision needs to be made on a token.</simpara>
<simpara>If the first 8 bits are 1, the remaining data is treated as a 32 bit number.
If the first 8 bits are 2, the remaining data is treated as a 255 bytes of binary data.
If the first 8 bits are 3, the remaining data is treated as a 8 byte string.</simpara>
<simpara>When fuzzing, Peach chooses one of the three types and fuzzes the output as an 8 bit number followed by the corresponding type.</simpara>
<simpara>Peach attempts to fill all three types. You can use data sets to specify which choice to make at different stages in the state model.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach ../peach.xsd"&gt;

  &lt;DataModel name="ChoiceExample1"&gt;
   &lt;Choice name="Choice1"&gt;
    &lt;Block name="Type1"&gt;
      &lt;Number name="Str1" size="8" value="1" token="true" /&gt;
      &lt;Number size="32"/&gt;
    &lt;/Block&gt;

    &lt;Block name="Type2"&gt;
      &lt;Number name="Str2" size="8" value="2" token="true" /&gt;
      &lt;Blob length="255" /&gt;
    &lt;/Block&gt;

    &lt;Block name="Type3"&gt;
      &lt;Number name="Str3" size="8" value="3" token="true" /&gt;
      &lt;String length="8" /&gt;
    &lt;/Block&gt;
   &lt;/Choice&gt;
  &lt;/DataModel&gt;

  &lt;StateModel name="TheState" initialState="initial"&gt;
    &lt;State name="initial"&gt;
      &lt;Action type="output" publisher="ConsolePub"&gt;
        &lt;DataModel ref="ChoiceExample1" /&gt;
        &lt;Data&gt;
          &lt;Field name="Choice1.Type1" value="1"/&gt;
        &lt;/Data&gt;
      &lt;/Action&gt;

      &lt;Action type="output" publisher="ConsolePub"&gt;
        &lt;DataModel ref="ChoiceExample1" /&gt;
        &lt;Data&gt;
          &lt;Field name="Choice1.Type2" value="2"/&gt;
        &lt;/Data&gt;
      &lt;/Action&gt;
    &lt;/State&gt;
  &lt;/StateModel&gt;

  &lt;Test name="Default"&gt;
    &lt;StateModel ref="TheState"/&gt;

    &lt;Publisher class="ConsoleHex" name="ConsolePub"/&gt;
  &lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Output from this example.</simpara>
<screen>&gt; peach -1 --debug example.xml

[*] Test 'Default' starting with random seed 10646.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher start()
Peach.Core.Publishers.ConsolePublisher open()
Peach.Core.Publishers.ConsolePublisher output(5 bytes)
00000000   01 00 00 00 00                                     ????? <co xml:id="CO13-3"/>
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher output(256 bytes) <co xml:id="CO13-4"/>
00000000   02 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00   ????????????????
00000010   00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00   ????????????????
00000020   00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00   ????????????????
00000030   00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00   ????????????????
00000040   00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00   ????????????????
00000050   00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00   ????????????????
00000060   00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00   ????????????????
00000070   00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00   ????????????????
00000080   00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00   ????????????????
00000090   00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00   ????????????????
000000A0   00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00   ????????????????
000000B0   00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00   ????????????????
000000C0   00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00   ????????????????
000000D0   00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00   ????????????????
000000E0   00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00   ????????????????
000000F0   00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00   ????????????????
Peach.Core.Publishers.ConsolePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.ConsolePublisher stop()

[*] Test 'Default' finished.</screen>
<calloutlist>
<callout arearefs="CO13-1 CO13-2 CO13-3">
<para>Output when choice 1 is picked.</para>
</callout>
<callout arearefs="CO13-4">
<para>Output when choice 2 is picked.</para>
</callout>
</calloutlist>
</example>
<example>
<title>An Array of Choices</title>
<simpara>The first example is good for making a single choice but what if there are many Type1, Type2, and Type3 blocks following one another? An array is the form to use. To declare the <emphasis>Choice</emphasis> as an array, set the minOccurs, maxOccurs, or occurs attribute to specify that the choice should be repeated.</simpara>
<simpara>This example attempts to crack at least 3 different choices and no more than 6.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach ../peach.xsd"&gt;

  &lt;DataModel name="ChoiceExample1"&gt;
   &lt;Choice name="Choice1" minOccurs="3" maxOccurs="6"&gt;

    &lt;Block name="Type1"&gt;
      &lt;Number name="Str1" size="8" value="1" token="true" /&gt;
      &lt;Number size="32"/&gt;
    &lt;/Block&gt;

    &lt;Block name="Type2"&gt;
      &lt;Number name="Str2" size="8" value="2" token="true" /&gt;
      &lt;Blob length="255" /&gt;
    &lt;/Block&gt;

    &lt;Block name="Type3"&gt;
      &lt;Number name="Str3" size="8" value="3" token="true" /&gt;
      &lt;String length="8" /&gt;
    &lt;/Block&gt;
   &lt;/Choice&gt;
  &lt;/DataModel&gt;

  &lt;StateModel name="TheState" initialState="initial"&gt;
    &lt;State name="initial"&gt;
      &lt;Action type="output" publisher="ConsolePub"&gt;
        &lt;DataModel ref="ChoiceExample1" /&gt;
        &lt;Data&gt;
          &lt;Field name="Choice1[0].Type1" value=""/&gt;
          &lt;Field name="Choice1[1].Type3" value=""/&gt;
          &lt;Field name="Choice1[2].Type2" value=""/&gt;
        &lt;/Data&gt;
      &lt;/Action&gt;

      &lt;Action type="output" publisher="ConsolePub"&gt;
        &lt;DataModel ref="ChoiceExample1" /&gt;
        &lt;Data&gt;
          &lt;Field name="Choice1[0].Type1" value=""/&gt;
          &lt;Field name="Choice1[1].Type1" value=""/&gt;
          &lt;Field name="Choice1[2].Type1" value=""/&gt;
          &lt;Field name="Choice1[3].Type1" value=""/&gt;
          &lt;Field name="Choice1[4].Type1" value=""/&gt;
        &lt;/Data&gt;
      &lt;/Action&gt;
    &lt;/State&gt;
  &lt;/StateModel&gt;

  &lt;Test name="Default"&gt;
    &lt;StateModel ref="TheState"/&gt;

    &lt;Publisher class="ConsoleHex" name="ConsolePub"/&gt;
  &lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Output from this example.</simpara>
<screen>&gt; peach -1 --debug example.xml

[*] Test 'Default' starting with random seed 59860.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher start()
Peach.Core.Publishers.ConsolePublisher open()
Peach.Core.Publishers.ConsolePublisher output(270 bytes)
00000000   01 00 00 00 00 03 00 00  00 00 00 00 00 00 02 00   ????????????????
00000010   00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00   ????????????????
00000020   00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00   ????????????????
00000030   00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00   ????????????????
00000040   00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00   ????????????????
00000050   00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00   ????????????????
00000060   00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00   ????????????????
00000070   00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00   ????????????????
00000080   00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00   ????????????????
00000090   00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00   ????????????????
000000A0   00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00   ????????????????
000000B0   00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00   ????????????????
000000C0   00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00   ????????????????
000000D0   00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00   ????????????????
000000E0   00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00   ????????????????
000000F0   00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00   ????????????????
00000100   00 00 00 00 00 00 00 00  00 00 00 00 00 00         ??????????????
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher output(25 bytes)
00000000   01 00 00 00 00 01 00 00  00 00 01 00 00 00 00 01   ????????????????
00000010   00 00 00 00 01 00 00 00  00                        ?????????
Peach.Core.Publishers.ConsolePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.ConsolePublisher stop()

[*] Test 'Default' finished.</screen>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="DataModel">
<title>DataModel</title>
<simpara>The DataModel element is a child of the Peach root element.  DataModels define the structure of data blocks by specifying additional child elements such as <link linkend="Number">Number</link>, <link linkend="Blob">Blob</link>, or <link linkend="String">String</link>.</simpara>
<section xml:id="_syntax_48">
<title>Syntax</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;DataModel name="TheDataModel"&gt;
	&lt;String value="Hello World" /&gt;
&lt;/DataModel&gt;</programlisting>
</section>
<section xml:id="_attributes_33">
<title>Attributes</title>
<simpara><emphasis>Required:</emphasis></simpara>
<variablelist>
<varlistentry>
<term><link linkend="name">name</link></term>
<listitem>
<simpara>Friendly name of the DataModel. This attribute is useful when referencing a DataModel as a template or when debugging.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term><link linkend="ref">ref</link></term>
<listitem>
<simpara>Reference to another DataModel to use as a template.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_child_elements_17">
<title>Child Elements</title>
<variablelist>
<varlistentry>
<term><link linkend="Analyzers">Analyzer</link></term>
<listitem>
<simpara>Analyzes current element post cracking, can dynamically change model.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Blob">Blob</link></term>
<listitem>
<simpara>Represents binary data (array of bytes) to create simple dumb fuzzers in Peach.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Block">Block</link></term>
<listitem>
<simpara>Groups one or more data elements in a logical structure.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Choice">Choice</link></term>
<listitem>
<simpara>Indicates all of the sub-elements are valid; however, only one sub-element should be selected.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Fixup">Fixup</link></term>
<listitem>
<simpara>Are dynamic transformations such as checksums and CRCs.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Flags">Flags</link></term>
<listitem>
<simpara>Defines a set of bit sized flags.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Hint">Hint</link></term>
<listitem>
<simpara>Provides information to mutators.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Number">Number</link></term>
<listitem>
<simpara>Defines a binary number of arbitrary bit size.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Padding">Padding</link></term>
<listitem>
<simpara>Pads variably sized blocks or data models to provide uniformity or consistency.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Placement">Placement</link></term>
<listitem>
<simpara>Relocates an element after it has been cracked.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Stream">Stream</link></term>
<listitem>
<simpara>Groups one or more data elements in a logical structure.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Transformer">Transformer</link></term>
<listitem>
<simpara>Performs static transformations such as compression or encoding.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="XmlElement">XmlElement</link></term>
<listitem>
<simpara>Defines an XML element, the basic building block of XML documents.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_mutators_7">
<title>Mutators</title>
<simpara>The following mutators operate on this element type:</simpara>
<simpara><emphasis>Used for all data elements</emphasis></simpara>
<variablelist>
<varlistentry>
<term><link linkend="Mutators_DataElementBitFlipper">DataElementBitFlipper</link></term>
<listitem>
<simpara>This mutator produces test cases by flipping bits in the output value.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_DataElementDuplicate">DataElementDuplicate</link></term>
<listitem>
<simpara>This mutator duplicates data elements.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_DataElementRemove">DataElementRemove</link></term>
<listitem>
<simpara>This mutator removes data elements.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_DataElementSwapNear">DataElementSwapNear</link></term>
<listitem>
<simpara>This mutator swaps data elements.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_SampleNinjaMutator">SampleNinjaMutator</link></term>
<listitem>
<simpara>This mutator combines data elements from different data sets.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Enabled when element is part of a size relation</emphasis></simpara>
<variablelist>
<varlistentry>
<term><link linkend="Mutators_SizedDataEdgeCase">SizedDataEdgeCase</link></term>
<listitem>
<simpara>This mutator causes the data portion of a relation to be sized as numerical edge cases.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_SizedDataVariance">SizedDataVariance</link></term>
<listitem>
<simpara>This mutator causes the data portion of a relation to be sized as numerical variances.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_SizedEdgeCase">SizedEdgeCase</link></term>
<listitem>
<simpara>This mutator changes both sides of the relation (data and value) to match numerical edge cases.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_SizedVariance">SizedVariance</link></term>
<listitem>
<simpara>This mutator changes both sides of the relation (data and value) to match numerical variances of the current size.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_32">
<title>Examples</title>
<example>
<title>DataModel Example</title>
<simpara>Any number of <emphasis>DataModels</emphasis> can be specified in a Peach Pit file. However, each <emphasis>DataModel</emphasis> must have a unique name. You can break down complex formats into smaller models by splitting them into logical parts. This makes DataModels easier to read, debug, and re-use.</simpara>
<simpara>An example DataModel named "HelloWorld" contains a single string and outputs "Hello world!"</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach ../peach.xsd"&gt;

  &lt;DataModel name="HelloWorld"&gt;
    &lt;String value="Hello world!" /&gt;
  &lt;/DataModel&gt;

  &lt;StateModel name="TheState" initialState="initial"&gt;
    &lt;State name="initial"&gt;
      &lt;Action type="output"&gt;
        &lt;DataModel ref="HelloWorld" /&gt;
      &lt;/Action&gt;
    &lt;/State&gt;
  &lt;/StateModel&gt;

  &lt;Test name="Default"&gt;
    &lt;StateModel ref="TheState"/&gt;

    &lt;Publisher class="ConsoleHex"/&gt;
  &lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Output from this example.</simpara>
<screen>&gt;peach -1 --debug example.xml

[*] Test 'Default' starting with random seed 63002.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher start()
Peach.Core.Publishers.ConsolePublisher open()
Peach.Core.Publishers.ConsolePublisher output(12 bytes)
00000000   48 65 6C 6C 6F 20 77 6F  72 6C 64 21               Hello world!
Peach.Core.Publishers.ConsolePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.ConsolePublisher stop()

[*] Test 'Default' finished.</screen>
<simpara>DataModels can reference other DataModels and inherit child elements with the ref attribute.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach ../peach.xsd"&gt;

  &lt;DataModel name="ParentModel"&gt;
    &lt;String value="Hello " /&gt;
  &lt;/DataModel&gt;

  &lt;DataModel name="HelloWorldModel" ref="ParentModel" &gt;
    &lt;String value=" world!" /&gt;
  &lt;/DataModel&gt;

  &lt;StateModel name="TheState" initialState="initial"&gt;
    &lt;State name="initial"&gt;
      &lt;Action type="output"&gt;
        &lt;DataModel ref="HelloWorldModel" /&gt;
      &lt;/Action&gt;
    &lt;/State&gt;
  &lt;/StateModel&gt;

  &lt;Test name="Default"&gt;
    &lt;StateModel ref="TheState"/&gt;

    &lt;Publisher class="ConsoleHex"/&gt;
  &lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Output from this example.</simpara>
<screen>&gt;peach -1 --debug DocSample.xml

[*] Test 'Default' starting with random seed 35043.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher start()
Peach.Core.Publishers.ConsolePublisher open()
Peach.Core.Publishers.ConsolePublisher output(13 bytes)
00000000   48 65 6C 6C 6F 20 20 77  6F 72 6C 64 21            Hello  world!
Peach.Core.Publishers.ConsolePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.ConsolePublisher stop()

[*] Test 'Default' finished.</screen>
</example>
<example>
<title>References (ref attribute)</title>
<simpara>When a reference (ref attribute) is supplied, the contents of the referenced DataModel are copied to create the base of the new DataModel.  Any child elements in the new DataModel override elements from that base with the same name. In this example, the child DataModel Customized contains a String named Key. The value from the child DataModel overwrites the String "Key" of the parent DataModel, which has no value.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach ../peach.xsd"&gt;

  &lt;DataModel name="Template"&gt;
    &lt;String name="Key" /&gt;
    &lt;String value=": " token="true" /&gt;
    &lt;String name="Value" /&gt;
    &lt;String value="\r\n" token="true" /&gt;
  &lt;/DataModel&gt;

  &lt;DataModel name="Customized" ref="Template"&gt;
    &lt;String name="Key" value="Content-Length" /&gt;
    &lt;String name="Value"&gt;
      &lt;Relation type="size" of="HttpBody" /&gt;
    &lt;/String&gt;
    &lt;Blob name="HttpBody" /&gt;
  &lt;/DataModel&gt;

  &lt;StateModel name="TheState" initialState="initial"&gt;
    &lt;State name="initial"&gt;
      &lt;Action type="output"&gt;
        &lt;DataModel ref="Customized" /&gt;
      &lt;/Action&gt;
    &lt;/State&gt;
  &lt;/StateModel&gt;

  &lt;Test name="Default"&gt;
    &lt;StateModel ref="TheState"/&gt;

    &lt;Publisher class="ConsoleHex"/&gt;
  &lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Output from this example.</simpara>
<screen>&gt;peach -1 --debug DocSample.xml

*] Test 'Default' starting with random seed 3945.

R1,-,-] Performing iteration
each.Core.Engine runTest: Performing recording iteration.
each.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
each.Core.Dom.Action ActionType.Output
each.Core.Publishers.ConsolePublisher start()
each.Core.Publishers.ConsolePublisher open()
each.Core.Publishers.ConsolePublisher output(4 bytes)
0000000   3A 20 0D 0A                                        : ?? <co xml:id="CO14-1"/>
each.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
each.Core.Dom.Action ActionType.Output
each.Core.Publishers.ConsolePublisher output(19 bytes)
0000000   43 6F 6E 74 65 6E 74 2D  4C 65 6E 67 74 68 3A 20   Content-Length: <co xml:id="CO14-2"/>
0000010   30 0D 0A                                           0??
each.Core.Publishers.ConsolePublisher close()
each.Core.Engine runTest: context.config.singleIteration == true
each.Core.Publishers.ConsolePublisher stop()

*] Test 'Default' finished.</screen>
<screen>&lt;1&gt; The output of "Template"   is " : \r\n"
&lt;2&gt; The output of "Customized" is "Content-Length: 100\r\n"</screen>
<simpara>When parsed into a DataModel, Customized looks like a combination of both data models.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;DataModel name="Customized" ref="Template"&gt;
  &lt;String name="Key" value="Content-Length" /&gt;
  &lt;String value=": " token="true" /&gt;
  &lt;String name="Value"&gt;
    &lt;Relation type="size" of="HttpBody" /&gt;
  &lt;/String&gt;
  &lt;String value="\r\n" token="true" /&gt;
  &lt;Blob name="HttpBody"/&gt;
&lt;/DataModel&gt;</programlisting>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Double">
<title>Double</title>
<simpara>The <emphasis>Double</emphasis> element defines a floating-point number of 32 or 64 bits. Floating point values are packed into a byte representation with a byte order of little or big endian.</simpara>
<simpara>The Double element is a child element of <link linkend="DataModel">DataModel</link>, <link linkend="Block">Block</link>, <link linkend="Sequence">Sequence</link> or <link linkend="Choice">Choice</link>.</simpara>
<note>
<simpara>The floating point representation used for the <emphasis>Double</emphasis> element is based on the IEEE 754 floating point specification. For floating point values not conforming to IEEE 754, consider using a <link linkend="Blob">Blob</link> data type as an alternative.</simpara>
</note>
<section xml:id="_syntax_49">
<title>Syntax</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;Double name="Precision" size="64" endian="big"/&gt;</programlisting>
</section>
<section xml:id="_attributes_34">
<title>Attributes</title>
<simpara><emphasis>Required:</emphasis></simpara>
<variablelist>
<varlistentry>
<term><link linkend="size">size</link></term>
<listitem>
<simpara>Size of floating point number in bits. Valid options are 32 or 64.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term><link linkend="name">name</link></term>
<listitem>
<simpara>Name of the floating point number.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="value">value</link></term>
<listitem>
<simpara>The default value to assign to the floating point number.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="valueType">valueType</link></term>
<listitem>
<simpara>The representation of the value.
Valid options are string and hex.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="token">token</link></term>
<listitem>
<simpara>This element is treated as a token when parsing, defaults to false. Valid options true and false.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="endian">endian</link></term>
<listitem>
<simpara>Byte order of the number, defaults to little. Valid options are big, little, and network.
Network is the same as big.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="constraint">constraint</link></term>
<listitem>
<simpara>A constraint in the form of a python expression.
Used during data cracking.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="mutable">mutable</link></term>
<listitem>
<simpara>Is data element changeable (should it be mutated during fuzzing), defaults to true.
Valid options true and false.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="minOccurs">minOccurs</link></term>
<listitem>
<simpara>The minimum number of times this number must occur.
Defaults to 1.
Valid options are a positive integer value.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="maxOccurs">maxOccurs</link></term>
<listitem>
<simpara>The maximum number of times this number can occur.
No default.
Valid options are a positive integer value.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="occurs">occurs</link></term>
<listitem>
<simpara>The actual number of times this number occurs.
Defaults to 1.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_child_elements_18">
<title>Child Elements</title>
<variablelist>
<varlistentry>
<term><link linkend="Analyzers">Analyzer</link></term>
<listitem>
<simpara>Analyze current element post cracking, can dynamically change model.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Fixup">Fixup</link></term>
<listitem>
<simpara>Dynamic transformations such as checksums and CRCs.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Hint">Hint</link></term>
<listitem>
<simpara>Provide information to mutators.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Placement">Placement</link></term>
<listitem>
<simpara>Relocate an element after it has been cracked.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Relation">Relation</link></term>
<listitem>
<simpara>Modeling of relationships in the data (such as comparisons)</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Transformer">Transformer</link></term>
<listitem>
<simpara>Static transformations such as compression or encoding.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_mutators_8">
<title>Mutators</title>
<simpara>The following mutators will operate on this element type:</simpara>
<simpara><emphasis>Enabled when element is marked as an array</emphasis></simpara>
<variablelist>
<varlistentry>
<term><link linkend="Mutators_ArrayNumericalEdgeCasesMutator">ArrayNumericalEdgeCasesMutator</link></term>
<listitem>
<simpara>This mutator will grow and shrink an array to counts based on numerical edge cases.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_ArrayRandomizeOrderMutator">ArrayRandomizeOrderMutator</link></term>
<listitem>
<simpara>This mutator will randomize the order of items in an array.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_ArrayReverseOrderMutator">ArrayReverseOrderMutator</link></term>
<listitem>
<simpara>This mutator will reverse the order of items in an array.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_ArrayVarianceMutator">ArrayVarianceMutator</link></term>
<listitem>
<simpara>This mutator will grow and shrink an array to a variance of counts based on the current size.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Used for all data elements</emphasis></simpara>
<variablelist>
<varlistentry>
<term><link linkend="Mutators_DataElementBitFlipper">DataElementBitFlipper</link></term>
<listitem>
<simpara>This mutator will produce test cases by flipping bits in the output value.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_DataElementDuplicate">DataElementDuplicate</link></term>
<listitem>
<simpara>This mutator will duplicate data elements.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_DataElementRemove">DataElementRemove</link></term>
<listitem>
<simpara>This mutator will remove data elements.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_DataElementSwapNear">DataElementSwapNear</link></term>
<listitem>
<simpara>This mutator will swap data elements.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_SampleNinjaMutator">SampleNinjaMutator</link></term>
<listitem>
<simpara>This mutator will combine data elements from different data sets.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Enabled when element is part of a size relation</emphasis></simpara>
<variablelist>
<varlistentry>
<term><link linkend="Mutators_SizedDataEdgeCase">SizedDataEdgeCase</link></term>
<listitem>
<simpara>This mutator will cause the data portion of a relation to be sized as numerical edge cases.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_SizedDataVariance">SizedDataVariance</link></term>
<listitem>
<simpara>This mutator will cause the data portion of a relation to be sized as numerical variances.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_SizedEdgeCase">SizedEdgeCase</link></term>
<listitem>
<simpara>This mutator will change both sides of the relation (data and value) to match numerical edge cases.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_SizedVariance">SizedVariance</link></term>
<listitem>
<simpara>This mutator will change both sides of the relation (data and value) to match numerical variances of the current size.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Specific to this element type</emphasis></simpara>
<variablelist>
<varlistentry>
<term><link linkend="Mutators_DoubleRandom">DoubleRandom</link></term>
<listitem>
<simpara>This mutator will produce random values from the available numerical space.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_DoubleVariance">DoubleVariance</link></term>
<listitem>
<simpara>This mutator will produce values near the current value of a number.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_33">
<title>Examples</title>
<example>
<title>Size</title>
<simpara>Produce 32 bit (4 byte) floating point number with a default value of 5.1:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
			 xsi:schemaLocation="http://peachfuzzer.com/2012/Peach /peach/peach.xsd"&gt;
	&lt;DataModel name="DoubleExample1"&gt;
		&lt;Double name="Hi51" value="5.1" size="32"/&gt;
	&lt;/DataModel&gt;

	&lt;StateModel name="TheState" initialState="Initial"&gt;
		&lt;State name="Initial"&gt;
			&lt;Action type="output"&gt;
				&lt;DataModel ref="DoubleExample1"/&gt;
			&lt;/Action&gt;
		&lt;/State&gt;
	&lt;/StateModel&gt;

	&lt;Agent name="TheAgent" /&gt;

	&lt;Test name="Default"&gt;
		&lt;Agent ref="TheAgent"/&gt;

		&lt;StateModel ref="TheState"/&gt;

		&lt;Publisher class="ConsoleHex"/&gt;
	&lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Output from this example.</simpara>
<screen>&gt;peach -1 --debug DoubleExample1.xml

[*] Test 'Default' starting with random seed 12232.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.StateModel Run(): Changing to state "Initial".
Peach.Core.Dom.Action Run(Action): Output
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Publishers.ConsolePublisher start()
Peach.Core.Publishers.ConsolePublisher open()
Peach.Core.Publishers.ConsolePublisher output(4 bytes)
00000000   33 33 A3 40                                        33.@ <co xml:id="CO14-3"/>
Peach.Core.Publishers.ConsolePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.ConsolePublisher stop()

[*] Test 'Default' finished.</screen>
<calloutlist>
<callout arearefs="CO14-1 CO14-3">
<para>The 32 bit little endian value 5.1</para>
</callout>
</calloutlist>
<simpara>To use 64 bits (four byte) change the size to 64.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
			 xsi:schemaLocation="http://peachfuzzer.com/2012/Peach /peach/peach.xsd"&gt;

	&lt;DataModel name="DoubleExample2"&gt;
		&lt;Double name="Hi51" value="5.1" size="64"/&gt;
	&lt;/DataModel&gt;

	&lt;StateModel name="TheState" initialState="Initial"&gt;
		&lt;State name="Initial"&gt;
			&lt;Action type="output"&gt;
				&lt;DataModel ref="DoubleExample2"/&gt;
			&lt;/Action&gt;
		&lt;/State&gt;
	&lt;/StateModel&gt;

	&lt;Agent name="TheAgent" /&gt;

	&lt;Test name="Default"&gt;
		&lt;Agent ref="TheAgent"/&gt;

		&lt;StateModel ref="TheState"/&gt;

		&lt;Publisher class="ConsoleHex"/&gt;
	&lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Output from this example.</simpara>
<screen>&gt;peach -1 --debug DoubleExample2.xml

[*] Test 'Default' starting with random seed 51105.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.StateModel Run(): Changing to state "Initial".
Peach.Core.Dom.Action Run(Action): Output
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Publishers.ConsolePublisher start()
Peach.Core.Publishers.ConsolePublisher open()
Peach.Core.Publishers.ConsolePublisher output(8 bytes)
00000000   66 66 66 66 66 66 14 40                            ffffff.@ <co xml:id="CO15-1"/>
Peach.Core.Publishers.ConsolePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.ConsolePublisher stop()

[*] Test 'Default' finished.</screen>
<calloutlist>
<callout arearefs="CO15-1">
<para>The 64 bit little endian value 5.1</para>
</callout>
</calloutlist>
<simpara><emphasis role="strong">NOTE:</emphasis> Double elements use the <literal>size</literal> attribute which is, by default, the size in
<emphasis role="strong">bits</emphasis>. <literal>Double</literal> elements do not accept <literal>length</literal> attribute used by other elements.</simpara>
</example>
<example>
<title>Endian</title>
<simpara>To change the endianness of the floating point number set the endian attribute. Endianness defines in which order the bytes are the least or most significant.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
			 xsi:schemaLocation="http://peachfuzzer.com/2012/Peach /peach/peach.xsd"&gt;

	&lt;DataModel name="DoubleExample3"&gt;
		&lt;Double name="big" value="10.0" size="64" endian="big" /&gt;
	&lt;/DataModel&gt;

	&lt;DataModel name="DoubleExample4"&gt;
		&lt;Double name="little" value="10.0" size="64" endian="little" /&gt;
	&lt;/DataModel&gt;

	&lt;StateModel name="TheState" initialState="Initial"&gt;
		&lt;State name="Initial"&gt;
			&lt;Action type="output"&gt;
				&lt;DataModel ref="DoubleExample3"/&gt;
			&lt;/Action&gt;
			&lt;Action type="output"&gt;
				&lt;DataModel ref="DoubleExample4"/&gt;
			&lt;/Action&gt;
		&lt;/State&gt;
	&lt;/StateModel&gt;

	&lt;Agent name="TheAgent" /&gt;

	&lt;Test name="Default"&gt;
		&lt;Agent ref="TheAgent"/&gt;

		&lt;StateModel ref="TheState"/&gt;

		&lt;Publisher class="ConsoleHex"/&gt;
	&lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Output from this example.</simpara>
<screen>&gt;peach -1 --debug DoubleEndianExample.xml

[*] Test 'Default' starting with random seed 35381.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.StateModel Run(): Changing to state "Initial".
Peach.Core.Dom.Action Run(Action): Output
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Publishers.ConsolePublisher start()
Peach.Core.Publishers.ConsolePublisher open()
Peach.Core.Publishers.ConsolePublisher output(8 bytes)
00000000   40 24 00 00 00 00 00 00                            @$...... <co xml:id="CO16-1"/>
Peach.Core.Dom.Action Run(Action_1): Output
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Publishers.ConsolePublisher output(8 bytes)
00000000   00 00 00 00 00 00 24 40                            ......$@ <co xml:id="CO16-2"/>
Peach.Core.Publishers.ConsolePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.ConsolePublisher stop()

[*] Test 'Default' finished.</screen>
<calloutlist>
<callout arearefs="CO16-1">
<para>Big endian outputs the bytes in the order</para>
</callout>
<callout arearefs="CO16-2">
<para>Little endian outputs the bytes in the order</para>
</callout>
</calloutlist>
<simpara>Note, however, that endian-ness doesn&#8217;t have any impact on output if the <literal>valueType</literal>
is <literal>"hex"</literal>:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
			 xsi:schemaLocation="http://peachfuzzer.com/2012/Peach /peach/peach.xsd"&gt;

	&lt;DataModel name="DoubleExample5"&gt;
		&lt;Double name="abcd" valueType="hex" value="ABCDEF01ABCDEF01" size="64" endian="little" /&gt;
	&lt;/DataModel&gt;

	&lt;DataModel name="DoubleExample6"&gt;
		&lt;Double name="abcd" valueType="hex" value="ABCDEF01ABCDEF01" size="64" endian="big" /&gt;
	&lt;/DataModel&gt;

	&lt;StateModel name="TheState" initialState="Initial"&gt;
		&lt;State name="Initial"&gt;
			&lt;Action type="output"&gt;
				&lt;DataModel ref="DoubleExample5"/&gt;
			&lt;/Action&gt;
			&lt;Action type="output"&gt;
				&lt;DataModel ref="DoubleExample6"/&gt;
			&lt;/Action&gt;
		&lt;/State&gt;
	&lt;/StateModel&gt;

	&lt;Agent name="TheAgent" /&gt;

	&lt;Test name="Default"&gt;
		&lt;Agent ref="TheAgent"/&gt;

		&lt;StateModel ref="TheState"/&gt;

		&lt;Publisher class="ConsoleHex"/&gt;
	&lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Output from this example.</simpara>
<screen>&gt;peach -1 --debug NumberEndianExample.xml

[*] Test 'Default' starting with random seed 53121.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.StateModel Run(): Changing to state "Initial".
Peach.Core.Dom.Action Run(Action): Output
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Publishers.ConsolePublisher start()
Peach.Core.Publishers.ConsolePublisher open()
Peach.Core.Publishers.ConsolePublisher output(8 bytes)
00000000   AB CD EF 01 AB CD EF 01                            ........   <co xml:id="CO17-1"/>
Peach.Core.Dom.Action Run(Action_1): Output
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Publishers.ConsolePublisher output(8 bytes)
00000000   AB CD EF 01 AB CD EF 01                            ........   <co xml:id="CO17-2"/>
Peach.Core.Publishers.ConsolePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.ConsolePublisher stop()

[*] Test 'Default' finished.</screen>
<calloutlist>
<callout arearefs="CO17-1">
<para>For little we see the expected output</para>
</callout>
<callout arearefs="CO17-2">
<para>For big endian, nothing changes</para>
</callout>
</calloutlist>
<simpara>When the attribute <literal>valueType</literal> is set to <literal>"hex"</literal> this indicates that
the ordering is exactly as specified. The <literal>endian</literal> attribute still
impacts mutation and input parsing.</simpara>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Flag">
<title>Flag</title>
<simpara>The Flag element defines a specific bit field in a Flags container.</simpara>
<simpara>See also parent element <link linkend="Flags">Flags</link>.</simpara>
<section xml:id="_syntax_50">
<title>Syntax</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;Flags name="options" size="16"&gt;
  &lt;Flag name="compression" position="0" size="1" /&gt;
  &lt;Flag name="compressionType" position="1" size="3" /&gt;
  &lt;Flag name="opcode" position="10" size="2" value="5" /&gt;
&lt;/Flags&gt;</programlisting>
</section>
<section xml:id="_attributes_35">
<title>Attributes</title>
<simpara><emphasis>Required:</emphasis></simpara>
<variablelist>
<varlistentry>
<term><link linkend="size">size</link></term>
<listitem>
<simpara>Size in bits</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>position</term>
<listitem>
<simpara>Location of the flag. <emphasis>Position</emphasis> identifies the location of the first bit of a flag. The value is a zero-based index.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term><link linkend="name">name</link></term>
<listitem>
<simpara>Name of the element.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="value">value</link></term>
<listitem>
<simpara>The default value contained within the element.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="valueType">valueType</link></term>
<listitem>
<simpara>The format in which the default value is expressed. (i.e. hex, string, or literal).</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="token">token</link></term>
<listitem>
<simpara>Is data element a token? Default is false.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="mutable">mutable</link></term>
<listitem>
<simpara>Is data element changeable (should it be mutated), defaults to true.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_child_elements_19">
<title>Child Elements</title>
<variablelist>
<varlistentry>
<term><link linkend="Analyzers">Analyzer</link></term>
<listitem>
<simpara>Analyzes the current element post cracking; can dynamically change model.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Fixup">Fixup</link></term>
<listitem>
<simpara>Performs dynamic transformations such as checksums and CRCs.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Hint">Hint</link></term>
<listitem>
<simpara>Provides information to mutators.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Placement">Placement</link></term>
<listitem>
<simpara>Relocates an element after it has been cracked.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Relation">Relation</link></term>
<listitem>
<simpara>Identifies a type of relationship with another data element, such as count.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Transformer">Transformer</link></term>
<listitem>
<simpara>Static transformations such as compression or encoding.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_mutators_9">
<title>Mutators</title>
<simpara>The following mutators operate on this element type:</simpara>
<simpara><emphasis>Enabled when element is marked as an array</emphasis></simpara>
<variablelist>
<varlistentry>
<term><link linkend="Mutators_ArrayNumericalEdgeCasesMutator">ArrayNumericalEdgeCasesMutator</link></term>
<listitem>
<simpara>This mutator grows and shrinks an array to counts based on numerical edge cases.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_ArrayRandomizeOrderMutator">ArrayRandomizeOrderMutator</link></term>
<listitem>
<simpara>This mutator randomizes the order of items in an array.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_ArrayReverseOrderMutator">ArrayReverseOrderMutator</link></term>
<listitem>
<simpara>This mutator reverses the order of items in an array.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_ArrayVarianceMutator">ArrayVarianceMutator</link></term>
<listitem>
<simpara>This mutator grows and shrinks an array to a variance of counts based on the current size.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Used for all data elements</emphasis></simpara>
<variablelist>
<varlistentry>
<term><link linkend="Mutators_DataElementBitFlipper">DataElementBitFlipper</link></term>
<listitem>
<simpara>This mutator produces test cases by flipping bits in the output value.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_DataElementDuplicate">DataElementDuplicate</link></term>
<listitem>
<simpara>This mutator duplicates data elements.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_DataElementRemove">DataElementRemove</link></term>
<listitem>
<simpara>This mutator removes data elements.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_DataElementSwapNear">DataElementSwapNear</link></term>
<listitem>
<simpara>This mutator swaps data elements.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_SampleNinjaMutator">SampleNinjaMutator</link></term>
<listitem>
<simpara>This mutator combines data elements from different data sets.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Enabled when element is part of a size relation</emphasis></simpara>
<variablelist>
<varlistentry>
<term><link linkend="Mutators_SizedDataEdgeCase">SizedDataEdgeCase</link></term>
<listitem>
<simpara>This mutator causes the data portion of a relation to be sized as numerical edge cases.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_SizedDataVariance">SizedDataVariance</link></term>
<listitem>
<simpara>This mutator causes the data portion of a relation to be sized as numerical variances.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_SizedEdgeCase">SizedEdgeCase</link></term>
<listitem>
<simpara>This mutator changes both sides of the relation (data and value) to match numerical edge cases.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_SizedVariance">SizedVariance</link></term>
<listitem>
<simpara>This mutator changes both sides of the relation (data and value) to match numerical variances of the current size.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Specific to this element type</emphasis></simpara>
<variablelist>
<varlistentry>
<term><link linkend="Mutators_ExtraValues">ExtraValues</link></term>
<listitem>
<simpara>This mutator provides extra test case values on a per-data element basis.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_NumberEdgeCase">NumberEdgeCase</link></term>
<listitem>
<simpara>This mutator produces numerical edge cases for integer values.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_NumberRandom">NumberRandom</link></term>
<listitem>
<simpara>This mutator produces random values from the available numerical space.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_NumberVariance">NumberVariance</link></term>
<listitem>
<simpara>This mutator produces values near the current value of a number.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_34">
<title>Examples</title>
<example>
<title>Example of Flags</title>
<simpara>This example shows a real-world example of a flag set by modeling a TCP packet (without options). This example also shows using relations with the <link linkend="Flag">Flag</link> element.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
			 xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

	&lt;DataModel name="TcpPacket"&gt;
		&lt;Block name="Header"&gt;
			&lt;Number name="SrcPort" size="16" endian="big" value="1234"/&gt;
			&lt;Number name="DestPort" size="16" endian="big" value="1234"/&gt;
			&lt;Number name="SequenceNumber" size="32" endian="big" valueType="hex" value="0043a577"/&gt;
			&lt;Number name="AcknowledgmentNumber" size="32" endian="big" value="0"/&gt;

			&lt;Flags name="ControlBits" size="16" endian="big"&gt;
				&lt;Flag name="Offset" position="0" size="4" valueType="hex"&gt;
					&lt;Relation type="size" of="Header" expressionGet="size * 4" expressionSet="size / 4"/&gt;
				&lt;/Flag&gt;
				&lt;Flag name="Reserved" position="4" size="3"/&gt;
				&lt;Flag name="NS" position="7" size="1"/&gt;
				&lt;Flag name="CWR" position="8" size="1"/&gt;
				&lt;Flag name="ECE" position="9" size="1"/&gt;
				&lt;Flag name="URG" position="10" size="1"/&gt;
				&lt;Flag name="ACK" position="11" size="1"/&gt;
				&lt;Flag name="PSH" position="12" size="1"/&gt;
				&lt;Flag name="RST" position="13" size="1"/&gt;
				&lt;Flag name="SYN" position="14" size="1"/&gt;
				&lt;Flag name="FIN" position="15" size="1"/&gt;
			&lt;/Flags&gt;

			&lt;Number name="WindowSize" size="16" endian="big" valueType="hex" value="aaaa"/&gt;
			&lt;Number name="CheckSum" size="16" endian="big"&gt;
				&lt;Fixup class="TCPChecksumFixup"&gt;
					&lt;Param name="ref" value="TcpPacket" /&gt;
					&lt;Param name="src" value="127.0.0.1" /&gt;
					&lt;Param name="dst" value="127.0.0.1" /&gt;
				&lt;/Fixup&gt;
			&lt;/Number&gt;
			&lt;Number name="UrgentPointer" size="16" endian="big"/&gt;
		&lt;/Block&gt;

		&lt;Blob name="TcpPayload" value="this is a packet.\n"/&gt;
	&lt;/DataModel&gt;

	&lt;StateModel name="TheStateModel" initialState="InitialState"&gt;
		&lt;State name="InitialState"&gt;
			&lt;Action type="output"&gt;
				&lt;DataModel ref="TcpPacket" /&gt;
			&lt;/Action&gt;
		&lt;/State&gt;
	&lt;/StateModel&gt;

	&lt;Test name="Default"&gt;
		&lt;StateModel ref="TheStateModel" /&gt;

		&lt;Publisher class="ConsoleHex"/&gt;	&lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Produces the following output:</simpara>
<screen>&gt; peach -1 --debug example.xml

[*] Test 'Default' starting with random seed 17543.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher start()
Peach.Core.Publishers.ConsolePublisher open()
Peach.Core.Publishers.ConsolePublisher output(38 bytes)
00000000   04 D2 04 D2 00 43 A5 77  00 00 00 00 50 00 AA AA   ?????C?w????P???
00000010   1D F6 00 00 74 68 69 73  20 69 73 20 61 20 70 61   ????this is a pa
00000020   63 6B 65 74 2E 0A                                  cket.?
Peach.Core.Publishers.ConsolePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.ConsolePublisher stop()

[*] Test 'Default' finished.</screen>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Flags">
<title>Flags</title>
<simpara>The Flags element defines a set of bit-sized flags.</simpara>
<simpara>See also <link linkend="Flag">Flag</link>.</simpara>
<note>
<simpara>The <emphasis>Flags</emphasis> element is largely provided for backwards compatibility with older versions of Peach that did not support arbitrarily-sized <link linkend="Number">Number</link> elements.</simpara>
</note>
<section xml:id="_syntax_51">
<title>Syntax</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;Flags name="options" size="16"&gt;
  &lt;Flag name="compression" position="0" size="1" /&gt;
  &lt;Flag name="compressionType" position="1" size="3" /&gt;
  &lt;Flag name="opcode" position="10" size="2" value="5" /&gt;
&lt;/Flags&gt;</programlisting>
</section>
<section xml:id="_attributes_36">
<title>Attributes</title>
<simpara><emphasis>Required:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>size</term>
<listitem>
<simpara>Size of the set of flags in bits. Only 8-bit aligned values are supported: 8, 16, 24, 32, 64.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term><link linkend="name">name</link></term>
<listitem>
<simpara>Name of the element.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="endian">endian</link></term>
<listitem>
<simpara>Byte order of number. Defaults to <emphasis>little</emphasis>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="token">token</link></term>
<listitem>
<simpara>Specifies whether this data element is a token. Defaults to <emphasis>false</emphasis>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="mutable">mutable</link></term>
<listitem>
<simpara>Specifies whether this data element should it be mutated. Defaults to <emphasis>true</emphasis>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="constraint">constraint</link></term>
<listitem>
<simpara>Scripting expression that evaluates to true or false. Defaults to none.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="minOccurs">minOccurs</link></term>
<listitem>
<simpara>The minimum number of times this element must occur. Defaults to 1. <?asciidoc-br?></simpara>
<itemizedlist>
<listitem>
<simpara>Used to define arrays with variable size. Arrays defined by min/maxOccurs generally have a relation
defined.</simpara>
</listitem>
<listitem>
<simpara>Adding this attribute, even with a value of 1, converts the element to an array.</simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="maxOccurs">maxOccurs</link></term>
<listitem>
<simpara>The maximum number of times this element can occur. Defaults to 1. <?asciidoc-br?></simpara>
<itemizedlist>
<listitem>
<simpara>Used to define arrays with static size.</simpara>
</listitem>
<listitem>
<simpara>Adding this attribute, even with a value of 1, converts the element to an array.</simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="occurs">occurs</link></term>
<listitem>
<simpara>Actual occurrences of element. Defaults to 1. <?asciidoc-br?></simpara>
<itemizedlist>
<listitem>
<simpara>Used to define arrays with static size.</simpara>
</listitem>
<listitem>
<simpara>Adding this attribute, even with a value of 1, converts the element to an array.</simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_child_elements_20">
<title>Child Elements</title>
<simpara><emphasis>Required:</emphasis></simpara>
<simpara>None.</simpara>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term><link linkend="Analyzers">Analyzer</link></term>
<listitem>
<simpara>Analyzes current element post cracking, can dynamically change model.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Fixup">Fixup</link></term>
<listitem>
<simpara>Performs dynamic transformations such as checksums and CRCs.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Flag">Flag</link></term>
<listitem>
<simpara>Defines a specific bit field in a Flags container.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Hint">Hint</link></term>
<listitem>
<simpara>Provides information to mutators.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Placement">Placement</link></term>
<listitem>
<simpara>Relocates an element after it has been cracked.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Transformer">Transformer</link></term>
<listitem>
<simpara>Performs static transformations such as compression or encoding.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_mutators_10">
<title>Mutators</title>
<simpara>The following mutators operate on this element type:</simpara>
<simpara><emphasis>Enabled when element is marked as an array</emphasis></simpara>
<variablelist>
<varlistentry>
<term><link linkend="Mutators_ArrayNumericalEdgeCasesMutator">ArrayNumericalEdgeCasesMutator</link></term>
<listitem>
<simpara>This mutator grows and shrinks an array to counts based on numerical edge cases.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_ArrayRandomizeOrderMutator">ArrayRandomizeOrderMutator</link></term>
<listitem>
<simpara>This mutator randomizes the order of items in an array.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_ArrayReverseOrderMutator">ArrayReverseOrderMutator</link></term>
<listitem>
<simpara>This mutator reverses the order of items in an array.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_ArrayVarianceMutator">ArrayVarianceMutator</link></term>
<listitem>
<simpara>This mutator grows and shrinks an array to a variance of counts based on the current size.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Used for all data elements</emphasis></simpara>
<variablelist>
<varlistentry>
<term><link linkend="Mutators_DataElementBitFlipper">DataElementBitFlipper</link></term>
<listitem>
<simpara>This mutator produces test cases by flipping bits in the output value.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_DataElementDuplicate">DataElementDuplicate</link></term>
<listitem>
<simpara>This mutator duplicates data elements.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_DataElementRemove">DataElementRemove</link></term>
<listitem>
<simpara>This mutator removes data elements.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_DataElementSwapNear">DataElementSwapNear</link></term>
<listitem>
<simpara>This mutator swaps data elements.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_SampleNinjaMutator">SampleNinjaMutator</link></term>
<listitem>
<simpara>This mutator combines data elements from different data sets.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Enabled when element is part of a size relation</emphasis></simpara>
<variablelist>
<varlistentry>
<term><link linkend="Mutators_SizedDataEdgeCase">SizedDataEdgeCase</link></term>
<listitem>
<simpara>This mutator causes the data portion of a relation to be sized as numerical edge cases.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_SizedDataVariance">SizedDataVariance</link></term>
<listitem>
<simpara>This mutator causes the data portion of a relation to be sized as numerical variances.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_SizedEdgeCase">SizedEdgeCase</link></term>
<listitem>
<simpara>This mutator changes both sides of the relation (data and value) to match numerical edge cases.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_SizedVariance">SizedVariance</link></term>
<listitem>
<simpara>This mutator changes both sides of the relation (data and value) to match numerical variances of the current size.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_35">
<title>Examples</title>
<example>
<title>Example of Flags</title>
<simpara>This example shows a real world example of a flag set by modeling a TCP packet (without options). This example also shows using relations with the <link linkend="Flag">Flag</link> element.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
			 xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

	&lt;DataModel name="TcpPacket"&gt;
		&lt;Block name="Header"&gt;
			&lt;Number name="SrcPort" size="16" endian="big" value="1234"/&gt;
			&lt;Number name="DestPort" size="16" endian="big" value="1234"/&gt;
			&lt;Number name="SequenceNumber" size="32" endian="big" valueType="hex" value="0043a577"/&gt;
			&lt;Number name="AcknowledgmentNumber" size="32" endian="big" value="0"/&gt;

			&lt;Flags name="ControlBits" size="16" endian="big"&gt;
				&lt;Flag name="Offset" position="0" size="4" valueType="hex"&gt;
					&lt;Relation type="size" of="Header" expressionGet="size * 4" expressionSet="size / 4"/&gt;
				&lt;/Flag&gt;
				&lt;Flag name="Reserved" position="4" size="3"/&gt;
				&lt;Flag name="NS" position="7" size="1"/&gt;
				&lt;Flag name="CWR" position="8" size="1"/&gt;
				&lt;Flag name="ECE" position="9" size="1"/&gt;
				&lt;Flag name="URG" position="10" size="1"/&gt;
				&lt;Flag name="ACK" position="11" size="1"/&gt;
				&lt;Flag name="PSH" position="12" size="1"/&gt;
				&lt;Flag name="RST" position="13" size="1"/&gt;
				&lt;Flag name="SYN" position="14" size="1"/&gt;
				&lt;Flag name="FIN" position="15" size="1"/&gt;
			&lt;/Flags&gt;

			&lt;Number name="WindowSize" size="16" endian="big" valueType="hex" value="aaaa"/&gt;
			&lt;Number name="CheckSum" size="16" endian="big"&gt;
				&lt;Fixup class="TCPChecksumFixup"&gt;
					&lt;Param name="ref" value="TcpPacket" /&gt;
					&lt;Param name="src" value="127.0.0.1" /&gt;
					&lt;Param name="dst" value="127.0.0.1" /&gt;
				&lt;/Fixup&gt;
			&lt;/Number&gt;
			&lt;Number name="UrgentPointer" size="16" endian="big"/&gt;
		&lt;/Block&gt;

		&lt;Blob name="TcpPayload" value="this is a packet.\n"/&gt;
	&lt;/DataModel&gt;

	&lt;StateModel name="TheStateModel" initialState="InitialState"&gt;
		&lt;State name="InitialState"&gt;
			&lt;Action type="output"&gt;
				&lt;DataModel ref="TcpPacket" /&gt;
			&lt;/Action&gt;
		&lt;/State&gt;
	&lt;/StateModel&gt;

	&lt;Test name="Default"&gt;
		&lt;StateModel ref="TheStateModel" /&gt;

		&lt;Publisher class="ConsoleHex"/&gt;
	&lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Produces the following output:</simpara>
<screen>&gt; peach -1 --debug example.xml

[*] Test 'Default' starting with random seed 17543.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher start()
Peach.Core.Publishers.ConsolePublisher open()
Peach.Core.Publishers.ConsolePublisher output(38 bytes)
00000000   04 D2 04 D2 00 43 A5 77  00 00 00 00 50 00 AA AA   ?????C?w????P???
00000010   1D F6 00 00 74 68 69 73  20 69 73 20 61 20 70 61   ????this is a pa
00000020   63 6B 65 74 2E 0A                                  cket.?
Peach.Core.Publishers.ConsolePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.ConsolePublisher stop()

[*] Test 'Default' finished.</screen>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Frag">
<title>Frag</title>
<simpara>This element is used model fragmentation layers in protocols. The fragmentation method can be simplistic such as length based or more complex requiring custom logic and inspection of payload to determine how to parition the data.</simpara>
<simpara>The Peach fragmentation support also has two corresponding Actions that are specific for supporting fragmented protocols: <link linkend="Action_outfrag">outfrag</link> and <link linkend="Action_infrag">infrag</link>. These actions are aware of fragmentation and will correctly output multiple fragments or receive and reconstruct multiple fragments.</simpara>
<simpara>The <emphasis>Frag</emphasis> element expects two child elements to exist: <emphasis>Payload</emphasis> and <emphasis>Template</emphasis>.
The <emphasis>Template</emphasis> model defines what each fragment will look like while the <emphasis>Payload</emphasis> model contains the unfragmented data.</simpara>
<simpara>When outputing a <emphasis>Frag</emphasis> element via the <link linkend="Action_outfrag">outfrag</link> action, the <emphasis>Frag</emphasis> element will generate a new child element called <emphasis>Rendering</emphasis> of type <link linkend="Sequence">Sequence</link> that contians each of the framgents.  Each fragment is a copy of the <emphasis>Template</emphasis> element with the fragmented <emphasis>Payload</emphasis> data placed into it&#8217;s <emphasis>FragData</emphasis> element. During an <emphasis>outfrag</emphasis> action, each element in <emphasis>Rendering</emphasis> is sent via it&#8217;s own <emphasis>output</emphasis> action.</simpara>
<simpara>When receiving input into a <emphasis>Frag</emphasis> element via the <link linkend="Action_infrag">infrag</link> action, each fragment will be placed into a child element called <emphasis>Rendering</emphasis> of type <link linkend="Sequence">Sequence</link>. Once all fragments have been received the unfragmented data is cracked into the <emphasis>Payload</emphasis> element.</simpara>
<simpara>All <emphasis>Frag</emphasis> elements are paired with a fragmentation algorithm which contains the logic for generating fragments and also reconstructing the fragments. Peach comes with a single fragmentation algorithm called <literal>ByLength</literal> which supports simple size based fragmentation. For more complicated fragmentation logic a custom fragmentation algorithm must be written. Currently the fragmentation algorithms must be written in a Microsoft.NET language such as C#.</simpara>
<note>
<simpara>The <emphasis>Frag</emphasis> element must be the first and only element in a <link linkend="DataModel">DataModel</link>. Multiple layers of fragmentation is not supported.</simpara>
</note>
<simpara>See also: <link linkend="Action_outfrag">action outfrag</link>, <link linkend="Action_infrag">action infrag</link>, <link linkend="Sequence">Sequence</link>, <link linkend="DataModel">DataModel</link>.</simpara>
<section xml:id="_syntax_52">
<title>Syntax</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;Frag fragLength="1024" totalLengthField="TotalLength" fragLengthField="FragLength" fragIndexField="FragIndex"&gt;

    &lt;Block name="Template"&gt;
        &lt;Number name="FragLength" size="32"/&gt;
        &lt;Number name="FragIndex" size="32"/&gt;
        &lt;Number name="TotalLength" size="32"/&gt;

        &lt;Blob name="FragData" /&gt;
    &lt;/Block&gt;

    &lt;Block name="Payload"&gt;
        &lt;!-- Payload contents --&gt;
    &lt;/Block&gt;

&lt;/Frag&gt;</programlisting>
</section>
<section xml:id="_attributes_37">
<title>Attributes</title>
<simpara><emphasis>Required:</emphasis></simpara>
<simpara>No required attributes.</simpara>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term><link linkend="name">name</link></term>
<listitem>
<simpara>Name of the boolean value.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>fragLength</term>
<listitem>
<simpara>Fragment size in bytes. Used in combination with a fragmentation algorithm that supports this attribute such as the default <emphasis>ByLength</emphasis> algorithm.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>class</term>
<listitem>
<simpara>Fragmentation algorithm to use, defaults to <emphasis>ByLength</emphasis>. The fragmentation algorithm provides the logic for generating fragments and also reconstructing fragments. Custom fragmentation algorithms are supported by extending from the <literal>FragmentAlgorithm</literal> base class.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="constraint">constraint</link></term>
<listitem>
<simpara>A constraint in the form of a python expression. Used during data cracking.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>payloadOptional</term>
<listitem>
<simpara>Protocol allows for null payload. Some fragmentation layers will send a single fragment with a null payload.  This attribute enabled support for this mode of operation.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>totalLengthField</term>
<listitem>
<simpara>Name of total length field in <emphasis>Template</emphasis> element.
If the fragment template has a field for the total length of the payload it can be automatically set using this attribute.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>fragmentLengthField</term>
<listitem>
<simpara>Name of fragment length field in <emphasis>Template</emphasis> element.
If the fragment template has a field for the length of the current frament it can be automatically set using this attribute.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>fragmentOffsetField</term>
<listitem>
<simpara>Name of fragment offset field in <emphasis>Template</emphasis> element.
If the fragment template has a field for the offset of the current frament it can be automatically set using this attribute.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>fragmentIndexField</term>
<listitem>
<simpara>Name of fragment index field in <emphasis>Template</emphasis> element.
If the fragment template has a field for the offset of the current frament it can be automatically set using this attribute.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>reassembleDataSet</term>
<listitem>
<simpara>Controls how a file based <link linkend="Data">data set</link> is applied to a model containing a <emphasis>Frag</emphasis> element.
If the value is <emphasis>true</emphasis>, the data set is expected to be fragmented and the <emphasis>Frag</emphasis> element will perform reassembly.
If the value is <emphasis>false</emphasis>, the data set is not expected to be fragmented and is expected to only contain the value and will be applied directly to the <emphasis>Payload</emphasis> element.
The default value is <emphasis>false</emphasis>.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_child_elements_21">
<title>Child Elements</title>
<simpara>No supported child elements.</simpara>
</section>
<section xml:id="_mutators_11">
<title>Mutators</title>
<simpara>The muations for the <emphasis>Frag</emphasis> element are:</simpara>
<itemizedlist>
<listitem>
<simpara>Fuzz each fragment. All elements specified in <emphasis>Template</emphasis> will be fuzzed.</simpara>
</listitem>
<listitem>
<simpara>Fuzz <emphasis>Payload</emphasis>. All elements specified in <emphasis>Payload</emphasis> will be fuzzed.</simpara>
</listitem>
<listitem>
<simpara>Fuzz the <emphasis>Rendering</emphasis> sequence using all Array mutators.</simpara>
<itemizedlist>
<listitem>
<simpara>Out of order fragments</simpara>
</listitem>
<listitem>
<simpara>Missing fragments</simpara>
</listitem>
<listitem>
<simpara>Duplicated fragments</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
<simpara>The following mutators will operate on this element type:</simpara>
<simpara><emphasis>Specific to this element type</emphasis></simpara>
<variablelist>
<varlistentry>
<term><link linkend="Mutators_ArrayNumericalEdgeCasesMutator">ArrayNumericalEdgeCasesMutator</link></term>
<listitem>
<simpara>This mutator will grow and shrink an array to counts based on numerical edge cases.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_ArrayRandomizeOrderMutator">ArrayRandomizeOrderMutator</link></term>
<listitem>
<simpara>This mutator will randomize the order of items in an array.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_ArrayReverseOrderMutator">ArrayReverseOrderMutator</link></term>
<listitem>
<simpara>This mutator will reverse the order of items in an array.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_ArrayVarianceMutator">ArrayVarianceMutator</link></term>
<listitem>
<simpara>This mutator will grow and shrink an array to a variance of counts based on the current size.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Used for all data elements</emphasis></simpara>
<variablelist>
<varlistentry>
<term><link linkend="Mutators_DataElementDuplicate">DataElementDuplicate</link></term>
<listitem>
<simpara>This mutator will duplicate data elements.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_DataElementRemove">DataElementRemove</link></term>
<listitem>
<simpara>This mutator will remove data elements.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_DataElementSwapNear">DataElementSwapNear</link></term>
<listitem>
<simpara>This mutator will swap data elements.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_SampleNinjaMutator">SampleNinjaMutator</link></term>
<listitem>
<simpara>This mutator will combine data elements from different data sets.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_36">
<title>Examples</title>
<example>
<title>Simple Example</title>
<simpara>Produce three fragments with each fragment contianing the current fragment lenght, fragement sequence and total length of data. The Payload is 30 bytes of 0x41.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
			 xsi:schemaLocation="http://peachfuzzer.com/2012/Peach /peach/peach.xsd"&gt;

    &lt;DataModel name="Fragmented"&gt;
        &lt;Frag fragLength="10"
              totalLengthField="TotalLength"
              fragmentLengthField="FragLength"
              fragmentIndexField="FragIndex"&gt;

            &lt;Block name="Template"&gt;
                &lt;Number name="FragLength" size="32"/&gt;
                &lt;Number name="FragIndex" size="32"/&gt;
                &lt;Number name="TotalLength" size="32"/&gt;

                &lt;Blob name="FragData" /&gt;
            &lt;/Block&gt;

            &lt;Block name="Payload"&gt;
                &lt;Blob valueType="hex" value="
                    41 41 41 41 41 41 41 41 41 41
                    41 41 41 41 41 41 41 41 41 41
                    41 41 41 41 41 41 41 41 41 41"/&gt;
            &lt;/Block&gt;
        &lt;/Frag&gt;
	&lt;/DataModel&gt;

	&lt;StateModel name="TheState" initialState="Initial"&gt;
		&lt;State name="Initial"&gt;
			&lt;Action type="outfrag"&gt;
				&lt;DataModel ref="Fragmented"/&gt;
			&lt;/Action&gt;
		&lt;/State&gt;
	&lt;/StateModel&gt;

	&lt;Test name="Default"&gt;
		&lt;StateModel ref="TheState"/&gt;
		&lt;Publisher class="ConsoleHex"/&gt;
	&lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>The example pit will produce three fragments with 10 bytes of payload per-fragment.</simpara>
<simpara>Output from this example:</simpara>
<screen>&gt;peach -1 --debug example.xml

[*] Web site running at: http://10.0.1.87:8888/

[*] Test 'Default' starting with random seed 7010.
2016-07-07 14:26:22.2979 Peach.Pro.Core.Loggers.JobLogger Writing debug.log to: C:\peach-pro\output\win_x64_debug\bin\Logs\example.xml_20160707142621\debug.log

[R1,-,-] Performing iteration
2016-07-07 14:26:22.4288 Peach.Core.Engine runTest: Performing control recording iteration.
2016-07-07 14:26:22.4690 Peach.Pro.Core.Dom.Frag Generating fragments:
2016-07-07 14:26:22.4870 Peach.Core.Dom.StateModel Run(): Changing to state "Initial".
2016-07-07 14:26:22.4951 Peach.Core.Dom.Action Run(Action): Outfrag
2016-07-07 14:26:22.6139 Peach.Pro.Core.Publishers.ConsolePublisher start()
2016-07-07 14:26:22.6139 Peach.Pro.Core.Publishers.ConsolePublisher open()
2016-07-07 14:26:22.6188 Peach.Pro.Core.Publishers.ConsolePublisher output(22 bytes) <co xml:id="CO18-1"/>
00000000   0A 00 00 00 01 00 00 00  1E 00 00 00 41 41 41 41   ............AAAA
00000010   41 41 41 41 41 41                                  AAAAAA
2016-07-07 14:26:22.6188 Peach.Pro.Core.Publishers.ConsolePublisher output(22 bytes) <co xml:id="CO18-2"/>
00000000   0A 00 00 00 02 00 00 00  1E 00 00 00 41 41 41 41   ............AAAA
00000010   41 41 41 41 41 41                                  AAAAAA
2016-07-07 14:26:22.6188 Peach.Pro.Core.Publishers.ConsolePublisher output(22 bytes) <co xml:id="CO18-3"/>
00000000   0A 00 00 00 03 00 00 00  1E 00 00 00 41 41 41 41   ............AAAA
00000010   41 41 41 41 41 41                                  AAAAAA
2016-07-07 14:26:22.6188 Peach.Pro.Core.Publishers.ConsolePublisher close()
2016-07-07 14:26:22.6329 Peach.Core.Engine runTest: context.config.singleIteration == true
2016-07-07 14:26:22.6329 Peach.Pro.Core.Publishers.ConsolePublisher stop()
2016-07-07 14:26:22.6329 Peach.Core.Engine EndTest: Stopping all agents and monitors

[*] Test 'Default' finished.</screen>
<calloutlist>
<callout arearefs="CO18-1">
<para>First fragment. Notice sequence number is 1.</para>
</callout>
<callout arearefs="CO18-2">
<para>Second fragment. Notice sequence number is 2.</para>
</callout>
<callout arearefs="CO18-3">
<para>Third fragment. Notice sequence number is 3.</para>
</callout>
</calloutlist>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="JsonArray">
<title>JsonArray</title>
<simpara><emphasis>JsonArray</emphasis> is used to represent a JSON array.
It&#8217;s similar in operation to <link linkend="Sequence">Sequence</link>.</simpara>
<simpara>A <emphasis>JsonArray</emphasis> element is used to construct an array with all its elements predefined.
A <emphasis>JsonArray</emphasis> is able to contain multiple data types at once.
Unlike regular arrays in Peach,
the size of the array is determined by the number of elements within the array.</simpara>
<section xml:id="_syntax_53">
<title>Syntax</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;JsonObject&gt;
    &lt;JsonArray propertyName="items"&gt;
      &lt;JsonString name="name" value="Peach Toy" /&gt;
      &lt;JsonInteger name="stock" value="10" /&gt;
    &lt;/JsonArray&gt;
&lt;/JsonObject&gt;

&lt;JsonArray&gt;
  &lt;JsonString name="name" value="Peach Toy" /&gt;
  &lt;JsonInteger name="stock" value="10" /&gt;
&lt;/JsonArray&gt;</programlisting>
</section>
<section xml:id="_attributes_38">
<title>Attributes</title>
<simpara><emphasis>Required:</emphasis></simpara>
<simpara>There are no required attributes.</simpara>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term><link linkend="name">name</link></term>
<listitem>
<simpara>Name of the sequence.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>isNull</term>
<listitem>
<simpara>Set default value of this element to null (defaults to false)</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>type</term>
<listitem>
<simpara>Type controls the output encoding allowing both traditional json and also binary json (bson). Supported values: <emphasis>json</emphasis> or <emphasis>bson</emphasis>. Defaults to <emphasis>json</emphasis>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="mutable">mutable</link></term>
<listitem>
<simpara>Is data element changeable (should it be mutated), defaults to false.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_child_elements_22">
<title>Child Elements</title>
<variablelist>
<varlistentry>
<term><link linkend="Analyzers">Analyzer</link></term>
<listitem>
<simpara>Analyze current element post cracking, can dynamically change model.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Fixup">Fixup</link></term>
<listitem>
<simpara>Dynamic transformations such as checksums and CRCs.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Hint">Hint</link></term>
<listitem>
<simpara>Provide information to mutators.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="JsonArray">JsonArray</link></term>
<listitem>
<simpara>JSON array</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="JsonBool">JsonBool</link></term>
<listitem>
<simpara>JSON boolean</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="JsonBlob">JsonBlob</link></term>
<listitem>
<simpara>JSON BLOB</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="JsonDouble">JsonDouble</link></term>
<listitem>
<simpara>JSON double/float</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="JsonInteger">JsonInteger</link></term>
<listitem>
<simpara>JSON integer</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="JsonObject">JsonObject</link></term>
<listitem>
<simpara>JSON object</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="JsonString">JsonString</link></term>
<listitem>
<simpara>JSON string</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Placement">Placement</link></term>
<listitem>
<simpara>Relocate an element after it has been cracked.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Transformer">Transformer</link></term>
<listitem>
<simpara>Static transformations such as compression or encoding.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_mutators_12">
<title>Mutators</title>
<simpara>The following mutators will operate on this element type:</simpara>
<simpara><emphasis>Specific to this element type</emphasis></simpara>
<variablelist>
<varlistentry>
<term><link linkend="Mutators_ArrayNumericalEdgeCasesMutator">ArrayNumericalEdgeCasesMutator</link></term>
<listitem>
<simpara>This mutator will grow and shrink an array to counts based on numerical edge cases.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_ArrayRandomizeOrderMutator">ArrayRandomizeOrderMutator</link></term>
<listitem>
<simpara>This mutator will randomize the order of items in an array.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_ArrayReverseOrderMutator">ArrayReverseOrderMutator</link></term>
<listitem>
<simpara>This mutator will reverse the order of items in an array.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_ArrayVarianceMutator">ArrayVarianceMutator</link></term>
<listitem>
<simpara>This mutator will grow and shrink an array to a variance of counts based on the current size.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Used for all data elements</emphasis></simpara>
<variablelist>
<varlistentry>
<term><link linkend="Mutators_DataElementDuplicate">DataElementDuplicate</link></term>
<listitem>
<simpara>This mutator will duplicate data elements.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_DataElementRemove">DataElementRemove</link></term>
<listitem>
<simpara>This mutator will remove data elements.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_DataElementSwapNear">DataElementSwapNear</link></term>
<listitem>
<simpara>This mutator will swap data elements.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_SampleNinjaMutator">SampleNinjaMutator</link></term>
<listitem>
<simpara>This mutator will combine data elements from different data sets.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Enabled when element is part of a size relation</emphasis></simpara>
<variablelist>
<varlistentry>
<term><link linkend="Mutators_SizedDataEdgeCase">SizedDataEdgeCase</link></term>
<listitem>
<simpara>This mutator will cause the data portion of a relation to be sized as numerical edge cases.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_SizedDataVariance">SizedDataVariance</link></term>
<listitem>
<simpara>This mutator will cause the data portion of a relation to be sized as numerical variances.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_SizedEdgeCase">SizedEdgeCase</link></term>
<listitem>
<simpara>This mutator will change both sides of the relation (data and value) to match numerical edge cases.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_SizedVariance">SizedVariance</link></term>
<listitem>
<simpara>This mutator will change both sides of the relation (data and value) to match numerical variances of the current size.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_37">
<title>Examples</title>
<example>
<title>Simple Example</title>
<simpara>Simple example of a JSON array with two elements.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
			 xsi:schemaLocation="http://peachfuzzer.com/2012/Peach /peach/peach.xsd"&gt;
	&lt;DataModel name="SequenceExample"&gt;
        &lt;JsonObject&gt;
            &lt;JsonArray propertyName="items"&gt;
              &lt;JsonString name="name" value="Peach Toy" /&gt;
              &lt;JsonInteger name="stock" value="10" /&gt;
            &lt;/JsonArray&gt;
        &lt;/JsonObject&gt;
	&lt;/DataModel&gt;

	&lt;StateModel name="TheState" initialState="Initial"&gt;
		&lt;State name="Initial"&gt;
			&lt;Action type="output"&gt;
				&lt;DataModel ref="SequenceExample"/&gt;
			&lt;/Action&gt;
		&lt;/State&gt;
	&lt;/StateModel&gt;

	&lt;Agent name="TheAgent" /&gt;

	&lt;Test name="Default"&gt;
		&lt;Agent ref="TheAgent"/&gt;

		&lt;StateModel ref="TheState"/&gt;

		&lt;Publisher class="ConsoleHex"/&gt;
	&lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Output from this example.</simpara>
<screen>&gt;peach -1 --debug example.xml

[*] Web site running at: http://10.0.1.57:8888/

[*] Test 'Default' starting with random seed 23959.
Peach.Pro.Core.Loggers.JobLogger Writing debug.log to: c:\peach\Logs\example.xml_20160223175744\debug.log

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.StateModel Run(): Changing to state "Initial".
Peach.Core.Dom.Action Run(Action): Output
Peach.Pro.Core.Publishers.ConsolePublisher start()
Peach.Pro.Core.Publishers.ConsolePublisher open()
Peach.Pro.Core.Publishers.ConsolePublisher output(26 bytes)
00000000   7B 22 69 74 65 6D 73 22  3A 5B 22 50 65 61 63 68   {"items":["Peach
00000010   20 54 6F 79 22 2C 31 30  5D 7D                      Toy",10]}
Peach.Pro.Core.Publishers.ConsolePublisher close()
Peach.Core.Agent.AgentManager DetectedFault: TheAgent
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Pro.Core.Publishers.ConsolePublisher stop()
Peach.Core.Engine EndTest: Stopping all agents and monitors

[*] Test 'Default' finished.</screen>
</example>
</section>
</section>
<section xml:id="JsonBlob">
<title>JsonBlob</title>
<simpara>A JsonBlob <footnote><simpara>Blob stands for "binary large object" a term used by databases to represent a column of binary data.</simpara></footnote> is used to represent binary JSON data (array of bytes).
JsonBlobs are base64 encoded.</simpara>
<simpara>By definition, the internal contents of a JsonBlob is unknown.
Consequently, Blobs are dumb fuzzed, as the list of applicable mutators below indicates.</simpara>
<section xml:id="_syntax_54">
<title>Syntax</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;JsonObject&gt;
    &lt;JsonBlob propertyName="image" valueType="hex" value="01 06 22 03" /&gt;
&lt;/JsonObject&gt;

&lt;JsonBlob valueType="hex" value="01 06 22 03" /&gt;</programlisting>
</section>
<section xml:id="_attributes_39">
<title>Attributes</title>
<simpara><emphasis>Required:</emphasis></simpara>
<simpara>There are no required attributes.</simpara>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term><link linkend="name">name</link></term>
<listitem>
<simpara>Element name</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>isNull</term>
<listitem>
<simpara>Is this elements value null. JSON output will be <literal>null</literal> instead of value.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>type</term>
<listitem>
<simpara>Type controls the output encoding allowing both traditional json and also binary json (bson). Supported values: <emphasis>json</emphasis> or <emphasis>bson</emphasis>. Defaults to <emphasis>json</emphasis>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="value">value</link></term>
<listitem>
<simpara>Default value.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="valueType">valueType</link></term>
<listitem>
<simpara>Format of value attribute.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="mutable">mutable</link></term>
<listitem>
<simpara>Is the blob changeable (should it be fuzzed). Defaults to true.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="token">token</link></term>
<listitem>
<simpara>This element should be treated as a token when parsing. Defaults to false.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_child_elements_23">
<title>Child Elements</title>
<variablelist>
<varlistentry>
<term><link linkend="Analyzers">Analyzer</link></term>
<listitem>
<simpara>Analyzes current element post cracking, can dynamically change model.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Fixup">Fixup</link></term>
<listitem>
<simpara>Performs dynamic transformations such as checksums and CRCs.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Hint">Hint</link></term>
<listitem>
<simpara>Provides information to mutators.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Placement">Placement</link></term>
<listitem>
<simpara>Relocates an element after it has been cracked.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Transformer">Transformer</link></term>
<listitem>
<simpara>Performs static transformations such as compression or encoding.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_mutators_13">
<title>Mutators</title>
<simpara>The following mutators operate on this element type.</simpara>
<simpara><emphasis>Used for all data elements</emphasis></simpara>
<variablelist>
<varlistentry>
<term><link linkend="Mutators_DataElementDuplicate">DataElementDuplicate</link></term>
<listitem>
<simpara>This mutator duplicates data elements.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_DataElementRemove">DataElementRemove</link></term>
<listitem>
<simpara>This mutator removes data elements.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_DataElementSwapNear">DataElementSwapNear</link></term>
<listitem>
<simpara>This mutator swaps data elements.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_SampleNinjaMutator">SampleNinjaMutator</link></term>
<listitem>
<simpara>This mutator combines data elements from different data sets.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Enabled when element is part of a size relation</emphasis></simpara>
<variablelist>
<varlistentry>
<term><link linkend="Mutators_SizedDataEdgeCase">SizedDataEdgeCase</link></term>
<listitem>
<simpara>This mutator causes the data portion of a relation to be sized as numerical edge cases.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_SizedDataVariance">SizedDataVariance</link></term>
<listitem>
<simpara>This mutator causes the data portion of a relation to be sized as numerical variances.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_SizedEdgeCase">SizedEdgeCase</link></term>
<listitem>
<simpara>This mutator changes both sides of the relation (data and value) to match numerical edge cases.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_SizedVariance">SizedVariance</link></term>
<listitem>
<simpara>This mutator changes both sides of the relation (data and value) to match numerical variances of the current size.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Specific to this element type</emphasis></simpara>
<variablelist>
<varlistentry>
<term><link linkend="Mutators_BlobChangeFromNull">BlobChangeFromNull</link></term>
<listitem>
<simpara>This mutator produces test cases in which null bytes in a <link linkend="Blob">Blob</link> element are changed to a non-null value.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_BlobChangeRandom">BlobChangeRandom</link></term>
<listitem>
<simpara>This mutator produces test cases by changing random selections of bytes to random value.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_BlobChangeSpecial">BlobChangeSpecial</link></term>
<listitem>
<simpara>This mutator produces test cases by changing random selections of bytes to one of 0x00, 0x01, 0xFE, 0xFF.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_BlobChangeToNull">BlobChangeToNull</link></term>
<listitem>
<simpara>This mutator produces test cases by changing a random number of bytes to 0x00.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_BlobExpandSingleIncrementing">BlobExpandSingleIncrementing</link></term>
<listitem>
<simpara>This mutator produces test cases by expanding the size of the blob using incrementing values.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_BlobExpandAllRandom">BlobExpandAllRandom</link></term>
<listitem>
<simpara>This mutator produces test cases by expanding the size of the blob using random values.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_BlobExpandSingleRandom">BlobExpandSingleRandom</link></term>
<listitem>
<simpara>This mutator produces test cases by expanding the size of the blob using a single random byte (repeated as needed).</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_BlobExpandZero">BlobExpandZero</link></term>
<listitem>
<simpara>This mutator produces test cases by expanding the blob using null values.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_BlobReduce">BlobReduce</link></term>
<listitem>
<simpara>This mutator produces test cases by reducing the size of the blob by a random amount.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_ExtraValues">ExtraValues</link></term>
<listitem>
<simpara>This mutator allows providing extra test case values on a per-data element basis.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="JsonBlob_Examples">
<title>Examples</title>
<example>
<title>Defining a JsonBlob with a default value</title>
<simpara>A JsonBlob with a default value. Providing a default value does not set a fixed length unless the token="true" attribute is used.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach ../peach.xsd"&gt;

  &lt;DataModel name="Ex1"&gt;
    &lt;JsonObject&gt;
        &lt;JsonBlob propertyName="rawData" valueType="hex" value="AA BB CC DD" /&gt;
    &lt;/JsonObject&gt;
  &lt;/DataModel&gt;

  &lt;StateModel name="TheState" initialState="initial"&gt;
    &lt;State name="initial"&gt;
      &lt;Action type="output"&gt;
        &lt;DataModel ref="Ex1" /&gt;
      &lt;/Action&gt;
    &lt;/State&gt;
  &lt;/StateModel&gt;

  &lt;Test name="Default"&gt;
    &lt;StateModel ref="TheState"/&gt;

    &lt;Publisher class="ConsoleHex"/&gt;
  &lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Output from this example.</simpara>
<screen>&gt;peach -1 --debug example.xml


[*] Web site running at: http://10.0.1.57:8888/

[*] Test 'Default' starting with random seed 4555.
Peach.Pro.Core.Loggers.JobLogger Writing debug.log to: c:\peach\Logs\example.xml_20160223173145\debug.log

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.StateModel Run(): Changing to state "initial".
Peach.Core.Dom.Action Run(Action): Output
Peach.Pro.Core.Publishers.ConsolePublisher start()
Peach.Pro.Core.Publishers.ConsolePublisher open()
Peach.Pro.Core.Publishers.ConsolePublisher output(22 bytes)
00000000   7B 22 72 61 77 44 61 74  61 22 3A 22 71 72 76 4D   {"rawData":"qrvM
00000010   33 51 3D 3D 22 7D                                  3Q=="}
Peach.Pro.Core.Publishers.ConsolePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Pro.Core.Publishers.ConsolePublisher stop()
Peach.Core.Engine EndTest: Stopping all agents and monitors

[*] Test 'Default' finished.</screen>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="JsonBool">
<title>JsonBool</title>
<simpara>The <emphasis>JsonBool</emphasis> element defines a Boolean value (values 0 or 1) that represents either true or false.</simpara>
<section xml:id="_syntax_55">
<title>Syntax</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;JsonObject&gt;
    &lt;JsonBool propertyName="enabled" value="1"/&gt;
&lt;/JsonObject&gt;</programlisting>
</section>
<section xml:id="_attributes_40">
<title>Attributes</title>
<simpara><emphasis>Required:</emphasis></simpara>
<simpara>No required attributes.</simpara>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term><link linkend="name">name</link></term>
<listitem>
<simpara>Name of the boolean value.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>isNull</term>
<listitem>
<simpara>Set default value of this element to null (defaults to false)</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>type</term>
<listitem>
<simpara>Type controls the output encoding allowing both traditional json and also binary json (bson). Supported values: <emphasis>json</emphasis> or <emphasis>bson</emphasis>. Defaults to <emphasis>json</emphasis>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="value">value</link></term>
<listitem>
<simpara>The default value to assign to the boolean.
Valid options are integer values 0 or 1.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="mutable">mutable</link></term>
<listitem>
<simpara>Is data element changeable (should it be mutated during fuzzing), defaults to true.
Valid options true and false.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_child_elements_24">
<title>Child Elements</title>
<variablelist>
<varlistentry>
<term><link linkend="Hint">Hint</link></term>
<listitem>
<simpara>Provide information to mutators.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Placement">Placement</link></term>
<listitem>
<simpara>Relocate an element after it has been cracked.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_mutators_14">
<title>Mutators</title>
<simpara>The following mutators will operate on this element type:</simpara>
<simpara><emphasis>Used for all data elements</emphasis></simpara>
<variablelist>
<varlistentry>
<term><link linkend="Mutators_DataElementDuplicate">DataElementDuplicate</link></term>
<listitem>
<simpara>This mutator will duplicate data elements.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_DataElementRemove">DataElementRemove</link></term>
<listitem>
<simpara>This mutator will remove data elements.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_DataElementSwapNear">DataElementSwapNear</link></term>
<listitem>
<simpara>This mutator will swap data elements.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_SampleNinjaMutator">SampleNinjaMutator</link></term>
<listitem>
<simpara>This mutator will combine data elements from different data sets.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Enabled when element is part of a size relation</emphasis></simpara>
<variablelist>
<varlistentry>
<term><link linkend="Mutators_SizedDataEdgeCase">SizedDataEdgeCase</link></term>
<listitem>
<simpara>This mutator will cause the data portion of a relation to be sized as numerical edge cases.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_SizedDataVariance">SizedDataVariance</link></term>
<listitem>
<simpara>This mutator will cause the data portion of a relation to be sized as numerical variances.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_SizedEdgeCase">SizedEdgeCase</link></term>
<listitem>
<simpara>This mutator will change both sides of the relation (data and value) to match numerical edge cases.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_SizedVariance">SizedVariance</link></term>
<listitem>
<simpara>This mutator will change both sides of the relation (data and value) to match numerical variances of the current size.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_38">
<title>Examples</title>
<example>
<title>Simple Example</title>
<simpara>Produce Json string with a boolean value of true.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
			 xsi:schemaLocation="http://peachfuzzer.com/2012/Peach /peach/peach.xsd"&gt;
	&lt;DataModel name="BoolExample"&gt;
        &lt;JsonObject&gt;
            &lt;JsonBool propertyName="enabled" value="1"/&gt;
        &lt;/JsonObject&gt;
	&lt;/DataModel&gt;

	&lt;StateModel name="TheState" initialState="Initial"&gt;
		&lt;State name="Initial"&gt;
			&lt;Action type="output"&gt;
				&lt;DataModel ref="BoolExample"/&gt;
			&lt;/Action&gt;
		&lt;/State&gt;
	&lt;/StateModel&gt;

	&lt;Agent name="TheAgent" /&gt;

	&lt;Test name="Default"&gt;
		&lt;Agent ref="TheAgent"/&gt;

		&lt;StateModel ref="TheState"/&gt;

		&lt;Publisher class="ConsoleHex"/&gt;
	&lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Output from this example.</simpara>
<screen>&gt;peach -1 --debug BoolExample1.xml

[*] Web site running at: http://10.0.1.57:8888/

[*] Test 'Default' starting with random seed 65435.
Peach.Pro.Core.Loggers.JobLogger Writing debug.log to: c:\peach\Logs\example.xml_20160223180045\debug.log

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.StateModel Run(): Changing to state "Initial".
Peach.Core.Dom.Action Run(Action): Output
Peach.Pro.Core.Publishers.ConsolePublisher start()
Peach.Pro.Core.Publishers.ConsolePublisher open()
Peach.Pro.Core.Publishers.ConsolePublisher output(16 bytes)
00000000   7B 22 65 6E 61 62 6C 65  64 22 3A 74 72 75 65 7D   {"enabled":true}
Peach.Pro.Core.Publishers.ConsolePublisher close()
Peach.Core.Agent.AgentManager DetectedFault: TheAgent
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Pro.Core.Publishers.ConsolePublisher stop()
Peach.Core.Engine EndTest: Stopping all agents and monitors

[*] Test 'Default' finished.</screen>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="JsonDouble">
<title>JsonDouble</title>
<simpara>The <emphasis>JsonDouble</emphasis> element defines a JSON floating-point number of up to 64-bits.</simpara>
<simpara>The JsonDouble element is a child element of
<link linkend="DataModel">DataModel</link>,
<link linkend="Block">Block</link>,
<link linkend="Sequence">Sequence</link>,
<link linkend="JsonObject">JsonObject</link>,
<link linkend="JsonArray">JsonArray</link>,
or <link linkend="Choice">Choice</link>.</simpara>
<section xml:id="_syntax_56">
<title>Syntax</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;JsonObject&gt;
    &lt;JsonDouble propertyName="Price" value="1.99" /&gt;
&lt;/JsonObject&gt;

&lt;JsonArray&gt;
    &lt;JsonDouble value="1.99" /&gt;
&lt;/JsonArray&gt;</programlisting>
</section>
<section xml:id="_attributes_41">
<title>Attributes</title>
<simpara><emphasis>Required:</emphasis></simpara>
<simpara>None.</simpara>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term><link linkend="name">name</link></term>
<listitem>
<simpara>Name of the floating point number.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>propertyName</term>
<listitem>
<simpara>Property name for element when child of <link linkend="JsonObject">JsonObject</link>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>isNull</term>
<listitem>
<simpara>Is this elements value null. Json output will be <literal>null</literal> instead of value.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>type</term>
<listitem>
<simpara>Type controls the output encoding allowing both traditional json and also binary json (bson). Supported values: <emphasis>json</emphasis> or <emphasis>bson</emphasis>. Defaults to <emphasis>json</emphasis>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="value">value</link></term>
<listitem>
<simpara>The default value to assign to the floating point number.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="valueType">valueType</link></term>
<listitem>
<simpara>The representation of the value.
Valid options are string and hex.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="token">token</link></term>
<listitem>
<simpara>This element is treated as a token when parsing, defaults to false. Valid options true and false.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="mutable">mutable</link></term>
<listitem>
<simpara>Is data element changeable (should it be mutated during fuzzing), defaults to true.
Valid options true and false.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_child_elements_25">
<title>Child Elements</title>
<variablelist>
<varlistentry>
<term><link linkend="Analyzers">Analyzer</link></term>
<listitem>
<simpara>Analyze current element post cracking, can dynamically change model.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Fixup">Fixup</link></term>
<listitem>
<simpara>Dynamic transformations such as checksums and CRCs.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Hint">Hint</link></term>
<listitem>
<simpara>Provide information to mutators.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Placement">Placement</link></term>
<listitem>
<simpara>Relocate an element after it has been cracked.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Relation">Relation</link></term>
<listitem>
<simpara>Modeling of relationships in the data (such as comparisons)</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Transformer">Transformer</link></term>
<listitem>
<simpara>Static transformations such as compression or encoding.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_mutators_15">
<title>Mutators</title>
<simpara>The following mutators will operate on this element type:</simpara>
<simpara><emphasis>Used for all data elements</emphasis></simpara>
<variablelist>
<varlistentry>
<term><link linkend="Mutators_DataElementDuplicate">DataElementDuplicate</link></term>
<listitem>
<simpara>This mutator will duplicate data elements.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_DataElementRemove">DataElementRemove</link></term>
<listitem>
<simpara>This mutator will remove data elements.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_DataElementSwapNear">DataElementSwapNear</link></term>
<listitem>
<simpara>This mutator will swap data elements.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_SampleNinjaMutator">SampleNinjaMutator</link></term>
<listitem>
<simpara>This mutator will combine data elements from different data sets.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Enabled when element is part of a size relation</emphasis></simpara>
<variablelist>
<varlistentry>
<term><link linkend="Mutators_SizedDataEdgeCase">SizedDataEdgeCase</link></term>
<listitem>
<simpara>This mutator will cause the data portion of a relation to be sized as numerical edge cases.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_SizedDataVariance">SizedDataVariance</link></term>
<listitem>
<simpara>This mutator will cause the data portion of a relation to be sized as numerical variances.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_SizedEdgeCase">SizedEdgeCase</link></term>
<listitem>
<simpara>This mutator will change both sides of the relation (data and value) to match numerical edge cases.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_SizedVariance">SizedVariance</link></term>
<listitem>
<simpara>This mutator will change both sides of the relation (data and value) to match numerical variances of the current size.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Specific to this element type</emphasis></simpara>
<variablelist>
<varlistentry>
<term><link linkend="Mutators_DoubleRandom">DoubleRandom</link></term>
<listitem>
<simpara>This mutator will produce random values from the available numerical space.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_DoubleVariance">DoubleVariance</link></term>
<listitem>
<simpara>This mutator will produce values near the current value of a number.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_ExtraValues">ExtraValues</link></term>
<listitem>
<simpara>This mutator provides extra test case values on a per-data element basis.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_NumberEdgeCase">NumberEdgeCase</link></term>
<listitem>
<simpara>This mutator produces numerical edge cases for integer values.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_NumberRandom">NumberRandom</link></term>
<listitem>
<simpara>This mutator produces random values from the available numerical space.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_NumberVariance">NumberVariance</link></term>
<listitem>
<simpara>This mutator produces values near the current value of a number.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_39">
<title>Examples</title>
<example>
<title>Simple Double</title>
<simpara>This example outputs a double that is part of a <link linkend="JsonObject">JsonObject</link>.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

	&lt;DataModel name="TheDataModel"&gt;
        &lt;JsonObject&gt;
		  &lt;JsonDouble propertyName="price" value="1.99" /&gt;
        &lt;/JsonObject&gt;
	&lt;/DataModel&gt;

	&lt;StateModel name="TheStateModel" initialState="InitialState" &gt;
		&lt;State name="InitialState"&gt;
			&lt;Action type="output"&gt;
				&lt;DataModel ref="TheDataModel"/&gt;
			&lt;/Action&gt;
		&lt;/State&gt;
	&lt;/StateModel&gt;

	&lt;Test name="Default"&gt;
		&lt;StateModel ref="TheStateModel"/&gt;

		&lt;Publisher class="ConsoleHex" /&gt;
	&lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Produces the following output:</simpara>
<screen>&gt; peach -1 --debug example.xml

[*] Web site running at: http://10.0.1.57:8888/

[*] Test 'Default' starting with random seed 48084.
Peach.Pro.Core.Loggers.JobLogger Writing debug.log to: c:\peach\Logs\example.xml_20160215194649\debug.log

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.StateModel Run(): Changing to state "InitialState".
Peach.Core.Dom.Action Run(Action): Output
Peach.Pro.Core.Publishers.ConsolePublisher start()
Peach.Pro.Core.Publishers.ConsolePublisher open()
Peach.Pro.Core.Publishers.ConsolePublisher output(14 bytes)
00000000   7B 22 70 72 69 63 65 22  3A 31 2E 39 39 7D         {"price":1.99}
Peach.Pro.Core.Publishers.ConsolePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Pro.Core.Publishers.ConsolePublisher stop()
Peach.Core.Engine EndTest: Stopping all agents and monitors

[*] Test 'Default' finished.</screen>
</example>
<example>
<title>Null String</title>
<simpara>In this example our initial value for our JsonString element is null. During testing this field&#8217;s value
will be mutated to string values.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

	&lt;DataModel name="TheDataModel"&gt;
        &lt;JsonObject&gt;
		  &lt;JsonString propertyName="phrase" isNull="true" /&gt;
        &lt;/JsonObject&gt;
	&lt;/DataModel&gt;

	&lt;StateModel name="TheStateModel" initialState="InitialState" &gt;
		&lt;State name="InitialState"&gt;
			&lt;Action type="output"&gt;
				&lt;DataModel ref="TheDataModel"/&gt;
			&lt;/Action&gt;
		&lt;/State&gt;
	&lt;/StateModel&gt;

	&lt;Test name="Default"&gt;
		&lt;StateModel ref="TheStateModel"/&gt;

		&lt;Publisher class="ConsoleHex" /&gt;
	&lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Produces the following output:</simpara>
<screen>&gt; peach -1 --debug example.xml

[*] Web site running at: http://10.0.1.57:8888/

[*] Test 'Default' starting with random seed 29586.
Peach.Pro.Core.Loggers.JobLogger Writing debug.log to: c:\peach\Logs\example.xml_20160215192237\debug.log

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.StateModel Run(): Changing to state "InitialState".
Peach.Core.Dom.Action Run(Action): Output
Peach.Pro.Core.Publishers.ConsolePublisher start()
Peach.Pro.Core.Publishers.ConsolePublisher open()
Peach.Pro.Core.Publishers.ConsolePublisher output(15 bytes)
00000000   7B 22 70 68 72 61 73 65  22 3A 6E 75 6C 6C 7D      {"phrase":null}
Peach.Pro.Core.Publishers.ConsolePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Pro.Core.Publishers.ConsolePublisher stop()
Peach.Core.Engine EndTest: Stopping all agents and monitors

[*] Test 'Default' finished.</screen>
</example>
<example>
<title>String in JsonArray</title>
<simpara>This example outputs a string that is part of a <link linkend="JsonArray">JsonArray</link>.  Note that we do not
specify <literal>propertyName</literal> in this case.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

	&lt;DataModel name="TheDataModel"&gt;
        &lt;JsonArray&gt;
		  &lt;JsonString value="Hello World!" /&gt;
        &lt;/JsonArray&gt;
	&lt;/DataModel&gt;

	&lt;StateModel name="TheStateModel" initialState="InitialState" &gt;
		&lt;State name="InitialState"&gt;
			&lt;Action type="output"&gt;
				&lt;DataModel ref="TheDataModel"/&gt;
			&lt;/Action&gt;
		&lt;/State&gt;
	&lt;/StateModel&gt;

	&lt;Test name="Default"&gt;
		&lt;StateModel ref="TheStateModel"/&gt;

		&lt;Publisher class="ConsoleHex" /&gt;
	&lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Produces the following output:</simpara>
<screen>&gt; peach -1 --debug example.xml

[*] Web site running at: http://10.0.1.57:8888/

[*] Test 'Default' starting with random seed 4074.
Peach.Pro.Core.Loggers.JobLogger Writing debug.log to: c:\peach\Logs\example.xml_20160215192532\debug.log

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.StateModel Run(): Changing to state "InitialState".
Peach.Core.Dom.Action Run(Action): Output
Peach.Pro.Core.Publishers.ConsolePublisher start()
Peach.Pro.Core.Publishers.ConsolePublisher open()
Peach.Pro.Core.Publishers.ConsolePublisher output(16 bytes)
00000000   5B 22 48 65 6C 6C 6F 20  57 6F 72 6C 64 21 22 5D   ["Hello World!"]
Peach.Pro.Core.Publishers.ConsolePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Pro.Core.Publishers.ConsolePublisher stop()
Peach.Core.Engine EndTest: Stopping all agents and monitors

[*] Test 'Default' finished.</screen>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="JsonInteger">
<title>JsonInteger</title>
<simpara>The JsonInteger element defines a binary number of any arbitrary bit size from 1 to 64.
Binary numbers are packed into a byte representation with a byte order of little-endian or big-endian.</simpara>
<simpara>The Number element should not be used for character-based numbers, or ASCII numbers.
Instead, use a <link linkend="String">String</link> element.</simpara>
<simpara>The Number element is a child element of
<link linkend="DataModel">DataModel</link>,
<link linkend="Block">Block</link>,
or <link linkend="Choice">Choice</link>.</simpara>
<note>
<simpara>While Peach supports unaligned data structures, using unaligned data incurs a performance penalty. The penalty stems from bit slicing that occurs behind the scenes.</simpara>
</note>
<tip>
<simpara>In Peach, two attributes are commonly used to indicate size or length of an element,
<emphasis>size</emphasis> and <emphasis>length</emphasis>.
The <emphasis>size</emphasis> attribute always refers to the number of bits in an element.
In contrast, the <emphasis>length</emphasis> attribute refers to the number of bytes of an element.</simpara>
</tip>
<section xml:id="_syntax_57">
<title>Syntax</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;JsonObject&gt;
    &lt;JsonInteger propertyName="Almonds" value="100" /&gt;
&lt;/JsonObject&gt;

&lt;JsonInteger value="100" /&gt;</programlisting>
</section>
<section xml:id="_attributes_42">
<title>Attributes</title>
<simpara><emphasis>Required:</emphasis></simpara>
<simpara>None.</simpara>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term><link linkend="name">name</link></term>
<listitem>
<simpara>Name of the number.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>isNull</term>
<listitem>
<simpara>Is this elements value null. JSON output will be <literal>null</literal> instead of value.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>type</term>
<listitem>
<simpara>Type controls the output encoding allowing both traditional json and also binary json (bson). Supported values: <emphasis>json</emphasis> or <emphasis>bson</emphasis>. Defaults to <emphasis>json</emphasis>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="value">value</link></term>
<listitem>
<simpara>The default value to assign to the number.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="valueType">valueType</link></term>
<listitem>
<simpara>The representation of the value. Valid options are string and hex.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="token">token</link></term>
<listitem>
<simpara>This element is treated as a token when parsing. Valid values are true and false, defaults to false.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="mutable">mutable</link></term>
<listitem>
<simpara>Is data element changeable (should it be mutated during fuzzing). Valid values are true and false, defaults to true.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_child_elements_26">
<title>Child Elements</title>
<variablelist>
<varlistentry>
<term><link linkend="Analyzers">Analyzer</link></term>
<listitem>
<simpara>Analyzes current element post cracking, can dynamically change model.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Fixup">Fixup</link></term>
<listitem>
<simpara>Performs dynamic transformations such as checksums and CRCs.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Hint">Hint</link></term>
<listitem>
<simpara>Provides information to mutators.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Placement">Placement</link></term>
<listitem>
<simpara>Relocates an element after it has been cracked.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Relation">Relation</link></term>
<listitem>
<simpara>Identifies a type of relationship with another data element (such as count).</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Transformer">Transformer</link></term>
<listitem>
<simpara>Performs static transformations such as compression or encoding.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_mutators_16">
<title>Mutators</title>
<simpara>The following mutators operate on this element type:</simpara>
<simpara><emphasis>Used for all data elements</emphasis></simpara>
<variablelist>
<varlistentry>
<term><link linkend="Mutators_DataElementDuplicate">DataElementDuplicate</link></term>
<listitem>
<simpara>This mutator duplicates data elements.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_DataElementRemove">DataElementRemove</link></term>
<listitem>
<simpara>This mutator removes data elements.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_DataElementSwapNear">DataElementSwapNear</link></term>
<listitem>
<simpara>This mutator swaps data elements.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_SampleNinjaMutator">SampleNinjaMutator</link></term>
<listitem>
<simpara>This mutator combines data elements from different data sets.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Enabled when element is part of a size relation</emphasis></simpara>
<variablelist>
<varlistentry>
<term><link linkend="Mutators_SizedDataEdgeCase">SizedDataEdgeCase</link></term>
<listitem>
<simpara>This mutator causes the data portion of a relation to be sized as numerical edge cases.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_SizedDataVariance">SizedDataVariance</link></term>
<listitem>
<simpara>This mutator causes the data portion of a relation to be sized as numerical variances.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_SizedEdgeCase">SizedEdgeCase</link></term>
<listitem>
<simpara>This mutator changes both sides of the relation (data and value) to match numerical edge cases.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_SizedVariance">SizedVariance</link></term>
<listitem>
<simpara>This mutator changes both sides of the relation (data and value) to match numerical variances of the current size.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Specific to this element type</emphasis></simpara>
<variablelist>
<varlistentry>
<term><link linkend="Mutators_ExtraValues">ExtraValues</link></term>
<listitem>
<simpara>This mutator provides extra test case values on a per-data element basis.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_NumberEdgeCase">NumberEdgeCase</link></term>
<listitem>
<simpara>This mutator produces numerical edge cases for integer values.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_NumberRandom">NumberRandom</link></term>
<listitem>
<simpara>This mutator produces random values from the available numerical space.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_NumberVariance">NumberVariance</link></term>
<listitem>
<simpara>This mutator produces values near the current value of a number.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_40">
<title>Examples</title>
<example>
<title>Use in a JsonObject</title>
<simpara>Produce a 32-bit (4-byte) number with a default value of 5.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
			 xsi:schemaLocation="http://peachfuzzer.com/2012/Peach /peach/peach.xsd"&gt;

	&lt;DataModel name="NumberExample1"&gt;
        &lt;JsonObject&gt;
            &lt;JsonInteger propertyName="Almonds" value="100" /&gt;
        &lt;/JsonObject&gt;
	&lt;/DataModel&gt;

	&lt;StateModel name="TheState" initialState="Initial"&gt;
		&lt;State name="Initial"&gt;
			&lt;Action type="output"&gt;
				&lt;DataModel ref="NumberExample1"/&gt;
			&lt;/Action&gt;
		&lt;/State&gt;
	&lt;/StateModel&gt;

	&lt;Test name="Default"&gt;
		&lt;StateModel ref="TheState"/&gt;

		&lt;Publisher class="ConsoleHex"/&gt;
	&lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Output from this example.</simpara>
<screen>&gt;peach -1 --debug NumberExample1.xml


[*] Web site running at: http://10.0.1.57:8888/

[*] Test 'Default' starting with random seed 50669.
Peach.Pro.Core.Loggers.JobLogger Writing debug.log to: c:\peach\Logs\example.xml_20160223173806\debug.log

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.StateModel Run(): Changing to state "Initial".
Peach.Core.Dom.Action Run(Action): Output
Peach.Pro.Core.Publishers.ConsolePublisher start()
Peach.Pro.Core.Publishers.ConsolePublisher open()
Peach.Pro.Core.Publishers.ConsolePublisher output(15 bytes)
00000000   7B 22 41 6C 6D 6F 6E 64  73 22 3A 31 30 30 7D      {"Almonds":100}
Peach.Pro.Core.Publishers.ConsolePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Pro.Core.Publishers.ConsolePublisher stop()
Peach.Core.Engine EndTest: Stopping all agents and monitors

[*] Test 'Default' finished.</screen>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="JsonObject">
<title>JsonObject</title>
<simpara>The <emphasis>JsonObject</emphasis> element is used to model <link xl:href="http://www.json.org/">JavaScript Object Notation (JSON)</link> objects.</simpara>
<simpara><emphasis>JsonObject</emphasis> elements are containers that group JSON elements in a logical structure.
For example,
a <emphasis>JsonString</emphasis> element,
a <emphasis>JsonInteger</emphasis> element,
and a <emphasis>JsonBlob</emphasis> element can exist in the same <emphasis>JsonObject</emphasis>.
A <emphasis>JsonObject</emphasis> can contain other <emphasis>JsonObjects</emphasis>, or nest, as deeply as needed.</simpara>
<section xml:id="_syntax_58">
<title>Syntax</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;JsonObject name="ServiceRequest"&gt;

  &lt;JsonString propertyName="id" value="3fcbbc99-bb05-432d-8ce5-9df4fab91ae6" /&gt;

  &lt;JsonArray propertyName="items"&gt;

    &lt;JsonObject&gt;
        &lt;JsonString propertyName="id" value="5813200e-96db-4dd0-bc2a-fec6d19a7242" /&gt;
        &lt;JsonDouble propertyName="price" value="1.99" /&gt;
        &lt;JsonInteger propertyName="amount" value="10" /&gt;
    &lt;/JsonObject&gt;

    &lt;JsonObject&gt;
        &lt;JsonString propertyName="id" value="a921833c-5e3f-4199-a143-3ae60b6815ef" /&gt;
        &lt;JsonDouble propertyName="price" value="2.99" /&gt;
        &lt;JsonInteger propertyName="amount" value="1" /&gt;
    &lt;/JsonObject&gt;

  &lt;/JsonArray&gt;

&lt;/JsonObject&gt;</programlisting>
</section>
<section xml:id="_attributes_43">
<title>Attributes</title>
<simpara><emphasis>Required:</emphasis></simpara>
<simpara>None.</simpara>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term><link linkend="name">name</link></term>
<listitem>
<simpara>Name of the block.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>isNull</term>
<listitem>
<simpara>Is this elements value null. Json output will be <literal>null</literal> instead of value.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>type</term>
<listitem>
<simpara>Type controls the output encoding allowing both traditional json and also binary json (bson). Supported values: <emphasis>json</emphasis> or <emphasis>bson</emphasis>. Defaults to <emphasis>json</emphasis>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="ref">ref</link></term>
<listitem>
<simpara>Reference to a <xref linkend="DataModel"/> to use as a template.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="mutable">mutable</link></term>
<listitem>
<simpara>Is data element changeable (should it be mutated), defaults to false.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_child_elements_27">
<title>Child Elements</title>
<variablelist>
<varlistentry>
<term><link linkend="Analyzers">Analyzer</link></term>
<listitem>
<simpara>Analyzes current element post cracking, can dynamically change model.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Choice">Choice</link></term>
<listitem>
<simpara>Indicates that all of the sub-elements are valid; but, only one sub-element should be selected.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Fixup">Fixup</link></term>
<listitem>
<simpara>Are dynamic transformations such as checksums and CRCs.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Hint">Hint</link></term>
<listitem>
<simpara>Provides information to mutators.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="JsonArray">JsonArray</link></term>
<listitem>
<simpara>Json array</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="JsonBool">JsonBool</link></term>
<listitem>
<simpara>Json boolean</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="JsonBlob">JsonBlob</link></term>
<listitem>
<simpara>Json blob</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="JsonDouble">JsonDouble</link></term>
<listitem>
<simpara>Json double/float</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="JsonInteger">JsonInteger</link></term>
<listitem>
<simpara>Json integer</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="JsonObject">JsonObject</link></term>
<listitem>
<simpara>Json object</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="JsonString">JsonString</link></term>
<listitem>
<simpara>Json string</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Placement">Placement</link></term>
<listitem>
<simpara>Relocates an element after it has been cracked.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Transformer">Transformer</link></term>
<listitem>
<simpara>Performs static transformations such as compression or encoding.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_mutators_17">
<title>Mutators</title>
<simpara>The following mutators operate on this element type:</simpara>
<simpara><emphasis>Used for all data elements</emphasis></simpara>
<variablelist>
<varlistentry>
<term><link linkend="Mutators_DataElementDuplicate">DataElementDuplicate</link></term>
<listitem>
<simpara>This mutator duplicates data elements.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_DataElementRemove">DataElementRemove</link></term>
<listitem>
<simpara>This mutator removes data elements.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_DataElementSwapNear">DataElementSwapNear</link></term>
<listitem>
<simpara>This mutator swaps data elements.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_SampleNinjaMutator">SampleNinjaMutator</link></term>
<listitem>
<simpara>This mutator combines data elements from different data sets.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Enabled when element is part of a size relation</emphasis></simpara>
<variablelist>
<varlistentry>
<term><link linkend="Mutators_SizedDataEdgeCase">SizedDataEdgeCase</link></term>
<listitem>
<simpara>This mutator causes the data portion of a relation to be sized as numerical edge cases.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_SizedDataVariance">SizedDataVariance</link></term>
<listitem>
<simpara>This mutator causes the data portion of a relation to be sized as numerical variances.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_SizedEdgeCase">SizedEdgeCase</link></term>
<listitem>
<simpara>This mutator changes both sides of the relation (data and value) to match numerical edge cases.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_SizedVariance">SizedVariance</link></term>
<listitem>
<simpara>This mutator changes both sides of the relation (data and value) to match numerical variances of the current size.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_41">
<title>Examples</title>
<example>
<title>Example JsonObject</title>
<simpara>Example of generating a json object with an array.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach ../peach.xsd"&gt;

  &lt;DataModel name="BlockExample1"&gt;
    &lt;JsonObject name="ServiceRequest"&gt;

      &lt;JsonString propertyName="id" value="3fcbbc99-bb05-432d-8ce5-9df4fab91ae6" /&gt;

      &lt;JsonArray propertyName="items"&gt;

        &lt;JsonObject&gt;
            &lt;JsonString propertyName="id" value="5813200e-96db-4dd0-bc2a-fec6d19a7242" /&gt;
            &lt;JsonDouble propertyName="price" value="1.99" /&gt;
            &lt;JsonInteger propertyName="amount" value="10" /&gt;
        &lt;/JsonObject&gt;

        &lt;JsonObject&gt;
            &lt;JsonString propertyName="id" value="a921833c-5e3f-4199-a143-3ae60b6815ef" /&gt;
            &lt;JsonDouble propertyName="price" value="2.99" /&gt;
            &lt;JsonInteger propertyName="amount" value="1" /&gt;
        &lt;/JsonObject&gt;

      &lt;/JsonArray&gt;

    &lt;/JsonObject&gt;
  &lt;/DataModel&gt;

  &lt;StateModel name="TheState" initialState="initial"&gt;
    &lt;State name="initial"&gt;
      &lt;Action type="output" publisher="ConsolePub"&gt;
        &lt;DataModel ref="BlockExample1" /&gt;
      &lt;/Action&gt;
    &lt;/State&gt;
  &lt;/StateModel&gt;

  &lt;Test name="Default"&gt;
    &lt;StateModel ref="TheState"/&gt;

    &lt;Publisher class="ConsoleHex" name="ConsolePub"/&gt;
  &lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Output from this example.</simpara>
<screen>&gt;peach -1 --debug example.xml

[*] Web site running at: http://10.0.1.57:8888/

[*] Test 'Default' starting with random seed 29941.
Peach.Pro.Core.Loggers.JobLogger Writing debug.log to: c:\peach\Logs\example.xml_20160223174712\debug.log

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.StateModel Run(): Changing to state "initial".
Peach.Core.Dom.Action Run(Action): Output
Peach.Pro.Core.Publishers.ConsolePublisher start()
Peach.Pro.Core.Publishers.ConsolePublisher open()
Peach.Pro.Core.Publishers.ConsolePublisher output(196 bytes)
00000000   7B 22 69 64 22 3A 22 33  66 63 62 62 63 39 39 2D   {"id":"3fcbbc99-
00000010   62 62 30 35 2D 34 33 32  64 2D 38 63 65 35 2D 39   bb05-432d-8ce5-9
00000020   64 66 34 66 61 62 39 31  61 65 36 22 2C 22 69 74   df4fab91ae6","it
00000030   65 6D 73 22 3A 5B 7B 22  69 64 22 3A 22 35 38 31   ems":[{"id":"581
00000040   33 32 30 30 65 2D 39 36  64 62 2D 34 64 64 30 2D   3200e-96db-4dd0-
00000050   62 63 32 61 2D 66 65 63  36 64 31 39 61 37 32 34   bc2a-fec6d19a724
00000060   32 22 2C 22 70 72 69 63  65 22 3A 31 2E 39 39 2C   2","price":1.99,
00000070   22 61 6D 6F 75 6E 74 22  3A 31 30 7D 2C 7B 22 69   "amount":10},{"i
00000080   64 22 3A 22 61 39 32 31  38 33 33 63 2D 35 65 33   d":"a921833c-5e3
00000090   66 2D 34 31 39 39 2D 61  31 34 33 2D 33 61 65 36   f-4199-a143-3ae6
000000A0   30 62 36 38 31 35 65 66  22 2C 22 70 72 69 63 65   0b6815ef","price
000000B0   22 3A 32 2E 39 39 2C 22  61 6D 6F 75 6E 74 22 3A   ":2.99,"amount":
000000C0   31 7D 5D 7D                                        1}]}
Peach.Pro.Core.Publishers.ConsolePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Pro.Core.Publishers.ConsolePublisher stop()
Peach.Core.Engine EndTest: Stopping all agents and monitors

[*] Test 'Default' finished.</screen>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="JsonRaw">
<title>JsonRaw</title>
<simpara>The <emphasis>JsonRaw</emphasis> element is used to embeded raw string or binary data into a JSON document.
This allows creation of json that does not adhere to the JSON specification.</simpara>
<simpara>This is a container element that is able to host other data elements.</simpara>
<section xml:id="_syntax_59">
<title>Syntax</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;JsonObject name="ServiceRequest"&gt;

  &lt;JsonString propertyName="id" value="3fcbbc99-bb05-432d-8ce5-9df4fab91ae6" /&gt;

  &lt;JsonRaw propertyName="binary"&gt;
	&lt;Blob value="01 02 03 04 05" valueType="hex"/&gt;
  &lt;/JsonRaw&gt;

&lt;/JsonObject&gt;</programlisting>
</section>
<section xml:id="_attributes_44">
<title>Attributes</title>
<simpara><emphasis>Required:</emphasis></simpara>
<simpara>None.</simpara>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term><link linkend="name">name</link></term>
<listitem>
<simpara>Name of the block.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>isNull</term>
<listitem>
<simpara>Is this elements value null. Json output will be <literal>null</literal> instead of value.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="ref">ref</link></term>
<listitem>
<simpara>Reference to a <xref linkend="DataModel"/> to use as a template.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="mutable">mutable</link></term>
<listitem>
<simpara>Is data element changeable (should it be mutated), defaults to false.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_child_elements_28">
<title>Child Elements</title>
<simpara><emphasis>all data elements supported by Block are supported by JsonRaw</emphasis></simpara>
<variablelist>
<varlistentry>
<term><link linkend="Analyzers">Analyzer</link></term>
<listitem>
<simpara>Analyzes current element post cracking, can dynamically change model.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Fixup">Fixup</link></term>
<listitem>
<simpara>Are dynamic transformations such as checksums and CRCs.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Hint">Hint</link></term>
<listitem>
<simpara>Provides information to mutators.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Placement">Placement</link></term>
<listitem>
<simpara>Relocates an element after it has been cracked.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_mutators_18">
<title>Mutators</title>
<simpara>The following mutators operate on this element type:</simpara>
<simpara><emphasis>Used for all data elements</emphasis></simpara>
<variablelist>
<varlistentry>
<term><link linkend="Mutators_DataElementDuplicate">DataElementDuplicate</link></term>
<listitem>
<simpara>This mutator duplicates data elements.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_DataElementRemove">DataElementRemove</link></term>
<listitem>
<simpara>This mutator removes data elements.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_DataElementSwapNear">DataElementSwapNear</link></term>
<listitem>
<simpara>This mutator swaps data elements.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_SampleNinjaMutator">SampleNinjaMutator</link></term>
<listitem>
<simpara>This mutator combines data elements from different data sets.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Enabled when element is part of a size relation</emphasis></simpara>
<variablelist>
<varlistentry>
<term><link linkend="Mutators_SizedDataEdgeCase">SizedDataEdgeCase</link></term>
<listitem>
<simpara>This mutator causes the data portion of a relation to be sized as numerical edge cases.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_SizedDataVariance">SizedDataVariance</link></term>
<listitem>
<simpara>This mutator causes the data portion of a relation to be sized as numerical variances.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_SizedEdgeCase">SizedEdgeCase</link></term>
<listitem>
<simpara>This mutator changes both sides of the relation (data and value) to match numerical edge cases.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_SizedVariance">SizedVariance</link></term>
<listitem>
<simpara>This mutator changes both sides of the relation (data and value) to match numerical variances of the current size.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_42">
<title>Examples</title>
<example>
<title>Example JsonRaw</title>
<simpara>Example of using JsonRaw to output non-standard JSON document, including binary values.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach&gt;
  &lt;DataModel name="TheDataModel"&gt;

    &lt;JsonObject&gt;
      &lt;JsonArray propertyName="arrayWithRaw"&gt;
        &lt;JsonRaw&gt;
          &lt;Blob value="rawvalue"/&gt;
        &lt;/JsonRaw&gt;
      &lt;/JsonArray&gt;

      &lt;JsonRaw propertyName="raw"&gt;
        &lt;Blob value="01 02 03 04 05 06 07 08" valueType="hex"/&gt;
      &lt;/JsonRaw&gt;
    &lt;/JsonObject&gt;

    &lt;JsonObject&gt;
      &lt;JsonRaw propertyName="rawNull" isNull="true"&gt;
        &lt;Blob value="rawvalue"/&gt;
      &lt;/JsonRaw&gt;
    &lt;/JsonObject&gt;

  &lt;/DataModel&gt;

  &lt;StateModel name="TheState" initialState="initial"&gt;
    &lt;State name="initial"&gt;
      &lt;Action type="output"&gt;
        &lt;DataModel ref="TheDataModel" /&gt;
      &lt;/Action&gt;
    &lt;/State&gt;
  &lt;/StateModel&gt;

  &lt;Test name="Default"&gt;
    &lt;StateModel ref="TheState"/&gt;
      &lt;Publisher class="ConsoleHex"/&gt;
  &lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Output from this example.</simpara>
<screen>&gt;peach -1 --debug example.xml

[[ Peach Pro v0.0.0.1
[[ Copyright (c) 2017 Peach Fuzzer, LLC

[*] Web site running at: http://10.0.1.113:8888/
2017-08-09 12:45:30.4826 Peach.Pro.Core.MutationStrategies.RandomStrategy Initialized with seed 29202

[*] Test 'Default' starting with random seed 29202.
2017-08-09 12:45:30.5538 Peach.Pro.Core.Loggers.JobLogger Writing debug.log to: c:\peach\Logs\example.xml_20170809124529\debug.log

[R1,-,-] Performing iteration
2017-08-09 12:45:30.6610 Peach.Core.Engine runTest: Performing control recording iteration.
2017-08-09 12:45:30.7042 Peach.Core.Dom.StateModel Run(): Changing to state "initial".
2017-08-09 12:45:30.7112 Peach.Core.Dom.Action Run(Action): Output
2017-08-09 12:45:30.8125 Peach.Pro.Core.Publishers.ConsolePublisher start()
2017-08-09 12:45:30.8125 Peach.Pro.Core.Publishers.ConsolePublisher open()
2017-08-09 12:45:30.8125 Peach.Pro.Core.Publishers.ConsolePublisher output(58 bytes)
00000000   7B 22 61 72 72 61 79 57  69 74 68 52 61 77 22 3A   {"arrayWithRaw":
00000010   5B 72 61 77 76 61 6C 75  65 5D 2C 22 72 61 77 22   [rawvalue],"raw"
00000020   3A 01 02 03 04 05 06 07  08 7D 7B 22 72 61 77 4E   :........}{"rawN
00000030   75 6C 6C 22 3A 6E 75 6C  6C 7D                     ull":null}
2017-08-09 12:45:30.8224 Peach.Pro.Core.Publishers.ConsolePublisher close()
2017-08-09 12:45:30.8224 Peach.Core.Engine runTest: context.config.singleIteration == true
2017-08-09 12:45:30.8224 Peach.Core.Engine All test cases executed, stopping engine.
2017-08-09 12:45:30.8224 Peach.Pro.Core.Publishers.ConsolePublisher stop()
2017-08-09 12:45:30.8224 Peach.Core.Engine EndTest: Stopping all agents and monitors

[*] Test 'Default' finished.</screen>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="JsonString">
<title>JsonString</title>
<simpara>Represents a JSON string of Unicode characters.</simpara>
<simpara>All strings are encoded prior to output according to the JSON specification.</simpara>
<simpara>Strings can hold numbers that are stored in a string format.
When strings contain a number,
Peach additionally uses numerical mutators to mutate the strings.</simpara>
<simpara>The JsonString element is a child element of
<link linkend="DataModel">DataModel</link>,
<link linkend="Block">Block</link>,
<link linkend="Sequence">Sequence</link>,
<link linkend="JsonObject">JsonObject</link>,
<link linkend="JsonArray">JsonArray</link>,
or <link linkend="Choice">Choice</link>.</simpara>
<section xml:id="_syntax_60">
<title>Syntax</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;JsonString value="Hello World!" /&gt;

&lt;JsonObject&gt;
    &lt;JsonString propertyName="name" value="Peach" /&gt;
&lt;/JsonObject&gt;</programlisting>
</section>
<section xml:id="_attributes_45">
<title>Attributes</title>
<simpara><emphasis>Required:</emphasis></simpara>
<simpara>None.</simpara>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term><link linkend="name">name</link></term>
<listitem>
<simpara>Name of the element.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>propertyName</term>
<listitem>
<simpara>Property name for element when child of <link linkend="JsonObject">JsonObject</link>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>isNull</term>
<listitem>
<simpara>Is this elements value null. Json output will be <literal>null</literal> instead of <literal>""</literal> or value.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>type</term>
<listitem>
<simpara>Type controls the output encoding allowing both traditional json and also binary json (bson). Supported values: <emphasis>json</emphasis> or <emphasis>bson</emphasis>. Defaults to <emphasis>json</emphasis>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="value">value</link></term>
<listitem>
<simpara>The default value, defaults to "".</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="valueType">valueType</link></term>
<listitem>
<simpara>Format of the <emphasis>value</emphasis> attribute, defaults to string.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="token">token</link></term>
<listitem>
<simpara>This element should be treated as a token when parsing. Valid values are true and false, defaults to false.	+
This attribute is primarily used to assist in cracking strings when consuming input in a model.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="mutable">mutable</link></term>
<listitem>
<simpara>Should this data element be mutated (or, is it changeable)? Valid values are true and false, defaults to true.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_child_elements_29">
<title>Child Elements</title>
<variablelist>
<varlistentry>
<term><link linkend="Analyzers">Analyzer</link></term>
<listitem>
<simpara>Attaches an analyzer to this element</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Fixup">Fixup</link></term>
<listitem>
<simpara>Performs dynamic transformations such as checksums and CRCs.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Hint">Hint</link></term>
<listitem>
<simpara>Provides information to mutators.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Placement">Placement</link></term>
<listitem>
<simpara>Relocates an element after it has been cracked.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Relation">Relation</link></term>
<listitem>
<simpara>Identifies a type of relationship with another data element (such as count).</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Transformer">Transformer</link></term>
<listitem>
<simpara>Performs static transformations such as compression or encoding.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_mutators_19">
<title>Mutators</title>
<simpara>The following mutators operate on this element type:</simpara>
<simpara><emphasis>Used for all data elements</emphasis></simpara>
<variablelist>
<varlistentry>
<term><link linkend="Mutators_DataElementDuplicate">DataElementDuplicate</link></term>
<listitem>
<simpara>This mutator duplicates data elements.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_DataElementRemove">DataElementRemove</link></term>
<listitem>
<simpara>This mutator removes data elements.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_DataElementSwapNear">DataElementSwapNear</link></term>
<listitem>
<simpara>This mutator swaps data elements.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_SampleNinjaMutator">SampleNinjaMutator</link></term>
<listitem>
<simpara>This mutator combines data elements from different data sets.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Enabled when element is part of a size relation</emphasis></simpara>
<variablelist>
<varlistentry>
<term><link linkend="Mutators_SizedDataEdgeCase">SizedDataEdgeCase</link></term>
<listitem>
<simpara>This mutator causes the data portion of a relation to be sized as numerical edge cases.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_SizedDataVariance">SizedDataVariance</link></term>
<listitem>
<simpara>This mutator causes the data portion of a relation to be sized as numerical variances.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_SizedEdgeCase">SizedEdgeCase</link></term>
<listitem>
<simpara>This mutator changes both sides of the relation (data and value) to match numerical edge cases.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_SizedVariance">SizedVariance</link></term>
<listitem>
<simpara>This mutator changes both sides of the relation (data and value) to match numerical variances of the current size.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Specific to this element type</emphasis></simpara>
<variablelist>
<varlistentry>
<term><link linkend="Mutators_ExtraValues">ExtraValues</link></term>
<listitem>
<simpara>This mutator provides extra test case values on a per-data element basis.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_StringAsciiRandom">StringAsciiRandom</link></term>
<listitem>
<simpara>This mutator generates strings with random ASCII characters.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_StringCaseLower">StringCaseLower</link></term>
<listitem>
<simpara>This mutator generates a lower case version of the current value.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_StringCaseRandom">StringCaseRandom</link></term>
<listitem>
<simpara>This mutator generates a randomized case version of the current value.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_StringCaseUpper">StringCaseUpper</link></term>
<listitem>
<simpara>This mutator generates an upper case version of the current value.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_StringLengthEdgeCase">StringLengthEdgeCase</link></term>
<listitem>
<simpara>This mutator generates strings with lengths based on numerical edge cases.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_StringLengthVariance">StringLengthVariance</link></term>
<listitem>
<simpara>This mutator generates strings with lengths based on a variance around the current string length.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_StringList">StringList</link></term>
<listitem>
<simpara>This mutator allows providing a list of strings to use as test cases on an element by element basis.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_StringStatic">StringStatic</link></term>
<listitem>
<simpara>This mutator generates test cases using a static set of strings.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_StringUnicodeAbstractCharacters">StringUnicodeAbstractCharacters</link></term>
<listitem>
<simpara>This mutator generates Unicode strings using abstract characters.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_StringUnicodeFormatCharacters">StringUnicodeFormatCharacters</link></term>
<listitem>
<simpara>This mutator generates Unicode strings using format characters.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_StringUnicodeInvalid">StringUnicodeInvalid</link></term>
<listitem>
<simpara>This mutator generates Unicode strings using invalid characters.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_StringUnicodeNonCharacters">StringUnicodeNonCharacters</link></term>
<listitem>
<simpara>This mutator generates Unicode strings using non-characters.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_StringUnicodePlane0">StringUnicodePlane0</link></term>
<listitem>
<simpara>This mutator generates Unicode strings using Plane 0 characters.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_StringUnicodePlane1">StringUnicodePlane1</link></term>
<listitem>
<simpara>This mutator generates Unicode strings using Plane 1 characters.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_StringUnicodePlane14">StringUnicodePlane14</link></term>
<listitem>
<simpara>This mutator generates Unicode strings using Plan 14 characters.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_StringUnicodePlane15And16">StringUnicodePlane15And16</link></term>
<listitem>
<simpara>This mutator generates Unicode strings using Plane 15 and 16 characters.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_StringUnicodePlane2">StringUnicodePlane2</link></term>
<listitem>
<simpara>This mutator generates Unicode strings using Plane 2 characters.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_StringUnicodePrivateUseArea">StringUnicodePrivateUseArea</link></term>
<listitem>
<simpara>This mutator generates Unicode characters from the private use area.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_StringXmlW3C">StringXmlW3C</link></term>
<listitem>
<simpara>This mutator provides the W3C XML parser unit tests. Must be specifically enabled.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_43">
<title>Examples</title>
<example>
<title>Simple String</title>
<simpara>This example outputs a string that is part of a <link linkend="JsonObject">JsonObject</link>.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

	&lt;DataModel name="TheDataModel"&gt;
        &lt;JsonObject&gt;
		  &lt;JsonString propertyName="phrase" value="Hello World!" /&gt;
        &lt;/JsonObject&gt;
	&lt;/DataModel&gt;

	&lt;StateModel name="TheStateModel" initialState="InitialState" &gt;
		&lt;State name="InitialState"&gt;
			&lt;Action type="output"&gt;
				&lt;DataModel ref="TheDataModel"/&gt;
			&lt;/Action&gt;
		&lt;/State&gt;
	&lt;/StateModel&gt;

	&lt;Test name="Default"&gt;
		&lt;StateModel ref="TheStateModel"/&gt;

		&lt;Publisher class="ConsoleHex" /&gt;
	&lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Produces the following output:</simpara>
<screen>&gt; peach -1 --debug example.xml

[*] Web site running at: http://10.0.1.57:8888/

[*] Test 'Default' starting with random seed 51346.
Peach.Pro.Core.Loggers.JobLogger Writing debug.log to: c:\peach\Logs\example.xml_20160215191651\debug.log

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.StateModel Run(): Changing to state "InitialState".
Peach.Core.Dom.Action Run(Action): Output
Peach.Pro.Core.Publishers.ConsolePublisher start()
Peach.Pro.Core.Publishers.ConsolePublisher open()
Peach.Pro.Core.Publishers.ConsolePublisher output(25 bytes)
00000000   7B 22 70 68 72 61 73 65  22 3A 22 48 65 6C 6C 6F   {"phrase":"Hello
00000010   20 57 6F 72 6C 64 21 22  7D                         World!"}
Peach.Pro.Core.Publishers.ConsolePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Pro.Core.Publishers.ConsolePublisher stop()
Peach.Core.Engine EndTest: Stopping all agents and monitors

[*] Test 'Default' finished.</screen>
</example>
<example>
<title>Null String</title>
<simpara>In this example our initial value for our JsonString element is null. During testing this field&#8217;s value
will be mutated to string values.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

	&lt;DataModel name="TheDataModel"&gt;
        &lt;JsonObject&gt;
		  &lt;JsonString propertyName="phrase" isNull="true" /&gt;
        &lt;/JsonObject&gt;
	&lt;/DataModel&gt;

	&lt;StateModel name="TheStateModel" initialState="InitialState" &gt;
		&lt;State name="InitialState"&gt;
			&lt;Action type="output"&gt;
				&lt;DataModel ref="TheDataModel"/&gt;
			&lt;/Action&gt;
		&lt;/State&gt;
	&lt;/StateModel&gt;

	&lt;Test name="Default"&gt;
		&lt;StateModel ref="TheStateModel"/&gt;

		&lt;Publisher class="ConsoleHex" /&gt;
	&lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Produces the following output:</simpara>
<screen>&gt; peach -1 --debug example.xml

[*] Web site running at: http://10.0.1.57:8888/

[*] Test 'Default' starting with random seed 29586.
Peach.Pro.Core.Loggers.JobLogger Writing debug.log to: c:\peach\Logs\example.xml_20160215192237\debug.log

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.StateModel Run(): Changing to state "InitialState".
Peach.Core.Dom.Action Run(Action): Output
Peach.Pro.Core.Publishers.ConsolePublisher start()
Peach.Pro.Core.Publishers.ConsolePublisher open()
Peach.Pro.Core.Publishers.ConsolePublisher output(15 bytes)
00000000   7B 22 70 68 72 61 73 65  22 3A 6E 75 6C 6C 7D      {"phrase":null}
Peach.Pro.Core.Publishers.ConsolePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Pro.Core.Publishers.ConsolePublisher stop()
Peach.Core.Engine EndTest: Stopping all agents and monitors

[*] Test 'Default' finished.</screen>
</example>
<example>
<title>String in JsonArray</title>
<simpara>This example outputs a string that is part of a <link linkend="JsonArray">JsonArray</link>.  Note that we do not
specify <literal>propertyName</literal> in this case.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

	&lt;DataModel name="TheDataModel"&gt;
        &lt;JsonArray&gt;
		  &lt;JsonString value="Hello World!" /&gt;
        &lt;/JsonArray&gt;
	&lt;/DataModel&gt;

	&lt;StateModel name="TheStateModel" initialState="InitialState" &gt;
		&lt;State name="InitialState"&gt;
			&lt;Action type="output"&gt;
				&lt;DataModel ref="TheDataModel"/&gt;
			&lt;/Action&gt;
		&lt;/State&gt;
	&lt;/StateModel&gt;

	&lt;Test name="Default"&gt;
		&lt;StateModel ref="TheStateModel"/&gt;

		&lt;Publisher class="ConsoleHex" /&gt;
	&lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Produces the following output:</simpara>
<screen>&gt; peach -1 --debug example.xml

[*] Web site running at: http://10.0.1.57:8888/

[*] Test 'Default' starting with random seed 4074.
Peach.Pro.Core.Loggers.JobLogger Writing debug.log to: c:\peach\example.xml_20160215192532\debug.log

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.StateModel Run(): Changing to state "InitialState".
Peach.Core.Dom.Action Run(Action): Output
Peach.Pro.Core.Publishers.ConsolePublisher start()
Peach.Pro.Core.Publishers.ConsolePublisher open()
Peach.Pro.Core.Publishers.ConsolePublisher output(16 bytes)
00000000   5B 22 48 65 6C 6C 6F 20  57 6F 72 6C 64 21 22 5D   ["Hello World!"]
Peach.Pro.Core.Publishers.ConsolePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Pro.Core.Publishers.ConsolePublisher stop()
Peach.Core.Engine EndTest: Stopping all agents and monitors

[*] Test 'Default' finished.</screen>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Null">
<title>Null</title>
<simpara>The <emphasis>Null</emphasis> element defines an element which has no value.</simpara>
<simpara>The Null element is a child element of <link linkend="DataModel">DataModel</link>, <link linkend="Block">Block</link>, <link linkend="Sequence">Sequence</link> or <link linkend="Choice">Choice</link>.</simpara>
<section xml:id="_syntax_61">
<title>Syntax</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;Null name="null"/&gt;</programlisting>
</section>
<section xml:id="_attributes_46">
<title>Attributes</title>
<simpara><emphasis>Required:</emphasis></simpara>
<simpara>No required attributes.</simpara>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term><link linkend="name">name</link></term>
<listitem>
<simpara>Name of the Null value.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="constraint">constraint</link></term>
<listitem>
<simpara>A constraint in the form of a python expression.
Used during data cracking.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="mutable">mutable</link></term>
<listitem>
<simpara>Is data element changeable (should it be mutated during fuzzing), defaults to true.
Valid options true and false.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="minOccurs">minOccurs</link></term>
<listitem>
<simpara>The minimum number of times this number must occur.
Defaults to 1.
Valid options are a positive integer value.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="maxOccurs">maxOccurs</link></term>
<listitem>
<simpara>The maximum number of times this number can occur.
Defaults to 1.
Valid options are a positive integer value.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="occurs">occurs</link></term>
<listitem>
<simpara>The actual number of times this number occurs.
Defaults to 1.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_child_elements_30">
<title>Child Elements</title>
<variablelist>
<varlistentry>
<term><link linkend="Placement">Placement</link></term>
<listitem>
<simpara>Relocate an element after it has been cracked.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_mutators_20">
<title>Mutators</title>
<simpara>The following mutators will operate on this element type:</simpara>
<simpara><emphasis>Enabled when element is marked as an array</emphasis></simpara>
<variablelist>
<varlistentry>
<term><link linkend="Mutators_ArrayNumericalEdgeCasesMutator">ArrayNumericalEdgeCasesMutator</link></term>
<listitem>
<simpara>This mutator will grow and shrink an array to counts based on numerical edge cases.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_ArrayRandomizeOrderMutator">ArrayRandomizeOrderMutator</link></term>
<listitem>
<simpara>This mutator will randomize the order of items in an array.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_ArrayReverseOrderMutator">ArrayReverseOrderMutator</link></term>
<listitem>
<simpara>This mutator will reverse the order of items in an array.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_ArrayVarianceMutator">ArrayVarianceMutator</link></term>
<listitem>
<simpara>This mutator will grow and shrink an array to a variance of counts based on the current size.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Used for all data elements</emphasis></simpara>
<variablelist>
<varlistentry>
<term><link linkend="Mutators_DataElementBitFlipper">DataElementBitFlipper</link></term>
<listitem>
<simpara>This mutator will produce test cases by flipping bits in the output value.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_DataElementDuplicate">DataElementDuplicate</link></term>
<listitem>
<simpara>This mutator will duplicate data elements.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_DataElementRemove">DataElementRemove</link></term>
<listitem>
<simpara>This mutator will remove data elements.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_DataElementSwapNear">DataElementSwapNear</link></term>
<listitem>
<simpara>This mutator will swap data elements.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_SampleNinjaMutator">SampleNinjaMutator</link></term>
<listitem>
<simpara>This mutator will combine data elements from different data sets.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_44">
<title>Examples</title>
<example>
<title>Json Null</title>
<simpara>Outputs a Json string with a single null value.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
			 xsi:schemaLocation="http://peachfuzzer.com/2012/Peach /peach/peach.xsd"&gt;
	&lt;DataModel name="NullExample"&gt;
		&lt;Json&gt;
			&lt;Null name="Null"/&gt;
		&lt;/Json&gt;
	&lt;/DataModel&gt;

	&lt;StateModel name="TheState" initialState="Initial"&gt;
		&lt;State name="Initial"&gt;
			&lt;Action type="output"&gt;
				&lt;DataModel ref="NullExample"/&gt;
			&lt;/Action&gt;
		&lt;/State&gt;
	&lt;/StateModel&gt;

	&lt;Agent name="TheAgent" /&gt;

	&lt;Test name="Default"&gt;
		&lt;Agent ref="TheAgent"/&gt;

		&lt;StateModel ref="TheState"/&gt;

		&lt;Publisher class="ConsoleHex"/&gt;
	&lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Output from this example.</simpara>
<screen>&gt;peach -1 --debug NullExample1.xml

[*] Web site running at: http://localhost:8888/

[*] Test 'Default' starting with random seed 24442.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.StateModel Run(): Changing to state "Initial".
Peach.Core.Dom.Action Run(Action): Output
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Publishers.ConsolePublisher start()
Peach.Core.Publishers.ConsolePublisher open()
Peach.Core.Publishers.ConsolePublisher output(13 bytes)
00000000   7B 22 4E 75 6C 6C 22 3A  6E 75 6C 6C 7D            {"Null":null}
Peach.Core.Publishers.ConsolePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.ConsolePublisher stop()

[*] Test 'Default' finished.</screen>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Number">
<title>Number</title>
<simpara>The Number element defines a binary number of any arbitrary bit size from 1 to 64. Binary numbers are packed into a byte representation with a byte order of little-endian or big-endian.</simpara>
<simpara>The Number element should not be used for character-based numbers, or ASCII numbers. Instead, use a <link linkend="String">String</link> element.</simpara>
<simpara>The Number element is a child element of <link linkend="DataModel">DataModel</link>, <link linkend="Block">Block</link>, or <link linkend="Choice">Choice</link>.</simpara>
<simpara>See also <link linkend="VarNumber">VarNumber</link> and <link linkend="String">String</link>.</simpara>
<note>
<simpara>While Peach supports unaligned data structures, using unaligned data incurs a performance penalty. The penalty stems from bit slicing that occurs behind the scenes.</simpara>
</note>
<tip>
<simpara>In Peach, two attributes are commonly used to indicate size or length of an element, <emphasis>size</emphasis> and <emphasis>length</emphasis>. The <emphasis>size</emphasis> attribute always refers to the number of bits in an element. In contrast, the <emphasis>length</emphasis> attribute refers to the number of bytes of an element.</simpara>
</tip>
<section xml:id="_syntax_62">
<title>Syntax</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;Number name="Almonds" size="32" endian="big" signed="false" /&gt;</programlisting>
</section>
<section xml:id="_attributes_47">
<title>Attributes</title>
<simpara><emphasis>Required:</emphasis></simpara>
<variablelist>
<varlistentry>
<term><link linkend="size">size</link></term>
<listitem>
<simpara>Size of number in bits.  Valid options are 1 through 64.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term><link linkend="name">name</link></term>
<listitem>
<simpara>Name of the number.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="value">value</link></term>
<listitem>
<simpara>The default value to assign to the number.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="valueType">valueType</link></term>
<listitem>
<simpara>The representation of the value. Valid options are string and hex.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="token">token</link></term>
<listitem>
<simpara>This element is treated as a token when parsing. Valid values are true and false, defaults to false.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="endian">endian</link></term>
<listitem>
<simpara>Byte order of the number. Valid options are big, little, and network. Network is an alias for big. The default value is little.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="signed">signed</link></term>
<listitem>
<simpara>The number is signed or unsigned. Valid values are true and false, defaults to false.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="constraint">constraint</link></term>
<listitem>
<simpara>A constraint in the form of a python expression. Used during data cracking.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="mutable">mutable</link></term>
<listitem>
<simpara>Is data element changeable (should it be mutated during fuzzing). Valid values are true and false, defaults to true.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="minOccurs">minOccurs</link></term>
<listitem>
<simpara>The minimum number of times this element must occur. Defaults to 1. <?asciidoc-br?></simpara>
<itemizedlist>
<listitem>
<simpara>Used to define arrays with variable size. Arrays defined by min/maxOccurs generally have a relation
defined.</simpara>
</listitem>
<listitem>
<simpara>Adding this attribute, even with a value of 1, converts the element to an array.</simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="maxOccurs">maxOccurs</link></term>
<listitem>
<simpara>The maximum number of times this element can occur.<?asciidoc-br?></simpara>
<itemizedlist>
<listitem>
<simpara>Used to define arrays with static size.</simpara>
</listitem>
<listitem>
<simpara>Adding this attribute, even with a value of 1, converts the element to an array.</simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="occurs">occurs</link></term>
<listitem>
<simpara>Actual occurrences of element. Defaults to 1. <?asciidoc-br?></simpara>
<itemizedlist>
<listitem>
<simpara>Used to define arrays with static size.</simpara>
</listitem>
<listitem>
<simpara>Adding this attribute, even with a value of 1, converts the element to an array.</simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_child_elements_31">
<title>Child Elements</title>
<variablelist>
<varlistentry>
<term><link linkend="Analyzers">Analyzer</link></term>
<listitem>
<simpara>Analyzes current element post cracking, can dynamically change model.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Fixup">Fixup</link></term>
<listitem>
<simpara>Performs dynamic transformations such as checksums and CRCs.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Hint">Hint</link></term>
<listitem>
<simpara>Provides information to mutators.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Placement">Placement</link></term>
<listitem>
<simpara>Relocates an element after it has been cracked.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Relation">Relation</link></term>
<listitem>
<simpara>Identifies a type of relationship with another data element (such as count).</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Transformer">Transformer</link></term>
<listitem>
<simpara>Performs static transformations such as compression or encoding.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_mutators_21">
<title>Mutators</title>
<simpara>The following mutators operate on this element type:</simpara>
<simpara><emphasis>Enabled when element is marked as an array</emphasis></simpara>
<variablelist>
<varlistentry>
<term><link linkend="Mutators_ArrayNumericalEdgeCasesMutator">ArrayNumericalEdgeCasesMutator</link></term>
<listitem>
<simpara>This mutator grows and shrinks an array to counts based on numerical edge cases.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_ArrayRandomizeOrderMutator">ArrayRandomizeOrderMutator</link></term>
<listitem>
<simpara>This mutator randomizes the order of items in an array.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_ArrayReverseOrderMutator">ArrayReverseOrderMutator</link></term>
<listitem>
<simpara>This mutator reverses the order of items in an array.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_ArrayVarianceMutator">ArrayVarianceMutator</link></term>
<listitem>
<simpara>This mutator grows and shrinks an array to a variance of counts based on the current size.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Used for all data elements</emphasis></simpara>
<variablelist>
<varlistentry>
<term><link linkend="Mutators_DataElementBitFlipper">DataElementBitFlipper</link></term>
<listitem>
<simpara>This mutator produces test cases by flipping bits in the output value.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_DataElementDuplicate">DataElementDuplicate</link></term>
<listitem>
<simpara>This mutator duplicates data elements.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_DataElementRemove">DataElementRemove</link></term>
<listitem>
<simpara>This mutator removes data elements.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_DataElementSwapNear">DataElementSwapNear</link></term>
<listitem>
<simpara>This mutator swaps data elements.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_SampleNinjaMutator">SampleNinjaMutator</link></term>
<listitem>
<simpara>This mutator combines data elements from different data sets.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Enabled when element is part of a size relation</emphasis></simpara>
<variablelist>
<varlistentry>
<term><link linkend="Mutators_SizedDataEdgeCase">SizedDataEdgeCase</link></term>
<listitem>
<simpara>This mutator causes the data portion of a relation to be sized as numerical edge cases.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_SizedDataVariance">SizedDataVariance</link></term>
<listitem>
<simpara>This mutator causes the data portion of a relation to be sized as numerical variances.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_SizedEdgeCase">SizedEdgeCase</link></term>
<listitem>
<simpara>This mutator changes both sides of the relation (data and value) to match numerical edge cases.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_SizedVariance">SizedVariance</link></term>
<listitem>
<simpara>This mutator changes both sides of the relation (data and value) to match numerical variances of the current size.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Specific to this element type</emphasis></simpara>
<variablelist>
<varlistentry>
<term><link linkend="Mutators_ExtraValues">ExtraValues</link></term>
<listitem>
<simpara>This mutator provides extra test case values on a per-data element basis.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_NumberEdgeCase">NumberEdgeCase</link></term>
<listitem>
<simpara>This mutator produces numerical edge cases for integer values.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_NumberRandom">NumberRandom</link></term>
<listitem>
<simpara>This mutator produces random values from the available numerical space.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_NumberVariance">NumberVariance</link></term>
<listitem>
<simpara>This mutator produces values near the current value of a number.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_45">
<title>Examples</title>
<example>
<title>Size</title>
<simpara>Produce a 32-bit (4-byte) number with a default value of 5.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
			 xsi:schemaLocation="http://peachfuzzer.com/2012/Peach /peach/peach.xsd"&gt;
	&lt;DataModel name="NumberExample1"&gt;
		&lt;Number name="Hi5" value="5" size="32"/&gt;
	&lt;/DataModel&gt;

	&lt;StateModel name="TheState" initialState="Initial"&gt;
		&lt;State name="Initial"&gt;
			&lt;Action type="output"&gt;
				&lt;DataModel ref="NumberExample1"/&gt;
			&lt;/Action&gt;
		&lt;/State&gt;
	&lt;/StateModel&gt;

	&lt;Agent name="TheAgent" /&gt;

	&lt;Test name="Default"&gt;
		&lt;Agent ref="TheAgent"/&gt;

		&lt;StateModel ref="TheState"/&gt;

		&lt;Publisher class="ConsoleHex"/&gt;
	&lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Output from this example.</simpara>
<screen>&gt;peach -1 --debug NumberExample1.xml

[*] Test 'Default' starting with random seed 6226.
Peach.Core.MutationStrategies.RandomStrategy Iteration: Switch iteration, setting controlIteration and controlRecordingIteration.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Updating action to original data model
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher start()
Peach.Core.Publishers.ConsolePublisher open()
Peach.Core.Publishers.ConsolePublisher output(4 bytes)
00000000   05 00 00 00                                        ????            <co xml:id="CO19-1"/>
Peach.Core.Publishers.ConsolePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.ConsolePublisher stop()

[*] Test 'Default' finished.</screen>
<calloutlist>
<callout arearefs="CO19-1">
<para>The 32-bit, little-endian value is 5.</para>
</callout>
</calloutlist>
<simpara>Change the previous example to use a 16-bit (two-byte) number by adjusting the size to 16.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
			 xsi:schemaLocation="http://peachfuzzer.com/2012/Peach /peach/peach.xsd"&gt;

	&lt;DataModel name="NumberExample2"&gt;
		&lt;Number name="Hi5" value="5" size="16"/&gt;
	&lt;/DataModel&gt;

	&lt;StateModel name="TheState" initialState="Initial"&gt;
		&lt;State name="Initial"&gt;
			&lt;Action type="output"&gt;
				&lt;DataModel ref="NumberExample2"/&gt;
			&lt;/Action&gt;
		&lt;/State&gt;
	&lt;/StateModel&gt;

	&lt;Agent name="TheAgent" /&gt;

	&lt;Test name="Default"&gt;
		&lt;Agent ref="TheAgent"/&gt;

		&lt;StateModel ref="TheState"/&gt;

		&lt;Publisher class="ConsoleHex"/&gt;
	&lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Output from this example.</simpara>
<screen>&gt;peach -1 --debug NumberExample2.xml

[*] Test 'Default' starting with random seed 51118.
Peach.Core.MutationStrategies.RandomStrategy Iteration: Switch iteration, setting controlIteration and controlRecordingIteration.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Updating action to original data model
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher start()
Peach.Core.Publishers.ConsolePublisher open()
Peach.Core.Publishers.ConsolePublisher output(2 bytes)
00000000   05 00                                              ??              <co xml:id="CO20-1"/>
Peach.Core.Publishers.ConsolePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.ConsolePublisher stop()

[*] Test 'Default' finished.</screen>
<calloutlist>
<callout arearefs="CO20-1">
<para>The 16 bit little endian value 5</para>
</callout>
</calloutlist>
<simpara><emphasis role="strong">NOTE:</emphasis> Numbers use the <literal>size</literal> attribute which specifies the number of <emphasis role="strong">bits</emphasis>. <emphasis>Number</emphasis> elements do not accept the <literal>length</literal> attribute used by other elements.</simpara>
</example>
<example>
<title>Byte Alignment</title>
<simpara>While many data structures are byte aligned, some are not. This example arbitrarily defines sizes that do not
fall on byte boundaries.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
			 xsi:schemaLocation="http://peachfuzzer.com/2012/Peach /peach/peach.xsd"&gt;

	&lt;DataModel name="ByteAlignmentExample1"&gt;
		&lt;Number value="2" size="3" /&gt;
		&lt;Number value="12" size="5" /&gt;
	&lt;/DataModel&gt;

	&lt;StateModel name="TheState" initialState="Initial"&gt;
		&lt;State name="Initial"&gt;
			&lt;Action type="output"&gt;
				&lt;DataModel ref="ByteAlignmentExample1"/&gt;
			&lt;/Action&gt;
		&lt;/State&gt;
	&lt;/StateModel&gt;

	&lt;Agent name="TheAgent" /&gt;
	&lt;Test name="Default"&gt;
		&lt;Agent ref="TheAgent"/&gt;

		&lt;StateModel ref="TheState"/&gt;

		&lt;Publisher class="ConsoleHex"/&gt;
	&lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Output from this example.</simpara>
<screen>&gt;peach -1 --debug ByteAlignExample.xml

[*] Test 'Default' starting with random seed 41464.
Peach.Core.MutationStrategies.RandomStrategy Iteration: Switch iteration, setting controlIteration and controlRecordingIteration.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Updating action to original data model
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher start()
Peach.Core.Publishers.ConsolePublisher open()
Peach.Core.Publishers.ConsolePublisher output(1 bytes)
00000000   4C                                                 L               <co xml:id="CO21-1"/>
Peach.Core.Publishers.ConsolePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.ConsolePublisher stop()</screen>
<calloutlist>
<callout arearefs="CO21-1">
<para>Two numbers are compacted into one byte.</para>
</callout>
</calloutlist>
<simpara>The first number is three bits with the value <literal>"2"</literal>. This number
becomes the first three bits of the byte. The remaining five bits are
appended to the left.</simpara>
<simpara>In Python this could be written as the following:</simpara>
<screen>&gt;&gt;&gt; hex((2 &lt;&lt; 5) + 12)
'0x4c'</screen>
<simpara>Input parsing is simply the inverse.</simpara>
<screen>&gt;&gt;&gt; input_byte = 0x4C
&gt;&gt;&gt; offset = 5
&gt;&gt;&gt; (input_byte &gt;&gt; offset)
2																				<co xml:id="CO22-1"/>
&gt;&gt;&gt; input_byte &amp; (-1 + (2**offset))
12																			<co xml:id="CO22-2"/></screen>
<calloutlist>
<callout arearefs="CO22-1">
<para>The first byte is bit-shifted using the size of the second.</para>
</callout>
<callout arearefs="CO22-2">
<para>By masking off the first number, we get the second.</para>
</callout>
</calloutlist>
</example>
<example>
<title>Endian</title>
<simpara>To change the endian-ness of the number, set the endian attribute. Endian-ness defines the order of the least-significant or most-significant bytes.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
			 xsi:schemaLocation="http://peachfuzzer.com/2012/Peach /peach/peach.xsd"&gt;

	&lt;DataModel name="NumberExample6"&gt;
		&lt;Number name="abcd" value="52651" size="16" signed="false" endian="big" /&gt;
	&lt;/DataModel&gt;

	&lt;DataModel name="NumberExample7"&gt;
		&lt;Number name="abcd" value="52651" size="16" signed="false" endian="little" /&gt;
	&lt;/DataModel&gt;

	&lt;StateModel name="TheState" initialState="Initial"&gt;
		&lt;State name="Initial"&gt;
			&lt;Action type="output"&gt;
				&lt;DataModel ref="NumberExample6"/&gt;
			&lt;/Action&gt;
			&lt;Action type="output"&gt;
				&lt;DataModel ref="NumberExample7"/&gt;
			&lt;/Action&gt;
		&lt;/State&gt;
	&lt;/StateModel&gt;

	&lt;Agent name="TheAgent" /&gt;

	&lt;Test name="Default"&gt;
		&lt;Agent ref="TheAgent"/&gt;

		&lt;StateModel ref="TheState"/&gt;

		&lt;Publisher class="ConsoleHex"/&gt;
	&lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Output from this example.</simpara>
<screen>&gt;peach -1 --debug NumberEndianExample.xml

[*] Test 'Default' starting with random seed 16220.
Peach.Core.MutationStrategies.RandomStrategy Iteration: Switch iteration, setting controlIteration and controlRecordingIteration.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Updating action to original data model
Peach.Core.Dom.Action Updating action to original data model
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher start()
Peach.Core.Publishers.ConsolePublisher open()
Peach.Core.Publishers.ConsolePublisher output(2 bytes)
00000000   CD AB                                              ??              <co xml:id="CO23-1"/>
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher output(2 bytes)
00000000   AB CD                                              ??              <co xml:id="CO23-2"/>
Peach.Core.Publishers.ConsolePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.ConsolePublisher stop()

[*] Test 'Default' finished.</screen>
<calloutlist>
<callout arearefs="CO23-1">
<para>Little endian outputs the bytes in the order  CD AB</para>
</callout>
<callout arearefs="CO23-2">
<para>Big endian outputs the bytes in the order  AB CD</para>
</callout>
</calloutlist>
<simpara>Note, however, that endian-ness doesn&#8217;t have any impact on output if the <literal>valueType</literal>
is <literal>"hex"</literal>:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
			 xsi:schemaLocation="http://peachfuzzer.com/2012/Peach /peach/peach.xsd"&gt;

	&lt;DataModel name="NumberExample6"&gt;
		&lt;Number name="abcd" valueType="hex" value="ABCD" size="16" signed="false" endian="little" /&gt;
	&lt;/DataModel&gt;

	&lt;DataModel name="NumberExample7"&gt;
		&lt;Number name="abcd" valueType="hex" value="ABCD" size="16" signed="false" endian="big" /&gt;
	&lt;/DataModel&gt;

	&lt;StateModel name="TheState" initialState="Initial"&gt;
		&lt;State name="Initial"&gt;
			&lt;Action type="output"&gt;
				&lt;DataModel ref="NumberExample6"/&gt;
			&lt;/Action&gt;
			&lt;Action type="output"&gt;
				&lt;DataModel ref="NumberExample7"/&gt;
			&lt;/Action&gt;
		&lt;/State&gt;
	&lt;/StateModel&gt;

	&lt;Agent name="TheAgent" /&gt;

	&lt;Test name="Default"&gt;
		&lt;Agent ref="TheAgent"/&gt;

		&lt;StateModel ref="TheState"/&gt;

		&lt;Publisher class="ConsoleHex"/&gt;
	&lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Output from this example.</simpara>
<screen>&gt;peach -1 --debug NumberEndianExample.xml

[*] Test 'Default' starting with random seed 37516.
Peach.Core.MutationStrategies.RandomStrategy Iteration: Switch iteration, setting controlIteration and controlRecordingIteration.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Updating action to original data model
Peach.Core.Dom.Action Updating action to original data model
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher start()
Peach.Core.Publishers.ConsolePublisher open()
Peach.Core.Publishers.ConsolePublisher output(2 bytes)
00000000   AB CD                                              ??              <co xml:id="CO24-1"/>
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher output(2 bytes)
00000000   AB CD                                              ??							<co xml:id="CO24-2"/>
Peach.Core.Publishers.ConsolePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.ConsolePublisher stop()

[*] Test 'Default' finished.</screen>
<calloutlist>
<callout arearefs="CO24-1">
<para>For little endian, the expected output displays.</para>
</callout>
<callout arearefs="CO24-2">
<para>For big endian, nothing changes.</para>
</callout>
</calloutlist>
<simpara>When the attribute <literal>valueType</literal> is set to <literal>"hex"</literal>, the ordering is exactly as specified.
The <literal>endian</literal> attribute still impacts mutation and input parsing.</simpara>
</example>
<example>
<title>Signed and Unsigned</title>
<simpara>To indicate value is signed, set the <literal>signed</literal> attribute equal to <literal>"true"</literal>. The default is false.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
			 xsi:schemaLocation="http://peachfuzzer.com/2012/Peach /peach/peach.xsd"&gt;

	&lt;DataModel name="UnsignedExample"&gt;
		&lt;Number name="UnsignedInt" value="4294967295" size="32"/&gt;
	&lt;/DataModel&gt;

	&lt;DataModel name="SignedExample"&gt;
		&lt;Number name="SignedInt" value="-2147483648" size="32" signed="true"/&gt;
	&lt;/DataModel&gt;

	&lt;StateModel name="TheState" initialState="Initial"&gt;
		&lt;State name="Initial"&gt;
			&lt;Action type="output"&gt;
				&lt;DataModel ref="UnsignedExample"/&gt;
			&lt;/Action&gt;
			&lt;Action type="output"&gt;
				&lt;DataModel ref="SignedExample"/&gt;
			&lt;/Action&gt;
		&lt;/State&gt;
	&lt;/StateModel&gt;

	&lt;Agent name="TheAgent" /&gt;

	&lt;Test name="Default"&gt;
		&lt;Agent ref="TheAgent"/&gt;

		&lt;StateModel ref="TheState"/&gt;

		&lt;Publisher class="ConsoleHex"/&gt;
	&lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Output from this example.</simpara>
<screen>&gt;peach -1 --debug NumberExample3.xml

[*] Test 'Default' starting with random seed 64304.
Peach.Core.MutationStrategies.RandomStrategy Iteration: Switch iteration, setting controlIteration and controlRecordingIteration.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Updating action to original data model
Peach.Core.Dom.Action Updating action to original data model
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher start()
Peach.Core.Publishers.ConsolePublisher open()
Peach.Core.Publishers.ConsolePublisher output(4 bytes)
00000000   FF FF FF FF                                        ????            <co xml:id="CO25-1"/>
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher output(4 bytes)
00000000   FF FF FF FF                                        ????            <co xml:id="CO25-2"/>
Peach.Core.Publishers.ConsolePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.ConsolePublisher stop()

[*] Test 'Default' finished.</screen>
<calloutlist>
<callout arearefs="CO25-1">
<para>Output of unsigned 4294967295</para>
</callout>
<callout arearefs="CO25-2">
<para>Output of signed -1</para>
</callout>
</calloutlist>
</example>
<example>
<title>Value Type</title>
<simpara>The valueType defines how to interpret the value attribute. Valid options are <emphasis>"string"</emphasis> and <emphasis>"hex"</emphasis>. The default value is <emphasis>string</emphasis>.</simpara>
<simpara>To assign a value of 1000 to MyValue, use the default <literal>valueType</literal> of <literal>"string"</literal>. The <literal>"string"</literal> type supports
both decimal and hexadecimal values.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
			 xsi:schemaLocation="http://peachfuzzer.com/2012/Peach /peach/peach.xsd"&gt;

	&lt;DataModel name="NumberTypeExample1"&gt;
		&lt;Number name="MyValue" value="1000" valueType="string" size="16" signed="false" /&gt;
	&lt;/DataModel&gt;

	&lt;DataModel name="NumberTypeExample2"&gt;
		&lt;Number name="MyValue" value="0x03e8" valueType="string" size="16" signed="false" /&gt;
	&lt;/DataModel&gt;

	&lt;StateModel name="TheState" initialState="Initial"&gt;
		&lt;State name="Initial"&gt;
			&lt;Action type="output"&gt;
				&lt;DataModel ref="NumberTypeExample1"/&gt;
			&lt;/Action&gt;
			&lt;Action type="output"&gt;
				&lt;DataModel ref="NumberTypeExample2"/&gt;
			&lt;/Action&gt;
		&lt;/State&gt;
	&lt;/StateModel&gt;

	&lt;Agent name="TheAgent" /&gt;

	&lt;Test name="Default"&gt;
		&lt;Agent ref="TheAgent"/&gt;

		&lt;StateModel ref="TheState"/&gt;

		&lt;Publisher class="ConsoleHex"/&gt;
	&lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Output from this example.</simpara>
<screen>&gt;peach -1 --debug NumberExample4.xml

[*] Test 'Default' starting with random seed 61690.
Peach.Core.MutationStrategies.RandomStrategy Iteration: Switch iteration, setting controlIteration and controlRecordingIteration.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Updating action to original data model
Peach.Core.Dom.Action Updating action to original data model
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher start()
Peach.Core.Publishers.ConsolePublisher open()
Peach.Core.Publishers.ConsolePublisher output(2 bytes)
00000000   E8 03                                              ??              <co xml:id="CO26-1"/>
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher output(2 bytes)
00000000   E8 03                                              ??              <co xml:id="CO26-2"/>
Peach.Core.Publishers.ConsolePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.ConsolePublisher stop()

[*] Test 'Default' finished.</screen>
<calloutlist>
<callout arearefs="CO26-1">
<para>The value 1000</para>
</callout>
<callout arearefs="CO26-2">
<para>The value 1000, having been defined in hex as 0x03e8</para>
</callout>
</calloutlist>
<simpara>Notice that the <literal>valueType</literal> of <literal>"string"</literal> represents a number. This
number may be changed by endian-ness. Observe that the numeric value
was entered as 0x03e8, but Peach output the bytes 0xE8 and 0x03. The
value was converted to little endian before being output.</simpara>
<simpara>To assign a value as if copied directly from a hex editor we can use
the <literal>"hex"</literal> <literal>valueType</literal>. Values entered in <literal>"hex"</literal> are output exactly as input
regardless of endian-ness, as shown in the previous example that exercises  the <literal>endian</literal> attribute.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
			 xsi:schemaLocation="http://peachfuzzer.com/2012/Peach /peach/peach.xsd"&gt;

	&lt;DataModel name="NumberExample5"&gt;
		&lt;Number name="MyValue" value="AB CD" valueType="hex" size="16" signed="false" /&gt;
	&lt;/DataModel&gt;

	&lt;StateModel name="TheState" initialState="Initial"&gt;
		&lt;State name="Initial"&gt;
			&lt;Action type="output"&gt;
				&lt;DataModel ref="NumberExample5"/&gt;
			&lt;/Action&gt;
		&lt;/State&gt;
	&lt;/StateModel&gt;

	&lt;Agent name="TheAgent" /&gt;

	&lt;Test name="Default"&gt;
		&lt;Agent ref="TheAgent"/&gt;

		&lt;StateModel ref="TheState"/&gt;

		&lt;Publisher class="ConsoleHex"/&gt;
	&lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Output from this example.</simpara>
<screen>&gt;peach -1 --debug NumberExample5.xml

[*] Test 'Default' starting with random seed 55408.
Peach.Core.MutationStrategies.RandomStrategy Iteration: Switch iteration, setting controlIteration and controlRecordingIteration.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Updating action to original data model
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher start()
Peach.Core.Publishers.ConsolePublisher open()
Peach.Core.Publishers.ConsolePublisher output(2 bytes)
00000000   AB CD                                              ??              <co xml:id="CO27-1"/>
Peach.Core.Publishers.ConsolePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.ConsolePublisher stop()

[*] Test 'Default' finished.</screen>
<calloutlist>
<callout arearefs="CO27-1">
<para>The value is 43981.</para>
</callout>
</calloutlist>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Padding">
<title>Padding</title>
<simpara>The <emphasis>Padding</emphasis> element provides padding for variable-sized blocks or data models.</simpara>
<simpara>When padding the data, the value of the pad characters is always 0. This is not customizable.</simpara>
<simpara>When cracking data into a model that contains the padding element, the pad data is skipped.</simpara>
<section xml:id="_syntax_63">
<title>Syntax</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;DataModel name="NumberExample1"&gt;
 &lt;String name="VariableSizeString" /&gt;

 &lt;Padding /&gt;
&lt;/DataModel&gt;</programlisting>
</section>
<section xml:id="_attributes_48">
<title>Attributes</title>
<simpara><emphasis>Required:</emphasis></simpara>
<simpara>None.</simpara>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term><link linkend="name">name</link></term>
<listitem>
<simpara>Element name.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>alignment</term>
<listitem>
<simpara>Align to the specified bit boundary: 8, 16, 32, 64, etc. The default value is  8</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>alignedTo</term>
<listitem>
<simpara>Name of reference element for alignment, defaults to parent element.
The alignment starts at the beginning of the reference element</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="mutable">mutable</link></term>
<listitem>
<simpara>Is the data element changeable (should it be mutated during fuzzing), defaults to true. Valid options true and false.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_child_elements_32">
<title>Child Elements</title>
<variablelist>
<varlistentry>
<term><link linkend="Fixup">Fixup</link></term>
<listitem>
<simpara>Performs dynamic transformations such as checksums and CRCs.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Hint">Hint</link></term>
<listitem>
<simpara>Provides information to mutators</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Transformer">Transformer</link></term>
<listitem>
<simpara>Performs static transformations such as compression or encoding.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_mutators_22">
<title>Mutators</title>
<simpara>The following mutators can operate on this element type:</simpara>
<simpara><emphasis>Enabled when the data element is marked as an array</emphasis></simpara>
<variablelist>
<varlistentry>
<term><link linkend="Mutators_ArrayNumericalEdgeCasesMutator">ArrayNumericalEdgeCasesMutator</link></term>
<listitem>
<simpara>This mutator grows and shrinks an array to counts based on numerical edge cases.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_ArrayRandomizeOrderMutator">ArrayRandomizeOrderMutator</link></term>
<listitem>
<simpara>This mutator randomizes the order of items in an array.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_ArrayReverseOrderMutator">ArrayReverseOrderMutator</link></term>
<listitem>
<simpara>This mutator reverses the sequence of items in an array.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_ArrayVarianceMutator">ArrayVarianceMutator</link></term>
<listitem>
<simpara>This mutator grows and shrinks an array to a variance of counts based on the current size.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Used for all data elements</emphasis></simpara>
<variablelist>
<varlistentry>
<term><link linkend="Mutators_DataElementBitFlipper">DataElementBitFlipper</link></term>
<listitem>
<simpara>This mutator produces test cases by flipping bits in the output value.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_DataElementDuplicate">DataElementDuplicate</link></term>
<listitem>
<simpara>This mutator duplicates data elements.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_DataElementRemove">DataElementRemove</link></term>
<listitem>
<simpara>This mutator removes data elements.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_DataElementSwapNear">DataElementSwapNear</link></term>
<listitem>
<simpara>This mutator swaps data elements.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_SampleNinjaMutator">SampleNinjaMutator</link></term>
<listitem>
<simpara>This mutator combines data elements from different data sets.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Enabled when the data element is part of a size relation</emphasis></simpara>
<variablelist>
<varlistentry>
<term><link linkend="Mutators_SizedDataEdgeCase">SizedDataEdgeCase</link></term>
<listitem>
<simpara>This mutator causes the data portion of a relation to be sized as numerical edge cases.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_SizedDataVariance">SizedDataVariance</link></term>
<listitem>
<simpara>This mutator causes the data portion of a relation to be sized as numerical variances.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_SizedEdgeCase">SizedEdgeCase</link></term>
<listitem>
<simpara>This mutator changes both sides of the relation (data and value) to match numerical edge cases.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_SizedVariance">SizedVariance</link></term>
<listitem>
<simpara>This mutator changes both sides of the relation (data and value) to match numerical variances of the current size.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_46">
<title>Examples</title>
<example>
<title>Padding with Default Options</title>
<simpara>This example demonstrates the default case of padding. The AlignTo attribute aligns pad characters along 8-bit boundaries.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

	&lt;DataModel name="TheDataModel"&gt;
		&lt;Number size="1" value="0" /&gt;
		&lt;Number size="8" value="0xff" /&gt;

		&lt;Padding /&gt;
	&lt;/DataModel&gt;

	&lt;StateModel name="TheStateModel" initialState="InitialState" &gt;
		&lt;State name="InitialState"&gt;
			&lt;Action type="output"&gt;
				&lt;DataModel ref="TheDataModel"/&gt;
			&lt;/Action&gt;
		&lt;/State&gt;
	&lt;/StateModel&gt;

	&lt;Test name="Default"&gt;
		&lt;StateModel ref="TheStateModel"/&gt;

		&lt;Publisher class="ConsoleHex" /&gt;
	&lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Produces the following output:</simpara>
<screen>&gt; peach -1 --debug example.xml

[*] Test 'Default' starting with random seed 56742.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher start()
Peach.Core.Publishers.ConsolePublisher open()
Peach.Core.Publishers.ConsolePublisher output(2 bytes)
00000000   7F 80                                              .?
Peach.Core.Publishers.ConsolePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.ConsolePublisher stop()

[*] Test 'Default' finished.</screen>
</example>
<example>
<title>Padding Aligned to 32 bit Boundary</title>
<simpara>This example aligns the pad  data to a 32-bit boundary.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

	&lt;DataModel name="TheDataModel"&gt;
		&lt;Number size="1" value="0" /&gt;
		&lt;Number size="8" value="0xff" /&gt;

		&lt;Padding alignment="32" /&gt;
	&lt;/DataModel&gt;

	&lt;StateModel name="TheStateModel" initialState="InitialState" &gt;
		&lt;State name="InitialState"&gt;
			&lt;Action type="output"&gt;
				&lt;DataModel ref="TheDataModel"/&gt;
			&lt;/Action&gt;
		&lt;/State&gt;
	&lt;/StateModel&gt;

	&lt;Test name="Default"&gt;
		&lt;StateModel ref="TheStateModel"/&gt;

		&lt;Publisher class="ConsoleHex" /&gt;
	&lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Produces the following output:</simpara>
<screen>&gt; peach -1 --debug example.xml

[*] Test 'Default' starting with random seed 51106.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher start()
Peach.Core.Publishers.ConsolePublisher open()
Peach.Core.Publishers.ConsolePublisher output(4 bytes)
00000000   7F 80 00 00                                        .???
Peach.Core.Publishers.ConsolePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.ConsolePublisher stop()

[*] Test 'Default' finished.</screen>
</example>
<example>
<title>Padding Separated from Unaligned Value</title>
<simpara>This example demonstrates padding with unaligned data preceding and following the padding.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

	&lt;DataModel name="TheDataModel"&gt;
		&lt;Number name="ToBeAligned" size="1" value="0" /&gt;

		&lt;Number size="16" value="42" /&gt;
		&lt;Number size="2" value="1" /&gt;

		&lt;Padding alignment="32" alignedTo="ToBeAligned" /&gt;

		&lt;Number size="6" value="42" /&gt;
	&lt;/DataModel&gt;

	&lt;StateModel name="TheStateModel" initialState="InitialState" &gt;
		&lt;State name="InitialState"&gt;
			&lt;Action type="output"&gt;
				&lt;DataModel ref="TheDataModel"/&gt;
			&lt;/Action&gt;
		&lt;/State&gt;
	&lt;/StateModel&gt;

	&lt;Test name="Default"&gt;
		&lt;StateModel ref="TheStateModel"/&gt;

		&lt;Publisher class="ConsoleHex" /&gt;
	&lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Produces the following output:</simpara>
<screen>&gt; peach -1 --debug example.xml

[*] Test 'Default' starting with random seed 49630.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher start()
Peach.Core.Publishers.ConsolePublisher open()
Peach.Core.Publishers.ConsolePublisher output(7 bytes)
00000000   15 00 20 00 00 00 2A                               ?? ???*
Peach.Core.Publishers.ConsolePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.ConsolePublisher stop()

[*] Test 'Default' finished.</screen>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Sequence">
<title>Sequence</title>
<simpara>A <emphasis>Sequence</emphasis> element is used to construct an array with all its elements predefined.
A <emphasis>Sequence</emphasis> is able to contain multiple data types at once. Unlike regular arrays
in Peach, the size of the Sequence it determined by the number of elements within
the sequence.</simpara>
<note>
<simpara>A <emphasis>Sequence</emphasis> element that uses the Occurs, minOccurs, or maxOccurs attribute
creates an array of <emphasis>Sequences</emphasis>.</simpara>
</note>
<section xml:id="_syntax_64">
<title>Syntax</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;Sequence&gt;
  &lt;String name="Foo" value="Hello world!" /&gt;
  &lt;Number name="Num" value="101" /&gt;
&lt;/Sequence&gt;</programlisting>
</section>
<section xml:id="_attributes_49">
<title>Attributes</title>
<simpara><emphasis>Required:</emphasis></simpara>
<simpara>There are no required attributes.</simpara>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term><link linkend="name">name</link></term>
<listitem>
<simpara>Name of the sequence.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="ref">ref</link></term>
<listitem>
<simpara>Reference to a <link linkend="DataModel">DataModel</link> to use as a template.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="length">length</link></term>
<listitem>
<simpara>Data element length.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="lengthType">lengthType</link></term>
<listitem>
<simpara>The unit measure of length attribute. Default is bytes.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="constraint">constraint</link></term>
<listitem>
<simpara>Scripting expression that evaluates to true or false. Default is null.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="minOccurs">minOccurs</link></term>
<listitem>
<simpara>The minimum number of times this sequence must occur.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="maxOccurs">maxOccurs</link></term>
<listitem>
<simpara>The maximum number of times this sequence can occur.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="occurs">occurs</link></term>
<listitem>
<simpara>The actual number of times this sequence occurs.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="mutable">mutable</link></term>
<listitem>
<simpara>Is data element changeable (should it be mutated), defaults to false.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_child_elements_33">
<title>Child Elements</title>
<variablelist>
<varlistentry>
<term><link linkend="Analyzers">Analyzer</link></term>
<listitem>
<simpara>Analyze current element post cracking, can dynamically change model.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Blob">Blob</link></term>
<listitem>
<simpara>Used to represent binary data (think array of bytes) to create simple dumb fuzzers in Peach.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Block">Block</link></term>
<listitem>
<simpara>Group one or more data elements together into a logical structure.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Bool">Bool</link></term>
<listitem>
<simpara>Defines a boolean value.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Choice">Choice</link></term>
<listitem>
<simpara>Indicate any of the sub-elements are valid but only one should be selected.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Double">Double</link></term>
<listitem>
<simpara>Defines a floating point number of 32 or 64 bits.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Fixup">Fixup</link></term>
<listitem>
<simpara>Dynamic transformations such as checksums and CRCs.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Flags">Flags</link></term>
<listitem>
<simpara>Defines a set of bit sized flags.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Hint">Hint</link></term>
<listitem>
<simpara>Provide information to mutators.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Null">Null</link></term>
<listitem>
<simpara>Defines a null value element.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Number">Number</link></term>
<listitem>
<simpara>Defines a binary number of arbitrary bit size.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Padding">Padding</link></term>
<listitem>
<simpara>Pad out variably sized blocks or data models.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Placement">Placement</link></term>
<listitem>
<simpara>Relocate an element after it has been cracked.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Sequence">Sequence</link></term>
<listitem>
<simpara>Groups one or more data elements together into a logical structure.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Stream">Stream</link></term>
<listitem>
<simpara>Group one or more data elements together into a logical structure.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Transformer">Transformer</link></term>
<listitem>
<simpara>Static transformations such as compression or encoding.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="XmlElement">XmlElement</link></term>
<listitem>
<simpara>Defines an XML element, the basic building block of XML documents.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_mutators_23">
<title>Mutators</title>
<simpara>The following mutators will operate on this element type:</simpara>
<simpara><emphasis>Enabled when element is marked as an array</emphasis></simpara>
<variablelist>
<varlistentry>
<term><link linkend="Mutators_ArrayNumericalEdgeCasesMutator">ArrayNumericalEdgeCasesMutator</link></term>
<listitem>
<simpara>This mutator will grow and shrink an array to counts based on numerical edge cases.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_ArrayRandomizeOrderMutator">ArrayRandomizeOrderMutator</link></term>
<listitem>
<simpara>This mutator will randomize the order of items in an array.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_ArrayReverseOrderMutator">ArrayReverseOrderMutator</link></term>
<listitem>
<simpara>This mutator will reverse the order of items in an array.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_ArrayVarianceMutator">ArrayVarianceMutator</link></term>
<listitem>
<simpara>This mutator will grow and shrink an array to a variance of counts based on the current size.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Used for all data elements</emphasis></simpara>
<variablelist>
<varlistentry>
<term><link linkend="Mutators_DataElementBitFlipper">DataElementBitFlipper</link></term>
<listitem>
<simpara>This mutator will produce test cases by flipping bits in the output value.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_DataElementDuplicate">DataElementDuplicate</link></term>
<listitem>
<simpara>This mutator will duplicate data elements.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_DataElementRemove">DataElementRemove</link></term>
<listitem>
<simpara>This mutator will remove data elements.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_DataElementSwapNear">DataElementSwapNear</link></term>
<listitem>
<simpara>This mutator will swap data elements.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_SampleNinjaMutator">SampleNinjaMutator</link></term>
<listitem>
<simpara>This mutator will combine data elements from different data sets.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Enabled when element is part of a size relation</emphasis></simpara>
<variablelist>
<varlistentry>
<term><link linkend="Mutators_SizedDataEdgeCase">SizedDataEdgeCase</link></term>
<listitem>
<simpara>This mutator will cause the data portion of a relation to be sized as numerical edge cases.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_SizedDataVariance">SizedDataVariance</link></term>
<listitem>
<simpara>This mutator will cause the data portion of a relation to be sized as numerical variances.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_SizedEdgeCase">SizedEdgeCase</link></term>
<listitem>
<simpara>This mutator will change both sides of the relation (data and value) to match numerical edge cases.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_SizedVariance">SizedVariance</link></term>
<listitem>
<simpara>This mutator will change both sides of the relation (data and value) to match numerical variances of the current size.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_47">
<title>Examples</title>
<example>
<title>Empty Sequence</title>
<simpara>The simplest sequence has no children.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
			 xsi:schemaLocation="http://peachfuzzer.com/2012/Peach /peach/peach.xsd"&gt;
	&lt;DataModel name="SequenceExample"&gt;
		&lt;Sequence&gt;

		&lt;/Sequence&gt;
	&lt;/DataModel&gt;

	&lt;StateModel name="TheState" initialState="Initial"&gt;
		&lt;State name="Initial"&gt;
			&lt;Action type="output"&gt;
				&lt;DataModel ref="SequenceExample"/&gt;
			&lt;/Action&gt;
		&lt;/State&gt;
	&lt;/StateModel&gt;

	&lt;Agent name="TheAgent" /&gt;

	&lt;Test name="Default"&gt;
		&lt;Agent ref="TheAgent"/&gt;

		&lt;StateModel ref="TheState"/&gt;

		&lt;Publisher class="ConsoleHex"/&gt;
	&lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Output from this example.</simpara>
<screen>&gt;peach -1 --debug example.xml

[*] Test 'Default' starting with random seed 3808.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.StateModel Run(): Changing to state "Initial".
Peach.Core.Dom.Action Run(Action): Output
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Publishers.ConsolePublisher start()
Peach.Core.Publishers.ConsolePublisher open()
Peach.Core.Publishers.ConsolePublisher output(2 bytes)
00000000   7B 7D                                              {}
Peach.Core.Publishers.ConsolePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.ConsolePublisher stop()

[*] Test 'Default' finished.</screen>
</example>
<example>
<title>Single Child</title>
<simpara>The output of a sequence with a single child</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
			 xsi:schemaLocation="http://peachfuzzer.com/2012/Peach /peach/peach.xsd"&gt;
	&lt;DataModel name="SequenceExample"&gt;
		&lt;Sequence&gt;
			&lt;Number name="num" size="8" value="101"/&gt;
		&lt;/Sequence&gt;
	&lt;/DataModel&gt;

	&lt;StateModel name="TheState" initialState="Initial"&gt;
		&lt;State name="Initial"&gt;
			&lt;Action type="output"&gt;
				&lt;DataModel ref="SequenceExample"/&gt;
			&lt;/Action&gt;
		&lt;/State&gt;
	&lt;/StateModel&gt;

	&lt;Agent name="TheAgent" /&gt;

	&lt;Test name="Default"&gt;
		&lt;Agent ref="TheAgent"/&gt;

		&lt;StateModel ref="TheState"/&gt;

		&lt;Publisher class="ConsoleHex"/&gt;
	&lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Output from this example.</simpara>
<screen>&gt;peach -1 --debug example.xml

[*] Test 'Default' starting with random seed 40441.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.StateModel Run(): Changing to state "Initial".
Peach.Core.Dom.Action Run(Action): Output
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Publishers.ConsolePublisher start()
Peach.Core.Publishers.ConsolePublisher open()
Peach.Core.Publishers.ConsolePublisher output(1 bytes)
00000000   65                                                 e
Peach.Core.Publishers.ConsolePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.ConsolePublisher stop()

[*] Test 'Default' finished.</screen>
</example>
<example>
<title>Naming A Sequence</title>
<simpara>Assign sequences a friendly name to make them easier to understand and debug.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
			 xsi:schemaLocation="http://peachfuzzer.com/2012/Peach /peach/peach.xsd"&gt;
	&lt;DataModel name="SequenceExample"&gt;
		&lt;Sequence name="MySeq"&gt;
			&lt;Number name="num" size="8" value="101"/&gt;
		&lt;/Sequence&gt;
	&lt;/DataModel&gt;

	&lt;StateModel name="TheState" initialState="Initial"&gt;
		&lt;State name="Initial"&gt;
			&lt;Action type="output"&gt;
				&lt;DataModel ref="SequenceExample"/&gt;
			&lt;/Action&gt;
		&lt;/State&gt;
	&lt;/StateModel&gt;

	&lt;Agent name="TheAgent" /&gt;

	&lt;Test name="Default"&gt;
		&lt;Agent ref="TheAgent"/&gt;

		&lt;StateModel ref="TheState"/&gt;

		&lt;Publisher class="ConsoleHex"/&gt;
	&lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Output from this example.</simpara>
<screen>&gt;peach -1 --debug example.xml

[*] Test 'Default' starting with random seed 30169.

[*] Test 'Default' starting with random seed 37527.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.StateModel Run(): Changing to state "Initial".
Peach.Core.Dom.Action Run(Action): Output
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Publishers.ConsolePublisher start()
Peach.Core.Publishers.ConsolePublisher open()
Peach.Core.Publishers.ConsolePublisher output(1 bytes)
00000000   65                                                 e
Peach.Core.Publishers.ConsolePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.ConsolePublisher stop()

[*] Test 'Default' finished.</screen>
</example>
<example>
<title>Nested Sequences</title>
<simpara>Sequences can be nested as deep as required. Sequences help create logical structure and do not change the data contained within.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach ../peach.xsd"&gt;

  &lt;DataModel name="SequenceExample"&gt;
    &lt;Sequence&gt;
      &lt;Sequence&gt;
        &lt;Sequence&gt;
          &lt;String value="1" /&gt;
        &lt;/Sequence&gt;

        &lt;Sequence&gt;
          &lt;String value="2" /&gt;
        &lt;/Sequence&gt;

        &lt;String value="3" /&gt;
      &lt;/Sequence&gt;
      &lt;String value="4" /&gt;
    &lt;/Sequence&gt;
  &lt;/DataModel&gt;

  &lt;StateModel name="TheState" initialState="initial"&gt;
    &lt;State name="initial"&gt;
      &lt;Action type="output" publisher="ConsolePub"&gt;
        &lt;DataModel ref="SequenceExample" /&gt;
      &lt;/Action&gt;
    &lt;/State&gt;
  &lt;/StateModel&gt;

  &lt;Test name="Default"&gt;
    &lt;StateModel ref="TheState"/&gt;

    &lt;Publisher class="ConsoleHex" name="ConsolePub"/&gt;
  &lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Output from this example.</simpara>
<screen>&gt;peach -1 --debug example.xml

[*] Test 'Default' starting with random seed 27277.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.StateModel Run(): Changing to state "initial".
Peach.Core.Dom.Action Run(Action): Output
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Publishers.ConsolePublisher start()
Peach.Core.Publishers.ConsolePublisher open()
Peach.Core.Publishers.ConsolePublisher output(4 bytes)
00000000   31 32 33 34                                        1234
Peach.Core.Publishers.ConsolePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.ConsolePublisher stop()

[*] Test 'Default' finished.</screen>
</example>
<example>
<title>Altering Sequence Values using Data Fields</title>
<simpara>Sequences values can be altered from the state model using data fields.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
			 xsi:schemaLocation="http://peachfuzzer.com/2012/Peach /peach/peach.xsd"&gt;
	&lt;DataModel name="SequenceExample"&gt;
		&lt;Sequence name="MySeq"&gt;
			&lt;String name="val1" value="Old"/&gt;
			&lt;String name="val2" value="OLDER"/&gt;
		&lt;/Sequence&gt;
	&lt;/DataModel&gt;

	&lt;StateModel name="TheState" initialState="Initial"&gt;
		&lt;State name="Initial"&gt;
			&lt;Action type="output"&gt;
				&lt;DataModel ref="SequenceExample"/&gt;
				&lt;Data&gt;
					&lt;Field name="MySeq[0]" value="Updated Value for val1"/&gt;
				&lt;/Data&gt;
			&lt;/Action&gt;
		&lt;/State&gt;
	&lt;/StateModel&gt;

	&lt;Agent name="TheAgent" /&gt;

	&lt;Test name="Default"&gt;
		&lt;Agent ref="TheAgent"/&gt;

		&lt;StateModel ref="TheState"/&gt;

		&lt;Publisher class="ConsoleHex"/&gt;
	&lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Output from this example.</simpara>
<screen>&gt;peach -1 --debug example.xml

[*] Test 'Default' starting with random seed 24392.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.StateModel Run(): Changing to state "Initial".
Peach.Core.Dom.Action Run(Action): Output
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Publishers.ConsolePublisher start()
Peach.Core.Publishers.ConsolePublisher open()
Peach.Core.Publishers.ConsolePublisher output(27 bytes)
00000000   55 70 64 61 74 65 64 20  56 61 6C 75 65 20 66 6F   Updated Value fo
00000010   72 20 76 61 6C 31 4F 4C  44 45 52                  r val1OLDER
Peach.Core.Publishers.ConsolePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.ConsolePublisher stop()

[*] Test 'Default' finished.</screen>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Stream">
<title>Stream</title>
<simpara><emphasis>Streams</emphasis> are logical blocks of data that contain other data blocks (such as zip and audio/video [A/V] multimedia files). <emphasis>Stream</emphasis> elements are used to represent streams in a single model.</simpara>
<simpara>Like <link linkend="Block">Block</link> elements, <emphasis>Stream</emphasis> elements allow groupings of one or more data elements in a logical structure, in this case to represent the content of the stream.</simpara>
<simpara><emphasis>Stream</emphasis> elements have two additional pieces of metadata that <emphasis>Blocks</emphasis> lack, a stream name and a stream attribute. Stream-aware publishers can use the metadata and content to combine all streams in a data model into a single file. A single data model representing a zip file would use the <emphasis>Stream</emphasis> element to represent each file that makes up the zip file.</simpara>
<simpara><emphasis>Stream</emphasis> is a child element of either <link linkend="DataModel">DataModel</link> or <link linkend="Block">Block</link>.</simpara>
<simpara>The <link linkend="Publishers_Zip">Zip</link> publisher looks for Stream elements and creates a zip archive of all the streams in a model.</simpara>
<important>
<simpara>Zip is the only Peach-supplied publisher aware of <emphasis>Stream</emphasis> elements. If you wish to fuzz an A/V file, you will need to create your own publisher.</simpara>
</important>
<section xml:id="_syntax_65">
<title>Syntax</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;Stream streamName="TheStream"&gt;
  &lt;String value="Hello world!" /&gt;
&lt;/Block&gt;</programlisting>
</section>
<section xml:id="_attributes_50">
<title>Attributes</title>
<simpara><emphasis>Required:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>streamName</term>
<listitem>
<simpara>Name of the underlying stream</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term><link linkend="name">name</link></term>
<listitem>
<simpara>Name of the stream element.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="ref">ref</link></term>
<listitem>
<simpara>Reference to a <link linkend="DataModel">DataModel_Stream</link> to use as a template.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="length">length</link></term>
<listitem>
<simpara>Data element length.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="lengthType">lengthType</link></term>
<listitem>
<simpara>The unit of measure for the length attribute. The default value is bytes.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="constraint">constraint</link></term>
<listitem>
<simpara>Scripting expression that evaluates to true or false. Default is null.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="minOccurs">minOccurs</link></term>
<listitem>
<simpara>The minimum number of times this element must occur. Defaults to 1. <?asciidoc-br?></simpara>
<itemizedlist>
<listitem>
<simpara>Used to define arrays with variable size. Arrays defined by min/maxOccurs generally have a relation
defined.</simpara>
</listitem>
<listitem>
<simpara>Adding this attribute, even with a value of 1, converts the element to an array.</simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="maxOccurs">maxOccurs</link></term>
<listitem>
<simpara>The maximum number of times this element can occur. Defaults to 1. <?asciidoc-br?></simpara>
<itemizedlist>
<listitem>
<simpara>Used to define arrays with static size.</simpara>
</listitem>
<listitem>
<simpara>Adding this attribute, even with a value of 1, converts the element to an array.</simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="occurs">occurs</link></term>
<listitem>
<simpara>Actual occurrences of element. Defaults to 1. <?asciidoc-br?></simpara>
<itemizedlist>
<listitem>
<simpara>Used to define arrays with static size.</simpara>
</listitem>
<listitem>
<simpara>Adding this attribute, even with a value of 1, converts the element to an array.</simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="mutable">mutable</link></term>
<listitem>
<simpara>Is this data element changeable (should it be mutated), defaults to false.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>streamAttribute</term>
<listitem>
<simpara>Integer representing any underlying attribute of a stream, defaults to 0.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_child_elements_34">
<title>Child Elements</title>
<variablelist>
<varlistentry>
<term><link linkend="Analyzers">Analyzer</link></term>
<listitem>
<simpara>Analyzes current element post cracking, can dynamically change model.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Blob">Blob</link></term>
<listitem>
<simpara>Represents binary data (array of bytes) to create simple dumb fuzzers in Peach.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Block">Block</link></term>
<listitem>
<simpara>Groups one or more data elements in a logical structure.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Choice">Choice</link></term>
<listitem>
<simpara>Indicates all sub-elements are valid; but only one sub-element should be selected.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Fixup">Fixup</link></term>
<listitem>
<simpara>Perform dynamic transformations such as checksums and CRCs.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Flags">Flags</link></term>
<listitem>
<simpara>Defines a set of bit sized flags.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Hint">Hint</link></term>
<listitem>
<simpara>Provides information to mutators.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Number">Number</link></term>
<listitem>
<simpara>Defines a binary number of arbitrary bit size.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Padding">Padding</link></term>
<listitem>
<simpara>Pads variably sized blocks or data models for uniformity and consistency.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Placement">Placement</link></term>
<listitem>
<simpara>Relocates an element after it has been cracked.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Transformer">Transformer</link></term>
<listitem>
<simpara>Performs static transformations such as compression or encoding.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="XmlElement">XmlElement</link></term>
<listitem>
<simpara>Defines an XML element, the basic building block of XML documents.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_mutators_24">
<title>Mutators</title>
<simpara>The following mutators operate on this element type:</simpara>
<simpara><emphasis>Enabled when element is marked as an array</emphasis></simpara>
<variablelist>
<varlistentry>
<term><link linkend="Mutators_ArrayNumericalEdgeCasesMutator">ArrayNumericalEdgeCasesMutator</link></term>
<listitem>
<simpara>This mutator grows and shrinks an array to counts based on numerical edge cases.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_ArrayRandomizeOrderMutator">ArrayRandomizeOrderMutator</link></term>
<listitem>
<simpara>This mutator randomizes the order of items in an array.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_ArrayReverseOrderMutator">ArrayReverseOrderMutator</link></term>
<listitem>
<simpara>This mutator reverses the order of items in an array.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_ArrayVarianceMutator">ArrayVarianceMutator</link></term>
<listitem>
<simpara>This mutator grows and shrinks an array to a variance of counts based on the current size.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Used for all data elements</emphasis></simpara>
<variablelist>
<varlistentry>
<term><link linkend="Mutators_DataElementBitFlipper">DataElementBitFlipper</link></term>
<listitem>
<simpara>This mutator produces test cases by flipping bits in the output value.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_DataElementDuplicate">DataElementDuplicate</link></term>
<listitem>
<simpara>This mutator duplicates data elements.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_DataElementRemove">DataElementRemove</link></term>
<listitem>
<simpara>This mutator removes data elements.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_DataElementSwapNear">DataElementSwapNear</link></term>
<listitem>
<simpara>This mutator swaps data elements.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_SampleNinjaMutator">SampleNinjaMutator</link></term>
<listitem>
<simpara>This mutator combines data elements from different data sets.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Enabled when element is part of a size relation</emphasis></simpara>
<variablelist>
<varlistentry>
<term><link linkend="Mutators_SizedDataEdgeCase">SizedDataEdgeCase</link></term>
<listitem>
<simpara>This mutator causes the data portion of a relation to be sized as numerical edge cases.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_SizedDataVariance">SizedDataVariance</link></term>
<listitem>
<simpara>This mutator causes the data portion of a relation to be sized as numerical variances.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_SizedEdgeCase">SizedEdgeCase</link></term>
<listitem>
<simpara>This mutator changes both sides of the relation (data and value) to match numerical edge cases.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_SizedVariance">SizedVariance</link></term>
<listitem>
<simpara>This mutator changes both sides of the relation (data and value) to match numerical variances of the current size.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_background">
<title>Background</title>
<simpara>The Stream element is very similar to the <link linkend="Block">Block</link> element, except the Stream element includes two pieces of additional data: the streamName and the streamAttribute.</simpara>
<simpara>Conceptually, the following Stream and Block examples are very similar to one another.</simpara>
<simpara>Stream example:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;Stream name="TheStream" streamName="file1.txt" streamAttribute="100"&gt;
  &lt;String value="Hello World"/&gt;
  &lt;Transformer class="Base64Encode"/&gt;
&lt;/Stream&gt;</programlisting>
<simpara>Block example (compare this with the previous Stream definition):</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;Block name="TheStream"&gt;
  &lt;String name="Name" value="file1.txt"/&gt;
  &lt;Number name="Attribute" size="32" signed="false" value="100"/&gt;
  &lt;Block name="Content"&gt;
    &lt;String value="Hello World"/&gt;
    &lt;Transformer class="Base64Encode"/&gt;
  &lt;/Block&gt;
&lt;/Block&gt;</programlisting>
<simpara>The stream name, attribute and children all support fuzzing.</simpara>
<simpara>Additionally, relations and fixups can reference children of different streams.</simpara>
<simpara>The Stream element is intended for use by publishers that are stream aware (such as <link linkend="Publishers_Zip">Zip</link>). If the publisher is not stream aware, the stream element is treated exactly like a <link linkend="Block">Block</link>.</simpara>
</section>
<section xml:id="_examples_48">
<title>Examples</title>
<example>
<title>Stream with <link linkend="Publishers_Zip">Zip</link> publisher</title>
<simpara>The following definition produces a zip file containing a single entry <emphasis>file1.txt</emphasis> containing the string <emphasis>Hello World</emphasis>.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach ../peach.xsd"&gt;

  &lt;DataModel name="StreamExample1"&gt;
    &lt;Stream streamName="file1.txt"&gt;
      &lt;String value="Hello World"/&gt;
    &lt;/Stream&gt;
  &lt;/DataModel&gt;

  &lt;StateModel name="TheState" initialState="initial"&gt;
    &lt;State name="initial"&gt;
      &lt;Action type="output"&gt;
        &lt;DataModel ref="StreamExample1" /&gt;
      &lt;/Action&gt;
    &lt;/State&gt;
  &lt;/StateModel&gt;

  &lt;Test name="Default"&gt;
    &lt;StateModel ref="TheState"/&gt;

    &lt;Publisher class="Zip"&gt;
      &lt;Param name="FileName" value="fuzzed.zip" /&gt;
    &lt;/Publisher&gt;
  &lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Output from this example.</simpara>
<screen>&gt;peach -1 --debug example.xml

[*] Test 'Default' starting with random seed 59388.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Enterprise.Publishers.ZipPublisher start()
Peach.Enterprise.Publishers.ZipPublisher open()
Peach.Enterprise.Publishers.ZipPublisher Added 1 entries to zip file.
Peach.Enterprise.Publishers.ZipPublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Enterprise.Publishers.ZipPublisher stop()

[*] Test 'Default' finished.</screen>
</example>
<example>
<title>Stream with <link linkend="Publishers_ConsoleHex">ConsoleHex</link> publisher</title>
<simpara>Streams are treated like blocks when used with publishers that are not stream aware.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach ../peach.xsd"&gt;

  &lt;DataModel name="StreamExample2"&gt;
    &lt;Stream streamName="file1.txt"&gt;
      &lt;String value="Hello World"/&gt;
    &lt;/Stream&gt;
  &lt;/DataModel&gt;

  &lt;StateModel name="TheState" initialState="initial"&gt;
    &lt;State name="initial"&gt;
      &lt;Action type="output" publisher="ConsolePub"&gt;
        &lt;DataModel ref="StreamExample2" /&gt;
      &lt;/Action&gt;
    &lt;/State&gt;
  &lt;/StateModel&gt;

  &lt;Test name="Default"&gt;
    &lt;StateModel ref="TheState"/&gt;

    &lt;Publisher class="ConsoleHex" name="ConsolePub"/&gt;
  &lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Output from this example.</simpara>
<screen>&gt;peach -1 --debug example.xml

[*] Test 'Default' starting with random seed 30169.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher start()
Peach.Core.Publishers.ConsolePublisher open()
Peach.Core.Publishers.ConsolePublisher output(11 bytes)
00000000   48 65 6C 6C 6F 20 57 6F  72 6C 64                  Hello World
Peach.Core.Publishers.ConsolePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.ConsolePublisher stop()

[*] Test 'Default' finished.</screen>
</example>
<example>
<title>Multiple streams</title>
<simpara>Produce a zip file containing multiple files.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach ../peach.xsd"&gt;

  &lt;DataModel name="StreamExample3"&gt;
    &lt;Stream streamName="file1.txt"&gt;
      &lt;String value="Root file one"/&gt;
    &lt;/Stream&gt;
    &lt;Stream streamName="dir/file1.txt"&gt;
      &lt;String value="File one in subdirectory"/&gt;
    &lt;/Stream&gt;
    &lt;Stream streamName="dir/file2.txt"&gt;
      &lt;String value="File two in subdirectory"/&gt;
    &lt;/Stream&gt;
  &lt;/DataModel&gt;

  &lt;StateModel name="TheState" initialState="initial"&gt;
    &lt;State name="initial"&gt;
      &lt;Action type="output"&gt;
        &lt;DataModel ref="StreamExample3" /&gt;
      &lt;/Action&gt;
    &lt;/State&gt;
  &lt;/StateModel&gt;

  &lt;Test name="Default"&gt;
    &lt;StateModel ref="TheState"/&gt;

    &lt;Publisher class="Zip"&gt;
      &lt;Param name="FileName" value="fuzzed.zip" /&gt;
    &lt;/Publisher&gt;
  &lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Output from this example.</simpara>
<screen>&gt;peach -1 --debug example.xml

[*] Test 'Default' starting with random seed 58326.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Enterprise.Publishers.ZipPublisher start()
Peach.Enterprise.Publishers.ZipPublisher open()
Peach.Enterprise.Publishers.ZipPublisher Added 3 entries to zip file.
Peach.Enterprise.Publishers.ZipPublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Enterprise.Publishers.ZipPublisher stop()

[*] Test 'Default' finished.</screen>
<simpara>Contents of produced <literal>fuzzed.zip</literal></simpara>
<screen>&gt; unzip -l fuzzed.zip
Archive:  fuzzed.zip
  Length      Date    Time    Name
---------  ---------- -----   ----
       13  04-09-2014 18:14   file1.txt
       24  04-09-2014 18:14   dir/file1.txt
       24  04-09-2014 18:14   dir/file2.txt
---------                     -------
       61                     3 files</screen>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="String">
<title>String</title>
<simpara>A string containing ASCII or Unicode characters. Strings can be null terminated, padded, with or without a fixed length.</simpara>
<simpara>All strings are encoded prior to output with the default 7-bit ASCII encoding (aka Latin-1). A number of different Unicode encodings are also supported (see the <emphasis>type</emphasis> attribute).</simpara>
<simpara>Strings can hold numbers that are stored in a string format. When strings contain a number, Peach additionally uses  numerical mutators to mutate the strings.</simpara>
<section xml:id="_syntax_66">
<title>Syntax</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;String value="Hello World!" /&gt;

&lt;String value="Null terminated string" nullTerminated="true" /&gt;</programlisting>
</section>
<section xml:id="_attributes_51">
<title>Attributes</title>
<simpara><emphasis>Required:</emphasis></simpara>
<simpara>None.</simpara>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term><link linkend="name">name</link></term>
<listitem>
<simpara>Name of the string.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="length">length</link></term>
<listitem>
<simpara>Length of the string, typically expressed as bytes. The default length is unspecified. The units of measure for length are specified in the <emphasis>lengthType</emphasis> attribute.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="lengthType">lengthType</link></term>
<listitem>
<simpara>Units of measure of the length attribute. Valid values are bits-in multiples of 8, bytes, and chars. The default value is bytes.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>type</term>
<listitem>
<simpara>Character encoding type, defaults to <emphasis>utf8</emphasis>. Valid options are: ascii, utf7, utf8, utf16, utf16be, utf32. 	+
Before strings are output, they are first encoded. The default encoding is utf-8. Most common ASCII and Unicode encodings are supported.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="value">value</link></term>
<listitem>
<simpara>The default value, defaults to "".</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="valueType">valueType</link></term>
<listitem>
<simpara>Format of the <emphasis>value</emphasis> attribute, defaults to string.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>nullTerminated</term>
<listitem>
<simpara>Specifies whether this string is null terminated. Valid values are true and false, defaults to false.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>The <emphasis>nullTerminated</emphasis> attribute indicates the produced string should be null terminated.</simpara>
<note>
<simpara>Only the final value has the null terminator applied. If the value is accessed, the internal value will not have the null attached.</simpara>
</note>
<note>
<simpara>When the <emphasis>nullTerminated</emphasis> attribute is provided, the <link linkend="String">String</link> must not specify a <link linkend="length">length</link>; these two attributes are mutually exclusive.</simpara>
</note>
<variablelist>
<varlistentry>
<term>padCharacter</term>
<listitem>
<simpara>Character to use as padding at the end of the string, defaults to null (0x00).<?asciidoc-br?>
If the <emphasis>length</emphasis> attribute is provided and the value contained in the string is shorter than the length, the string is padded to fill the length.
This attribute allows controlling the character used to pad the string.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="token">token</link></term>
<listitem>
<simpara>This element should be treated as a token when parsing. Valid values are true and false, defaults to false.	+
This attribute is primarily used to assist in cracking strings when consuming input in a model.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="constraint">constraint</link></term>
<listitem>
<simpara>Scripting expression that evaluates to true or false. The default value is "", meaning that a constraint is not defined.<?asciidoc-br?>
This attribute is used exclusively during data cracking and has two main uses:</simpara>
<itemizedlist>
<listitem>
<simpara>Provides switch-like processing when combined with the <link linkend="Choice">Choice</link> element;</simpara>
</listitem>
<listitem>
<simpara>Controls array expansion.</simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>
<note>
<simpara>This expression does not control or affect mutated values in anyway.</simpara>
</note>
<variablelist>
<varlistentry>
<term><link linkend="mutable">mutable</link></term>
<listitem>
<simpara>Should this data element be mutated (or, is it changeable)? Valid values are true and false, defaults to true.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="minOccurs">minOccurs</link></term>
<listitem>
<simpara>The minimum number of times this element must occur. Defaults to 1. <?asciidoc-br?></simpara>
<itemizedlist>
<listitem>
<simpara>Used to define arrays with variable size. Arrays defined by min/maxOccurs generally have a relation
defined.</simpara>
</listitem>
<listitem>
<simpara>Adding this attribute, even with a value of 1, converts the element to an array.</simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="maxOccurs">maxOccurs</link></term>
<listitem>
<simpara>The maximum number of times this element can occur. Defaults to 1. <?asciidoc-br?></simpara>
<itemizedlist>
<listitem>
<simpara>Used to define arrays with static size.</simpara>
</listitem>
<listitem>
<simpara>Adding this attribute, even with a value of 1, converts the element to an array.</simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="occurs">occurs</link></term>
<listitem>
<simpara>Actual occurrences of element. Defaults to 1. <?asciidoc-br?></simpara>
<itemizedlist>
<listitem>
<simpara>Used to define arrays with static size.</simpara>
</listitem>
<listitem>
<simpara>Adding this attribute, even with a value of 1, converts the element to an array.</simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_child_elements_35">
<title>Child Elements</title>
<variablelist>
<varlistentry>
<term><link linkend="Analyzers">Analyzer</link></term>
<listitem>
<simpara>Attaches an analyzer to this element</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Fixup">Fixup</link></term>
<listitem>
<simpara>Performs dynamic transformations such as checksums and CRCs.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Hint">Hint</link></term>
<listitem>
<simpara>Provides information to mutators.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Placement">Placement</link></term>
<listitem>
<simpara>Relocates an element after it has been cracked.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Relation">Relation</link></term>
<listitem>
<simpara>Identifies a type of relationship with another data element (such as count).</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Transformer">Transformer</link></term>
<listitem>
<simpara>Performs static transformations such as compression or encoding.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_mutators_25">
<title>Mutators</title>
<simpara>The following mutators operate on this element type:</simpara>
<simpara><emphasis>Enabled when element is marked as an array</emphasis></simpara>
<variablelist>
<varlistentry>
<term><link linkend="Mutators_ArrayNumericalEdgeCasesMutator">ArrayNumericalEdgeCasesMutator</link></term>
<listitem>
<simpara>This mutator grows and shrinks an array to counts based on numerical edge cases.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_ArrayRandomizeOrderMutator">ArrayRandomizeOrderMutator</link></term>
<listitem>
<simpara>This mutator randomizes the order of items in an array.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_ArrayReverseOrderMutator">ArrayReverseOrderMutator</link></term>
<listitem>
<simpara>This mutator reverses the order of items in an array.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_ArrayVarianceMutator">ArrayVarianceMutator</link></term>
<listitem>
<simpara>This mutator grows and shrinks an array to a variance of counts based on the current size.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Used for all data elements</emphasis></simpara>
<variablelist>
<varlistentry>
<term><link linkend="Mutators_DataElementBitFlipper">DataElementBitFlipper</link></term>
<listitem>
<simpara>This mutator produces test cases by flipping bits in the output value.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_DataElementDuplicate">DataElementDuplicate</link></term>
<listitem>
<simpara>This mutator duplicates data elements.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_DataElementRemove">DataElementRemove</link></term>
<listitem>
<simpara>This mutator removes data elements.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_DataElementSwapNear">DataElementSwapNear</link></term>
<listitem>
<simpara>This mutator swaps data elements.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_SampleNinjaMutator">SampleNinjaMutator</link></term>
<listitem>
<simpara>This mutator combines data elements from different data sets.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Enabled when element is part of a size relation</emphasis></simpara>
<variablelist>
<varlistentry>
<term><link linkend="Mutators_SizedDataEdgeCase">SizedDataEdgeCase</link></term>
<listitem>
<simpara>This mutator causes the data portion of a relation to be sized as numerical edge cases.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_SizedDataVariance">SizedDataVariance</link></term>
<listitem>
<simpara>This mutator causes the data portion of a relation to be sized as numerical variances.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_SizedEdgeCase">SizedEdgeCase</link></term>
<listitem>
<simpara>This mutator changes both sides of the relation (data and value) to match numerical edge cases.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_SizedVariance">SizedVariance</link></term>
<listitem>
<simpara>This mutator changes both sides of the relation (data and value) to match numerical variances of the current size.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Specific to this element type</emphasis></simpara>
<variablelist>
<varlistentry>
<term><link linkend="Mutators_ExtraValues">ExtraValues</link></term>
<listitem>
<simpara>This mutator provides extra test case values on a per-data element basis.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_StringAsciiRandom">StringAsciiRandom</link></term>
<listitem>
<simpara>This mutator generates strings with random ASCII characters.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_StringCaseLower">StringCaseLower</link></term>
<listitem>
<simpara>This mutator generates a lower case version of the current value.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_StringCaseRandom">StringCaseRandom</link></term>
<listitem>
<simpara>This mutator generates a randomized case version of the current value.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_StringCaseUpper">StringCaseUpper</link></term>
<listitem>
<simpara>This mutator generates an upper case version of the current value.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_StringLengthEdgeCase">StringLengthEdgeCase</link></term>
<listitem>
<simpara>This mutator generates strings with lengths based on numerical edge cases.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_StringLengthVariance">StringLengthVariance</link></term>
<listitem>
<simpara>This mutator generates strings with lengths based on a variance around the current string length.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_StringList">StringList</link></term>
<listitem>
<simpara>This mutator allows providing a list of strings to use as test cases on an element by element basis.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_StringStatic">StringStatic</link></term>
<listitem>
<simpara>This mutator generates test cases using a static set of strings.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_StringUnicodeAbstractCharacters">StringUnicodeAbstractCharacters</link></term>
<listitem>
<simpara>This mutator generates Unicode strings using abstract characters.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_StringUnicodeFormatCharacters">StringUnicodeFormatCharacters</link></term>
<listitem>
<simpara>This mutator generates Unicode strings using format characters.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_StringUnicodeInvalid">StringUnicodeInvalid</link></term>
<listitem>
<simpara>This mutator generates Unicode strings using invalid characters.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_StringUnicodeNonCharacters">StringUnicodeNonCharacters</link></term>
<listitem>
<simpara>This mutator generates Unicode strings using non-characters.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_StringUnicodePlane0">StringUnicodePlane0</link></term>
<listitem>
<simpara>This mutator generates Unicode strings using Plane 0 characters.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_StringUnicodePlane1">StringUnicodePlane1</link></term>
<listitem>
<simpara>This mutator generates Unicode strings using Plane 1 characters.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_StringUnicodePlane14">StringUnicodePlane14</link></term>
<listitem>
<simpara>This mutator generates Unicode strings using Plan 14 characters.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_StringUnicodePlane15And16">StringUnicodePlane15And16</link></term>
<listitem>
<simpara>This mutator generates Unicode strings using Plane 15 and 16 characters.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_StringUnicodePlane2">StringUnicodePlane2</link></term>
<listitem>
<simpara>This mutator generates Unicode strings using Plane 2 characters.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_StringUnicodePrivateUseArea">StringUnicodePrivateUseArea</link></term>
<listitem>
<simpara>This mutator generates Unicode characters from the private use area.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_StringXmlW3C">StringXmlW3C</link></term>
<listitem>
<simpara>This mutator provides the W3C XML parser unit tests. Must be specifically enabled.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_49">
<title>Examples</title>
<example>
<title>Simple ASCII String</title>
<simpara>This example outputs a string with minimal attribute declarations. Other than the <emphasis>value</emphasis> attribute, the string uses  default values for its attributes. The string consists of 7-bit ASCII characters.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

	&lt;DataModel name="TheDataModel"&gt;
		&lt;String value="Hello World!" /&gt;
	&lt;/DataModel&gt;

	&lt;StateModel name="TheStateModel" initialState="InitialState" &gt;
		&lt;State name="InitialState"&gt;
			&lt;Action type="output"&gt;
				&lt;DataModel ref="TheDataModel"/&gt;
			&lt;/Action&gt;
		&lt;/State&gt;
	&lt;/StateModel&gt;

	&lt;Test name="Default"&gt;
		&lt;StateModel ref="TheStateModel"/&gt;

		&lt;Publisher class="ConsoleHex" /&gt;
	&lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Produces the following output:</simpara>
<screen>&gt; peach -1 --debug example.xml

[*] Test 'Default' starting with random seed 25723.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher start()
Peach.Core.Publishers.ConsolePublisher open()
Peach.Core.Publishers.ConsolePublisher output(12 bytes)
00000000   48 65 6C 6C 6F 20 57 6F  72 6C 64 21               Hello World!
Peach.Core.Publishers.ConsolePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.ConsolePublisher stop()

[*] Test 'Default' finished.</screen>
</example>
<example>
<title>String with UTF-16 Encoding</title>
<simpara>This example outputs a string consisting of characters represented with Unicode UTF-16 encoding. UTF-16 is a two-byte character encoding that supports Latin and non-Latin character sets. Also, UTF-16 is the WCHAR type on the Windows operating systems.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

	&lt;DataModel name="TheDataModel"&gt;
		&lt;String type="utf16" value="Hello World!" /&gt;
	&lt;/DataModel&gt;

	&lt;StateModel name="TheStateModel" initialState="InitialState" &gt;
		&lt;State name="InitialState"&gt;
			&lt;Action type="output"&gt;
				&lt;DataModel ref="TheDataModel"/&gt;
			&lt;/Action&gt;
		&lt;/State&gt;
	&lt;/StateModel&gt;

	&lt;Test name="Default"&gt;
		&lt;StateModel ref="TheStateModel"/&gt;

		&lt;Publisher class="ConsoleHex" /&gt;
	&lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Produces the following output:</simpara>
<screen>&gt; peach -1 --debug example.xml

[*] Test 'Default' starting with random seed 57920.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher start()
Peach.Core.Publishers.ConsolePublisher open()
Peach.Core.Publishers.ConsolePublisher output(24 bytes)
00000000   48 00 65 00 6C 00 6C 00  6F 00 20 00 57 00 6F 00   H?e?l?l?o? ?W?o?
00000010   72 00 6C 00 64 00 21 00                            r?l?d?!?
Peach.Core.Publishers.ConsolePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.ConsolePublisher stop()

[*] Test 'Default' finished.</screen>
</example>
<example>
<title>Null Terminated String</title>
<simpara>This example outputs a null-terminated string.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

	&lt;DataModel name="TheDataModel"&gt;
		&lt;String nullTerminated="true" value="Hello World!" /&gt;
	&lt;/DataModel&gt;

	&lt;StateModel name="TheStateModel" initialState="InitialState" &gt;
		&lt;State name="InitialState"&gt;
			&lt;Action type="output"&gt;
				&lt;DataModel ref="TheDataModel"/&gt;
			&lt;/Action&gt;
		&lt;/State&gt;
	&lt;/StateModel&gt;

	&lt;Test name="Default"&gt;
		&lt;StateModel ref="TheStateModel"/&gt;

		&lt;Publisher class="ConsoleHex" /&gt;
	&lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Produces the following output:</simpara>
<screen>&gt; peach -1 --debug example.xml

[*] Test 'Default' starting with random seed 53517.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher start()
Peach.Core.Publishers.ConsolePublisher open()
Peach.Core.Publishers.ConsolePublisher output(13 bytes)
00000000   48 65 6C 6C 6F 20 57 6F  72 6C 64 21 00            Hello World!?
Peach.Core.Publishers.ConsolePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.ConsolePublisher stop()

[*] Test 'Default' finished.</screen>
</example>
<example>
<title>String Padded with Default Character</title>
<simpara>This example outputs a string that is shorter than the required length. The string receives one or more pad characters to reach its required length. The default pad character is null (0x00).</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

	&lt;DataModel name="TheDataModel"&gt;
		&lt;String length="20" value="Hello World!" /&gt;
	&lt;/DataModel&gt;

	&lt;StateModel name="TheStateModel" initialState="InitialState" &gt;
		&lt;State name="InitialState"&gt;
			&lt;Action type="output"&gt;
				&lt;DataModel ref="TheDataModel"/&gt;
			&lt;/Action&gt;
		&lt;/State&gt;
	&lt;/StateModel&gt;

	&lt;Test name="Default"&gt;
		&lt;StateModel ref="TheStateModel"/&gt;

		&lt;Publisher class="ConsoleHex" /&gt;
	&lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Produces the following output:</simpara>
<screen>&gt; peach -1 --debug example.xml

[*] Test 'Default' starting with random seed 43832.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher start()
Peach.Core.Publishers.ConsolePublisher open()
Peach.Core.Publishers.ConsolePublisher output(20 bytes)
00000000   48 65 6C 6C 6F 20 57 6F  72 6C 64 21 00 00 00 00   Hello World!????
00000010   00 00 00 00                                        ????
Peach.Core.Publishers.ConsolePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.ConsolePublisher stop()

[*] Test 'Default' finished.</screen>
</example>
<example>
<title>String Padded with Specified Character</title>
<simpara>This example output a string that is shorter than the required length. The string receives one or more pad characters to reach its required length. Unlike the earlier example, we define the pad character as <emphasis>_</emphasis>, thus overriding the default pad character.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

	&lt;DataModel name="TheDataModel"&gt;
		&lt;String length="20" padCharacter="_" value="Hello World!" /&gt;
	&lt;/DataModel&gt;

	&lt;StateModel name="TheStateModel" initialState="InitialState" &gt;
		&lt;State name="InitialState"&gt;
			&lt;Action type="output"&gt;
				&lt;DataModel ref="TheDataModel"/&gt;
			&lt;/Action&gt;
		&lt;/State&gt;
	&lt;/StateModel&gt;

	&lt;Test name="Default"&gt;
		&lt;StateModel ref="TheStateModel"/&gt;

		&lt;Publisher class="ConsoleHex" /&gt;
	&lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Produces the following output:</simpara>
<screen>&gt; peach -1 --debug example.xml

[*] Test 'Default' starting with random seed 62597.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher start()
Peach.Core.Publishers.ConsolePublisher open()
Peach.Core.Publishers.ConsolePublisher output(20 bytes)
00000000   48 65 6C 6C 6F 20 57 6F  72 6C 64 21 5F 5F 5F 5F   Hello World!____
00000010   5F 5F 5F 5F                                        ____
Peach.Core.Publishers.ConsolePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.ConsolePublisher stop()

[*] Test 'Default' finished.</screen>
</example>
<example>
<title>String with Backslash Characters</title>
<simpara>This example outputs a string that contains carriage return and line feed characters using the <literal>\r</literal> and <literal>\n</literal> notation. Also, the output string includes a backslash character (<literal>\</literal>).</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

	&lt;DataModel name="TheDataModel"&gt;
		&lt;String value="This is the first line\nAnd this is the second line\n\rThis is backslash \\." /&gt;
	&lt;/DataModel&gt;

	&lt;StateModel name="TheStateModel" initialState="InitialState" &gt;
		&lt;State name="InitialState"&gt;
			&lt;Action type="output"&gt;
				&lt;DataModel ref="TheDataModel"/&gt;
			&lt;/Action&gt;
		&lt;/State&gt;
	&lt;/StateModel&gt;

	&lt;Test name="Default"&gt;
		&lt;StateModel ref="TheStateModel"/&gt;

		&lt;Publisher class="Console" /&gt;
	&lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Produces the following output:</simpara>
<screen>&gt; peach -1 --debug example.xml

[*] Test 'Default' starting with random seed 29966.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher start()
Peach.Core.Publishers.ConsolePublisher open()
Peach.Core.Publishers.ConsolePublisher output(72 bytes)
This is the first line
And this is the second line
This is backslash \.Peach.Core.Publishers.ConsolePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.ConsolePublisher stop()

[*] Test 'Default' finished.</screen>
</example>
<example>
<title>String with Size-Of Relation</title>
<simpara>In this example, a the DataModel declares a String element that contains the ASCII length of some data. A size-of relation is used to allow the size to dynamically update during fuzzing.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

	&lt;DataModel name="TheDataModel"&gt;
		&lt;String name="Length"&gt;
			&lt;Relation type="size" of="Data" /&gt;
		&lt;/String&gt;

		&lt;String value="\n" /&gt;

		&lt;Block name="Data"&gt;
			&lt;String value="This is some data!" /&gt;
			&lt;String value=" And this is even more data!" /&gt;
		&lt;/Block&gt;
	&lt;/DataModel&gt;

	&lt;StateModel name="TheStateModel" initialState="InitialState" &gt;
		&lt;State name="InitialState"&gt;
			&lt;Action type="output"&gt;
				&lt;DataModel ref="TheDataModel"/&gt;
			&lt;/Action&gt;
		&lt;/State&gt;
	&lt;/StateModel&gt;

	&lt;Test name="Default"&gt;
		&lt;StateModel ref="TheStateModel"/&gt;

		&lt;Publisher class="Console" /&gt;
	&lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Produces the following output:</simpara>
<screen>&gt; peach -1 --debug example.xml

[*] Test 'Default' starting with random seed 2887.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher start()
Peach.Core.Publishers.ConsolePublisher open()
Peach.Core.Publishers.ConsolePublisher output(49 bytes)
46
This is some data! And this is even more data!Peach.Core.Publishers.ConsolePubli
sher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.ConsolePublisher stop()

[*] Test 'Default' finished.</screen>
</example>
<example>
<title>Using token Attribute to Crack Strings</title>
<simpara>In this example, Peach parses a simple text string using the <emphasis>token</emphasis> attribute. This example uses two files, a file containing sample data called <literal>string.txt</literal> and the pit file <literal>example.xml</literal>. The sample string to parse consists of three parts: 1)the key, 2)the token separator, and 3)a value.</simpara>
<simpara>Potentially, the key and value can be any arbitrary size, so cracking this sample string requires knowledge about the token separator. In the pit file, the string that is used as a token includes the <emphasis>token</emphasis> attribute to indicate that the token must be present in the incoming data stream. This allows the data cracker to figure out the length of both the key and the value.</simpara>
<tip>
<simpara>Peach fuzzes elements marked as <emphasis>token</emphasis>.</simpara>
</tip>
<formalpara>
<title>string.txt</title>
<para>
<screen>Content-length: 10</screen>
</para>
</formalpara>
<formalpara>
<title>example.xml</title>
<para>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

	&lt;DataModel name="TheDataModel"&gt;
		&lt;String name="Key"/&gt;

		&lt;String value=":" token="true" /&gt;

		&lt;String name="Value"/&gt;
	&lt;/DataModel&gt;

	&lt;StateModel name="TheStateModel" initialState="InitialState" &gt;
		&lt;State name="InitialState"&gt;
			&lt;Action type="output"&gt;
				&lt;DataModel ref="TheDataModel"/&gt;
				&lt;Data fileName="string.txt" /&gt;
			&lt;/Action&gt;
		&lt;/State&gt;
	&lt;/StateModel&gt;

	&lt;Test name="Default"&gt;
		&lt;StateModel ref="TheStateModel"/&gt;

		&lt;Publisher class="Console" /&gt;
	&lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
</para>
</formalpara>
<simpara>Produces the following output:</simpara>
<screen>&gt; peach -1 --debug example.xml

[*] Test 'Default' starting with random seed 18622.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker DataModel 'TheDataModel' Bytes: 0/21, Bits: 0/168

Peach.Core.Cracker.DataCracker getSize: -----&gt; DataModel 'TheDataModel'
Peach.Core.Cracker.DataCracker scan: DataModel 'TheDataModel'
Peach.Core.Cracker.DataCracker scan: String 'TheDataModel.Key' -&gt; Offset: 0, Unsized element
Peach.Core.Cracker.DataCracker getSize: &lt;----- Deterministic: ???
Peach.Core.Cracker.DataCracker Crack: DataModel 'TheDataModel' Size: &lt;null&gt;, Bytes: 0/21, Bits: 0/168
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker String 'TheDataModel.Key' Bytes: 0/21, Bits: 0/168
Peach.Core.Cracker.DataCracker getSize: -----&gt; String 'TheDataModel.Key'
Peach.Core.Cracker.DataCracker scan: String 'TheDataModel.Key' -&gt; Offset: 0, Unsized element
Peach.Core.Cracker.DataCracker lookahead: String 'TheDataModel.Key'
Peach.Core.Cracker.DataCracker scan: String 'TheDataModel.DataElement_0' -&gt; Pos: 0, Saving Token
Peach.Core.Cracker.DataCracker scan: String 'TheDataModel.DataElement_0' -&gt; Pos: 8, Length: 8
Peach.Core.Cracker.DataCracker scan: String 'TheDataModel.Value' -&gt; Offset: 8, Unsized element
Peach.Core.Cracker.DataCracker getSize: &lt;----- Required Token: 112
Peach.Core.Cracker.DataCracker Crack: String 'TheDataModel.Key' Size: 112, Bytes: 0/21, Bits: 0/168
Peach.Core.Dom.DataElement String 'TheDataModel.Key' value is: Content-length <co xml:id="CO28-1"/>
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker String 'TheDataModel.DataElement_0' Bytes: 14/21, Bits: 112/168
Peach.Core.Cracker.DataCracker getSize: -----&gt; String 'TheDataModel.DataElement_0'
Peach.Core.Cracker.DataCracker scan: String 'TheDataModel.DataElement_0' -&gt; Pos: 0, Saving Token
Peach.Core.Cracker.DataCracker scan: String 'TheDataModel.DataElement_0' -&gt; Pos: 8, Length: 8
Peach.Core.Cracker.DataCracker getSize: &lt;----- Size: 8
Peach.Core.Cracker.DataCracker Crack: String 'TheDataModel.DataElement_0' Size:8, Bytes: 14/21, Bits: 112/168
Peach.Core.Dom.DataElement String 'TheDataModel.DataElement_0' value is: : <co xml:id="CO28-2"/>
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker String 'TheDataModel.Value' Bytes: 15/21, Bits: 120/168
Peach.Core.Cracker.DataCracker getSize: -----&gt; String 'TheDataModel.Value'
Peach.Core.Cracker.DataCracker scan: String 'TheDataModel.Value' -&gt; Offset: 0, Unsized element
Peach.Core.Cracker.DataCracker lookahead: String 'TheDataModel.Value'
Peach.Core.Cracker.DataCracker getSize: &lt;----- Last Unsized: 48
Peach.Core.Cracker.DataCracker Crack: String 'TheDataModel.Value' Size: 48, Bytes: 15/21, Bits: 120/168
Peach.Core.Dom.DataElement String 'TheDataModel.Value' value is:  10 <co xml:id="CO28-3"/>

Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher start()
Peach.Core.Publishers.ConsolePublisher open()
Peach.Core.Publishers.ConsolePublisher output(21 bytes)
Content-length: 10
Peach.Core.Publishers.ConsolePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.ConsolePublisher stop()

[*] Test 'Default' finished.</screen>
<calloutlist>
<callout arearefs="CO28-1">
<para>Cracking "Content-length" into <emphasis>Key</emphasis></para>
</callout>
<callout arearefs="CO28-2">
<para>Cracking ":" into token string</para>
</callout>
<callout arearefs="CO28-3">
<para>Cracking "10\n" into <emphasis>Value</emphasis></para>
</callout>
</calloutlist>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="VarNumber">
<title>VarNumber</title>
<simpara>The <emphasis>VarNumber</emphasis> element defines a variable width binary number of any arbitrary bit size from 1 to 64. Binary numbers are packed into a byte representation with a byte order of little-endian or big-endian.</simpara>
<simpara><emphasis>VarNumber</emphasis> is similar to <link linkend="Number">Number</link> except the size is not hard coded and instead is driven by a method such as a size-of relation or limit of available data.</simpara>
<simpara>The <emphasis>VarNumber</emphasis> element should not be used for character-based numbers, or ASCII numbers. Instead, use a <link linkend="String">String</link> element.</simpara>
<simpara>See also <link linkend="Number">Number</link>.</simpara>
<note>
<simpara>While Peach supports unaligned data structures, using unaligned data incurs a performance penalty. The penalty stems from bit slicing that occurs behind the scenes.</simpara>
</note>
<section xml:id="_syntax_67">
<title>Syntax</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;Number name="SizeOfAlmondsNumber" size="4" endian="big" signed="false"&gt;
    &lt;Relation type="size" of="Almonds" /&gt;
&lt;/Number&gt;

&lt;VarNumber name="Almonds" endian="big" signed="false" /&gt;</programlisting>
</section>
<section xml:id="_attributes_52">
<title>Attributes</title>
<simpara><emphasis>Required:</emphasis></simpara>
<simpara>No required attributes.</simpara>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term><link linkend="name">name</link></term>
<listitem>
<simpara>Name of the number.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="value">value</link></term>
<listitem>
<simpara>The default value to assign to the number.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="valueType">valueType</link></term>
<listitem>
<simpara>The representation of the value. Valid options are string and hex.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="token">token</link></term>
<listitem>
<simpara>This element is treated as a token when parsing. Valid values are true and false, defaults to false.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="endian">endian</link></term>
<listitem>
<simpara>Byte order of the number. Valid options are big, little, and network. Network is an alias for big. The default value is little.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="signed">signed</link></term>
<listitem>
<simpara>The number is signed or unsigned. Valid values are true and false, defaults to false.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="constraint">constraint</link></term>
<listitem>
<simpara>A constraint in the form of a python expression. Used during data cracking.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="mutable">mutable</link></term>
<listitem>
<simpara>Is data element changeable (should it be mutated during fuzzing). Valid values are true and false, defaults to true.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="minOccurs">minOccurs</link></term>
<listitem>
<simpara>The minimum number of times this element must occur. Defaults to 1. <?asciidoc-br?></simpara>
<itemizedlist>
<listitem>
<simpara>Used to define arrays with variable size. Arrays defined by min/maxOccurs generally have a relation
defined.</simpara>
</listitem>
<listitem>
<simpara>Adding this attribute, even with a value of 1, converts the element to an array.</simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="maxOccurs">maxOccurs</link></term>
<listitem>
<simpara>The maximum number of times this element can occur.<?asciidoc-br?></simpara>
<itemizedlist>
<listitem>
<simpara>Used to define arrays with static size.</simpara>
</listitem>
<listitem>
<simpara>Adding this attribute, even with a value of 1, converts the element to an array.</simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="occurs">occurs</link></term>
<listitem>
<simpara>Actual occurrences of element. Defaults to 1. <?asciidoc-br?></simpara>
<itemizedlist>
<listitem>
<simpara>Used to define arrays with static size.</simpara>
</listitem>
<listitem>
<simpara>Adding this attribute, even with a value of 1, converts the element to an array.</simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_child_elements_36">
<title>Child Elements</title>
<variablelist>
<varlistentry>
<term><link linkend="Analyzers">Analyzer</link></term>
<listitem>
<simpara>Analyzes current element post cracking, can dynamically change model.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Fixup">Fixup</link></term>
<listitem>
<simpara>Performs dynamic transformations such as checksums and CRCs.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Hint">Hint</link></term>
<listitem>
<simpara>Provides information to mutators.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Placement">Placement</link></term>
<listitem>
<simpara>Relocates an element after it has been cracked.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Relation">Relation</link></term>
<listitem>
<simpara>Identifies a type of relationship with another data element (such as count).</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Transformer">Transformer</link></term>
<listitem>
<simpara>Performs static transformations such as compression or encoding.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_mutators_26">
<title>Mutators</title>
<simpara>The following mutators operate on this element type:</simpara>
<simpara><emphasis>Enabled when element is marked as an array</emphasis></simpara>
<variablelist>
<varlistentry>
<term><link linkend="Mutators_ArrayNumericalEdgeCasesMutator">ArrayNumericalEdgeCasesMutator</link></term>
<listitem>
<simpara>This mutator grows and shrinks an array to counts based on numerical edge cases.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_ArrayRandomizeOrderMutator">ArrayRandomizeOrderMutator</link></term>
<listitem>
<simpara>This mutator randomizes the order of items in an array.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_ArrayReverseOrderMutator">ArrayReverseOrderMutator</link></term>
<listitem>
<simpara>This mutator reverses the order of items in an array.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_ArrayVarianceMutator">ArrayVarianceMutator</link></term>
<listitem>
<simpara>This mutator grows and shrinks an array to a variance of counts based on the current size.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Used for all data elements</emphasis></simpara>
<variablelist>
<varlistentry>
<term><link linkend="Mutators_DataElementBitFlipper">DataElementBitFlipper</link></term>
<listitem>
<simpara>This mutator produces test cases by flipping bits in the output value.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_DataElementDuplicate">DataElementDuplicate</link></term>
<listitem>
<simpara>This mutator duplicates data elements.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_DataElementRemove">DataElementRemove</link></term>
<listitem>
<simpara>This mutator removes data elements.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_DataElementSwapNear">DataElementSwapNear</link></term>
<listitem>
<simpara>This mutator swaps data elements.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_SampleNinjaMutator">SampleNinjaMutator</link></term>
<listitem>
<simpara>This mutator combines data elements from different data sets.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Enabled when element is part of a size relation</emphasis></simpara>
<variablelist>
<varlistentry>
<term><link linkend="Mutators_SizedDataEdgeCase">SizedDataEdgeCase</link></term>
<listitem>
<simpara>This mutator causes the data portion of a relation to be sized as numerical edge cases.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_SizedDataVariance">SizedDataVariance</link></term>
<listitem>
<simpara>This mutator causes the data portion of a relation to be sized as numerical variances.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_SizedEdgeCase">SizedEdgeCase</link></term>
<listitem>
<simpara>This mutator changes both sides of the relation (data and value) to match numerical edge cases.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_SizedVariance">SizedVariance</link></term>
<listitem>
<simpara>This mutator changes both sides of the relation (data and value) to match numerical variances of the current size.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Specific to this element type</emphasis></simpara>
<variablelist>
<varlistentry>
<term><link linkend="Mutators_ExtraValues">ExtraValues</link></term>
<listitem>
<simpara>This mutator provides extra test case values on a per-data element basis.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_NumberEdgeCase">NumberEdgeCase</link></term>
<listitem>
<simpara>This mutator produces numerical edge cases for integer values.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_NumberRandom">NumberRandom</link></term>
<listitem>
<simpara>This mutator produces random values from the available numerical space.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_NumberVariance">NumberVariance</link></term>
<listitem>
<simpara>This mutator produces values near the current value of a number.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_50">
<title>Examples</title>
<example>
<title>Simple VarNumber Example</title>
<simpara>Output with different values in a <emphasis>VarNumber</emphasis> element to show how the encoded expands as needed.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach	xmlns="http://peachfuzzer.com/2012/Peach"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xsi:schemaLocation="http://peachfuzzer.com/2012/Peach /peach/peach.xsd"&gt;

	&lt;DataModel name="TheDataModel"&gt;

		&lt;Number name="NumLength" size="8"&gt;
			&lt;Relation type="size" of="Almonds"/&gt;
		&lt;/Number&gt;

		&lt;VarNumber name="Almonds" value="32000" /&gt;

	&lt;/DataModel&gt;

	&lt;StateModel name="TheState" initialState="Initial"&gt;
		&lt;State name="Initial"&gt;
			&lt;Action type="output"&gt;
				&lt;DataModel ref="TheDataModel"/&gt;
				&lt;Data&gt;
					&lt;Field name="Almonds" value="1"/&gt; <co xml:id="CO29-1"/>
				&lt;/Data&gt;
			&lt;/Action&gt;

			&lt;Action type="output"&gt;
				&lt;DataModel ref="TheDataModel"/&gt;
				&lt;Data&gt;
					&lt;Field name="Almonds" value="32000"/&gt; <co xml:id="CO29-2"/>
				&lt;/Data&gt;
			&lt;/Action&gt;

			&lt;Action type="output"&gt;
				&lt;DataModel ref="TheDataModel"/&gt;
				&lt;Data&gt;
					&lt;Field name="Almonds" value="3200000"/&gt; <co xml:id="CO29-3"/>
				&lt;/Data&gt;
			&lt;/Action&gt;
		&lt;/State&gt;
	&lt;/StateModel&gt;

	&lt;Test name="Default"&gt;
		&lt;StateModel ref="TheState"/&gt;

		&lt;Publisher class="ConsoleHex"/&gt;
	&lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<calloutlist>
<callout arearefs="CO29-1">
<para>First output should produce 1 byte for the size and 1 byte for the number</para>
</callout>
<callout arearefs="CO29-2">
<para>Second output should produce 1 byte for the size and 2 bytes for the number</para>
</callout>
<callout arearefs="CO29-3">
<para>Third output should produce 1 byte for the size and 3 bytes for the number</para>
</callout>
</calloutlist>
<simpara>Output from this example:</simpara>
<screen>&gt;peach -1 --debug NumberExample1.xml

[*] Web site running at: http://10.0.1.87:8888/

[*] Test 'Default' starting with random seed 56906.
2016-07-08 16:38:47.6099 Peach.Pro.Core.Loggers.JobLogger Writing debug.log to: c:\peach-pro\output\win_x64_debug\bin\Logs\example.xml_20160708163846\debug.log

[R1,-,-] Performing iteration
2016-07-08 16:38:47.7699 Peach.Core.Engine runTest: Performing control recording iteration.
2016-07-08 16:38:47.8159 Peach.Core.Dom.StateModel Run(): Changing to state "Initial".
2016-07-08 16:38:47.8259 Peach.Core.Dom.Action Run(Action): Output
2016-07-08 16:38:47.9450 Peach.Pro.Core.Publishers.ConsolePublisher start()
2016-07-08 16:38:47.9450 Peach.Pro.Core.Publishers.ConsolePublisher open()
2016-07-08 16:38:47.9450 Peach.Pro.Core.Publishers.ConsolePublisher output(2 bytes) <co xml:id="CO30-1"/>
00000000   01 01                                              ..
2016-07-08 16:38:47.9550 Peach.Core.Dom.Action Run(Action_1): Output
2016-07-08 16:38:47.9550 Peach.Pro.Core.Publishers.ConsolePublisher output(3 bytes) <co xml:id="CO30-2"/>
00000000   02 7D 00                                           .}.
2016-07-08 16:38:47.9550 Peach.Core.Dom.Action Run(Action_2): Output
2016-07-08 16:38:47.9550 Peach.Pro.Core.Publishers.ConsolePublisher output(4 bytes) <co xml:id="CO30-3"/>
00000000   03 30 D4 00                                        .0..
2016-07-08 16:38:47.9550 Peach.Pro.Core.Publishers.ConsolePublisher close()
2016-07-08 16:38:47.9550 Peach.Core.Engine runTest: context.config.singleIteration == true
2016-07-08 16:38:47.9677 Peach.Pro.Core.Publishers.ConsolePublisher stop()
2016-07-08 16:38:47.9677 Peach.Core.Engine EndTest: Stopping all agents and monitors

[*] Test 'Default' finished.</screen>
<calloutlist>
<callout arearefs="CO30-1">
<para>Value of <emphasis>1</emphasis> encoded as a single byte</para>
</callout>
<callout arearefs="CO30-2">
<para>Value of <emphasis>32000</emphasis> using two bytes</para>
</callout>
<callout arearefs="CO30-3">
<para>Value of <emphasis>3200000</emphasis> using three bytes</para>
</callout>
</calloutlist>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="XmlAttribute">
<title>XmlAttribute</title>
<simpara>Defines an attribute for an XML element. The parent element must be an <link linkend="XmlElement">XmlElement</link>.</simpara>
<note>
<simpara>The <emphasis>XmlElement</emphasis> and the <emphasis>XmlAttribute</emphasis> elements do not support cracking of data. If you need to crack XML content into <emphasis>XmlElement</emphasis> and <emphasis>XmlAttribute</emphasis> elements, use an <link linkend="Analyzers_Xml">XmlAnalyzer</link> attached to a String element.</simpara>
</note>
<note>
<simpara>The resulting value produced by any child element must be a string. In the case of elements that produce binary output, a <link linkend="Transformer">Transformer</link> must be used to convert the binary output to a string. An example of such a transformer is the <link linkend="Transformers_Base64EncodeTransformer">Base64Encode</link> transformer.</simpara>
</note>
<simpara>See also <link linkend="Analyzers_Xml">XML</link> analyzer and <link linkend="XmlElement">XmlElement</link> element.</simpara>
<section xml:id="_syntax_68">
<title>Syntax</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;XmlElement name="example" elementName="Foo"&gt;
  &lt;XmlAttribute attributeName="bar"&gt;
    &lt;String value="My Attribute!" /&gt;
  &lt;/XmlAttribute&gt;
&lt;/XmlElement&gt;</programlisting>
<programlisting language="xml" linenumbering="unnumbered">&lt;Foo bar="My Attribute!"/&gt;</programlisting>
</section>
<section xml:id="_attributes_53">
<title>Attributes</title>
<simpara><emphasis>Required:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>attributeName</term>
<listitem>
<simpara>Name of XML element</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term><link linkend="name">name</link></term>
<listitem>
<simpara>Name of the data model</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="constraint">constraint</link></term>
<listitem>
<simpara>Scripting expression that evaluates to true or false. Defaults to null meaning that no constraint is declared.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="minOccurs">minOccurs</link></term>
<listitem>
<simpara>The minimum number of times this element must occur. Defaults to 1. <?asciidoc-br?></simpara>
<itemizedlist>
<listitem>
<simpara>Used to define arrays with variable size. Arrays defined by min/maxOccurs generally have a relation
defined.</simpara>
</listitem>
<listitem>
<simpara>Adding this attribute, even with a value of 1, converts the element to an array.</simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="maxOccurs">maxOccurs</link></term>
<listitem>
<simpara>The maximum number of times this element can occur. Defaults to 1. <?asciidoc-br?></simpara>
<itemizedlist>
<listitem>
<simpara>Used to define arrays with static size.</simpara>
</listitem>
<listitem>
<simpara>Adding this attribute, even with a value of 1, converts the element to an array.</simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="mutable">mutable</link></term>
<listitem>
<simpara>Should this data element be mutated (Or, is it changeable)? The default value is true.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>ns</term>
<listitem>
<simpara>XML namespace.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_child_elements_37">
<title>Child Elements</title>
<variablelist>
<varlistentry>
<term><link linkend="Blob">Blob</link></term>
<listitem>
<simpara>Used to represent binary data (array of bytes) to create simple dumb fuzzers in Peach.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Block">Block</link></term>
<listitem>
<simpara>Groups one or more data elements in a logical structure.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Choice">Choice</link></term>
<listitem>
<simpara>Indicates all sub-elements are valid; however, one sub-element should be selected.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Fixup">Fixup</link></term>
<listitem>
<simpara>Performs dynamic transformations such as checksums and CRCs.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Flags">Flags</link></term>
<listitem>
<simpara>Defines a set of bit sized flags.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Hint">Hint</link></term>
<listitem>
<simpara>Provides information to mutators.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Number">Number</link></term>
<listitem>
<simpara>Defines a binary number of lengths 8, 16, 24, 32, or 64 bits.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="String">String</link></term>
<listitem>
<simpara>Defines a single or double byte string.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_mutators_27">
<title>Mutators</title>
<simpara>The following mutators operate on this element type:</simpara>
<simpara><emphasis>Enabled when element is marked as an array</emphasis></simpara>
<variablelist>
<varlistentry>
<term><link linkend="Mutators_ArrayNumericalEdgeCasesMutator">ArrayNumericalEdgeCasesMutator</link></term>
<listitem>
<simpara>This mutator grows and shrinks an array to counts based on numerical edge cases.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_ArrayRandomizeOrderMutator">ArrayRandomizeOrderMutator</link></term>
<listitem>
<simpara>This mutator randomizes the order of items in an array.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_ArrayReverseOrderMutator">ArrayReverseOrderMutator</link></term>
<listitem>
<simpara>This mutator reverses the order of items in an array.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_ArrayVarianceMutator">ArrayVarianceMutator</link></term>
<listitem>
<simpara>This mutator grows and shrinks an array to a variance of counts based on the current size.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Used for all data elements</emphasis></simpara>
<variablelist>
<varlistentry>
<term><link linkend="Mutators_DataElementBitFlipper">DataElementBitFlipper</link></term>
<listitem>
<simpara>This mutator produces test cases by flipping bits in the output value.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_DataElementDuplicate">DataElementDuplicate</link></term>
<listitem>
<simpara>This mutator duplicates data elements.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_DataElementRemove">DataElementRemove</link></term>
<listitem>
<simpara>This mutator removes data elements.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_DataElementSwapNear">DataElementSwapNear</link></term>
<listitem>
<simpara>This mutator swaps data elements.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_SampleNinjaMutator">SampleNinjaMutator</link></term>
<listitem>
<simpara>This mutator combines data elements from different data sets.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_51">
<title>Examples</title>
<example>
<title>Cracking XML File using Analyzer</title>
<simpara>The following example loads the <literal>example.xml</literal> file into a <link linkend="String">String</link> element, then uses the XML analyzer to convert it to XmlElement and XmlAttribute elements.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

	&lt;DataModel name="TheDataModel"&gt;
		&lt;String&gt;
			&lt;Analyzer class="Xml" /&gt;
		&lt;/String&gt;
	&lt;/DataModel&gt;

	&lt;StateModel name="TheStateModel" initialState="InitialState" &gt;
		&lt;State name="InitialState"&gt;
			&lt;Action type="output"&gt;
				&lt;DataModel ref="TheDataModel"/&gt;
				&lt;Data fileName="example.xml" /&gt;
			&lt;/Action&gt;
		&lt;/State&gt;
	&lt;/StateModel&gt;

	&lt;Test name="Default"&gt;
		&lt;StateModel ref="TheStateModel"/&gt;

		&lt;Publisher class="Console" /&gt;
	&lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Produces the following output:</simpara>
<screen>&gt; peach -1 --debug example.xml

[*] Test 'Default' starting with random seed 1238.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker DataModel 'TheDataModel' Bytes: 0/684, Bits: 0/5472
Peach.Core.Cracker.DataCracker getSize: -----&gt; DataModel 'TheDataModel'
Peach.Core.Cracker.DataCracker scan: DataModel 'TheDataModel'
Peach.Core.Cracker.DataCracker scan: String 'TheDataModel.DataElement_0' -&gt; Offset: 0, Unsized element
Peach.Core.Cracker.DataCracker getSize: &lt;----- Deterministic: ???
Peach.Core.Cracker.DataCracker Crack: DataModel 'TheDataModel' Size: &lt;null&gt;, Bytes: 0/684, Bits: 0/5472
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker String 'TheDataModel.DataElement_0' Bytes: 0/684, Bits: 0/5472
Peach.Core.Cracker.DataCracker getSize: -----&gt; String 'TheDataModel.DataElement_0'
Peach.Core.Cracker.DataCracker scan: String 'TheDataModel.DataElement_0' -&gt; Offset: 0, Unsized element
Peach.Core.Cracker.DataCracker lookahead: String 'TheDataModel.DataElement_0'
Peach.Core.Cracker.DataCracker getSize: &lt;----- Last Unsized: 5472
Peach.Core.Cracker.DataCracker Crack: String 'TheDataModel.DataElement_0' Size:5472, Bytes: 0/684, Bits: 0/5472
Peach.Core.Dom.DataElement String 'TheDataModel.DataElement_0' value is: &lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://pea.. (Len: 684 chars)
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher start()
Peach.Core.Publishers.ConsolePublisher open()
Peach.Core.Publishers.ConsolePublisher output(618 bytes) <co xml:id="CO31-1"/>
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" d1p1:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd" xmlns:d1p1="http://www.w3.org/2001/XMLSchema-instance"&gt;&lt;DataModel name="TheDataModel"&gt;&lt;String&gt;&lt;Analyzer class="Xml" /&gt;&lt;/String&gt;&lt;/DataModel&gt;&lt;StateModelname="TheStateModel" initialState="InitialState"&gt;&lt;State name="InitialState"&gt;&lt;Action type="output"&gt;&lt;DataModel ref="TheDataModel" /&gt;&lt;Data fileName="c:\temp\example.xml" /&gt;&lt;/Action&gt;&lt;/State&gt;&lt;/StateModel&gt;&lt;Test name="Default"&gt;&lt;StateModel ref="TheStateModel" /&gt;&lt;Publisher class="Console" /&gt;&lt;/Test&gt;&lt;/Peach&gt;Peach.Core.Publishers.
ConsolePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.ConsolePublisher stop()

[*] Test 'Default' finished.

C:\peach\output\win_x64_debug\bin&gt;</screen>
<calloutlist>
<callout arearefs="CO31-1">
<para>Generated XML output</para>
</callout>
</calloutlist>
</example>
<example>
<title>Converting Binary Data with Transformer</title>
<simpara>The following example converts binary data to a string format using a <link linkend="Transformer">Transformer</link> with an <literal>XmlAttribute</literal> element.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

	&lt;DataModel name="TheDataModel"&gt;
		&lt;XmlElement elementName="Value"&gt;
			&lt;XmlAttribute attributeName="data"&gt;
				&lt;Block&gt;
					&lt;Number size="32" value="42" /&gt;
					&lt;Number size="32" value="42" /&gt;
					&lt;Number size="32" value="42" /&gt;

					&lt;Transformer class="Base64Encode" /&gt;
				&lt;/Block&gt;
			&lt;/XmlAttribute&gt;
		&lt;/XmlElement&gt;
	&lt;/DataModel&gt;

	&lt;StateModel name="TheStateModel" initialState="InitialState" &gt;
		&lt;State name="InitialState"&gt;
			&lt;Action type="output"&gt;
				&lt;DataModel ref="TheDataModel"/&gt;
			&lt;/Action&gt;
		&lt;/State&gt;
	&lt;/StateModel&gt;

	&lt;Test name="Default"&gt;
		&lt;StateModel ref="TheStateModel"/&gt;

		&lt;Publisher class="Console" /&gt;
	&lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Produces the following output:</simpara>
<screen>&gt; peach -1 --debug example.xml

[*] Test 'Default' starting with random seed 59320.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher start()
Peach.Core.Publishers.ConsolePublisher open()
Peach.Core.Publishers.ConsolePublisher output(33 bytes) <co xml:id="CO32-1"/>
&lt;Value data="KgAAACoAAAAqAAAA" /&gt;Peach.Core.Publishers.ConsolePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.ConsolePublisher stop()

[*] Test 'Default' finished.</screen>
<calloutlist>
<callout arearefs="CO32-1">
<para>Generated output is Base64 encoded, converting the binary data to a string</para>
</callout>
</calloutlist>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="XmlCharacterData">
<title>XmlCharacterData</title>
<simpara>Defines an XML CDATA section. This element must a child of <link linkend="XmlElement">XmlElement</link> and is used to fuzz the content of an XML CDATA section.  All the output produced from <emphasis>XmlCharacterData</emphasis> and it&#8217;s parent <link linkend="XmlElement">XmlElement</link> are well formed.</simpara>
<note>
<simpara>The <emphasis>XmlCharacterData</emphasis> and the <emphasis>XmlElement</emphasis> elements do not support cracking of data. If you need to crack XML content into <emphasis>XmlCharacterDataElement</emphasis> and <emphasis>XmlElement</emphasis> components, use an <link linkend="Analyzers_Xml">XmlAnalyzer</link> attached to a String element.</simpara>
</note>
<note>
<simpara>The resulting value produced by any child element(s) must be a string. In the case of elements that produce binary output, a <link linkend="Transformer">Transformer</link> must be used to convert the binary output to a string. An example of such a transformer is the <link linkend="Transformers_Base64EncodeTransformer">Base64Encode</link> transformer.</simpara>
</note>
<simpara>See also <link linkend="Analyzers_Xml">XML</link> analyzer, <link linkend="XmlElement">XmlElement</link> and <link linkend="XmlAttribute">XmlAttribute</link> elements.</simpara>
<section xml:id="_syntax_69">
<title>Syntax</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;XmlElement elementName="Foo"&gt;
  &lt;XmlCharacterData&gt;
    &lt;String value="Hello World!" /&gt;
  &lt;/XmlCharacterData&gt;
&lt;/XmlElement&gt;</programlisting>
<programlisting language="xml" linenumbering="unnumbered">&lt;Foo&gt;&lt;![CDATA[Hello World!]]&gt;&lt;/Foo&gt;</programlisting>
</section>
<section xml:id="_attributes_54">
<title>Attributes</title>
<simpara><emphasis>Required:</emphasis></simpara>
<simpara>No required attributes.</simpara>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term><link linkend="name">name</link></term>
<listitem>
<simpara>Name of the data model</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="length">length</link></term>
<listitem>
<simpara>length of the data element. Default is null</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="lengthType">lengthType</link></term>
<listitem>
<simpara>Units of the length attribute. Default is bytes</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="constraint">constraint</link></term>
<listitem>
<simpara>Scripting expression that evaluates to true or false. Default is null</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="token">token</link></term>
<listitem>
<simpara>This element should be treated as a token when parsing, defaults to false.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="mutable">mutable</link></term>
<listitem>
<simpara>Is data element changeable (should it be mutated), defaults to true.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_child_elements_38">
<title>Child Elements</title>
<variablelist>
<varlistentry>
<term><link linkend="Blob">Blob</link></term>
<listitem>
<simpara>Used to represent binary data (array of bytes) to create simple dumb fuzzers in Peach.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Block">Block</link></term>
<listitem>
<simpara>Group one or more data elements in a logical structure.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Choice">Choice</link></term>
<listitem>
<simpara>Indicate all sub-elements are valid; however, only one sub-element should be selected.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Fixup">Fixup</link></term>
<listitem>
<simpara>Dynamic transformations such as checksums and CRCs.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Flags">Flags</link></term>
<listitem>
<simpara>Defines a set of bit sized flags.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Hint">Hint</link></term>
<listitem>
<simpara>Provide information to mutators.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Number">Number</link></term>
<listitem>
<simpara>Defines a binary number of lengths 8, 16, 24, 32, or 64 bits.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="String">String</link></term>
<listitem>
<simpara>Defines a single or double byte string.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="XmlElement">XmlElement</link></term>
<listitem>
<simpara>Defines an XML element, the basic building block of XML documents.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_mutators_28">
<title>Mutators</title>
<simpara>The following mutators operate on this element type:</simpara>
<simpara><emphasis>Enabled when element is marked as an array</emphasis></simpara>
<variablelist>
<varlistentry>
<term><link linkend="Mutators_ArrayNumericalEdgeCasesMutator">ArrayNumericalEdgeCasesMutator</link></term>
<listitem>
<simpara>This mutator grows and shrinks an array to counts based on numerical edge cases.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_ArrayRandomizeOrderMutator">ArrayRandomizeOrderMutator</link></term>
<listitem>
<simpara>This mutator randomizes the order of items in an array.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_ArrayReverseOrderMutator">ArrayReverseOrderMutator</link></term>
<listitem>
<simpara>This mutator reverses the order of items in an array.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_ArrayVarianceMutator">ArrayVarianceMutator</link></term>
<listitem>
<simpara>This mutator grows and shrinks an array to a variance of counts based on the current size.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Used for all data elements</emphasis></simpara>
<variablelist>
<varlistentry>
<term><link linkend="Mutators_DataElementBitFlipper">DataElementBitFlipper</link></term>
<listitem>
<simpara>This mutator produces test cases by flipping bits in the output value.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_DataElementDuplicate">DataElementDuplicate</link></term>
<listitem>
<simpara>This mutator duplicates data elements.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_DataElementRemove">DataElementRemove</link></term>
<listitem>
<simpara>This mutator removes data elements.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_DataElementSwapNear">DataElementSwapNear</link></term>
<listitem>
<simpara>This mutator swaps data elements.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_SampleNinjaMutator">SampleNinjaMutator</link></term>
<listitem>
<simpara>This mutator combines data elements from different data sets.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_52">
<title>Examples</title>
<example>
<title>XML Namespace</title>
<simpara>The following example models an XML snippet with a CDATA section.</simpara>
<formalpara>
<title>XML to model</title>
<para>
<programlisting language="xml" linenumbering="unnumbered">&lt;Foo&gt;&lt;![CDATA[Hello World!]]&gt;&lt;/Foo&gt;</programlisting>
</para>
</formalpara>
<formalpara>
<title>example.xml</title>
<para>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

	&lt;DataModel name="TheDataModel"&gt;
        &lt;XmlElement elementName="Foo"&gt;
          &lt;XmlCharacterData&gt;
            &lt;String value="Hello World!" /&gt;
          &lt;/XmlCharacterData&gt;
        &lt;/XmlElement&gt;
	&lt;/DataModel&gt;

	&lt;StateModel name="TheStateModel" initialState="InitialState" &gt;
		&lt;State name="InitialState"&gt;
			&lt;Action type="output"&gt;
				&lt;DataModel ref="TheDataModel"/&gt;
			&lt;/Action&gt;
		&lt;/State&gt;
	&lt;/StateModel&gt;

	&lt;Test name="Default"&gt;
		&lt;StateModel ref="TheStateModel"/&gt;
		&lt;Publisher class="Console" /&gt;
	&lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
</para>
</formalpara>
<simpara>Produces the following output:</simpara>
<screen>&gt; peach -1 --debug example.xml

[*] Test 'Default' starting with random seed 50415.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher start()
Peach.Core.Publishers.ConsolePublisher open()
Peach.Core.Publishers.ConsolePublisher output(90 bytes) <co xml:id="CO33-1"/>
&lt;Foo&gt;&lt;![CDATA[Hello World!]]&gt;&lt;/Foo&gt;Peach.Core.Publishers.ConsolePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.ConsolePublisher stop()

[*] Test 'Default' finished.</screen>
<calloutlist>
<callout arearefs="CO33-1">
<para>Produced XML</para>
</callout>
</calloutlist>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="XmlElement">
<title>XmlElement</title>
<simpara>Defines an XML element, the basic building block of XML documents. The <emphasis>XmlElement</emphasis> is used to fuzz the content of an XML document, but not the XML parser.  All the output produced from <emphasis>XmlElement</emphasis> and <link linkend="XmlAttribute">XmlAttribute</link> are well formed.</simpara>
<note>
<simpara>The <emphasis>XmlElement</emphasis> and the <emphasis>XmlAttribute</emphasis> elements do not support cracking of data. If you need to crack XML content into <emphasis>XmlElement</emphasis> and <emphasis>XmlAttribute</emphasis> components, use an <link linkend="Analyzers_Xml">XmlAnalyzer</link> attached to a String element.</simpara>
</note>
<note>
<simpara>The resulting value produced by any child element must be a string. In the case of elements that produce binary output, a <link linkend="Transformer">Transformer</link> must be used to convert the binary output to a string. An example of such a transformer is the <link linkend="Transformers_Base64EncodeTransformer">Base64Encode</link> transformer.</simpara>
</note>
<simpara>See also <link linkend="Analyzers_Xml">XML</link> analyzer and <link linkend="XmlAttribute">XmlAttribute</link> element.</simpara>
<section xml:id="_syntax_70">
<title>Syntax</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;XmlElement elementName="Foo"&gt;
  &lt;XmlElement elementName="Bar"&gt;
    &lt;String value="Hello World!" /&gt;
  &lt;/XmlElement/&gt;
&lt;/XmlElement&gt;</programlisting>
<programlisting language="xml" linenumbering="unnumbered">&lt;Foo&gt;&lt;Bar&gt;Hello World!&lt;/Bar&gt;&lt;/Foo&gt;</programlisting>
</section>
<section xml:id="_attributes_55">
<title>Attributes</title>
<simpara><emphasis>Required:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>elementName</term>
<listitem>
<simpara>Name of the XML element</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term><link linkend="name">name</link></term>
<listitem>
<simpara>Name of the data model</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="length">length</link></term>
<listitem>
<simpara>length of the data element. Default is null</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="lengthType">lengthType</link></term>
<listitem>
<simpara>Units of the length attribute. Default is bytes</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="constraint">constraint</link></term>
<listitem>
<simpara>Scripting expression that evaluates to true or false. Default is null</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="minOccurs">minOccurs</link></term>
<listitem>
<simpara>The minimum number of times this element must occur. Defaults to 1. <?asciidoc-br?></simpara>
<itemizedlist>
<listitem>
<simpara>Used to define arrays with variable size. Arrays defined by min/maxOccurs generally have a relation
defined.</simpara>
</listitem>
<listitem>
<simpara>Adding this attribute, even with a value of 1, converts the element to an array.</simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="maxOccurs">maxOccurs</link></term>
<listitem>
<simpara>The maximum number of times this element can occur. Defaults to 1. <?asciidoc-br?></simpara>
<itemizedlist>
<listitem>
<simpara>Used to define arrays with static size.</simpara>
</listitem>
<listitem>
<simpara>Adding this attribute, even with a value of 1, converts the element to an array.</simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="occurs">occurs</link></term>
<listitem>
<simpara>Actual occurrences of element. Defaults to 1. <?asciidoc-br?></simpara>
<itemizedlist>
<listitem>
<simpara>Used to define arrays with static size.</simpara>
</listitem>
<listitem>
<simpara>Adding this attribute, even with a value of 1, converts the element to an array.</simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term>ns</term>
<listitem>
<simpara>XML namespace</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="token">token</link></term>
<listitem>
<simpara>This element should be treated as a token when parsing, defaults to false.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="mutable">mutable</link></term>
<listitem>
<simpara>Is data element changeable (should it be mutated), defaults to true.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_child_elements_39">
<title>Child Elements</title>
<variablelist>
<varlistentry>
<term><link linkend="Blob">Blob</link></term>
<listitem>
<simpara>Used to represent binary data (array of bytes) to create simple dumb fuzzers in Peach.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Block">Block</link></term>
<listitem>
<simpara>Group one or more data elements in a logical structure.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Choice">Choice</link></term>
<listitem>
<simpara>Indicate all sub-elements are valid; however, only one sub-element should be selected.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Fixup">Fixup</link></term>
<listitem>
<simpara>Dynamic transformations such as checksums and CRCs.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Flags">Flags</link></term>
<listitem>
<simpara>Defines a set of bit sized flags.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Hint">Hint</link></term>
<listitem>
<simpara>Provide information to mutators.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Number">Number</link></term>
<listitem>
<simpara>Defines a binary number of lengths 8, 16, 24, 32, or 64 bits.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="String">String</link></term>
<listitem>
<simpara>Defines a single or double byte string.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="XmlAttribute">XmlAttribute</link></term>
<listitem>
<simpara>Defines an attribute for an XML element.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="XmlElement">XmlElement</link></term>
<listitem>
<simpara>Defines an XML element, the basic building block of XML documents.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_mutators_29">
<title>Mutators</title>
<simpara>The following mutators operate on this element type:</simpara>
<simpara><emphasis>Enabled when element is marked as an array</emphasis></simpara>
<variablelist>
<varlistentry>
<term><link linkend="Mutators_ArrayNumericalEdgeCasesMutator">ArrayNumericalEdgeCasesMutator</link></term>
<listitem>
<simpara>This mutator grows and shrinks an array to counts based on numerical edge cases.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_ArrayRandomizeOrderMutator">ArrayRandomizeOrderMutator</link></term>
<listitem>
<simpara>This mutator randomizes the order of items in an array.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_ArrayReverseOrderMutator">ArrayReverseOrderMutator</link></term>
<listitem>
<simpara>This mutator reverses the order of items in an array.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_ArrayVarianceMutator">ArrayVarianceMutator</link></term>
<listitem>
<simpara>This mutator grows and shrinks an array to a variance of counts based on the current size.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Used for all data elements</emphasis></simpara>
<variablelist>
<varlistentry>
<term><link linkend="Mutators_DataElementBitFlipper">DataElementBitFlipper</link></term>
<listitem>
<simpara>This mutator produces test cases by flipping bits in the output value.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_DataElementDuplicate">DataElementDuplicate</link></term>
<listitem>
<simpara>This mutator duplicates data elements.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_DataElementRemove">DataElementRemove</link></term>
<listitem>
<simpara>This mutator removes data elements.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_DataElementSwapNear">DataElementSwapNear</link></term>
<listitem>
<simpara>This mutator swaps data elements.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Mutators_SampleNinjaMutator">SampleNinjaMutator</link></term>
<listitem>
<simpara>This mutator combines data elements from different data sets.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_53">
<title>Examples</title>
<example>
<title>XML Namespace</title>
<simpara>The following example models an XML snippet with namespaces.</simpara>
<formalpara>
<title>XML to model</title>
<para>
<programlisting language="xml" linenumbering="unnumbered">&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach"&gt;
	&lt;DataModel name="TheDataModel"/&gt;
&lt;/Peach&gt;</programlisting>
</para>
</formalpara>
<formalpara>
<title>example.xml</title>
<para>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

	&lt;DataModel name="TheDataModel"&gt;
		&lt;XmlElement elementName="Peach" ns="http://peachfuzzer.com/2012/Peach"&gt;
			&lt;XmlElement elementName="DataModel" ns="http://peachfuzzer.com/2012/Peach"&gt;
				&lt;XmlAttribute attributeName="name"&gt;
					&lt;String value="TheDataModel" /&gt;
				&lt;/XmlAttribute&gt;
			&lt;/XmlElement&gt;
		&lt;/XmlElement&gt;
	&lt;/DataModel&gt;

	&lt;StateModel name="TheStateModel" initialState="InitialState" &gt;
		&lt;State name="InitialState"&gt;
			&lt;Action type="output"&gt;
				&lt;DataModel ref="TheDataModel"/&gt;
			&lt;/Action&gt;
		&lt;/State&gt;
	&lt;/StateModel&gt;

	&lt;Test name="Default"&gt;
		&lt;StateModel ref="TheStateModel"/&gt;

		&lt;Publisher class="Console" /&gt;
	&lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
</para>
</formalpara>
<simpara>Produces the following output:</simpara>
<screen>&gt; peach -1 --debug example.xml

[*] Test 'Default' starting with random seed 50415.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher start()
Peach.Core.Publishers.ConsolePublisher open()
Peach.Core.Publishers.ConsolePublisher output(90 bytes) <co xml:id="CO34-1"/>
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach"&gt;&lt;DataModel name="TheDataModel"
/&gt;&lt;/Peach&gt;Peach.Core.Publishers.ConsolePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.ConsolePublisher stop()

[*] Test 'Default' finished.</screen>
<calloutlist>
<callout arearefs="CO34-1">
<para>Produced XML</para>
</callout>
</calloutlist>
</example>
<example>
<title>Cracking XML File using Analyzer</title>
<simpara>The following example loads the <literal>example.xml</literal> file into a <link linkend="String">String</link> element, then use the XML analyzer to convert it to XmlElement and XmlAttribute elements.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

	&lt;DataModel name="TheDataModel"&gt;
		&lt;String&gt;
			&lt;Analyzer class="Xml" /&gt;
		&lt;/String&gt;
	&lt;/DataModel&gt;

	&lt;StateModel name="TheStateModel" initialState="InitialState" &gt;
		&lt;State name="InitialState"&gt;
			&lt;Action type="output"&gt;
				&lt;DataModel ref="TheDataModel"/&gt;
				&lt;Data fileName="example.xml" /&gt;
			&lt;/Action&gt;
		&lt;/State&gt;
	&lt;/StateModel&gt;

	&lt;Test name="Default"&gt;
		&lt;StateModel ref="TheStateModel"/&gt;

		&lt;Publisher class="Console" /&gt;
	&lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Produces the following output:</simpara>
<screen>&gt; peach -1 --debug example.xml

[*] Test 'Default' starting with random seed 1238.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker DataModel 'TheDataModel' Bytes: 0/684, Bits: 0/5472
Peach.Core.Cracker.DataCracker getSize: -----&gt; DataModel 'TheDataModel'
Peach.Core.Cracker.DataCracker scan: DataModel 'TheDataModel'
Peach.Core.Cracker.DataCracker scan: String 'TheDataModel.DataElement_0' -&gt; Offset: 0, Unsized element
Peach.Core.Cracker.DataCracker getSize: &lt;----- Deterministic: ???
Peach.Core.Cracker.DataCracker Crack: DataModel 'TheDataModel' Size: &lt;null&gt;, Bytes: 0/684, Bits: 0/5472
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker String 'TheDataModel.DataElement_0' Bytes: 0/684, Bits: 0/5472
Peach.Core.Cracker.DataCracker getSize: -----&gt; String 'TheDataModel.DataElement_0'
Peach.Core.Cracker.DataCracker scan: String 'TheDataModel.DataElement_0' -&gt; Offset: 0, Unsized element
Peach.Core.Cracker.DataCracker lookahead: String 'TheDataModel.DataElement_0'
Peach.Core.Cracker.DataCracker getSize: &lt;----- Last Unsized: 5472
Peach.Core.Cracker.DataCracker Crack: String 'TheDataModel.DataElement_0' Size:5472, Bytes: 0/684, Bits: 0/5472
Peach.Core.Dom.DataElement String 'TheDataModel.DataElement_0' value is: &lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://pea.. (Len: 684 chars)
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher start()
Peach.Core.Publishers.ConsolePublisher open()
Peach.Core.Publishers.ConsolePublisher output(618 bytes) <co xml:id="CO35-1"/>
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" d1p1:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd" xmlns:d1p1="http://www.w3.org/2001/XMLSchema-instance"&gt;&lt;DataModel name="TheDataModel"&gt;&lt;String&gt;&lt;Analyzer class="Xml" /&gt;&lt;/String&gt;&lt;/DataModel&gt;&lt;StateModelname="TheStateModel" initialState="InitialState"&gt;&lt;State name="InitialState"&gt;&lt;Action type="output"&gt;&lt;DataModel ref="TheDataModel" /&gt;&lt;Data fileName="c:\temp\example.xml" /&gt;&lt;/Action&gt;&lt;/State&gt;&lt;/StateModel&gt;&lt;Test name="Default"&gt;&lt;StateModel ref="TheStateModel" /&gt;&lt;Publisher class="Console" /&gt;&lt;/Test&gt;&lt;/Peach&gt;Peach.Core.Publishers.
ConsolePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.ConsolePublisher stop()

[*] Test 'Default' finished.

C:\peach\output\win_x64_debug\bin&gt;</screen>
<calloutlist>
<callout arearefs="CO35-1">
<para>Generated XML output</para>
</callout>
</calloutlist>
</example>
<example>
<title>Converting Binary Data with Transformer</title>
<simpara>The following example converts binary data to a string format using a <link linkend="Transformer">Transformer</link> with an <literal>XmlElement</literal> element.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

	&lt;DataModel name="TheDataModel"&gt;
		&lt;XmlElement elementName="Value"&gt;
			&lt;Block&gt;
				&lt;Number size="32" value="42" /&gt;
				&lt;Number size="32" value="42" /&gt;
				&lt;Number size="32" value="42" /&gt;

				&lt;Transformer class="Base64Encode" /&gt;
			&lt;/Block&gt;
		&lt;/XmlElement&gt;
	&lt;/DataModel&gt;

	&lt;StateModel name="TheStateModel" initialState="InitialState" &gt;
		&lt;State name="InitialState"&gt;
			&lt;Action type="output"&gt;
				&lt;DataModel ref="TheDataModel"/&gt;
			&lt;/Action&gt;
		&lt;/State&gt;
	&lt;/StateModel&gt;

	&lt;Test name="Default"&gt;
		&lt;StateModel ref="TheStateModel"/&gt;

		&lt;Publisher class="Console" /&gt;
	&lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Produces the following output:</simpara>
<screen>&gt; peach -1 --debug example.xml

[*] Test 'Default' starting with random seed 1238.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher start()
Peach.Core.Publishers.ConsolePublisher open()
Peach.Core.Publishers.ConsolePublisher output(31 bytes) <co xml:id="CO36-1"/>
&lt;Value&gt;KgAAACoAAAAqAAAA&lt;/Value&gt;Peach.Core.Publishers.ConsolePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.ConsolePublisher stop()

[*] Test 'Default' finished.</screen>
<calloutlist>
<callout arearefs="CO36-1">
<para>Generated output is Base64 encoded, converting the binary data to a string</para>
</callout>
</calloutlist>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
</section>
<section xml:id="_data_element_children">
<title>Data Element Children</title>
<simpara>This section contains information about data elements specified as child elements of another element. Child elements modify or clarify the use and scope of the data element. See also <link linkend="Fixup">Fixups</link> and <link linkend="Transformer">Transformers</link>.</simpara>
<section xml:id="Relation">
<title>Relation</title>
<simpara>Peach allows data relationship modeling and provides three types of Relations: Size, Count and Offset.</simpara>
<simpara>Each Relation element has two required attributes:</simpara>
<variablelist>
<varlistentry>
<term>type</term>
<listitem>
<simpara>Declares the relationship type to model (Size, Count, Offset).</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>of</term>
<listitem>
<simpara>Names the first data element of the relationship in the data model.</simpara>
</listitem>
</varlistentry>
</variablelist>
<section xml:id="Relations_Size">
<title>Size-of Relation</title>
<simpara>The Size relationship type specifies that "X is the size of Y" where "X" is the parent element of the relation element; and "Y" is the first data element of the relationship, specified as the value of the <emphasis>of</emphasis> attribute.</simpara>
<simpara>The Number element, the parent element of "Relation", is the byte count of the relation element. Unicode characters may be multi-byte and the Number value reflects the additional size.</simpara>
<simpara>In this example, the value of the number element indicates the size of the string element named <emphasis>TheValue</emphasis> in bytes.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;Number size="32" signed="false"&gt;
  &lt;Relation type="size" of="TheValue" /&gt;
&lt;/Number&gt;
&lt;String name="TheValue" /&gt;</programlisting>
<simpara><emphasis role="strong">With expressionGet/expressionSet</emphasis></simpara>
<simpara>Gets are applied during the cracking process and Sets are applied during the publishing process.</simpara>
<simpara>For the Size relation, expressionGet and expressionSet use the two variables, <literal>self</literal> and <literal>size</literal>.  Self refers to the parent element and size is an integer.</simpara>
<simpara>The expressionGet and expressionSet operations should be mathematically inverse operations. The input value for expressionGet and the output value of expressionSet should be identical.</simpara>
<simpara>In this example, we provide two python expressions that allow us to modify the size when it is get or set:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;Number size="32" signed="false"&gt;
  &lt;Relation type="size" of="Value" expressionGet="size/2" expressionSet="size*2" /&gt;
&lt;/Number&gt;
&lt;String name="TheValue" /&gt;</programlisting>
<variablelist>
<varlistentry>
<term>expressionGet</term>
<listitem>
<simpara>The result of this python expression is used internally to determine how many bytes the <link linkend="String">String</link> <emphasis>TheValue</emphasis> reads. If Peach picks up 10, it internally stores a 5 and in turn Peach will read 5 bytes into the string.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>expressionSet</term>
<listitem>
<simpara>Produces a value for the publisher.  In the prior example, <literal>size</literal> stored for <emphasis>TheValue</emphasis> is "5" (length of <emphasis>TheValue</emphasis>), so the value which Peach outputs via a Publisher will be "5*2" or 10.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="Relations_Count">
<title>Count-of Relation</title>
<simpara>The Count relationship type specifies that "X is the count of Y" where "X" is the parent element of the relation. "Y" is the relationship element; "Y" is specified as the value of <emphasis>of</emphasis>; and, "Y" is an array. The Count relationship only applies to arrays.</simpara>
<simpara>The Number element is the byte count of the relationship array.
Because Count applies to arrays, specify either <link linkend="minOccurs">minOccurs</link> or <link linkend="maxOccurs">maxOccurs</link> after the String name.</simpara>
<simpara>In this example the number indicates the count of the array <emphasis>Strings</emphasis>.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;Number size="32" signed="false"&gt;
  &lt;Relation type="count" of="Strings" /&gt;
&lt;/Number&gt;
&lt;String name="Strings" nullTerminated="true" maxOccurs="1024" /&gt;</programlisting>
<simpara><emphasis role="strong">With expressionGet/expressionSet</emphasis></simpara>
<simpara>Gets are applied during the cracking process and Sets are applied during the publishing process.</simpara>
<simpara>For the Count-of relation, expressionGet and expressionSet use the two variables, <literal>self</literal> and <literal>count</literal>.  Self refers to the parent element and count is an integer.</simpara>
<simpara>The expressionGet and expressionSet operations should be mathematically inverse operations. The input value for expressionGet and the output value of expressionSet should be identical.</simpara>
<simpara>In this example, we provide two python expressions that allow us to modify the count when it is set or get.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;Number name="CountIndicator" size="32" signed="false"&gt;
  &lt;Relation type="count" of="TheValue" expressionGet="count/2" expressionSet="count*2" /&gt;
&lt;/Number&gt;
&lt;String name="TheValue" nullTerminated="true" maxOccurs="1024" /&gt;</programlisting>
<variablelist>
<varlistentry>
<term>expressionGet</term>
<listitem>
<simpara>This value is used internally and ends up determining how many items <link linkend="String">String</link> expands to. Because of the <literal>maxOccurs=1024</literal> restriction on recurring strings, the max value that Peach should encounter while trying to crack in the <literal>CountIndicator</literal> element is 2048.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>expressionSet</term>
<listitem>
<simpara>Sets the value that is produced.  In the prior example, <literal>count</literal> is based on how many <link linkend="String">String</link> elements are read.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="Relations_Offset">
<title>Offset-of Relation</title>
<simpara>The Offset relationship type specifies "X is the offset (in bytes) of Y."</simpara>
<simpara>Offset relations allow modeling formats that require changing the offset and also outputting the offset of various elements.</simpara>
<simpara>If there are no Relative attributes, Offset is measured from the beginning of the data model. If there is a Relative attribute, Offset is measured from the specified element.</simpara>
<simpara>Here we have a series of elements which are ASCII representations of numeric values of the offset sizes to various string elements below.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;DataModel name="TheDataModel"&gt;
	&lt;String length="4" padCharacter=" "&gt;
		&lt;Relation type="offset" of="Offset0" /&gt;
	&lt;/String&gt;
	&lt;String length="4" padCharacter=" "&gt;
		&lt;Relation type="offset" of="Offset1" /&gt;
	&lt;/String&gt;
	&lt;String length="4" padCharacter=" "&gt;
		&lt;Relation type="offset" of="Offset2" /&gt;
	&lt;/String&gt;
	&lt;String length="4" padCharacter=" "&gt;
		&lt;Relation type="offset" of="Offset3" /&gt;
	&lt;/String&gt;
	&lt;String length="4" padCharacter=" "&gt;
		&lt;Relation type="offset" of="Offset4" /&gt;
	&lt;/String&gt;

	&lt;String length="4" padCharacter=" "&gt;
		&lt;Relation type="offset" of="Offset5" /&gt;
	&lt;/String&gt;

	&lt;String length="4" padCharacter=" "&gt;
		&lt;Relation type="offset" of="Offset6" /&gt;
	&lt;/String&gt;

	&lt;Block&gt;
		&lt;Block name="Offset0"&gt;
			&lt;Block&gt;
				&lt;String name="Offset1" value="CRAZY STRING!" /&gt;
				&lt;String value="aslkjalskdjas" /&gt;
				&lt;String value="aslkdjalskdjasdkjasdlkjasd" /&gt;
			&lt;/Block&gt;
			&lt;String name="Offset2" value="ALSKJDALKSJD" /&gt;
			&lt;Block&gt;
				&lt;String name="Offset3" value="1" /&gt;
				&lt;String name="Offset4" value="" /&gt;
				&lt;String name="Offset5" value="1293812093" /&gt;
			&lt;/Block&gt;
		&lt;/Block&gt;
	&lt;/Block&gt;

	&lt;String name="Offset6" value="aslkdjalskdjas" /&gt;

&lt;/DataModel&gt;</programlisting>
<simpara><emphasis role="strong">Relative Offset</emphasis></simpara>
<simpara>A relative offset is the offset from the data element the relation is attached to.</simpara>
<simpara>If there is data that represents the distance (in bytes) to somewhere in target element, use the relative offset when you model your data. Peach automatically calculates the location so you know exact where it is.</simpara>
<simpara>In this example, when determining the offset of <emphasis>StringData</emphasis>, Peach adds or subtracts the position of <emphasis>OffsetToString</emphasis> to its value as needed to determine the correct offset.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;!-- Other data elements precede --&gt;

&lt;Number name="OffsetToString"&gt;
   &lt;Relation type="offset" of="StringData" relative="true" /&gt;
&lt;/Number&gt;

&lt;String name="StringData" nullTerminated="true"/&gt;</programlisting>
<simpara><emphasis role="strong">relativeTo Offset</emphasis></simpara>
<simpara>Offsets can also relate to another element.  This is used when an element contains the offset to another element from the start of a structure.</simpara>
<simpara>If there is data that represents the distance (in bytes) to another target element, use relativeTo Offset when you model your data. Peach automatically calculates the location so you know exact where it is. This keeps the relationship intact when fuzzing.</simpara>
<simpara>In the following example the offset of <emphasis>StringData</emphasis> is calculated by adding the value of <emphasis>OffsetToString</emphasis> to the position of <emphasis>Structure</emphasis>.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;Block name="Structure"&gt;
   &lt;!-- Other data elements precede --&gt;

   &lt;Number name="OffsetToString"&gt;
      &lt;Relation type="offset" of="StringData" relative="true" relativeTo="Structure" /&gt;
   &lt;/Number&gt;

   &lt;String name="StringData" nullTerminated="true"/&gt;
&lt;/Structure&gt;</programlisting>
<simpara><emphasis role="strong">With expressionGet/expressionSet</emphasis></simpara>
<simpara>Gets are applied during the cracking process and Sets are applied during the publishing process.</simpara>
<simpara>For the Offset relations, expressionGet and expressionSet use the two variables, <literal>self</literal> and <literal>offset</literal>.  Self refers to the Parent element and offset is an integer.</simpara>
<simpara>Expression gets and sets should be each other&#8217;s mathematical inverse. The Get input and Set output should be the same.</simpara>
<simpara>In this example we provide two python expressions that allow us to modify the offset when it is set or get.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;DataModel name="TheDataModel"&gt;
	&lt;Number name="num" size="32"&gt;
		&lt;Relation type="offset" of="Offset0" expressionGet="offset / 2" expressionSet="offset * 2"/&gt;
	&lt;/Number&gt;

	&lt;Blob/&gt;

	&lt;String name="Target" value="CRAZY STRING!" /&gt;
&lt;/DataModel&gt;</programlisting>
<variablelist>
<varlistentry>
<term>expressionGet</term>
<listitem>
<simpara>This value is used internally and determines the starting point of <literal>Target</literal> when cracking. data.  In the preceding example, if the value of the number <literal>num</literal> is 20, the string <literal>Target</literal> will begin at 10 bytes from the beginning of the data model.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>expressionSet</term>
<listitem>
<simpara>Sets the value that is produced.  In the preceding example, <literal>offset</literal> is based on the distance in bytes from the start of the data model to the beginning of the string <literal>Target</literal>.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis role="strong">Offset Relation with Placement</emphasis></simpara>
<simpara>In this model we use a typical pattern where an array of offsets gives us the location of another element. We use the <link linkend="Placement">Placement</link> element to move the created <emphasis>Data</emphasis> strings to after our block called <emphasis>Chunks</emphasis>.</simpara>
<simpara><emphasis role="strong">NOTE:</emphasis> Placement only works when parsing data into a DataModel.  See <link linkend="Placement">Placement</link> for more information.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;DataModel name="TheDataModel"&gt;
  &lt;Block name="Chunks"&gt;
    &lt;Block name="ArrayOfChunks" maxOccurs="4"&gt;
      &lt;Number size="8" signed="false"&gt;
        &lt;Relation type="offset" of="Data"/&gt;
      &lt;/Number&gt;
      &lt;String name="Data" length="6"&gt;
        &lt;Placement after="Chunks"/&gt;
      &lt;/String&gt;
    &lt;/Block&gt;
  &lt;/Block&gt;
&lt;/DataModel&gt;</programlisting>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Placement">
<title>Placement</title>
<simpara>The placement element tells the data cracker to move specific elements after
parsing the input stream.  This, combined with <link linkend="Relation">offset-of relation</link>,
are the ways Peach supports handling files that contain references to elements
by offset.</simpara>
<simpara>See also <link linkend="DataModeling_Placement">Arrays of Offsets to Data</link> chapter.</simpara>
<note>
<simpara>Placement only works while parsing data into the DataModel by an input Action or a Data statement pointing to a file.</simpara>
</note>
<section xml:id="_syntax_71">
<title>Syntax</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;DataModel name="TheDataModel"&gt;
  &lt;Block name="Chunks"&gt;
    &lt;Block name="ArrayOfChunks" maxOccurs="4"&gt;
      &lt;Number size="8" signed="false"&gt;
        &lt;Relation type="offset" of="Data"/&gt;
      &lt;/Number&gt;
      &lt;String name="Data" length="6"&gt;
        &lt;Placement after="Chunks"/&gt;
      &lt;/String&gt;
    &lt;/Block&gt;
  &lt;/Block&gt;
&lt;/DataModel&gt;</programlisting>
</section>
<section xml:id="_attributes_56">
<title>Attributes</title>
<simpara>One of the following is required:</simpara>
<variablelist>
<varlistentry>
<term>after</term>
<listitem>
<simpara>Name of the data element used in relocation. The relocated data is placed after the specified data element.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>before</term>
<listitem>
<simpara>Name of the data element used in relocation. The relocated data is placed before  the specified data element.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_child_elements_40">
<title>Child Elements</title>
<simpara>None.</simpara>
</section>
<section xml:id="_examples_54">
<title>Examples</title>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
</section>
<section xml:id="Fixup">
<title>Fixups</title>
<simpara>A data that has been fuzzed might fail internal checks because integrity fields, such as checksums, are no longer valid. Fixups provide mechanisms to update the integrity fields and facilitate downstream processing. Peach provides "Fixups" to recalculate integrity-related items such as checksums, CRCs, and hash values.</simpara>
<important>
<simpara>Fixups should be run after fuzzing and before processing fuzzed data.</simpara>
</important>
<table frame="all" rowsep="1" colsep="1">
<title>Default Fixups</title>
<tgroup cols="5">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="16.6666*"/>
<colspec colname="col_3" colwidth="16.6666*"/>
<colspec colname="col_4" colwidth="16.6666*"/>
<colspec colname="col_5" colwidth="16.6669*"/>
<thead>
<row>
<entry align="left" valign="top">Fixup</entry>
<entry align="center" valign="top">Checksum</entry>
<entry align="center" valign="top">Hashing</entry>
<entry align="center" valign="top">Utility</entry>
<entry align="center" valign="top">Sequencing</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><link linkend="Fixups_CiscoFixup">CiscoCdp Checksum</link></simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"></entry>
<entry align="center" valign="top"></entry>
<entry align="center" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="Fixups_CopyValueFixup">CopyValue</link></simpara></entry>
<entry align="center" valign="top"></entry>
<entry align="center" valign="top"></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="Fixups_CrcFixup">Crc</link></simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"></entry>
<entry align="center" valign="top"></entry>
<entry align="center" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="Fixups_CrcDualFixup">CrcDual</link></simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"></entry>
<entry align="center" valign="top"></entry>
<entry align="center" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="Fixups_ExpressionFixup">Expression</link></simpara></entry>
<entry align="center" valign="top"></entry>
<entry align="center" valign="top"></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="Fixups_FillValueFixup">FillValue</link></simpara></entry>
<entry align="center" valign="top"></entry>
<entry align="center" valign="top"></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="Fixups_FragSeqIncrementFixup">FragSeqIncrement</link></simpara></entry>
<entry align="center" valign="top"></entry>
<entry align="center" valign="top"></entry>
<entry align="center" valign="top"></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="Fixups_FromFileFixup">FromFile</link></simpara></entry>
<entry align="center" valign="top"></entry>
<entry align="center" valign="top"></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="Fixups_HMACFixup">Hmac</link></simpara></entry>
<entry align="center" valign="top"></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"></entry>
<entry align="center" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="Fixups_IcmpChecksumFixup">Icmp Checksum</link></simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"></entry>
<entry align="center" valign="top"></entry>
<entry align="center" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="Fixups_IcmpV6ChecksumFixup">IcmpV6 Checksum</link></simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"></entry>
<entry align="center" valign="top"></entry>
<entry align="center" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="Fixups_IsoFletcher16ChecksumFixup">IsoFletcher16 Checksum</link></simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"></entry>
<entry align="center" valign="top"></entry>
<entry align="center" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="Fixups_LRCFixup">Lrc</link></simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"></entry>
<entry align="center" valign="top"></entry>
<entry align="center" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="Fixups_MD5Fixup">Md5</link></simpara></entry>
<entry align="center" valign="top"></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"></entry>
<entry align="center" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="Fixups_ScriptFixup">Script</link></simpara></entry>
<entry align="center" valign="top"></entry>
<entry align="center" valign="top"></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="Fixups_SequenceIncrementFixup">Sequence Increment</link></simpara></entry>
<entry align="center" valign="top"></entry>
<entry align="center" valign="top"></entry>
<entry align="center" valign="top"></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="Fixups_SequenceRandomFixup">Sequence Random</link></simpara></entry>
<entry align="center" valign="top"></entry>
<entry align="center" valign="top"></entry>
<entry align="center" valign="top"></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="Fixups_SHA1Fixup">Sha</link></simpara></entry>
<entry align="center" valign="top"></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"></entry>
<entry align="center" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="Fixups_SHA224Fixup">Sha224</link></simpara></entry>
<entry align="center" valign="top"></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"></entry>
<entry align="center" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="Fixups_SHA256Fixup">Sha256</link></simpara></entry>
<entry align="center" valign="top"></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"></entry>
<entry align="center" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="Fixups_SHA384Fixup">Sha384</link></simpara></entry>
<entry align="center" valign="top"></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"></entry>
<entry align="center" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="Fixups_SHA512Fixup">Sha512</link></simpara></entry>
<entry align="center" valign="top"></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"></entry>
<entry align="center" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="Fixups_SspiFixup">Sspi</link></simpara></entry>
<entry align="center" valign="top"></entry>
<entry align="center" valign="top"></entry>
<entry align="center" valign="top"><simpara>Y</simpara></entry>
<entry align="center" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="Fixups_TCPChecksumFixup">TCP Checksum</link></simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"></entry>
<entry align="center" valign="top"></entry>
<entry align="center" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="Fixups_UDPChecksumFixup">UDP Checksum</link></simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"></entry>
<entry align="center" valign="top"></entry>
<entry align="center" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="Fixups_UnixTimeFixup">Unix Time</link></simpara></entry>
<entry align="center" valign="top"></entry>
<entry align="center" valign="top"></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara><?asciidoc-pagebreak?></simpara>
<section xml:id="Fixups_CiscoFixup">
<title>CiscoCdpChecksum</title>
<simpara><emphasis>CiscoCdpChecksum</emphasis> is a Custom Peach algorithm to fix  Cisco&#8217;s one-off error in their CRC implementation (known feature).
It is defined in RFC1071.
It can be found in the Open source CRCTool Library.
This fixup is used when fuzzing protocols perform the Cisco implementation of CRC.</simpara>
<section xml:id="_parent_elements">
<title>Parent Elements</title>
<simpara><link linkend="Number">Number</link>
<link linkend="String">String</link></simpara>
</section>
<section xml:id="_parameters_11">
<title>Parameters</title>
<variablelist>
<varlistentry>
<term><link linkend="ref">ref</link></term>
<listitem>
<simpara>Reference to the input data element used in the CRC calculation.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_55">
<title>Examples</title>
<example>
<title>Basic Usage Example</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

	&lt;DataModel name="NoCrcPacket"&gt;
		&lt;Number name="SrcPort"  size="16" endian="big" value="1234"/&gt;
		&lt;Number name="DestPort" size="16" endian="big" value="1235"/&gt;
		&lt;Number name="Length"   size="16" endian="big"&gt;
			&lt;Relation type="size" of="NoCrcPacket"/&gt;
		&lt;/Number&gt;
		&lt;Number name="checksum" size="16"&gt;
		&lt;/Number&gt;
	&lt;/DataModel&gt;

	&lt;DataModel name="Packet"&gt;
		&lt;Number name="SrcPort"  size="16" endian="big" value="1234"/&gt;
		&lt;Number name="DestPort" size="16" endian="big" value="1235"/&gt;
		&lt;Number name="Length"   size="16" endian="big"&gt;
			&lt;Relation type="size" of="Packet"/&gt;
		&lt;/Number&gt;
		&lt;Number name="checksum" size="16"&gt;
			&lt;Fixup class="CiscoFixup"&gt;
				&lt;Param name="ref" value="Packet" /&gt;
			&lt;/Fixup&gt;
		&lt;/Number&gt;
	&lt;/DataModel&gt;

	&lt;StateModel name="TheState" initialState="initial"&gt;
		&lt;State name="initial"&gt;
			&lt;Action type="output"&gt;
				&lt;DataModel ref="NoCrcPacket" /&gt;
			&lt;/Action&gt;

			&lt;Action type="output"&gt;
				&lt;DataModel ref="Packet" /&gt;
			&lt;/Action&gt;
		&lt;/State&gt;
	&lt;/StateModel&gt;

	&lt;Test name="Default"&gt;
		&lt;StateModel ref="TheState"/&gt;

		&lt;Publisher class="ConsoleHex" /&gt;
	&lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Output from this example.</simpara>
<screen>&gt;peach -1 --debug example.xml

[*] Test 'Default' starting with random seed 26396.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Binding Error, unable to resolve binding 'Packet' attached to 'NoCrcPacket.Length'.
Peach.Core.Dom.SizeRelation Error, Of returned null
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher start()
Peach.Core.Publishers.ConsolePublisher open()
Peach.Core.Publishers.ConsolePublisher output(8 bytes)
00000000   04 D2 04 D3 00 08 00 00                            ???????? <co xml:id="CO37-1"/>
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher output(8 bytes)
00000000   04 D2 04 D3 00 08 52 F6                            ??????R? <co xml:id="CO37-2"/>
Peach.Core.Publishers.ConsolePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.ConsolePublisher stop()

[*] Test 'Default' finished.</screen>
<calloutlist>
<callout arearefs="CO37-1">
<para>Output without CiscoFixup. Last two bytes are zero.</para>
</callout>
<callout arearefs="CO37-2">
<para>Output with CiscoFixup. Last two bytes are a valid CRC for the packet.</para>
</callout>
</calloutlist>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Fixups_CopyValueFixup">
<title>CopyValue</title>
<simpara>The <emphasis>CopyValue</emphasis> copies the reference element (ref) value into ours.
This is useful for situations where two elements must be identical for redundancy checks.</simpara>
<section xml:id="_parent_elements_2">
<title>Parent Elements</title>
<simpara><link linkend="Number">Number</link>
<link linkend="String">String</link>
<link linkend="Blob">Blob</link>
<link linkend="Block">Block</link></simpara>
</section>
<section xml:id="_parameters_12">
<title>Parameters</title>
<variablelist>
<varlistentry>
<term><link linkend="ref">ref</link></term>
<listitem>
<simpara>Reference to the source data element, containing the value to copy.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_56">
<title>Examples</title>
<example>
<title>Basic Usage Example</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

	&lt;DataModel name="Packet"&gt;
		&lt;String name="Magic1" value="ABCD" /&gt;
		&lt;String name="Magic2"&gt;
			&lt;Fixup class="CopyValue"&gt;
				&lt;Param name="ref" value="Magic1" /&gt;
			&lt;/Fixup&gt;
		&lt;/String&gt;
		&lt;Number name="Length"   size="16" endian="big"&gt;
			&lt;Relation type="size" of="Packet"/&gt;
		&lt;/Number&gt;
	&lt;/DataModel&gt;

	&lt;StateModel name="TheState" initialState="initial"&gt;
		&lt;State name="initial"&gt;
			&lt;Action type="output"&gt;
				&lt;DataModel ref="Packet" /&gt;
			&lt;/Action&gt;
		&lt;/State&gt;
	&lt;/StateModel&gt;

	&lt;Test name="Default"&gt;
		&lt;StateModel ref="TheState"/&gt;

		&lt;Publisher class="ConsoleHex"/&gt;
	&lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
</example>
<example>
<title>Example with Block copy</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

  &lt;DataModel name="Packet"&gt;
    &lt;Block name="M1"&gt;
      &lt;Number size="32" value="1234" /&gt;
      &lt;String value="ASDF" /&gt;
    &lt;/Block&gt;
    &lt;Block name="M2"&gt;
      &lt;Number size="32"/&gt;
      &lt;String /&gt;
      &lt;Fixup class="CopyValue"&gt;
        &lt;Param name="ref" value="M1" /&gt;
      &lt;/Fixup&gt;
    &lt;/Block&gt;
  &lt;/DataModel&gt;

  &lt;StateModel name="TheState" initialState="initial"&gt;
    &lt;State name="initial"&gt;
      &lt;Action type="output"&gt;
        &lt;DataModel ref="Packet" /&gt;
      &lt;/Action&gt;
    &lt;/State&gt;
  &lt;/StateModel&gt;

  &lt;Test name="Default"&gt;
    &lt;StateModel ref="TheState"/&gt;

    &lt;Publisher class="ConsoleHex" /&gt;
  &lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Output from example.</simpara>
<screen>&gt;peach -1 --debug example.xml

[*] Test 'Default' starting with random seed 3042.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher start()
Peach.Core.Publishers.ConsolePublisher open()
Peach.Core.Publishers.ConsolePublisher output(16 bytes)
00000000   D2 04 00 00 41 53 44 46  D2 04 00 00 41 53 44 46   ????ASDF????ASDF <co xml:id="CO38-1"/>
Peach.Core.Publishers.ConsolePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.ConsolePublisher stop()

[*] Test 'Default' finished.</screen>
<calloutlist>
<callout arearefs="CO38-1">
<para>The CopyValue fixup copied the first block into the second block.</para>
</callout>
</calloutlist>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Fixups_CrcDualFixup">
<title>CrcDual</title>
<simpara>The <emphasis>CrcDual</emphasis> produces a CRC using data from two elements.
It is defined in ISO 3309 and can be found in the Open source CRCTool Library.
This is used when fuzzing protocols that perform the CRC checksum on two elements.</simpara>
<section xml:id="_parent_elements_3">
<title>Parent Elements</title>
<simpara><link linkend="Number">Number</link>
<link linkend="String">String</link></simpara>
</section>
<section xml:id="_parameters_13">
<title>Parameters</title>
<variablelist>
<varlistentry>
<term><link linkend="ref">ref1</link></term>
<listitem>
<simpara>Reference to first input element used in the CRC calculation.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="ref">ref2</link></term>
<listitem>
<simpara>Reference to second element used in the CRC calculation.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>type</term>
<listitem>
<simpara>Type of CRC to run [CRC32, CRC16, CRC_CCITT]. Defaults to CRC32.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_57">
<title>Examples</title>
<example>
<title>Basic Usage Example</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

  &lt;DataModel name="Packet"&gt;
    &lt;Number name="SrcPort"  size="16" endian="big" value="1234"/&gt;
    &lt;Number name="DestPort" size="16" endian="big" value="1235"/&gt;
    &lt;Number name="Length"   size="16" endian="big"&gt;
      &lt;Relation type="size" of="Packet"/&gt;
    &lt;/Number&gt;
    &lt;Number name="checksum" size="16"&gt;
      &lt;Fixup class="CrcDualFixup"&gt;
        &lt;Param name="ref1" value="SrcPort" /&gt;
        &lt;Param name="ref2" value="DestPort" /&gt;
        &lt;Param name="type" value="CRC16" /&gt;
      &lt;/Fixup&gt;
    &lt;/Number&gt;
  &lt;/DataModel&gt;

  &lt;StateModel name="TheState" initialState="initial"&gt;
    &lt;State name="initial"&gt;
      &lt;Action type="output"&gt;
        &lt;DataModel ref="Packet" /&gt;
      &lt;/Action&gt;
    &lt;/State&gt;
  &lt;/StateModel&gt;

  &lt;Test name="Default"&gt;
    &lt;StateModel ref="TheState"/&gt;

    &lt;Publisher class="ConsoleHex" /&gt;
  &lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Output from this example</simpara>
<screen>&gt;peach -1 --debug example.xml

[*] Test 'Default' starting with random seed 65340.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher start()
Peach.Core.Publishers.ConsolePublisher open()
Peach.Core.Publishers.ConsolePublisher output(8 bytes)
00000000   04 D2 04 D3 00 08 E2 54                            ???????T
Peach.Core.Publishers.ConsolePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.ConsolePublisher stop()

[*] Test 'Default' finished.</screen>
</example>
</section>
</section>
<section xml:id="Fixups_CrcFixup">
<title>Crc</title>
<simpara>The <emphasis>Crc</emphasis> produces a CRC using data from the reference element.
It is defined in ISO 3309.
This is used when fuzzing CRC checksum protocols.</simpara>
<section xml:id="_parent_elements_4">
<title>Parent Elements</title>
<simpara><link linkend="Number">Number</link>
<link linkend="String">String</link></simpara>
</section>
<section xml:id="_parameters_14">
<title>Parameters</title>
<variablelist>
<varlistentry>
<term><link linkend="ref">ref</link></term>
<listitem>
<simpara>Reference to the input data element used in the CRC calculation.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>type</term>
<listitem>
<simpara>Type of CRC to run [CRC32, CRC16, CRC_CCITT]. Defaults to CRC32.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_58">
<title>Examples</title>
<example>
<title>Basic Usage Example</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

	&lt;DataModel name="Packet"&gt;
		&lt;Number name="SrcPort"  size="16" endian="big" value="1234"/&gt;
		&lt;Number name="DestPort" size="16" endian="big" value="1235"/&gt;
		&lt;Number name="Length"   size="16" endian="big"&gt;
			&lt;Relation type="size" of="Packet"/&gt;
		&lt;/Number&gt;
		&lt;Number name="checksum" size="16"&gt;
			&lt;Fixup class="Crc"&gt;
				&lt;Param name="ref" value="Packet" /&gt;
				&lt;Param name="type" value="CRC16" /&gt;
			&lt;/Fixup&gt;
		&lt;/Number&gt;
	&lt;/DataModel&gt;

	&lt;StateModel name="TheState" initialState="initial"&gt;
		&lt;State name="initial"&gt;
			&lt;Action type="output"&gt;
				&lt;DataModel ref="Packet" /&gt;
			&lt;/Action&gt;
		&lt;/State&gt;
	&lt;/StateModel&gt;

	&lt;Test name="Default"&gt;
		&lt;StateModel ref="TheState"/&gt;

		&lt;Publisher class="ConsoleHex" /&gt;
	&lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Output from this example</simpara>
<screen>&gt;peach -1 --debug example.xml

[*] Test 'Default' starting with random seed 52848.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher start()
Peach.Core.Publishers.ConsolePublisher open()
Peach.Core.Publishers.ConsolePublisher output(8 bytes)
00000000   04 D2 04 D3 00 08 F6 6A                            ???????j
Peach.Core.Publishers.ConsolePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.ConsolePublisher stop()

[*] Test 'Default' finished.</screen>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Fixups_ExpressionFixup">
<title>Expression</title>
<simpara>The <emphasis>Expression</emphasis> evaluates a scripting expression that produces the new value for our element.</simpara>
<section xml:id="_parameters_15">
<title>Parameters</title>
<variablelist>
<varlistentry>
<term><link linkend="ref">ref</link></term>
<listitem>
<simpara>Reference to the input data element used in the given expression.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>expression</term>
<listitem>
<simpara>Scripting expression to evaluate.  Must return a string or integer value.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_scripting_variables">
<title>Scripting Variables</title>
<variablelist>
<varlistentry>
<term>self</term>
<listitem>
<simpara>Fixup instance</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>ref</term>
<listitem>
<simpara>Referenced element</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>data</term>
<listitem>
<simpara>Referenced elements value as a byte array</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_59">
<title>Examples</title>
<example>
<title>Basic Usage Example</title>
<formalpara>
<title>example.xml</title>
<para>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

  &lt;Import import="ExpressionFixup" /&gt;

  &lt;DataModel name="NumericExpressionData"&gt;
    &lt;Number name="NumericData" size="32" value="14"/&gt;
    &lt;Number size="32"&gt;
      &lt;Fixup class="ExpressionFixup"&gt;
        &lt;Param name="ref" value="NumericData" /&gt;
        &lt;Param name="expression" value="ExpressionFixup.multiply_by_three(ref)" /&gt;
      &lt;/Fixup&gt;
    &lt;/Number&gt;
  &lt;/DataModel&gt;

  &lt;DataModel name="ByteArrayExpressionData"&gt;
    &lt;Blob&gt;
      &lt;Fixup class="ExpressionFixup"&gt;
        &lt;Param name="ref" value="StringData" /&gt;
        &lt;Param name="expression" value="ExpressionFixup.rot13(ref)" /&gt;
      &lt;/Fixup&gt;
    &lt;/Blob&gt;
    &lt;String name="StringData" value="uryyb jbeyq"/&gt;
  &lt;/DataModel&gt;

  &lt;DataModel name="InlineExpression"&gt;
    &lt;String name="StringData" value="hello there \n"/&gt;
    &lt;String&gt;
      &lt;Fixup class="ExpressionFixup"&gt;
        &lt;Param name="ref" value="StringData" /&gt;
        &lt;Param name="expression" value="str(str(ref.DefaultValue).upper())" /&gt;
      &lt;/Fixup&gt;
    &lt;/String&gt;
  &lt;/DataModel&gt;

  &lt;StateModel name="TheState" initialState="DumpNumeric"&gt;
    &lt;State name="DumpNumeric"&gt;
      &lt;Action type="output"&gt;
        &lt;DataModel ref="NumericExpressionData"/&gt;
      &lt;/Action&gt;
      &lt;Action type="changeState" ref="DumpByteArray"/&gt;
    &lt;/State&gt;

    &lt;State name="DumpByteArray"&gt;
      &lt;Action type="output"&gt;
        &lt;DataModel ref="ByteArrayExpressionData"/&gt;
      &lt;/Action&gt;
      &lt;Action type="changeState" ref="DumpInline"/&gt;
    &lt;/State&gt;

    &lt;State name="DumpInline"&gt;
      &lt;Action type="output"&gt;
        &lt;DataModel ref="InlineExpression"/&gt;
      &lt;/Action&gt;
    &lt;/State&gt;

  &lt;/StateModel&gt;

  &lt;Test name="Default"&gt;
    &lt;StateModel ref="TheState"/&gt;

    &lt;Publisher class="ConsoleHex"/&gt;
  &lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
</para>
</formalpara>
<formalpara>
<title>ExpressionFixup.py</title>
<para>
<programlisting language="python" linenumbering="unnumbered">from code import InteractiveConsole

import clr
clr.AddReferenceByPartialName('Peach.Core')
import Peach.Core


def multiply_by_three(ref):
    return int(ref.DefaultValue) * 3


def rot13(ref):
    return str(ref.DefaultValue).encode('rot13')


def debug(ctx, ref, data):
    """Useful for basic debugging.

    &lt;Param name="expression" value="debug(self, ref, data)" /&gt;
    """
    console = InteractiveConsole(locals=dict(globals().items()+locals().items()))
    console.interact()</programlisting>
</para>
</formalpara>
<simpara>Output from this example.</simpara>
<screen>&gt;peach -1 --debug example.xml

[*] Test 'Default' starting with random seed 25461.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher start()
Peach.Core.Publishers.ConsolePublisher open()
Peach.Core.Publishers.ConsolePublisher output(8 bytes)
00000000   0E 00 00 00 2A 00 00 00                            ????*??? <co xml:id="CO39-1"/>
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.ChangeState
Peach.Core.Dom.Action Changing to state: DumpByteArray
Peach.Core.Dom.StateModel Run(): Changing to state "DumpByteArray".
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher output(22 bytes)
00000000   68 65 6C 6C 6F 20 77 6F  72 6C 64 75 72 79 79 62   hello worlduryyb <co xml:id="CO39-2"/>
00000010   20 6A 62 65 79 71                                   jbeyq
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.ChangeState
Peach.Core.Dom.Action Changing to state: DumpInline
Peach.Core.Dom.StateModel Run(): Changing to state "DumpInline".
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher output(26 bytes)
00000000   68 65 6C 6C 6F 20 74 68  65 72 65 20 0A 48 45 4C   hello there ?HEL <co xml:id="CO39-3"/>
00000010   4C 4F 20 54 48 45 52 45  20 0A                     LO THERE ?
Peach.Core.Publishers.ConsolePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.ConsolePublisher stop()

[*] Test 'Default' finished.</screen>
<calloutlist>
<callout arearefs="CO39-1">
<para>Output using multiply_by_three expression</para>
</callout>
<callout arearefs="CO39-2">
<para>Output using rot13 expression</para>
</callout>
<callout arearefs="CO39-3">
<para>Output using an inline express</para>
</callout>
</calloutlist>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Fixups_FillValueFixup">
<title>FillValue</title>
<simpara>The <emphasis>FillValue</emphasis> is used to fill a data element with sequential numbers. The first number of the sequence is the value of the start parameter, and the end of the sequence is the value of the stop parameter.</simpara>
<simpara>If the range specified by the start and stop parameters is less than the size of the referenced element, the sequence repeats after reaching the last value in the range.</simpara>
<simpara>This fixup is used when fuzzing the IPsec protocol, as the required padding in the encrypted portion of the data requires padding that is sequential numbers.</simpara>
<section xml:id="_parent_elements_5">
<title>Parent Elements</title>
<simpara><link linkend="Number">Number</link>
<link linkend="Blob">Blob</link>
<link linkend="Padding">Padding</link></simpara>
</section>
<section xml:id="_parameters_16">
<title>Parameters</title>
<variablelist>
<varlistentry>
<term><link linkend="ref">ref</link></term>
<listitem>
<simpara>Reference to the data element that receives the sequence of values.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>start</term>
<listitem>
<simpara>Inclusive start fill value.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>stop</term>
<listitem>
<simpara>Inclusive stop fill value.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_60">
<title>Examples</title>
<example>
<title>Basic Usage Example</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

  &lt;DataModel name="Data"&gt;
    &lt;String name="Start" value="Start"/&gt;
    &lt;Blob name="Data" length="17"&gt;
      &lt;Fixup class="FillValue"&gt;
        &lt;Param name="ref" value="Data"/&gt;
        &lt;Param name="start" value="0"/&gt;
        &lt;Param name="stop" value="10"/&gt;
      &lt;/Fixup&gt;
    &lt;/Blob&gt;
    &lt;String name="Stop" value="Stop"/&gt;
  &lt;/DataModel&gt;

  &lt;StateModel name="TheState" initialState="initial"&gt;
    &lt;State name="initial"&gt;
      &lt;Action type="output"&gt;
        &lt;DataModel ref="Data" /&gt;
      &lt;/Action&gt;
    &lt;/State&gt;
  &lt;/StateModel&gt;

  &lt;Test name="Default"&gt;
    &lt;StateModel ref="TheState"/&gt;

    &lt;Publisher class="ConsoleHex"/&gt;  &lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Output from this example.</simpara>
<screen>&gt;peach -1 --debug example.xml

[*] Test 'Default' starting with random seed 57241.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher start()
Peach.Core.Publishers.ConsolePublisher open()
Peach.Core.Publishers.ConsolePublisher output(26 bytes)
00000000   53 74 61 72 74 00 01 02  03 04 05 06 07 08 09 0A   Start??????????? <co xml:id="CO40-1"/>
00000010   00 01 02 03 04 05 53 74  6F 70                     ??????Stop
Peach.Core.Publishers.ConsolePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.ConsolePublisher stop()

[*] Test 'Default' finished.</screen>
<calloutlist>
<callout arearefs="CO40-1">
<para>The FillValue fixup adds sequential numbers from 0 to 10 then repeats until the size of the element is filled.</para>
</callout>
</calloutlist>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Fixups_FragSeqIncrementFixup">
<title>FragSeqIncrement</title>
<simpara><emphasis>FragSeqIncrement</emphasis> is a specialized version of <link linkend="Fixups_SequenceIncrementFixup">SequenceIncrement</link> fixup for use in <link linkend="Frag">Frag</link> element <emphasis>Templates</emphasis>. This fixup should not be used for any other purpose.</simpara>
<simpara><emphasis>FragSeqIncrement</emphasis> supplies a value that increments with each iteration in a fuzzing session.
The value supplied for the first iteration starts with 1. This fixup is useful when a field
must be a unique value, or a sequenced value every iteration.</simpara>
<simpara>This checksum is useful for fuzzing a protocol that contains an increasing numerical sequence.
The Fixup produces valid numbers for the data element it modifies. The maximum value supplied
by <emphasis>FragSeqIncrement</emphasis> is constrained to the size of the data element.</simpara>
<simpara>See also <link linkend="Fixups_SequenceIncrementFixup">SequenceIncrement</link>, <link linkend="Frag">Frag</link>.</simpara>
<note>
<simpara>This fixup must be used in a <link linkend="Frag">Frag</link> element <emphasis>Template</emphasis> model.</simpara>
</note>
<section xml:id="_parent_elements_6">
<title>Parent Elements</title>
<simpara><link linkend="Number">Number</link>
<link linkend="String">String</link></simpara>
</section>
<section xml:id="_parameters_17">
<title>Parameters</title>
<variablelist>
<varlistentry>
<term>Group</term>
<listitem>
<simpara>Designates a group name that bundles a single fixup to multiple data elements. The result coordinates the incrementing process with the members of the group.  The default value is "".</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>InitialValue</term>
<listitem>
<simpara>Sets the initial value for the first iteration. The default value is 1, and the sequence using the default value starts with 1, 2, 3. If InitialValue is set to the value 57, the sequence starts with 57, 58, 59.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Offset</term>
<listitem>
<simpara>Sets the initial value each iteration to Offset * (Iteration - 1). The default value is null.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Once</term>
<listitem>
<simpara>Increment the value once per iteration. The default value is false.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_61">
<title>Examples</title>
<example>
<title>Simple Example</title>
<simpara>Produce three fragments with each fragment contianing the current fragment lenght, fragement sequence and total length of data. The Payload is 30 bytes of 0x41.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
			 xsi:schemaLocation="http://peachfuzzer.com/2012/Peach /peach/peach.xsd"&gt;

    &lt;DataModel name="Fragmented"&gt;
        &lt;Frag fragLength="10" &gt;

            &lt;Block name="Template"&gt;
                &lt;Number name="FragSequence" size="32"&gt;
                    &lt;Fixup class="FragSeqIncrement" /&gt;
                &lt;/Number&gt;

                &lt;Blob name="FragData" /&gt;
            &lt;/Block&gt;

            &lt;Block name="Payload"&gt;
                &lt;Blob valueType="hex" value="
                    41 41 41 41 41 41 41 41 41 41
                    41 41 41 41 41 41 41 41 41 41
                    41 41 41 41 41 41 41 41 41 41"/&gt;
            &lt;/Block&gt;
        &lt;/Frag&gt;
	&lt;/DataModel&gt;

	&lt;StateModel name="TheState" initialState="Initial"&gt;
		&lt;State name="Initial"&gt;
			&lt;Action type="outfrag"&gt;
				&lt;DataModel ref="Fragmented"/&gt;
			&lt;/Action&gt;
		&lt;/State&gt;
	&lt;/StateModel&gt;

	&lt;Test name="Default"&gt;
		&lt;StateModel ref="TheState"/&gt;
		&lt;Publisher class="ConsoleHex"/&gt;
	&lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>The example pit will produce three fragments with 10 bytes of payload per-fragment.</simpara>
<simpara>Output from this example:</simpara>
<screen>&gt;peach -1 --debug example.xml

[*] Web site running at: http://10.0.1.87:8888/

[*] Test 'Default' starting with random seed 8670.
2016-07-12 13:40:06.2441 Peach.Pro.Core.Loggers.JobLogger Writing debug.log to: c:\peach-pro\output\win_x64_debug\bin\Logs\example.xml_20160712134004\debug.log

[R1,-,-] Performing iteration
2016-07-12 13:40:06.4156 Peach.Core.Engine runTest: Performing control recording iteration.
2016-07-12 13:40:06.4457 Peach.Core.Dom.Frag Generating fragments:
2016-07-12 13:40:06.4617 Peach.Core.Dom.StateModel Run(): Changing to state "Initial".
2016-07-12 13:40:06.4617 Peach.Core.Dom.Action Run(Action): Outfrag
2016-07-12 13:40:06.5968 Peach.Pro.Core.Publishers.ConsolePublisher start()
2016-07-12 13:40:06.5968 Peach.Pro.Core.Publishers.ConsolePublisher open()
2016-07-12 13:40:06.6008 Peach.Pro.Core.Publishers.ConsolePublisher output(14 bytes)
00000000   01 00 00 00 41 41 41 41  41 41 41 41 41 41         ....AAAAAAAAAA <co xml:id="CO41-1"/>
2016-07-12 13:40:06.6008 Peach.Pro.Core.Publishers.ConsolePublisher output(14 bytes)
00000000   02 00 00 00 41 41 41 41  41 41 41 41 41 41         ....AAAAAAAAAA <co xml:id="CO41-2"/>
2016-07-12 13:40:06.6008 Peach.Pro.Core.Publishers.ConsolePublisher output(14 bytes)
00000000   03 00 00 00 41 41 41 41  41 41 41 41 41 41         ....AAAAAAAAAA <co xml:id="CO41-3"/>
2016-07-12 13:40:06.6008 Peach.Pro.Core.Publishers.ConsolePublisher close()
2016-07-12 13:40:06.6008 Peach.Core.Engine runTest: context.config.singleIteration == true
2016-07-12 13:40:06.6008 Peach.Pro.Core.Publishers.ConsolePublisher stop()
2016-07-12 13:40:06.6008 Peach.Core.Engine EndTest: Stopping all agents and monitors

[*] Test 'Default' finished.</screen>
<calloutlist>
<callout arearefs="CO41-1">
<para>First fragment. Notice sequence number is 1.</para>
</callout>
<callout arearefs="CO41-2">
<para>Second fragment. Notice sequence number is 2.</para>
</callout>
<callout arearefs="CO41-3">
<para>Third fragment. Notice sequence number is 3.</para>
</callout>
</calloutlist>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Fixups_FromFileFixup">
<title>FromFile</title>
<simpara>The <emphasis>FromFile</emphasis> is used to fill a BLOB data element with the contents of the specified file. The entire file is transferred, replacing the content of the BLOB.
The fixup supports reading of raw or PEM-encoded data files.</simpara>
<simpara>The main use case is to access cryptographic keys stored in files instead of exposing the key values in Pits or configuration files. In this use case, Peach pulls keys from .pem files in fuzzing cryptographic protocols.</simpara>
<section xml:id="_parent_elements_7">
<title>Parent Elements</title>
<simpara><link linkend="Blob">Blob</link></simpara>
</section>
<section xml:id="_parameters_18">
<title>Parameters</title>
<variablelist>
<varlistentry>
<term>Filename</term>
<listitem>
<simpara>Filename that contains the data to load into the BLOB.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Encoding</term>
<listitem>
<simpara>Encoding scheme used on the data in the file. Values are</simpara>
<itemizedlist>
<listitem>
<simpara>Raw - This is the default value.</simpara>
</listitem>
<listitem>
<simpara>Pem - Base-64 X.509 encoding.</simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term>Required</term>
<listitem>
<simpara>Does the file have to exist? Defaults to true. When false, the blob will be empty with length of zero.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_62">
<title>Examples</title>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Fixups_IcmpChecksumFixup">
<title>IcmpChecksum</title>
<simpara>The <emphasis>IcmpChecksum</emphasis> produces a checksum using the ICMP algorithm used commonly in ICMP and IPv4. It is defined and documented in RFC 1071 and RFC 2460 and can be found in the Custom Peach implementation.</simpara>
<section xml:id="_parent_elements_8">
<title>Parent Elements</title>
<simpara><link linkend="Number">Number</link>
<link linkend="String">String</link></simpara>
</section>
<section xml:id="_parameters_19">
<title>Parameters</title>
<variablelist>
<varlistentry>
<term><link linkend="ref">ref</link></term>
<listitem>
<simpara>The input data element used in the checksum calculation.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_63">
<title>Examples</title>
<example>
<title>Basic Usage Example</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

  &lt;DataModel name="Data"&gt;
    &lt;Block name="Content"&gt;
      &lt;Number name="Type" size="8"/&gt;
      &lt;Number name="Code" size="8"/&gt;
      &lt;Number name="Checksum" endian="big" size="16"&gt;
        &lt;Fixup class="IcmpChecksumFixup"&gt;
          &lt;Param name="ref" value="Content" /&gt;
        &lt;/Fixup&gt;
      &lt;/Number&gt;
      &lt;Blob name="Payload" value="hello" /&gt;
    &lt;/Block&gt;
  &lt;/DataModel&gt;

  &lt;StateModel name="TheState" initialState="initial"&gt;
    &lt;State name="initial"&gt;
      &lt;Action type="output"&gt;
        &lt;DataModel ref="Data" /&gt;
      &lt;/Action&gt;
    &lt;/State&gt;
  &lt;/StateModel&gt;

  &lt;Test name="Default"&gt;
    &lt;StateModel ref="TheState"/&gt;

     &lt;Publisher class="RawV4"&gt;
      &lt;Param name="Host" value="127.0.0.1"/&gt;
      &lt;Param name="Interface" value="127.0.0.1"/&gt;
      &lt;Param name="Protocol" value="1"/&gt;
     &lt;/Publisher&gt;
  &lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Output from this example.</simpara>
<screen>&gt;peach -1 --debug example.xml

[*] Test 'Default' starting with random seed 37625.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.RawV4Publisher start()
Peach.Core.Publishers.RawV4Publisher open()
Peach.Core.Publishers.RawV4Publisher output(9 bytes)
Peach.Core.Publishers.RawV4Publisher

00000000   00 00 BC 2D 68 65 6C 6C  6F                        -hello

Peach.Core.Publishers.RawV4Publisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.RawV4Publisher stop()

[*] Test 'Default' finished.</screen>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Fixups_IcmpV6ChecksumFixup">
<title>IcmpV6Checksum</title>
<simpara>The <emphasis>IcmpV6Checksum</emphasis> fixup produces a checksum using the ICMPV6 algorithm used commonly in ICMP and IPv6. It is defined and documented in RFC 1071 and RFC 2460 and can be found in the Custom Peach implementation.</simpara>
<section xml:id="_parent_elements_9">
<title>Parent Elements</title>
<itemizedlist>
<listitem>
<simpara><link linkend="Number">Number</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="String">String</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="_parameters_20">
<title>Parameters</title>
<variablelist>
<varlistentry>
<term><link linkend="ref">ref</link></term>
<listitem>
<simpara>Reference to the input data element used in the checksum calculation.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>src</term>
<listitem>
<simpara>Source IPv6 address of the local machine.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>dst</term>
<listitem>
<simpara>Destination IPv6 address of the remote machine.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_64">
<title>Examples</title>
<example>
<title>Basic Usage Example</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

  &lt;DataModel name="Data"&gt;
    &lt;Block name="Content"&gt;
      &lt;Number name="Type" size="8"/&gt;
      &lt;Number name="Code" size="8"/&gt;
      &lt;Number name="Checksum" endian="big" size="16"&gt;
        &lt;Fixup class="IcmpV6ChecksumFixup"&gt;
          &lt;Param name="ref" value="Content" /&gt;
          &lt;Param name="src" value="::1" /&gt;
          &lt;Param name="dst" value="::1" /&gt;
        &lt;/Fixup&gt;
      &lt;/Number&gt;
      &lt;Blob name="Payload" value="hello" /&gt;
    &lt;/Block&gt;
  &lt;/DataModel&gt;

  &lt;StateModel name="TheState" initialState="initial"&gt;
    &lt;State name="initial"&gt;
      &lt;Action type="output"&gt;
        &lt;DataModel ref="Data" /&gt;
      &lt;/Action&gt;
    &lt;/State&gt;
  &lt;/StateModel&gt;

  &lt;Test name="Default"&gt;
    &lt;StateModel ref="TheState"/&gt;

    &lt;Publisher class="RawV6"&gt;
      &lt;Param name="Host" value="::1"/&gt;
      &lt;Param name="Interface" value="::1"/&gt;
      &lt;Param name="Protocol" value="1"/&gt;
    &lt;/Publisher&gt;  &lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Output from this example.</simpara>
<screen>&gt;peach -1 --debug DocSample.xml

[*] Test 'Default' starting with random seed 43286.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.RawV6Publisher start()
Peach.Core.Publishers.RawV6Publisher open()
Peach.Core.Publishers.RawV6Publisher output(9 bytes)
Peach.Core.Publishers.RawV6Publisher

00000000   00 00 BB E8 68 65 6C 6C  6F                        hello

Peach.Core.Publishers.RawV6Publisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.RawV6Publisher stop()

[*] Test 'Default' finished.</screen>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Fixups_IsoFletcher16ChecksumFixup">
<title>IsoFletcher16Checksum</title>
<simpara>The <emphasis>IsoFletcher16Checksum</emphasis> fixup produces a checksum defined in RFC 1008 section 7.
OSPF version 2 is one notable protocol which uses this checksum algorithm,
as defined in RFC 2328 section 12.1.7.</simpara>
<section xml:id="_parent_elements_10">
<title>Parent Elements</title>
<simpara><link linkend="Number">Number</link>
<link linkend="String">String</link></simpara>
</section>
<section xml:id="_parameters_21">
<title>Parameters</title>
<variablelist>
<varlistentry>
<term><link linkend="ref">ref</link></term>
<listitem>
<simpara>The input data element used in the checksum calculation.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_65">
<title>Examples</title>
<example>
<title>Basic Usage Example</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

  &lt;DataModel name="Data"&gt;
    &lt;Block name='Message'&gt;
        &lt;Number name='Header' size='32' endian='big' value='0' /&gt;
        &lt;Number name='Checksum' size='16' endian='big' value='0'&gt;
            &lt;Fixup class='IsoFletcher16Checksum'&gt;
                &lt;Param name='ref' value='Message'/&gt;
            &lt;/Fixup&gt;
        &lt;/Number&gt;
        &lt;Number name='Payload' size='32' endian='big' value='3133731337'/&gt;
    &lt;/Block&gt;
  &lt;/DataModel&gt;

  &lt;StateModel name="TheState" initialState="initial"&gt;
    &lt;State name="initial"&gt;
      &lt;Action type="output"&gt;
        &lt;DataModel ref="Data" /&gt;
      &lt;/Action&gt;
    &lt;/State&gt;
  &lt;/StateModel&gt;

  &lt;Test name="Default"&gt;
    &lt;StateModel ref="TheState"/&gt;
    &lt;Publisher class="ConsoleHex"/&gt;
  &lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Output from this example.</simpara>
<screen>&gt;peach -1 --debug example.xml

[*] Test 'Default' starting with random seed 32810.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.StateModel Run(): Changing to state "initial".
Peach.Core.Dom.Action Run(Action): Output
Peach.Pro.Core.Publishers.ConsolePublisher start()
Peach.Pro.Core.Publishers.ConsolePublisher open()
Peach.Pro.Core.Publishers.ConsolePublisher output(10 bytes)
00000000   00 00 00 00 49 37 BA C8  F2 09                     ....I7....
Peach.Pro.Core.Publishers.ConsolePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Pro.Core.Publishers.ConsolePublisher stop()
Peach.Core.Engine EndTest: Stopping all agents and monitors

[*] Test 'Default' finished.</screen>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Fixups_LRCFixup">
<title>Lrc</title>
<simpara>The <emphasis>Lrc</emphasis> fixup produces a longitudinal redundancy check (LRC) using data from a single element.
The LRC is defined in ISO 1150:1978 and the algorithm is part of the custom Peach implementation.</simpara>
<section xml:id="_parent_elements_11">
<title>Parent Elements</title>
<itemizedlist>
<listitem>
<simpara><link linkend="Number">Number</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="String">String</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="Blob">Blob</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="_parameters_22">
<title>Parameters</title>
<variablelist>
<varlistentry>
<term><link linkend="ref">ref</link></term>
<listitem>
<simpara>Reference to the input data element used in the LRC calculation.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_66">
<title>Examples</title>
<example>
<title>Basic Usage Example</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach ../peach.xsd"&gt;

  &lt;DataModel name="Data"&gt;
    &lt;String name="Start" value="Start"/&gt;
    &lt;Blob name="Data" valueType="hex" value="BEEFEA7E41"&gt;
      &lt;Fixup class="LRCFixup"&gt;
        &lt;Param name="ref" value="Data"/&gt;
      &lt;/Fixup&gt;
    &lt;/Blob&gt;
    &lt;String name="Stop" value="Stop"/&gt;
  &lt;/DataModel&gt;

  &lt;StateModel name="TheState" initialState="initial"&gt;
    &lt;State name="initial"&gt;
      &lt;Action type="output"&gt;
        &lt;DataModel ref="Data" /&gt;
      &lt;/Action&gt;
    &lt;/State&gt;
  &lt;/StateModel&gt;

  &lt;Test name="Default"&gt;
    &lt;StateModel ref="TheState"/&gt;

    &lt;Publisher class="ConsoleHex"/&gt;
  &lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Output from this example.</simpara>
<screen>&gt;peach -1 --debug example.xml

[*] Test 'Default' starting with random seed 13931.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher start()
Peach.Core.Publishers.ConsolePublisher open()
Peach.Core.Publishers.ConsolePublisher output(10 bytes)
00000000   53 74 61 72 74 AA 53 74  6F 70                     Start?Stop
Peach.Core.Publishers.ConsolePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.ConsolePublisher stop()

[*] Test 'Default' finished.</screen>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Fixups_HMACFixup">
<title>Hmac</title>
<simpara>The <emphasis>Hmac</emphasis> fixup hashes the <emphasis>ref</emphasis> element&#8217;s value using the one of the defined HMAC algorithms. This is used in fuzzing IPsec protocol implementations.</simpara>
<section xml:id="_parent_elements_12">
<title>Parent Elements</title>
<simpara><link linkend="String">String</link>
<link linkend="Blob">Blob</link></simpara>
</section>
<section xml:id="_parameters_23">
<title>Parameters</title>
<variablelist>
<varlistentry>
<term><link linkend="ref">ref</link></term>
<listitem>
<simpara>Reference to the input data element used in the HMAC calculation.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Key</term>
<listitem>
<simpara>Key to use for HMAC.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>HMAC</term>
<listitem>
<simpara>Hash algorithm to use (HMACSHA1 HMACMD5, HMACRIPEMD160, HMACSHA256, HMACSHA384, HMACSHA512, MACTripleDES).</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="length">Length</link></term>
<listitem>
<simpara>Length in bytes to return from HMAC, the default value is 0 and returns all bytes. Allows all or a portion of the calculated hash to be returned to the element.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_67">
<title>Examples</title>
<example>
<title>SHA-1 HMAC returning all bytes</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

  &lt;DataModel name="Data"&gt;
    &lt;String name="Start" value="Start"/&gt;
    &lt;Blob name="Data" valueType="hex" value="BEEFEA7E41"&gt;
      &lt;Fixup class="HMAC"&gt;
        &lt;Param name="ref" value="Data"/&gt;
        &lt;Param name="Key" value="aeaeaeaeaeaeaeaeaeaeaeaeaeaeaeae"/&gt;
        &lt;Param name="Hash" value="HMACSHA1"/&gt;
        &lt;Param name="Length" value="0"/&gt;
      &lt;/Fixup&gt;
    &lt;/Blob&gt;
    &lt;String name="Stop" value="Stop"/&gt;
  &lt;/DataModel&gt;

  &lt;StateModel name="TheState" initialState="initial"&gt;
    &lt;State name="initial"&gt;
      &lt;Action type="output"&gt;
        &lt;DataModel ref="Data" /&gt;
      &lt;/Action&gt;
    &lt;/State&gt;
  &lt;/StateModel&gt;

  &lt;Test name="Default"&gt;
    &lt;StateModel ref="TheState"/&gt;

    &lt;Publisher class="ConsoleHex"/&gt;  &lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Output from this example</simpara>
<screen>&gt;peach -1 --debug DocSample.xml

[*] Test 'Default' starting with random seed 40206.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher start()
Peach.Core.Publishers.ConsolePublisher open()
Peach.Core.Publishers.ConsolePublisher output(29 bytes)
00000000   53 74 61 72 74 43 A0 3C  5D 3C 68 39 53 B4 55 B5   StartC?&lt;]&lt;h9S?U?
00000010   07 E1 74 60 37 E9 72 D4  52 53 74 6F 70            ??t`7?r?RStop
Peach.Core.Publishers.ConsolePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.ConsolePublisher stop()

[*] Test 'Default' finished.</screen>
</example>
<example>
<title>SHA-1 HMAC returning 10 bytes of output</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

  &lt;DataModel name="Data"&gt;
    &lt;String name="Start" value="Start"/&gt;
    &lt;Blob name="Data" valueType="hex" value="BEEFEA7E41"&gt;
      &lt;Fixup class="HMAC"&gt;
        &lt;Param name="ref" value="Data"/&gt;
        &lt;Param name="Key" value="aeaeaeaeaeaeaeaeaeaeaeaeaeaeaeae"/&gt;
        &lt;Param name="Hash" value="HMACSHA1"/&gt;
        &lt;Param name="Length" value="10"/&gt;
      &lt;/Fixup&gt;
    &lt;/Blob&gt;
    &lt;String name="Stop" value="Stop"/&gt;
  &lt;/DataModel&gt;

  &lt;StateModel name="TheState" initialState="initial"&gt;
    &lt;State name="initial"&gt;
      &lt;Action type="output"&gt;
        &lt;DataModel ref="Data" /&gt;
      &lt;/Action&gt;
    &lt;/State&gt;
  &lt;/StateModel&gt;

  &lt;Test name="Default"&gt;
    &lt;StateModel ref="TheState"/&gt;

    &lt;Publisher class="ConsoleHex"/&gt;  &lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Output from this example</simpara>
<screen>&gt;peach -1 --debug example.xml

[*] Test 'Default' starting with random seed 27945.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher start()
Peach.Core.Publishers.ConsolePublisher open()
Peach.Core.Publishers.ConsolePublisher output(19 bytes)
00000000   53 74 61 72 74 43 A0 3C  5D 3C 68 39 53 B4 55 53   StartC?&lt;]&lt;h9S?US <co xml:id="CO42-1"/>
00000010   74 6F 70                                           top
Peach.Core.Publishers.ConsolePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.ConsolePublisher stop()

[*] Test 'Default' finished.</screen>
<calloutlist>
<callout arearefs="CO42-1">
<para>The output of the HMAC is truncated to 10 bytes</para>
</callout>
</calloutlist>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Fixups_MD5Fixup">
<title>Md5</title>
<simpara>The <emphasis>Md5</emphasis> fixup hashes the value of the reference element using the MD5 algorithm.
The MD5 algorithm is defined in defined in RFC 1321 and can be found in the .Net Framework Implementation.</simpara>
<section xml:id="_parent_elements_13">
<title>Parent Elements</title>
<itemizedlist>
<listitem>
<simpara><link linkend="String">String</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="Blob">Blob</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="_parameters_24">
<title>Parameters</title>
<variablelist>
<varlistentry>
<term><link linkend="ref">ref</link></term>
<listitem>
<simpara>Reference to the input data element used in the hash calculation.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_68">
<title>Examples</title>
<example>
<title>Basic Usage Example</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

  &lt;DataModel name="Data"&gt;
    &lt;String name="Start" value="Start"/&gt;
    &lt;Blob name="Data" valueType="hex" value="BEEFEA7E41"&gt;
      &lt;Fixup class="MD5Fixup"&gt;
        &lt;Param name="ref" value="Data"/&gt;
      &lt;/Fixup&gt;
    &lt;/Blob&gt;
    &lt;String name="Stop" value="Stop"/&gt;
  &lt;/DataModel&gt;

  &lt;StateModel name="TheState" initialState="initial"&gt;
    &lt;State name="initial"&gt;
      &lt;Action type="output"&gt;
        &lt;DataModel ref="Data" /&gt;
      &lt;/Action&gt;
    &lt;/State&gt;
  &lt;/StateModel&gt;

  &lt;Test name="Default"&gt;
    &lt;StateModel ref="TheState"/&gt;

    &lt;Publisher class="ConsoleHex"/&gt;  &lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Output from this example.</simpara>
<screen>&gt;peach -1 --debug example.xml

[*] Test 'Default' starting with random seed 60443.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher start()
Peach.Core.Publishers.ConsolePublisher open()
Peach.Core.Publishers.ConsolePublisher output(25 bytes)
00000000   53 74 61 72 74 10 09 04  EA 69 04 2A 0E 15 00 72   Start????i?*???r
00000010   FD 70 D0 25 52 53 74 6F  70                        ?p?%RStop
Peach.Core.Publishers.ConsolePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.ConsolePublisher stop()

[*] Test 'Default' finished.</screen>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Fixups_ScriptFixup">
<title>Script</title>
<simpara><emphasis>Script</emphasis> is a proxy that allow you to write fixups in a scripting language such as Python or Ruby.</simpara>
<simpara>The class parameter is required for python fixups. It has two arguments:</simpara>
<variablelist>
<varlistentry>
<term>self</term>
<listitem>
<simpara>a python construct inherent in the language.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>element</term>
<listitem>
<simpara>the data element that the script "fixed up".</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>The class parameter&#8217;s returned argument must match the Fixup parent&#8217;s DataElement type.</simpara>
<section xml:id="_parent_elements_14">
<title>Parent Elements</title>
<simpara>Parent type must match the DataElement type returned by the Fixup.</simpara>
</section>
<section xml:id="_parameters_25">
<title>Parameters</title>
<variablelist>
<varlistentry>
<term><link linkend="ref">ref</link></term>
<listitem>
<simpara>Reference to the input data element used in the script.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>class</term>
<listitem>
<simpara>Reference to the Python class to call.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_69">
<title>Examples</title>
<example>
<title>Basic Usage Example</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach ../peach.xsd"&gt;

  &lt;Import import="MathWrapperFixup" /&gt;

  &lt;DataModel name="TheDataModel"&gt;
    &lt;Number name="FirstNumber"  size="16" endian="big" value="10"/&gt;
    &lt;Number name="Log10Number" size="16"  endian="big"&gt;
      &lt;Fixup class="ScriptFixup"&gt;
        &lt;Param name="class" value="MathWrapperFixup.MathWrapper" /&gt;
        &lt;Param name="ref" value="FirstNumber" /&gt;
      &lt;/Fixup&gt;
    &lt;/Number&gt;
  &lt;/DataModel&gt;

  &lt;StateModel name="TheState" initialState="initial"&gt;
    &lt;State name="initial"&gt;
      &lt;Action type="output"&gt;
        &lt;DataModel ref="TheDataModel" /&gt;
      &lt;/Action&gt;
    &lt;/State&gt;
  &lt;/StateModel&gt;

  &lt;Test name="Default"&gt;
    &lt;StateModel ref="TheState"/&gt;

    &lt;Publisher class="ConsoleHex" /&gt;  &lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<programlisting language="python" linenumbering="unnumbered"># MathWrapperFixup.py
import math

class MathWrapper:
  def __init__(self, parent):
    self._parent = parent

  def fixup(self, element):
    return int(math.log10(element.DefaultValue))</programlisting>
<simpara>Output from this example.</simpara>
<screen>&gt;peach -1 --debug DocSample.xml

Peach.Core.Fixups.ScriptFixup ScriptFixup(): _pythonFixup != null

[*] Test 'Default' starting with random seed 22619.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Fixups.ScriptFixup fixupImpl(): ref: 27449293
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher start()
Peach.Core.Publishers.ConsolePublisher open()
Peach.Core.Publishers.ConsolePublisher output(4 bytes)
00000000   00 0A 00 01                                        ????
Peach.Core.Publishers.ConsolePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.ConsolePublisher stop()

[*] Test 'Default' finished.</screen>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Fixups_SequenceIncrementFixup">
<title>SequenceIncrement</title>
<simpara><emphasis>SequenceIncrement</emphasis> supplies a value that increments with each iteration in a fuzzing session.
The value supplied for the first iteration starts with 1. This fixup is useful when a field
must be a unique value, or a sequenced value every iteration.</simpara>
<simpara>This checksum is useful for fuzzing a protocol that contains an increasing numerical sequence.
The Fixup produces valid numbers for the data element it modifies. The maximum value supplied
by <emphasis>SequenceIncrement</emphasis> is constrained to the size of the data element.</simpara>
<section xml:id="_parent_elements_15">
<title>Parent Elements</title>
<simpara><link linkend="Number">Number</link>
<link linkend="String">String</link></simpara>
</section>
<section xml:id="_parameters_26">
<title>Parameters</title>
<variablelist>
<varlistentry>
<term>Group</term>
<listitem>
<simpara>Designates a group name that bundles a single fixup to multiple data elements. The result coordinates the incrementing process with the members of the group.  The default value is "".</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>InitialValue</term>
<listitem>
<simpara>Sets the initial value for the first iteration. The default value is 1, and the sequence using the default value starts with 1, 2, 3. If InitialValue is set to the value 57, the sequence starts with 57, 58, 59.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Offset</term>
<listitem>
<simpara>Sets the initial value each iteration to Offset * (Iteration - 1). The default value is null.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Once</term>
<listitem>
<simpara>Increment the value once per iteration. The default value is false.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_70">
<title>Examples</title>
<example>
<title>Basic SequencialIncrement Example</title>
<simpara>Three outputs with Once set to false. The number is incremented before each action.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

  &lt;DataModel name="Packet"&gt;
    &lt;Number name="SrcPort"  size="16" endian="big" value="1234"/&gt;
    &lt;Number name="DestPort" size="16" endian="big" value="1235"/&gt;
    &lt;Number name="Length"   size="16" endian="big"&gt;
      &lt;Relation type="size" of="Packet"/&gt;
    &lt;/Number&gt;
    &lt;Number name="IncrementingNumber" size="16"  endian="big"&gt;
      &lt;Fixup class="SequenceIncrementFixup"/&gt;
    &lt;/Number&gt;
  &lt;/DataModel&gt;

  &lt;StateModel name="TheState" initialState="initial"&gt;
    &lt;State name="initial"&gt;
      &lt;Action type="output"&gt;
        &lt;DataModel ref="Packet" /&gt;
      &lt;/Action&gt;
      &lt;Action type="output"&gt;
        &lt;DataModel ref="Packet" /&gt;
      &lt;/Action&gt;
      &lt;Action type="output"&gt;
        &lt;DataModel ref="Packet" /&gt;
      &lt;/Action&gt;
    &lt;/State&gt;
  &lt;/StateModel&gt;

  &lt;Test name="Default"&gt;
    &lt;StateModel ref="TheState"/&gt;

    &lt;Publisher class="ConsoleHex" /&gt;
  &lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Output from this example.</simpara>
<screen>&gt;peach -1 --debug example.xml

[*] Test 'Default' starting with random seed 64358.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher start()
Peach.Core.Publishers.ConsolePublisher open()
Peach.Core.Publishers.ConsolePublisher output(8 bytes)
00000000   04 D2 04 D3 00 08 00 01                            ????????
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher output(8 bytes)
00000000   04 D2 04 D3 00 08 00 02                            ????????
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher output(8 bytes)
00000000   04 D2 04 D3 00 08 00 03                            ????????
Peach.Core.Publishers.ConsolePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.ConsolePublisher stop()

[*] Test 'Default' finished.</screen>
</example>
<example>
<title>Non Default Offset</title>
<simpara>Three outputs with Once set to false and Offset to 5. The number is incremented by 5 each iteration.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

  &lt;DataModel name="Packet"&gt;
    &lt;Number name="SrcPort"  size="16" endian="big" value="1234"/&gt;
    &lt;Number name="DestPort" size="16" endian="big" value="1235"/&gt;
    &lt;Number name="Length"   size="16" endian="big"&gt;
      &lt;Relation type="size" of="Packet"/&gt;
    &lt;/Number&gt;
    &lt;Number name="IncrementingNumber" size="16"  endian="big"&gt;
      &lt;Fixup class="SequenceIncrementFixup"&gt;
        &lt;Param name="Offset" value="5" /&gt;
      &lt;/Fixup&gt;
    &lt;/Number&gt;
  &lt;/DataModel&gt;

  &lt;StateModel name="TheState" initialState="initial"&gt;
    &lt;State name="initial"&gt;
      &lt;Action type="output"&gt;
        &lt;DataModel ref="Packet" /&gt;
      &lt;/Action&gt;
    &lt;/State&gt;
  &lt;/StateModel&gt;

  &lt;Test name="Default"&gt;
    &lt;StateModel ref="TheState"/&gt;

    &lt;Publisher class="ConsoleHex" /&gt;
  &lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Output of this example.</simpara>
<screen>&gt;peach -1 --debug example.xml

[*] Test 'Default' starting with random seed 26794.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher start()
Peach.Core.Publishers.ConsolePublisher open()
Peach.Core.Publishers.ConsolePublisher output(8 bytes)
00000000   04 D2 04 D3 00 08 00 01                            ????????
Peach.Core.Publishers.ConsolePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.ConsolePublisher stop()

[*] Test 'Default' finished.</screen>
</example>
<example>
<title>Non Default Once</title>
<simpara>Three outputs with Once set to true. Each action outputs the same incremented number.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

  &lt;DataModel name="Packet"&gt;
    &lt;Number name="SrcPort"  size="16" endian="big" value="1234"/&gt;
    &lt;Number name="DestPort" size="16" endian="big" value="1235"/&gt;
    &lt;Number name="Length"   size="16" endian="big"&gt;
      &lt;Relation type="size" of="Packet"/&gt;
    &lt;/Number&gt;
    &lt;Number name="IncrementingNumber" size="16"  endian="big"&gt;
      &lt;Fixup class="SequenceIncrementFixup"&gt;
        &lt;Param name="Once" value="true" /&gt;
      &lt;/Fixup&gt;
    &lt;/Number&gt;
  &lt;/DataModel&gt;

  &lt;StateModel name="TheState" initialState="initial"&gt;
    &lt;State name="initial"&gt;
      &lt;Action type="output"&gt;
        &lt;DataModel ref="Packet" /&gt;
      &lt;/Action&gt;
      &lt;Action type="output"&gt;
        &lt;DataModel ref="Packet" /&gt;
      &lt;/Action&gt;
      &lt;Action type="output"&gt;
        &lt;DataModel ref="Packet" /&gt;
      &lt;/Action&gt;
    &lt;/State&gt;
  &lt;/StateModel&gt;

  &lt;Test name="Default"&gt;
    &lt;StateModel ref="TheState"/&gt;

    &lt;Publisher class="ConsoleHex" /&gt;
  &lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Output from this example.</simpara>
<screen>&gt;peach -1 --debug example.xml

[*] Test 'Default' starting with random seed 2157.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher start()
Peach.Core.Publishers.ConsolePublisher open()
Peach.Core.Publishers.ConsolePublisher output(8 bytes)
00000000   04 D2 04 D3 00 08 00 01                            ????????
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher output(8 bytes)
00000000   04 D2 04 D3 00 08 00 01                            ????????
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher output(8 bytes)
00000000   04 D2 04 D3 00 08 00 01                            ????????
Peach.Core.Publishers.ConsolePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.ConsolePublisher stop()</screen>
</example>
<example>
<title>Group</title>
<simpara>The group parameter coordinates the incrementing process among the data elements that specify a fixup with a common group name, as in the following DataModel.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;

&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

    &lt;DataModel name='DM'&gt;
		&lt;Number name='num' size='16'&gt;
			&lt;Fixup class='SequenceIncrementFixup'&gt;
				&lt;Param name='Group' value='mygroup'/&gt;
			&lt;/Fixup&gt;
		&lt;/Number&gt;
		&lt;Number name='num2' size='16'&gt;
			&lt;Fixup class='SequenceIncrementFixup'&gt;
				&lt;Param name='Group' value='mygroup'/&gt;
			&lt;/Fixup&gt;
		&lt;/Number&gt;
	&lt;/DataModel&gt;

    &lt;StateModel name="TheState" initialState="initial"&gt;
        &lt;State name="initial"&gt;
          &lt;Action type="output"&gt;
            &lt;DataModel ref="Packet" /&gt;
          &lt;/Action&gt;
        &lt;/State&gt;
    &lt;/StateModel&gt;

    &lt;Test name="Default"&gt;
      &lt;StateModel ref="TheState"/&gt;

      &lt;Publisher class="ConsoleHex" /&gt;
    &lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>In this example, data elements "num" and "num3" each have a fixup defined with the Group parameter set to "mygroup". This means that both data elements use the same fixup. When fuzzing occurs, the fixup initially assigns the value 1 to num. The next data item, "num2", uses this fixup as well and receives the value 2.</simpara>
<simpara>On the second fuzzing iteration, num and num2 receive the values 3 and 4 from the fixup, respecively.</simpara>
<simpara>Now, to contrast this behavior, if the Group parameter is not specified, num uses one fixup that has a starting value of 1; num2 also uses a fixup, albeit a different fixup, that has a starting value of 1. When fuzzing occurs, the fixup associated to num assigns the value 1 to num. The other fixup, associated to num2, assigns the value 1 to num2.</simpara>
<simpara>On the second fuzzing iteration, num and num2 receive the next values from their fixups. For num, this value is 2. For num2, the value from the second fixup is 2 as well.</simpara>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Fixups_SequenceRandomFixup">
<title>SequenceRandom</title>
<simpara>The <emphasis>SequenceRandom</emphasis> fixup produces a random integer each iteration.
This is useful when a field must be a unique value every iteration.</simpara>
<simpara>This checksum can be used when fuzzing protocols that contain a nonce or pseudo-random sequence number.
The RNG uses the same seed as Peach, so values produced are reproducible by setting the seed via the command line.</simpara>
<note>
<simpara>SequenceRandom does not protect duplicate values from occurring.</simpara>
</note>
<section xml:id="_parent_elements_16">
<title>Parent Elements</title>
<simpara><link linkend="Number">Number</link>
<link linkend="String">String</link></simpara>
</section>
<section xml:id="_parameters_27">
<title>Parameters</title>
<simpara>This fixup does not support any parameters.</simpara>
</section>
<section xml:id="_examples_71">
<title>Examples</title>
<example>
<title>Example of SequenceRandom Fixup</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

	&lt;DataModel name="Packet"&gt;
		&lt;Number name="SrcPort"  size="16" endian="big" value="1234"/&gt;
		&lt;Number name="DestPort" size="16" endian="big" value="1235"/&gt;
		&lt;Number name="Length"   size="16" endian="big"&gt;
			&lt;Relation type="size" of="Packet"/&gt;
		&lt;/Number&gt;
		&lt;Number name="Nonce" size="16" endian="big"&gt;
			&lt;Fixup class="SequenceRandomFixup" /&gt;
		&lt;/Number&gt;
	&lt;/DataModel&gt;

	&lt;StateModel name="TheState" initialState="initial"&gt;
		&lt;State name="initial"&gt;
			&lt;Action type="output"&gt;
				&lt;DataModel ref="Packet" /&gt;
			&lt;/Action&gt;
		&lt;/State&gt;
	&lt;/StateModel&gt;

	&lt;Test name="Default"&gt;
		&lt;StateModel ref="TheState"/&gt;

		&lt;Publisher class="ConsoleHex" /&gt;
	&lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Output of this example.</simpara>
<screen>&gt;peach -1 --debug example.xml

[*] Test 'Default' starting with random seed 24885.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher start()
Peach.Core.Publishers.ConsolePublisher open()
Peach.Core.Publishers.ConsolePublisher output(8 bytes)
00000000   04 D2 04 D3 00 08 93 F9                            ????????
Peach.Core.Publishers.ConsolePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.ConsolePublisher stop()

[*] Test 'Default' finished.</screen>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Fixups_SHA1Fixup">
<title>Sha1</title>
<simpara>Performs an SHA-1 hash of the value of the reference element and places the result in the parent element. This is used when fuzzing protocols that hash data with SHA-1.</simpara>
<simpara>The SHA1 algorithm is defined in US Federal Information Processing Standard (FIPS) PUB 180-4 and is implemented in .Net Framework Implementation - System.Security.Cryptography.</simpara>
<section xml:id="_parent_elements_17">
<title>Parent Elements</title>
<simpara><link linkend="String">String</link>
<link linkend="Blob">Blob</link></simpara>
</section>
<section xml:id="_parameters_28">
<title>Parameters</title>
<variablelist>
<varlistentry>
<term><link linkend="ref">ref</link></term>
<listitem>
<simpara>Reference to the input data element used in the hash calculation.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_72">
<title>Examples</title>
<example>
<title>Basic Sha1 Fixup Example</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

	&lt;DataModel name="Packet"&gt;
		&lt;Block name="Header"&gt;
			&lt;Number name="SrcPort"  size="16" endian="big" value="1234"/&gt;
			&lt;Number name="DestPort" size="16" endian="big" value="1235"/&gt;
			&lt;Number name="Length"   size="16" endian="big"&gt;
				&lt;Relation type="size" of="Packet"/&gt;
			&lt;/Number&gt;
		&lt;/Block&gt;
		&lt;Blob name="Checksum"&gt;
			&lt;Fixup class="SHA1Fixup"&gt;
				&lt;Param name="ref" value="Header" /&gt;
			&lt;/Fixup&gt;
		&lt;/Blob&gt;
	&lt;/DataModel&gt;

	&lt;StateModel name="TheState" initialState="initial"&gt;
		&lt;State name="initial"&gt;
			&lt;Action type="output"&gt;
				&lt;DataModel ref="Packet" /&gt;
			&lt;/Action&gt;
		&lt;/State&gt;
	&lt;/StateModel&gt;

	&lt;Test name="Default"&gt;
		&lt;StateModel ref="TheState"/&gt;

		&lt;Publisher class="ConsoleHex" /&gt;
	&lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Output from this example.</simpara>
<screen>&gt;peach -1 --debug example.xml

[*] Test 'Default' starting with random seed 7957.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher start()
Peach.Core.Publishers.ConsolePublisher open()
Peach.Core.Publishers.ConsolePublisher output(26 bytes)
00000000   04 D2 04 D3 00 1A 56 02  66 86 1E 9C 67 29 55 B9   ??????V?f???g)U?
00000010   E4 16 DE 0F 81 F0 10 19  B8 42                     ?????????B
Peach.Core.Publishers.ConsolePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.ConsolePublisher stop()

[*] Test 'Default' finished.</screen>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Fixups_SHA224Fixup">
<title>Sha224</title>
<simpara>Performs an SHA-224 hash of value of the reference element value and places the result in the parent element. This is used when fuzzing protocols that hash data with SHA-224.</simpara>
<simpara>The SHA224 algorithm is defined in US Federal Information Processing Standard (FIPS) PUB 180-4 and is implemented in .Net Framework Implementation - System.Security.Cryptography.</simpara>
<section xml:id="_parent_elements_18">
<title>Parent Elements</title>
<simpara><link linkend="String">String</link>
<link linkend="Blob">Blob</link></simpara>
</section>
<section xml:id="_parameters_29">
<title>Parameters</title>
<variablelist>
<varlistentry>
<term><link linkend="ref">ref</link></term>
<listitem>
<simpara>Reference to the input data element used in the hash calculation.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_73">
<title>Examples</title>
<example>
<title>Basic Sha224 Example</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

	&lt;DataModel name="Packet"&gt;
		&lt;Block name="Header"&gt;
			&lt;Number name="SrcPort"  size="16" endian="big" value="1234"/&gt;
			&lt;Number name="DestPort" size="16" endian="big" value="1235"/&gt;
			&lt;Number name="Length"   size="16" endian="big"&gt;
				&lt;Relation type="size" of="Packet"/&gt;
			&lt;/Number&gt;
		&lt;/Block&gt;
		&lt;Blob name="Checksum"&gt;
			&lt;Fixup class="SHA224Fixup"&gt;
				&lt;Param name="ref" value="Header" /&gt;
			&lt;/Fixup&gt;
		&lt;/Blob&gt;
	&lt;/DataModel&gt;

	&lt;StateModel name="TheState" initialState="initial"&gt;
		&lt;State name="initial"&gt;
			&lt;Action type="output"&gt;
				&lt;DataModel ref="Packet" /&gt;
			&lt;/Action&gt;
		&lt;/State&gt;
	&lt;/StateModel&gt;

	&lt;Test name="Default"&gt;
		&lt;StateModel ref="TheState"/&gt;

		&lt;Publisher class="ConsoleHex" /&gt;
	&lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Output from this example.</simpara>
<screen>&gt;peach -1 --debug example.xml

[*] Test 'Default' starting with random seed 54740.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher start()
Peach.Core.Publishers.ConsolePublisher open()
Peach.Core.Publishers.ConsolePublisher output(34 bytes)
00000000   04 D2 04 D3 00 22 C3 B5  EB 17 A9 4E DE EE 74 69   ?????"?????N??ti
00000010   DD 51 F3 E0 83 0B BD 39  BA 98 EB E7 A7 DC ED F2   ?Q?????9????????
00000020   1A A3                                              ??
Peach.Core.Publishers.ConsolePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.ConsolePublisher stop()

[*] Test 'Default' finished.</screen>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Fixups_SHA256Fixup">
<title>Sha256</title>
<simpara>Performs an SHA-256 hash of the value of the reference element and places the result in the parent element. This is used when fuzzing protocols that hash data with SHA-256.</simpara>
<simpara>The SHA256 algorithm is defined in US Federal Information Processing Standard (FIPS) PUB 180-4 and is implemented in .Net Framework Implementation - System.Security.Cryptography.</simpara>
<section xml:id="_parent_elements_19">
<title>Parent Elements</title>
<simpara><link linkend="String">String</link>
<link linkend="Blob">Blob</link></simpara>
</section>
<section xml:id="_parameters_30">
<title>Parameters</title>
<variablelist>
<varlistentry>
<term><link linkend="ref">ref</link></term>
<listitem>
<simpara>Reference to the input data element used in the hash calculation.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_74">
<title>Examples</title>
<example>
<title>Basic Sha256 Example</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach ../peach.xsd"&gt;

	&lt;DataModel name="Packet"&gt;
		&lt;Block name="Header"&gt;
			&lt;Number name="SrcPort"  size="16" endian="big" value="1234"/&gt;
			&lt;Number name="DestPort" size="16" endian="big" value="1235"/&gt;
			&lt;Number name="Length"   size="16" endian="big"&gt;
				&lt;Relation type="size" of="Packet"/&gt;
			&lt;/Number&gt;
		&lt;/Block&gt;
		&lt;Blob name="Checksum"&gt;
			&lt;Fixup class="SHA256Fixup"&gt;
				&lt;Param name="ref" value="Header" /&gt;
			&lt;/Fixup&gt;
		&lt;/Blob&gt;
	&lt;/DataModel&gt;

	&lt;StateModel name="TheState" initialState="initial"&gt;
		&lt;State name="initial"&gt;
			&lt;Action type="output"&gt;
				&lt;DataModel ref="Packet" /&gt;
			&lt;/Action&gt;
		&lt;/State&gt;
	&lt;/StateModel&gt;

	&lt;Test name="Default"&gt;
		&lt;StateModel ref="TheState"/&gt;

		&lt;Publisher class="ConsoleHex"/&gt;
	&lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Output from this example.</simpara>
<screen>&gt;peach -1 --debug example.xml

[*] Test 'Default' starting with random seed 16510.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher start()
Peach.Core.Publishers.ConsolePublisher open()
Peach.Core.Publishers.ConsolePublisher output(38 bytes)
00000000   04 D2 04 D3 00 26 77 C1  D9 9C D4 EC 59 14 A1 92   ?????&amp;w?????Y???
00000010   09 5D 9A A0 45 66 7C A4  14 80 DB A5 66 EC 53 3C   ?]??Ef|?????f?S&lt;
00000020   95 E4 34 CF 63 B9                                  ??4?c?
Peach.Core.Publishers.ConsolePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.ConsolePublisher stop()

[*] Test 'Default' finished.</screen>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Fixups_SHA384Fixup">
<title>Sha384</title>
<simpara>Performs an SHA-384 hash of value of the reference element and places the result in the parent element. This is used when fuzzing protocols that hash data with SHA-384.</simpara>
<simpara>The SHA384 algorithm is defined in US Federal Information Processing Standard (FIPS) PUB 180-4 and is implemented in .Net Framework Implementation - System.Security.Cryptography.</simpara>
<section xml:id="_parent_elements_20">
<title>Parent Elements</title>
<simpara><link linkend="String">String</link>
<link linkend="Blob">Blob</link></simpara>
</section>
<section xml:id="_parameters_31">
<title>Parameters</title>
<variablelist>
<varlistentry>
<term><link linkend="ref">ref</link></term>
<listitem>
<simpara>Reference to the input data element used in the hash calculation.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_75">
<title>Examples</title>
<example>
<title>Basic Sha384 Example</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

  &lt;DataModel name="Packet"&gt;
    &lt;Block name="Header"&gt;
      &lt;Number name="SrcPort"  size="16" endian="big" value="1234"/&gt;
      &lt;Number name="DestPort" size="16" endian="big" value="1235"/&gt;
      &lt;Number name="Length"   size="16" endian="big"&gt;
        &lt;Relation type="size" of="Packet"/&gt;
      &lt;/Number&gt;
    &lt;/Block&gt;
    &lt;Blob name="Checksum"&gt;
      &lt;Fixup class="SHA384Fixup"&gt;
        &lt;Param name="ref" value="Header"/&gt;
      &lt;/Fixup&gt;
    &lt;/Blob&gt;
  &lt;/DataModel&gt;

  &lt;StateModel name="TheState" initialState="initial"&gt;
    &lt;State name="initial"&gt;
      &lt;Action type="output"&gt;
        &lt;DataModel ref="Packet"/&gt;
      &lt;/Action&gt;
    &lt;/State&gt;
  &lt;/StateModel&gt;

  &lt;Test name="Default"&gt;
    &lt;StateModel ref="TheState"/&gt;

    &lt;Publisher class="ConsoleHex"/&gt;
  &lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Output of this example.</simpara>
<screen>&gt;peach -1 --debug example.xml

[*] Test 'Default' starting with random seed 22335.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher start()
Peach.Core.Publishers.ConsolePublisher open()
Peach.Core.Publishers.ConsolePublisher output(54 bytes)
00000000   04 D2 04 D3 00 36 20 74  77 0A 0F B0 5A F8 B0 6B   ?????6 tw???Z??k
00000010   BE FC 4C CC 83 1A 25 C5  E9 5B 02 F5 F7 E0 41 05   ??L???%??[????A?
00000020   77 FB 86 6F 02 40 CE 32  E5 46 85 74 7B A3 0C 70   w??o?@?2?F?t{??p
00000030   E6 67 7D 0B 74 5A                                  ?g}?tZ
Peach.Core.Publishers.ConsolePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.ConsolePublisher stop()

[*] Test 'Default' finished.</screen>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Fixups_SHA512Fixup">
<title>Sha512</title>
<simpara>Performs an SHA-512 hash of the value of the reference element value and places the result in the parent element. This is used when fuzzing protocols that hash data with SHA-512.</simpara>
<simpara>The SHA512 algorithm is defined in US Federal Information Processing Standard (FIPS) PUB 180-4 and is implemented in .Net Framework Implementation - System.Security.Cryptography.</simpara>
<section xml:id="_parent_elements_21">
<title>Parent Elements</title>
<simpara><link linkend="String">String</link>
<link linkend="Blob">Blob</link></simpara>
</section>
<section xml:id="_parameters_32">
<title>Parameters</title>
<variablelist>
<varlistentry>
<term><link linkend="ref">ref</link></term>
<listitem>
<simpara>Reference to the input data element used in the hash calculation.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_76">
<title>Examples</title>
<example>
<title>Example of SHA512Fixup Usage</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

	&lt;DataModel name="Packet"&gt;
		&lt;Block name="Header"&gt;
			&lt;Number name="SrcPort"  size="16" endian="big" value="1234"/&gt;
			&lt;Number name="DestPort" size="16" endian="big" value="1235"/&gt;
			&lt;Number name="Length"   size="16" endian="big"&gt;
				&lt;Relation type="size" of="Packet"/&gt;
			&lt;/Number&gt;
		&lt;/Block&gt;
		&lt;Blob name="Checksum"&gt;
			&lt;Fixup class="SHA512Fixup"&gt;
				&lt;Param name="ref" value="Header" /&gt;
			&lt;/Fixup&gt;
		&lt;/Blob&gt;
	&lt;/DataModel&gt;

	&lt;StateModel name="TheState" initialState="initial"&gt;
		&lt;State name="initial"&gt;
			&lt;Action type="output"&gt;
				&lt;DataModel ref="Packet" /&gt;
			&lt;/Action&gt;
		&lt;/State&gt;
	&lt;/StateModel&gt;

	&lt;Test name="Default"&gt;
		&lt;StateModel ref="TheState"/&gt;

		&lt;Publisher class="ConsoleHex" /&gt;
	&lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Output of this example.</simpara>
<screen>&gt;peach -1 --debug example.xml

[*] Test 'Default' starting with random seed 4183.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher start()
Peach.Core.Publishers.ConsolePublisher open()
Peach.Core.Publishers.ConsolePublisher output(70 bytes)
00000000   04 D2 04 D3 00 46 ED 87  D8 F8 8A B6 42 62 F9 51   ?????F??????Bb?Q
00000010   4F D8 A5 C7 6C 19 7C 14  8C 03 E3 09 EA 5D 28 78   O???l?|??????](x
00000020   E1 98 6D A7 1A 96 BA 9A  E1 F3 F0 B2 B3 EA 05 5C   ??m????????????\
00000030   9F A1 94 90 0A 68 80 2B  DB 9B F0 B6 05 2D 4D E6   ?????h?+?????-M?
00000040   DF 36 BB 42 F8 31                                  ?6?B?1
Peach.Core.Publishers.ConsolePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.ConsolePublisher stop()

[*] Test 'Default' finished.</screen>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Fixups_SspiFixup">
<title>Sspi</title>
<simpara>The <emphasis>Sspi</emphasis> fixup enables Peach to perform the Microsoft SSPI challenge-response
authentication process for the NTLMv2 mechanism and attempts to negotiate it.
The Microsoft SSPI authentication process is common across Microsoft protocols and
APIs, including Windows file-sharing protocols CIFS/SMB.</simpara>
<simpara>The challenge-response nature of this protocol necessitates using the fixup multiple
times to complete an authentication process. For NTLMv2, the challenge-response
process consists of at least three messages between the client and server. This fixup
uses and stores data in the iteration state bag to consume the last message from the
server. Also, the SSPI fixup provides a Boolean indicator identifying whether another
message is needed or authentication is complete.</simpara>
<simpara>Since the number of messages needed to complete the authentication process is not
known initially (due to the mechanism being negotiated), the protocol or API typically
has a loop that continues until authentication completes. A loop is the preferred way
to model this in the state model of the fuzzing definition. A specific state will be
performed over and over until the fixup indicates that authentication has completed.
See the examples section of this fixup for an example of how this might be modeled.</simpara>
<example>
<title>NOTES</title>
<simpara>The CIFS_Server Pit is a working example of this process. By default, this fixup uses
two iteration state store keys during it&#8217;s operation:</simpara>
<itemizedlist>
<listitem>
<simpara>Peach.SspiSecurityBuffer - Stores messages received from the server. In response to
this message, the fixup consumes this data and produces the next message in the series.</simpara>
</listitem>
<listitem>
<simpara>Peach.SspiContinueNeeded - Indicates whether an additional authentication message from
the service is needed. False indicates the authentication is complete. True indicates
another message is needed from the server, and is the default values.</simpara>
</listitem>
</itemizedlist>
</example>
<section xml:id="_parent_elements_22">
<title>Parent Elements</title>
<simpara><link linkend="Blob">Blob</link></simpara>
</section>
<section xml:id="_parameters_33">
<title>Parameters</title>
<simpara><emphasis>Required:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>User</term>
<listitem>
<simpara>User name of the authorizing account.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Password</term>
<listitem>
<simpara>Password associated with the authorizing account.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>Domain</term>
<listitem>
<simpara>Domain in which the authorizing account resides. Default is <literal>""</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>ContinueNeeded</term>
<listitem>
<simpara>Reference to a key for connection-oriented use in NTLM.
The value is the name of the field in the state bag that indicates whether
authentication continues (as in a connection).</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_77">
<title>Examples</title>
<formalpara>
<title>Sspi Fixup Example</title>
<para>This example consists of two code fragments:</para>
</formalpara>
<itemizedlist>
<listitem>
<simpara>A few lines of Python code takes the received message from the server and places
it into the Peach state store. The fixup then processes the message text next time
the script runs.</simpara>
</listitem>
<listitem>
<simpara>A portion of the State model that performs the challenge response authentication.</simpara>
</listitem>
</itemizedlist>
<note>
<simpara>The challenge-response authentication requires multiple exchanges between
the client and the server to complete the authentication process. The example
shows the portion of the state model that achieves the authentication.</simpara>
</note>
<simpara>The following Python fragment sets up the storage for the challenge/response value
in the state bag:</simpara>
<informalexample>
<literallayout class="monospaced">import clr
clr.AddReferenceByPartialName('Peach.Core')</literallayout>
<literallayout class="monospaced">import Peach.Core
import System</literallayout>
<literallayout class="monospaced">def ContinueUpdate(ctx, action):
    securityBuffer = action.dataModel.find('SecurityBuffer')
    if securityBuffer != None:
        ctx.iterationStateStore['Peach.SspiSecurityBuffer'] = securityBuffer.Value</literallayout>
</informalexample>
<simpara>The following pit fragment defines the action to achieve authentication in the state model.</simpara>
<informalexample>
<programlisting language="xml" linenumbering="unnumbered">&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

	&lt;DataModel name="Packet"&gt;
        &lt;String name="SspiResponse"&gt;
			&lt;Fixup class="SspiFixup"&gt;
                &lt;String name="User" value="PeachUser"/&gt;
                &lt;String name="Password" value="Calhoun30701"/&gt;
                &lt;String name="Domain" value="CAITLIN" /&gt;
                &lt;String name="SecurityContinues" value="" /&gt;
		    &lt;/Fixup&gt;
        &lt;/String&gt;

        &lt;BLob name="UserData" /&gt;
    &lt;/DataModel&gt;


    &lt;StateModel&gt;
        &lt;State name="Initial"&gt;
            &lt;!-- Fill in initial state details --&gt;
        &lt;/State&gt;

        &lt;!-- The next state will loop several times to perform
             the challenge-response authentication --&gt;
        &lt;State name="Authenticate"&gt;
            &lt;Action type="output" name="SessionSetupRequest"&gt;
                &lt;DataModel ref="CIFS:TcpRequest"/&gt;
            &lt;/Action&gt;

            &lt;Action type="input" name="SessionSetupResponse"
                onComplete="cifs.ContinueUpdate(Context, Action)"&gt;

                &lt;DataModel ref="CIFS:TcpResponse"/&gt;
            &lt;/Action&gt;

            &lt;!-- Next action does the loop until authenticate is done --&gt;
            &lt;Action type="changeState" ref="Authenticate"
                when="Context.iterationStateStore['Peach.SspiContinueNeeded']" /&gt;

            &lt;!-- Authentication complete, goto next state --&gt;
            &lt;Action type="changeState" ref="ConnectIpc" /&gt;
        &lt;/State&gt;
    &lt;/StateModel&gt;

    &lt;!-- Place the remaining pit details here. --&gt;

&lt;/Peach&gt;</programlisting>
</informalexample>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Fixups_TCPChecksumFixup">
<title>TCPChecksum</title>
<simpara>The <emphasis>TCPChecksum</emphasis> fixup produces an Internet checksum as defined in RFC 1071. This checksum is primarily used when fuzzing the TCPv4 and TCPv6 Protocols.</simpara>
<simpara>A discussion on how to apply TCPChecksum can be found in RFC 793 for IPv4 and RFC 2460 for IPv6.</simpara>
<section xml:id="_parent_elements_23">
<title>Parent Elements</title>
<simpara><link linkend="Number">Number</link>
<link linkend="String">String</link></simpara>
</section>
<section xml:id="_parameters_34">
<title>Parameters</title>
<variablelist>
<varlistentry>
<term><link linkend="ref">ref</link></term>
<listitem>
<simpara>Reference to the input data element used in the checksum calculation.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>src</term>
<listitem>
<simpara>Source IP Address. IP address of the local machine.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>dst</term>
<listitem>
<simpara>Destination IP Address. IP address of the remote machine.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_78">
<title>Examples</title>
<example>
<title>Basic Usage Example</title>
<simpara>This example shows the basic usage of TCPChecksum.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach ../peach.xsd"&gt;

	&lt;DataModel name="Packet"&gt;
		&lt;Block name="Header"&gt;
			&lt;Number name="SrcPort" size="16" endian="big" value="1234"/&gt;
			&lt;Number name="DestPort" size="16" endian="big" value="1235"/&gt;
			&lt;Number name="SequenceNumber" size="32" endian="big" valueType="hex" value="0043a577"/&gt;
			&lt;Number name="AcknowledgmentNumber" size="32" endian="big" value="0"/&gt;
			&lt;Number name="DataOffset" size="4" endian="big" /&gt;
			&lt;Number name="ControlBits" size="12" endian="big" /&gt;
			&lt;Number name="WindowSize" size="16" endian="big" valueType="hex" value="aaaa"/&gt;
			&lt;Number name="CheckSum" size="16" endian="big"&gt;
				&lt;Fixup class="TCPChecksum"&gt;
					&lt;Param name="ref" value="Packet" /&gt;
					&lt;Param name="src" value="127.0.0.1" /&gt;
					&lt;Param name="dst" value="127.0.0.1" /&gt;
				&lt;/Fixup&gt;
			&lt;/Number&gt;
			&lt;Number name="UrgentPointer" size="16" endian="big"/&gt;
		&lt;/Block&gt;
	&lt;/DataModel&gt;

	&lt;StateModel name="TheState" initialState="initial"&gt;
		&lt;State name="initial"&gt;
			&lt;Action type="output"&gt;
				&lt;DataModel ref="Packet" /&gt;
			&lt;/Action&gt;
		&lt;/State&gt;
	&lt;/StateModel&gt;

	&lt;Test name="Default"&gt;
		&lt;StateModel ref="TheState"/&gt;

		&lt;Publisher class="ConsoleHex" /&gt;	&lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Output from this example.</simpara>
<screen>&gt;peach -1 --debug example.xml

[*] Test 'Default' starting with random seed 20133.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher start()
Peach.Core.Publishers.ConsolePublisher open()
Peach.Core.Publishers.ConsolePublisher output(20 bytes)
00000000   04 D2 04 D3 00 43 A5 77  00 00 00 00 00 00 AA AA   ?????C?w????????
00000010   A7 D8 00 00                                        ????
Peach.Core.Publishers.ConsolePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.ConsolePublisher stop()

[*] Test 'Default' finished.</screen>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Fixups_UDPChecksumFixup">
<title>UDPChecksum</title>
<simpara>The <emphasis>UDPChecksum</emphasis> fixup produces an checksum as defined in RFC 1071. This checksum is primarily used when fuzzing the UDPv4 and UDPv6 Protocols.</simpara>
<simpara>A discussion on how to apply UDPChecksum can be found in RFC 793 for IPv4 and RFC 2460 for IPv6.</simpara>
<section xml:id="_parent_elements_24">
<title>Parent Elements</title>
<simpara><link linkend="Number">Number</link>
<link linkend="String">String</link></simpara>
</section>
<section xml:id="_parameters_35">
<title>Parameters</title>
<variablelist>
<varlistentry>
<term><link linkend="ref">ref</link></term>
<listitem>
<simpara>Reference to the input data element used in the checksum calculation.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>src</term>
<listitem>
<simpara>Source IP Address. IP address of the local machine.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>dst</term>
<listitem>
<simpara>Destination IP Address. IP address of the remote machine.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_79">
<title>Examples</title>
<example>
<title>UDP Packet Example</title>
<simpara>This example models a UDP packet which includes use of the UDPChecksum.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

	&lt;DataModel name="Packet"&gt;
		&lt;Number name="SrcPort"  size="16" endian="big" value="1234"/&gt;
		&lt;Number name="DestPort" size="16" endian="big" value="1235"/&gt;
		&lt;Number name="Length"   size="16" endian="big"&gt;
			&lt;Relation type="size" of="Packet"/&gt;
		&lt;/Number&gt;
		&lt;Number name="checksum" size="16"&gt;
			&lt;Fixup class="UDPChecksum"&gt;
				&lt;Param name="ref" value="Packet" /&gt;
				&lt;Param name="src" value="192.168.1.10" /&gt;
				&lt;Param name="dst" value="192.168.1.11" /&gt;
			&lt;/Fixup&gt;
		&lt;/Number&gt;
	&lt;/DataModel&gt;

	&lt;StateModel name="TheState" initialState="initial"&gt;
		&lt;State name="initial"&gt;
			&lt;Action type="output"&gt;
				&lt;DataModel ref="Packet" /&gt;
			&lt;/Action&gt;
		&lt;/State&gt;
	&lt;/StateModel&gt;

	&lt;Test name="Default"&gt;
		&lt;StateModel ref="TheState"/&gt;

		&lt;Publisher class="ConsoleHex" /&gt;	&lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Output from this example.</simpara>
<screen>&gt;peach -1 --debug example.xml

[*] Test 'Default' starting with random seed 60502.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher start()
Peach.Core.Publishers.ConsolePublisher open()
Peach.Core.Publishers.ConsolePublisher output(8 bytes)
00000000   04 D2 04 D3 00 08 D3 72                            ???????r
Peach.Core.Publishers.ConsolePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.ConsolePublisher stop()

[*] Test 'Default' finished.</screen>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Fixups_UnixTimeFixup">
<title>UnixTime</title>
<simpara>The <emphasis>FromFile</emphasis> is used to fill a BLOB data element with the contents of the specified file. The entire file is transferred, replacing the content of the BLOB.
The fixup supports reading of raw or PEM-encoded data files.</simpara>
<simpara>The main use case is to access cryptographic keys stored in files instead of exposing the key values in Pits or configuration files. In this use case, Peach pulls keys from .pem files in fuzzing cryptographic protocols.</simpara>
<section xml:id="_parent_elements_25">
<title>Parent Elements</title>
<itemizedlist>
<listitem>
<simpara><link linkend="Number">Number</link> (Not using Format parameter)</simpara>
</listitem>
<listitem>
<simpara><link linkend="String">String</link> (When using Format parameter)</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="_parameters_36">
<title>Parameters</title>
<variablelist>
<varlistentry>
<term>Gmt</term>
<listitem>
<simpara>Is time in GMT? Defaults to true.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Format</term>
<listitem>
<simpara>Format string to encode time with. Uses the Microsoft.NET format strings for Date and Time. When
specified the parent element must be a String. If no format is provided the parent must be a Number.</simpara>
<itemizedlist>
<listitem>
<simpara><link xl:href="https://msdn.microsoft.com/en-us/library/az4se3k1(v=vs.110).aspx">Standard Date and Time Format Strings</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://msdn.microsoft.com/en-us/library/8kb3ddd4(v=vs.110).aspx">Custom Date and Time Format Strings</link></simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_80">
<title>Examples</title>
<example>
<title>Simple Example w/o Format Parameter</title>
<simpara>Simple example of using the <emphasis>UnixTime</emphasis> fixup with out the Format parameter.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach	xmlns="http://peachfuzzer.com/2012/Peach"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

  &lt;DataModel name="TheDataModel"&gt;
	&lt;Number name="DateAndTime" size="32"&gt;
		&lt;Fixup class="UnixTime" /&gt;
	&lt;/Number&gt;
  &lt;/DataModel&gt;

  &lt;StateModel name="TheState" initialState="initial"&gt;
    &lt;State name="initial"&gt;
      &lt;Action type="output"&gt;
        &lt;DataModel ref="TheDataModel" /&gt;
      &lt;/Action&gt;
    &lt;/State&gt;
  &lt;/StateModel&gt;

  &lt;Test name="Default"&gt;
    &lt;StateModel ref="TheState"/&gt;
    &lt;Publisher class="ConsoleHex"/&gt;
  &lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Output from this example:</simpara>
<screen>&gt;peach -1 --debug example.xml

[*] Web site running at: http://10.0.1.87:8888/

[*] Test 'Default' starting with random seed 27871.
2016-07-08 18:08:51.9607 Peach.Pro.Core.Loggers.JobLogger Writing debug.log to: c:\peach-pro\output\win_x64_debug\bin\Logs\example.xml_20160708180850\debug.log

[R1,-,-] Performing iteration
2016-07-08 18:08:52.1052 Peach.Core.Engine runTest: Performing control recording iteration.
2016-07-08 18:08:52.1443 Peach.Core.Dom.StateModel Run(): Changing to state "initial".
2016-07-08 18:08:52.1443 Peach.Core.Dom.Action Run(Action): Output
2016-07-08 18:08:52.2744 Peach.Pro.Core.Publishers.ConsolePublisher start()
2016-07-08 18:08:52.2744 Peach.Pro.Core.Publishers.ConsolePublisher open()
2016-07-08 18:08:52.2784 Peach.Pro.Core.Publishers.ConsolePublisher output(4 bytes)
00000000   A4 4E 80 57                                        .N.W
2016-07-08 18:08:52.2784 Peach.Pro.Core.Publishers.ConsolePublisher close()
2016-07-08 18:08:52.2784 Peach.Core.Engine runTest: context.config.singleIteration == true
2016-07-08 18:08:52.2784 Peach.Pro.Core.Publishers.ConsolePublisher stop()
2016-07-08 18:08:52.2944 Peach.Core.Engine EndTest: Stopping all agents and monitors

[*] Test 'Default' finished.</screen>
</example>
<example>
<title>Simple Example with Format Parameter</title>
<simpara>Simple example of using the <emphasis>UnixTime</emphasis> fixup with the Format parameter.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach	xmlns="http://peachfuzzer.com/2012/Peach"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

  &lt;DataModel name="TheDataModel"&gt;
	&lt;String name="RFC1123Format" &gt;
		&lt;Fixup class="UnixTime"&gt;
			&lt;Param name="Format" value="R" /&gt;
		&lt;/Fixup&gt;
	&lt;/String&gt;
  &lt;/DataModel&gt;

  &lt;StateModel name="TheState" initialState="initial"&gt;
    &lt;State name="initial"&gt;
      &lt;Action type="output"&gt;
        &lt;DataModel ref="TheDataModel" /&gt;
      &lt;/Action&gt;
    &lt;/State&gt;
  &lt;/StateModel&gt;

  &lt;Test name="Default"&gt;
    &lt;StateModel ref="TheState"/&gt;
    &lt;Publisher class="ConsoleHex"/&gt;
  &lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Output from this example:</simpara>
<screen>&gt;peach -1 --debug example.xml

[*] Web site running at: http://10.0.1.87:8888/

[*] Test 'Default' starting with random seed 40931.
2016-07-08 18:10:55.0103 Peach.Pro.Core.Loggers.JobLogger Writing debug.log to: c:\peach-pro\output\win_x64_debug\bin\Logs\example.xml_20160708181053\debug.log

[R1,-,-] Performing iteration
2016-07-08 18:10:55.1412 Peach.Core.Engine runTest: Performing control recording iteration.
2016-07-08 18:10:55.1692 Peach.Core.Dom.StateModel Run(): Changing to state "initial".
2016-07-08 18:10:55.1692 Peach.Core.Dom.Action Run(Action): Output
2016-07-08 18:10:55.2913 Peach.Pro.Core.Publishers.ConsolePublisher start()
2016-07-08 18:10:55.2913 Peach.Pro.Core.Publishers.ConsolePublisher open()
2016-07-08 18:10:55.2953 Peach.Pro.Core.Publishers.ConsolePublisher output(29 bytes)
00000000   53 61 74 2C 20 30 39 20  4A 75 6C 20 32 30 31 36   Sat, 09 Jul 2016
00000010   20 30 31 3A 31 30 3A 35  35 20 47 4D 54             01:10:55 GMT
2016-07-08 18:10:55.2953 Peach.Pro.Core.Publishers.ConsolePublisher close()
2016-07-08 18:10:55.3103 Peach.Core.Engine runTest: context.config.singleIteration == true
2016-07-08 18:10:55.3103 Peach.Pro.Core.Publishers.ConsolePublisher stop()
2016-07-08 18:10:55.3103 Peach.Core.Engine EndTest: Stopping all agents and monitors

[*] Test 'Default' finished.</screen>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
</section>
<section xml:id="Transformer">
<title>Transformers</title>
<simpara>Transformers perform static transforms or encoding on the parent element.</simpara>
<simpara>Transformers most often occur in pairs, as encoding and decoding functions. The decoding function is the inverse of the encoding function. In this sense, they are
bi-directional. Examples include ZIP compression, Base64 encoding, and HTML encoding.</simpara>
<simpara>Some transformers lack a decoding function; they are unidirectional. For example,
the MD5 transformer is a unidirectional transformer that creates a hash.</simpara>
<simpara>Transformers are different than Fixups:</simpara>
<itemizedlist>
<listitem>
<simpara>Transformers operate on the parent data element.</simpara>
</listitem>
<listitem>
<simpara>Fixups generate their outputs by using values from other data elements.</simpara>
</listitem>
</itemizedlist>
<section xml:id="_example_3">
<title>Example</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;DataModel name="Base64TLV"&gt;
  &lt;Number name="Type" size="8" signed="false" value="1" token="true" /&gt;
  &lt;Number name="Length" size="16" signed="false"&gt;
    &lt;Relation type="size" of="base64Block" /&gt;
  &lt;/Number&gt;

  &lt;Block name="base64Block"&gt;
    &lt;Transformer class="Base64Encode" /&gt;
    &lt;Blob name="Data" /&gt;
  &lt;/Block&gt;
&lt;/DataModel&gt;</programlisting>
<simpara>The output of the above data model is <literal>0x01&lt;len(b64(Data))&gt;&lt;b64(Data)&gt;</literal>.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Peach Transformers</title>
<tgroup cols="4">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="25*"/>
<colspec colname="col_3" colwidth="25*"/>
<colspec colname="col_4" colwidth="25*"/>
<thead>
<row>
<entry align="left" valign="top">Transformer</entry>
<entry align="left" valign="top">Compress</entry>
<entry align="left" valign="top">Crypto</entry>
<entry align="left" valign="top">Encode</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><link linkend="Transformers_Aes128Transformer">Aes128</link></simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="Transformers_Base64DecodeTransformer">Base64Decode</link></simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="Transformers_Base64EncodeTransformer">Base64Encode</link></simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="Transformers_Bz2CompressTransformer">Bz2Compress</link></simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="Transformers_Bz2DecompressTransformer">Bz2Decompress</link></simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="Transformers_Des">Des</link></simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="Transformers_GzipCompressTransformer">GzipCompress</link></simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="Transformers_GzipDecompressTransformer">GzipDecompress</link></simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="Transformers_HexTransformer">Hex</link></simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="Transformers_HMACTransformer">HMAC</link></simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="Transformers_HtmlDecodeTransformer">HtmlDecode</link></simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="Transformers_HtmlEncodeTransformer">HtmlEncode</link></simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="Transformers_IntToHexTransformer">IntToHex</link></simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="Transformers_Ipv4StringToOctetTransformer">Ipv4StringToOctet</link></simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="Transformers_Ipv6StringToOctetTransformer">Ipv6StringToOctet</link></simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="Transformers_JsEncodeTransformer">JsEncode</link></simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="Transformers_MD5Transformer">MD5Crypt</link></simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="Transformers_NetBiosEncodeTransformer">NetBiosEncode</link></simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="Transformers_Sha1Transformer">Sha1</link></simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="Transformers_Sha256Transformer">Sha256</link></simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="Transformers_SidStringToBytesTransformer">SidStringToBytes</link></simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="Transformers_TripleDesTransformer">TripleDes</link></simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="Transformers_TruncateTransformer">Truncate</link></simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="Transformers_UrlEncodeTransformer">UrlEncode</link></simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
<section xml:id="Transformers_Aes128Transformer">
<title>Aes128</title>
<informaltable tabstyle="horizontal" frame="none" colsep="0" rowsep="0">
<tgroup cols="2">
<colspec colwidth="15*"/>
<colspec colwidth="85*"/>
<tbody valign="top">
<row>
<entry>
<simpara>Type</simpara>
</entry>
<entry>
<simpara>Cryptography</simpara>
</entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis>Aes128</emphasis> transforms the parent <link linkend="DataModel">DataModel</link> by encrypting the data using AES (Rijndael) with the provided Key and Initialization Vector.</simpara>
<simpara>The <link linkend="Transformer">Transformer</link> can bidirectionally encrypt and decrypt data.</simpara>
<section xml:id="_parameters_37">
<title>Parameters</title>
<simpara><emphasis>Required:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>Key</term>
<listitem>
<simpara>User provided symmetric key that is used to encrypt the value. Must be a hex string representation of a 16 byte key.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>IV</term>
<listitem>
<simpara>User provided initialization vector that is used as the first block for the AES128 operation. Must be a hex string representation of an 16 byte value.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Optional:</emphasis></simpara>
<simpara>None.</simpara>
</section>
<section xml:id="_actions_supported">
<title>Actions Supported</title>
<variablelist>
<varlistentry>
<term><link linkend="Action_input">input</link></term>
<listitem>
<simpara>On input, this transformer decrypts the incoming data.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_output">output</link></term>
<listitem>
<simpara>On output, this transformer encrypts the outgoing data.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_81">
<title>Examples</title>
<example>
<title>Simple Encrypt and Decrypt Example</title>
<simpara>This example uses Aes128 on an inline value, writes the transformed value to a file, and reads the value from the file to the console.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach ../peach.xsd"&gt;

	&lt;DataModel name="Ex1"&gt;
		&lt;String name="TransformMe" value="supersupersecret" &gt;
			&lt;Transformer class="Aes128"&gt;
				&lt;Param name="Key" value="ae1234567890aeaffeda214354647586"/&gt;
				&lt;Param name="IV" value="aeaeaeaeaeaeaeaeaeaeaeaeaeaeaeae"/&gt;
			&lt;/Transformer&gt;
		&lt;/String&gt;
	&lt;/DataModel&gt;

	&lt;StateModel name="TheState" initialState="initial"&gt;
		&lt;State name="initial"&gt;
			&lt;!-- Encrypted Output --&gt;
			&lt;Action type="output" publisher="ConsolePub"&gt;
				&lt;DataModel ref="Ex1" /&gt;
			&lt;/Action&gt;

			&lt;!-- Write Encrypted Output to File --&gt;
			&lt;Action type="output" publisher="FilePubWrite"&gt;
				&lt;DataModel ref="Ex1" /&gt;
			&lt;/Action&gt;

			&lt;Action type="close" publisher="FilePubWrite" /&gt;

			&lt;!-- Read and decrypt encrypted file and slurp output to console --&gt;
			&lt;Action type="input" publisher="FilePubRead" &gt;
				&lt;DataModel name="InputModel" ref="Ex1" /&gt;
			&lt;/Action&gt;

			&lt;Action type="slurp" valueXpath="//InputModel//TransformMe" setXpath="//OutputModel//StringValue" /&gt;

			&lt;Action type="output" publisher="ConsolePub"&gt;
				&lt;DataModel name="OutputModel"&gt;
					&lt;String name="StringValue" /&gt;
				&lt;/DataModel&gt;
			&lt;/Action&gt;
		&lt;/State&gt;
	&lt;/StateModel&gt;

	&lt;Test name="Default"&gt;
		&lt;StateModel ref="TheState"/&gt;

		&lt;Publisher class="ConsoleHex" name="ConsolePub"/&gt;

		&lt;Publisher class="File" name="FilePubWrite"&gt;
			&lt;Param name="FileName" value="encrypted.bin" /&gt;
		&lt;/Publisher&gt;

		&lt;Publisher class="File" name="FilePubRead"&gt;
			&lt;Param name="FileName" value="encrypted.bin" /&gt;
			&lt;Param name="Overwrite" value="false" /&gt;
		&lt;/Publisher&gt;
	&lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Output from this example.</simpara>
<screen>&gt; peach -1 --debug example.xml

[*] Test 'Default' starting with random seed 7617.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher start()
Peach.Core.Publishers.ConsolePublisher open()
Peach.Core.Publishers.ConsolePublisher output(16 bytes)
00000000   22 8D 4A 8B 30 1F 4D 6B  1A 31 24 3D B7 ED 97 E5   "?J?0?Mk?1$=????
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.FilePublisher start()
Peach.Core.Publishers.FilePublisher open()
Peach.Core.Publishers.FilePublisher output(16 bytes)
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Close
Peach.Core.Publishers.FilePublisher close()
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Input
Peach.Core.Publishers.FilePublisher start()
Peach.Core.Publishers.FilePublisher open()
Peach.Core.Publishers.FilePublisher input()
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker DataModel 'InputModel' Bytes: 0/16, Bits: 0/128
Peach.Core.Cracker.DataCracker getSize: -----&gt; DataModel 'InputModel'
Peach.Core.Cracker.DataCracker scan: DataModel 'InputModel'
Peach.Core.Cracker.DataCracker scan: String 'InputModel.TransformMe' -&gt; Offset: 0, Unsized element
Peach.Core.Cracker.DataCracker getSize: &lt;----- Deterministic: ???
Peach.Core.Cracker.DataCracker Crack: DataModel 'InputModel' Size: &lt;null&gt;, Bytes : 0/16, Bits: 0/128
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker String 'InputModel.TransformMe' Bytes: 0/16, Bits : 0/128
Peach.Core.Cracker.DataCracker getSize: -----&gt; String 'InputModel.TransformMe'
Peach.Core.Cracker.DataCracker scan: String 'InputModel.TransformMe' -&gt; Offset: 0, Unsized element
Peach.Core.Cracker.DataCracker lookahead: String 'InputModel.TransformMe'
Peach.Core.Cracker.DataCracker getSize: &lt;----- Last Unsized: 128
Peach.Core.Cracker.DataCracker Crack: String 'InputModel.TransformMe' Size: 128, Bytes: 0/16, Bits: 0/128
Peach.Core.Dom.DataElement String 'InputModel.TransformMe' value is: supersupersecret
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Slurp
Peach.Core.Dom.Action Slurp, setting OutputModel.StringValue from InputModel.TransformMe
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher output(16 bytes)
00000000   73 75 70 65 72 73 75 70  65 72 73 65 63 72 65 74   supersupersecret
Peach.Core.Publishers.ConsolePublisher close()
Peach.Core.Publishers.FilePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.ConsolePublisher stop()
Peach.Core.Publishers.FilePublisher stop()
Peach.Core.Publishers.FilePublisher stop()

[*] Test 'Default' finished.</screen>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Transformers_Base64DecodeTransformer">
<title>Base64Decode</title>
<informaltable tabstyle="horizontal" frame="none" colsep="0" rowsep="0">
<tgroup cols="2">
<colspec colwidth="15*"/>
<colspec colwidth="85*"/>
<tbody valign="top">
<row>
<entry>
<simpara>Type</simpara>
</entry>
<entry>
<simpara>Encoder/Decoder</simpara>
</entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis>Base64Decode</emphasis> decodes the value in the parent <link linkend="DataModel">DataModel</link> using a Base64 decoding algorithm.</simpara>
<simpara>The <link linkend="Transformer">Transformer</link> can bidirectionally encode data as well as decode data.</simpara>
<section xml:id="_parameters_38">
<title>Parameters</title>
<simpara>None.</simpara>
</section>
<section xml:id="_attributes_57">
<title>Attributes</title>
<simpara>None.</simpara>
</section>
<section xml:id="_actions_supported_2">
<title>Actions Supported</title>
<variablelist>
<varlistentry>
<term><link linkend="Action_input">input</link></term>
<listitem>
<simpara>On input, this transformer encodes the data into binary values using a Base64 encoding algorithm.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_output">output</link></term>
<listitem>
<simpara>On output, this transformer decodes the data into characters using a Base64 decoding algorithm.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_82">
<title>Examples</title>
<example>
<title>Decoding Value To and From File Example</title>
<simpara>This example uses  Base64Encode on an inline value, writes the transformed value to a file, and reads the value from the file to the console.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach ../peach.xsd"&gt;

	&lt;DataModel name="Ex1"&gt;
		&lt;String value="Plaintext: " token="true"/&gt;
		&lt;String name="TransformMe" value="QUJDREVGR0g="&gt;
			&lt;Transformer class="Base64Decode" /&gt;
		&lt;/String&gt;
	&lt;/DataModel&gt;

	&lt;StateModel name="TheState" initialState="initial"&gt;
		&lt;State name="initial"&gt;
			&lt;!-- Plaintext Output --&gt;
			&lt;Action type="output" publisher="ConsolePub"&gt;
				&lt;DataModel ref="Ex1" /&gt;
			&lt;/Action&gt;

			&lt;!-- Write Plaintext Output to File --&gt;
			&lt;Action type="output" publisher="FilePubWrite"&gt;
				&lt;DataModel ref="Ex1" /&gt;
				&lt;Data&gt;
					&lt;Field name="TransformMe" value="QUJDREVGR0g=" /&gt;
				&lt;/Data&gt;
			&lt;/Action&gt;

			&lt;Action type="close" publisher="FilePubWrite" /&gt;

			&lt;!-- Read and encode Plaintext file and slurp Base64 string to output in console --&gt;
			&lt;Action type="input" publisher="FilePubRead" &gt;
				&lt;DataModel name="InputModel" ref="Ex1" /&gt;
			&lt;/Action&gt;

			&lt;Action type="slurp" valueXpath="//InputModel//TransformMe" setXpath="//OutputModel//StringValue" /&gt;

			&lt;Action type="output" publisher="ConsolePub"&gt;
				&lt;DataModel name="OutputModel"&gt;
					&lt;String name="StringValue" /&gt;
				&lt;/DataModel&gt;
			&lt;/Action&gt;
		&lt;/State&gt;
	&lt;/StateModel&gt;

	&lt;Test name="Default"&gt;
		&lt;StateModel ref="TheState"/&gt;

		&lt;Publisher class="ConsoleHex" name="ConsolePub"/&gt;

		&lt;Publisher class="File" name="FilePubWrite"&gt;
			&lt;Param name="FileName" value="encoded.bin" /&gt;
		&lt;/Publisher&gt;

		&lt;Publisher class="File" name="FilePubRead"&gt;
			&lt;Param name="FileName" value="encoded.bin" /&gt;
			&lt;Param name="Overwrite" value="false" /&gt;
		&lt;/Publisher&gt;
	&lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Output from this example.</simpara>
<screen>&gt; peach -1 --debug example.xml

[*] Test 'Default' starting with random seed 12661.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher start()
Peach.Core.Publishers.ConsolePublisher open()
Peach.Core.Publishers.ConsolePublisher output(19 bytes)
00000000   50 6C 61 69 6E 74 65 78  74 3A 20 41 42 43 44 45   Plaintext: ABCDE
00000010   46 47 48                                           FGH
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.FilePublisher start()
Peach.Core.Publishers.FilePublisher open()
Peach.Core.Publishers.FilePublisher output(19 bytes)
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Close
Peach.Core.Publishers.FilePublisher close()
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Input
Peach.Core.Publishers.FilePublisher start()
Peach.Core.Publishers.FilePublisher open()
Peach.Core.Publishers.FilePublisher input()
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker DataModel 'InputModel' Bytes: 0/19, Bits: 0/152
Peach.Core.Cracker.DataCracker getSize: -----&gt; DataModel 'InputModel'
Peach.Core.Cracker.DataCracker scan: DataModel 'InputModel'
Peach.Core.Cracker.DataCracker scan: String 'InputModel.DataElement_0' -&gt; Pos: 0, Saving Token
Peach.Core.Cracker.DataCracker scan: String 'InputModel.DataElement_0' -&gt; Pos: 88, Length: 88
Peach.Core.Cracker.DataCracker getSize: &lt;----- Deterministic: ???
Peach.Core.Cracker.DataCracker Crack: DataModel 'InputModel' Size: &lt;null&gt;, Bytes: 0/19, Bits: 0/152
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker String 'InputModel.DataElement_0' Bytes: 0/19, Bits: 0/152
Peach.Core.Cracker.DataCracker getSize: -----&gt; String 'InputModel.DataElement_0'

Peach.Core.Cracker.DataCracker scan: String 'InputModel.DataElement_0' -&gt; Pos: 0, Saving Token
Peach.Core.Cracker.DataCracker scan: String 'InputModel.DataElement_0' -&gt; Pos: 88, Length: 88
Peach.Core.Cracker.DataCracker getSize: &lt;----- Size: 88
Peach.Core.Cracker.DataCracker Crack: String 'InputModel.DataElement_0' Size: 88, Bytes: 0/19, Bits: 0/152
Peach.Core.Dom.DataElement String 'InputModel.DataElement_0' value is: Plaintext :
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker String 'InputModel.TransformMe' Bytes: 11/19, Bits: 88/152
Peach.Core.Cracker.DataCracker getSize: -----&gt; String 'InputModel.TransformMe'
Peach.Core.Cracker.DataCracker scan: String 'InputModel.TransformMe' -&gt; Offset: 0, Unsized element
Peach.Core.Cracker.DataCracker lookahead: String 'InputModel.TransformMe'
Peach.Core.Cracker.DataCracker getSize: &lt;----- Last Unsized: 64
Peach.Core.Cracker.DataCracker Crack: String 'InputModel.TransformMe' Size: 96, Bytes: 0/12, Bits: 0/96
Peach.Core.Dom.DataElement String 'InputModel.TransformMe' value is: QUJDREVGR0g=
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Slurp
Peach.Core.Dom.Action Slurp, setting OutputModel.StringValue from InputModel.TransformMe
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher output(12 bytes)
00000000   51 55 4A 44 52 45 56 47  52 30 67 3D               QUJDREVGR0g=
Peach.Core.Publishers.ConsolePublisher close()
Peach.Core.Publishers.FilePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.ConsolePublisher stop()
Peach.Core.Publishers.FilePublisher stop()
Peach.Core.Publishers.FilePublisher stop()

[*] Test 'Default' finished.</screen>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Transformers_Base64EncodeTransformer">
<title>Base64Encode</title>
<informaltable tabstyle="horizontal" frame="none" colsep="0" rowsep="0">
<tgroup cols="2">
<colspec colwidth="15*"/>
<colspec colwidth="85*"/>
<tbody valign="top">
<row>
<entry>
<simpara>Type</simpara>
</entry>
<entry>
<simpara>Encoder/Decoder</simpara>
</entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis>Base64Encode</emphasis> encodes the value in the parent <link linkend="DataModel">DataModel</link> using a Base64 encoding algorithm.</simpara>
<simpara>The <link linkend="Transformer">Transformer</link> can bidirectionally encode data as well as decode data.</simpara>
<section xml:id="_parameters_39">
<title>Parameters</title>
<simpara>None.</simpara>
</section>
<section xml:id="_attributes_58">
<title>Attributes</title>
<simpara>None.</simpara>
</section>
<section xml:id="_actions_supported_3">
<title>Actions Supported</title>
<variablelist>
<varlistentry>
<term><link linkend="Action_input">input</link></term>
<listitem>
<simpara>On input, this transformer decodes the data into characters using a Base64 decoding algorithm.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_output">output</link></term>
<listitem>
<simpara>On output, this transformer encodes the data into binary values using a Base64 encoding algorithm.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_83">
<title>Examples</title>
<example>
<title>Encoding Value To and From File Example</title>
<simpara>This example uses  Base64Encode on an inline value, writes the transformed value to a file, and reads the value from the file to the console.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach ../peach.xsd"&gt;

	&lt;DataModel name="Ex1"&gt;
		&lt;String value="Base64: " token="true"/&gt;
		&lt;String name="TransformMe" value="ABCDEFGH"&gt;
			&lt;Transformer class="Base64Encode" /&gt;
		&lt;/String&gt;
	&lt;/DataModel&gt;

	&lt;StateModel name="TheState" initialState="initial"&gt;
		&lt;State name="initial"&gt;
			&lt;!-- Encoded Output --&gt;
			&lt;Action type="output" publisher="ConsolePub"&gt;
				&lt;DataModel ref="Ex1" /&gt;
			&lt;/Action&gt;

			&lt;!-- Write Encoded Output to File --&gt;
			&lt;Action type="output" publisher="FilePubWrite"&gt;
				&lt;DataModel ref="Ex1" /&gt;
				&lt;Data&gt;
					&lt;Field name="TransformMe" value="ABCDEFGH" /&gt;
				&lt;/Data&gt;
			&lt;/Action&gt;

			&lt;Action type="close" publisher="FilePubWrite" /&gt;

			&lt;!-- Read and decode encoded file and slurp Base64 decoded string to output in console --&gt;
			&lt;Action type="input" publisher="FilePubRead" &gt;
				&lt;DataModel name="InputModel" ref="Ex1" /&gt;
			&lt;/Action&gt;

			&lt;Action type="slurp" valueXpath="//InputModel//TransformMe" setXpath="//OutputModel//StringValue" /&gt;

			&lt;Action type="output" publisher="ConsolePub"&gt;
				&lt;DataModel name="OutputModel"&gt;
					&lt;String name="StringValue" /&gt;
				&lt;/DataModel&gt;
			&lt;/Action&gt;
		&lt;/State&gt;
	&lt;/StateModel&gt;

	&lt;Test name="Default"&gt;
		&lt;StateModel ref="TheState"/&gt;
		&lt;Publisher class="ConsoleHex" name="ConsolePub"/&gt;

		&lt;Publisher class="File" name="FilePubWrite"&gt;
			&lt;Param name="FileName" value="encoded.bin" /&gt;
		&lt;/Publisher&gt;

		&lt;Publisher class="File" name="FilePubRead"&gt;
			&lt;Param name="FileName" value="encoded.bin" /&gt;
			&lt;Param name="Overwrite" value="false" /&gt;
		&lt;/Publisher&gt;
	&lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Output from this example.</simpara>
<screen>&gt; peach -1 --debug example.xml

[*] Test 'Default' starting with random seed 11558.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher start()
Peach.Core.Publishers.ConsolePublisher open()
Peach.Core.Publishers.ConsolePublisher output(20 bytes)
00000000   42 61 73 65 36 34 3A 20  51 55 4A 44 52 45 56 47   Base64: QUJDREVG
00000010   52 30 67 3D                                        R0g=
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.FilePublisher start()
Peach.Core.Publishers.FilePublisher open()
Peach.Core.Publishers.FilePublisher output(20 bytes)
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Close
Peach.Core.Publishers.FilePublisher close()
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Input
Peach.Core.Publishers.FilePublisher start()
Peach.Core.Publishers.FilePublisher open()
Peach.Core.Publishers.FilePublisher input()
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker DataModel 'InputModel' Bytes: 0/20, Bits: 0/160
Peach.Core.Cracker.DataCracker getSize: -----&gt; DataModel 'InputModel'
Peach.Core.Cracker.DataCracker scan: DataModel 'InputModel'
Peach.Core.Cracker.DataCracker scan: String 'InputModel.DataElement_0' -&gt; Pos: 0, Saving Token
Peach.Core.Cracker.DataCracker scan: String 'InputModel.DataElement_0' -&gt; Pos: 64, Length: 64
Peach.Core.Cracker.DataCracker getSize: &lt;----- Deterministic: ???
Peach.Core.Cracker.DataCracker Crack: DataModel 'InputModel' Size: &lt;null&gt;, Bytes: 0/20, Bits: 0/160
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker String 'InputModel.DataElement_0' Bytes: 0/20, Bits: 0/160
Peach.Core.Cracker.DataCracker getSize: -----&gt; String 'InputModel.DataElement_0'

Peach.Core.Cracker.DataCracker scan: String 'InputModel.DataElement_0' -&gt; Pos: 0, Saving Token
Peach.Core.Cracker.DataCracker scan: String 'InputModel.DataElement_0' -&gt; Pos: 64, Length: 64
Peach.Core.Cracker.DataCracker getSize: &lt;----- Size: 64
Peach.Core.Cracker.DataCracker Crack: String 'InputModel.DataElement_0' Size: 64 , Bytes: 0/20, Bits: 0/160
Peach.Core.Dom.DataElement String 'InputModel.DataElement_0' value is: Base64:
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker String 'InputModel.TransformMe' Bytes: 8/20, Bits : 64/160
Peach.Core.Cracker.DataCracker getSize: -----&gt; String 'InputModel.TransformMe'
Peach.Core.Cracker.DataCracker scan: String 'InputModel.TransformMe' -&gt; Offset: 0, Unsized element
Peach.Core.Cracker.DataCracker lookahead: String 'InputModel.TransformMe'
Peach.Core.Cracker.DataCracker getSize: &lt;----- Last Unsized: 96
Peach.Core.Cracker.DataCracker Crack: String 'InputModel.TransformMe' Size: 64, Bytes: 0/8, Bits: 0/64
Peach.Core.Dom.DataElement String 'InputModel.TransformMe' value is: ABCDEFGH
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Slurp
Peach.Core.Dom.Action Slurp, setting OutputModel.StringValue from InputModel.TransformMe
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher output(8 bytes)
00000000   41 42 43 44 45 46 47 48                            ABCDEFGH
Peach.Core.Publishers.ConsolePublisher close()
Peach.Core.Publishers.FilePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.ConsolePublisher stop()
Peach.Core.Publishers.FilePublisher stop()
Peach.Core.Publishers.FilePublisher stop()

[*] Test 'Default' finished.</screen>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Transformers_Bz2CompressTransformer">
<title>Bz2Compress</title>
<informaltable tabstyle="horizontal" frame="none" colsep="0" rowsep="0">
<tgroup cols="2">
<colspec colwidth="15*"/>
<colspec colwidth="85*"/>
<tbody valign="top">
<row>
<entry>
<simpara>Type</simpara>
</entry>
<entry>
<simpara>Compress</simpara>
</entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis>Bz2Compress</emphasis> performs a bzip2 compression on the value in the parent <link linkend="DataModel">DataModel</link>.</simpara>
<simpara>The <link linkend="Transformer">Transformer</link> can bidirectionally compress data as well as decompress data.</simpara>
<section xml:id="_parameters_40">
<title>Parameters</title>
<simpara>None.</simpara>
</section>
<section xml:id="_attributes_59">
<title>Attributes</title>
<simpara><emphasis>Required:</emphasis></simpara>
<simpara>None.</simpara>
<simpara><emphasis>Optional:</emphasis></simpara>
<simpara>None.</simpara>
</section>
<section xml:id="_actions_supported_4">
<title>Actions Supported</title>
<variablelist>
<varlistentry>
<term><link linkend="Action_input">input</link></term>
<listitem>
<simpara>On input, this transformer decompresses the incoming data.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_output">output</link></term>
<listitem>
<simpara>On output, this transformer compresses the outgoing data.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_84">
<title>Examples</title>
<example>
<title>Compression To and From File Example</title>
<simpara>This example uses Bz2Compress to compress a value, write the value to the console, write to a file, and then read it from the file.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach ../peach.xsd"&gt;

  &lt;DataModel name="Ex1"&gt;
    &lt;String name="TransformMe" value="shrinkmepleaseshrinkmeplease"&gt;
      &lt;Transformer class="Bz2Compress" /&gt;
    &lt;/String&gt;
  &lt;/DataModel&gt;

  &lt;StateModel name="TheState" initialState="initial"&gt;
    &lt;State name="initial"&gt;
      &lt;!-- Compressed Output --&gt;
      &lt;Action type="output" publisher="ConsolePub"&gt;
        &lt;DataModel ref="Ex1" /&gt;
      &lt;/Action&gt;

      &lt;!-- Write Compressed Output to File --&gt;
      &lt;Action type="output" publisher="FilePubWrite"&gt;
        &lt;DataModel ref="Ex1" /&gt;
        &lt;Data&gt;
          &lt;Field name="TransformMe" value="shrinkmepleaseshrinkmeplease" /&gt;
        &lt;/Data&gt;
      &lt;/Action&gt;

      &lt;Action type="close" publisher="FilePubWrite" /&gt;
    &lt;/State&gt;
  &lt;/StateModel&gt;

  &lt;Test name="Default"&gt;
    &lt;StateModel ref="TheState"/&gt;

    &lt;Publisher class="ConsoleHex" name="ConsolePub"/&gt;

    &lt;Publisher class="File" name="FilePubWrite"&gt;
      &lt;Param name="FileName" value="compressed.bin" /&gt;
    &lt;/Publisher&gt;
  &lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Output from this example.</simpara>
<screen>&gt; peach -1 --debug example.xml

[*] Test 'Default' starting with random seed 47050.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher start()
Peach.Core.Publishers.ConsolePublisher open()
Peach.Core.Publishers.ConsolePublisher output(53 bytes)
00000000   42 5A 68 39 31 41 59 26  53 59 A7 83 53 78 00 00   BZh91AY&amp;SY??Sx??
00000010   0D 81 80 22 6F 58 00 20  00 31 00 D3 4D 01 55 03   ???"oX? ?1??M?U?
00000020   41 EA 5D 4D A1 1E 44 47  51 18 7C 5D C9 14 E1 42   A?]M??DGQ?|]???B
00000030   42 9E 0D 4D E0                                     B??M?
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.FilePublisher start()
Peach.Core.Publishers.FilePublisher open()
Peach.Core.Publishers.FilePublisher output(53 bytes)
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Close
Peach.Core.Publishers.FilePublisher close()
Peach.Core.Publishers.ConsolePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.ConsolePublisher stop()
Peach.Core.Publishers.FilePublisher stop()

[*] Test 'Default' finished.</screen>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Transformers_Bz2DecompressTransformer">
<title>Bz2Decompress</title>
<informaltable tabstyle="horizontal" frame="none" colsep="0" rowsep="0">
<tgroup cols="2">
<colspec colwidth="15*"/>
<colspec colwidth="85*"/>
<tbody valign="top">
<row>
<entry>
<simpara>Type</simpara>
</entry>
<entry>
<simpara>Compress</simpara>
</entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis>Bz2Decompress</emphasis> performs a bzip2 decompression on the value in the parent <link linkend="DataModel">DataModel</link>.</simpara>
<simpara>The <link linkend="Transformer">Transformer</link> can bidirectionally compress data as well as decompress data.</simpara>
<section xml:id="_parameters_41">
<title>Parameters</title>
<simpara>None.</simpara>
</section>
<section xml:id="_attributes_60">
<title>Attributes</title>
<simpara><emphasis>Required:</emphasis></simpara>
<simpara>None.</simpara>
<simpara><emphasis>Optional:</emphasis></simpara>
<simpara>None.</simpara>
</section>
<section xml:id="_actions_supported_5">
<title>Actions Supported</title>
<variablelist>
<varlistentry>
<term><link linkend="Action_input">input</link></term>
<listitem>
<simpara>On input, this transformer compresses the incoming data.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_output">output</link></term>
<listitem>
<simpara>On output, this transformer decompresses the outgoing data.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_85">
<title>Examples</title>
<example>
<title>Decompress From a Value To a File</title>
<simpara>This example uses Bz2Decompress to decompress a value, write the value to the console, write to a file, and then reads it from the file.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach ../peach.xsd"&gt;

	&lt;DataModel name="Ex1"&gt;
		&lt;Blob name="TransformMe" value="42 5A 68 39 31 41 59 26 53 59 A7 83 53 78 00 00 0D 81 80 22 6F 58 00 20 00 31 00 D3 4D 01 55 03 41 EA 5D 4D A1 1E 44 47 51 18 7C 5D C9 14 E1 42 42 9E 0D 4D E0" valueType="hex" &gt;
			&lt;Transformer class="Bz2Decompress" /&gt;
		&lt;/Blob&gt;
	&lt;/DataModel&gt;

	&lt;StateModel name="TheState" initialState="initial"&gt;
		&lt;State name="initial"&gt;
			&lt;!-- Decompressed Output --&gt;
			&lt;Action type="output" publisher="ConsolePub"&gt;
				&lt;DataModel ref="Ex1" /&gt;
			&lt;/Action&gt;

			&lt;!-- Write Decompressed Output to File --&gt;
			&lt;Action type="output" publisher="FilePubWrite"&gt;
				&lt;DataModel ref="Ex1" /&gt;
			&lt;/Action&gt;

			&lt;Action type="close" publisher="FilePubWrite" /&gt;

			&lt;!-- Read and decompress from file and slurp output to console --&gt;
			&lt;Action type="input" publisher="FilePubRead" &gt;
				&lt;DataModel name="InputModel" ref="Ex1" /&gt;
			&lt;/Action&gt;

			&lt;Action type="slurp" valueXpath="//InputModel//TransformMe" setXpath="//OutputModel//BlobValue" /&gt;

			&lt;Action type="output" publisher="ConsolePub"&gt;
				&lt;DataModel name="OutputModel"&gt;
					&lt;Blob name="BlobValue" /&gt;
				&lt;/DataModel&gt;
			&lt;/Action&gt;
		&lt;/State&gt;
	&lt;/StateModel&gt;

	&lt;Test name="Default"&gt;
		&lt;StateModel ref="TheState"/&gt;

		&lt;Publisher class="ConsoleHex" name="ConsolePub"/&gt;

		&lt;Publisher class="File" name="FilePubWrite"&gt;
			&lt;Param name="FileName" value="decompressed.bin" /&gt;
		&lt;/Publisher&gt;

		&lt;Publisher class="File" name="FilePubRead"&gt;
			&lt;Param name="FileName" value="decompressed.bin" /&gt;
			&lt;Param name="Overwrite" value="false" /&gt;
		&lt;/Publisher&gt;
	&lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Output from this example.</simpara>
<screen>&gt; peach -1 --debug example.xml

[*] Test 'Default' starting with random seed 19925.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher start()
Peach.Core.Publishers.ConsolePublisher open()
Peach.Core.Publishers.ConsolePublisher output(28 bytes)
00000000   73 68 72 69 6E 6B 6D 65  70 6C 65 61 73 65 73 68   shrinkmepleasesh
00000010   72 69 6E 6B 6D 65 70 6C  65 61 73 65               rinkmeplease
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.FilePublisher start()
Peach.Core.Publishers.FilePublisher open()
Peach.Core.Publishers.FilePublisher output(28 bytes)
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Close
Peach.Core.Publishers.FilePublisher close()
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Input
Peach.Core.Publishers.FilePublisher start()
Peach.Core.Publishers.FilePublisher open()
Peach.Core.Publishers.FilePublisher input()
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker DataModel 'InputModel' Bytes: 0/28, Bits: 0/224
Peach.Core.Cracker.DataCracker getSize: -----&gt; DataModel 'InputModel'
Peach.Core.Cracker.DataCracker scan: DataModel 'InputModel'
Peach.Core.Cracker.DataCracker scan: Blob 'InputModel.TransformMe' -&gt; Offset: 0,
 Unsized element
Peach.Core.Cracker.DataCracker getSize: &lt;----- Deterministic: ???
Peach.Core.Cracker.DataCracker Crack: DataModel 'InputModel' Size: &lt;null&gt;, Bytes
: 0/28, Bits: 0/224
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker Blob 'InputModel.TransformMe' Bytes: 0/28, Bits:
0/224
Peach.Core.Cracker.DataCracker getSize: -----&gt; Blob 'InputModel.TransformMe'
Peach.Core.Cracker.DataCracker scan: Blob 'InputModel.TransformMe' -&gt; Offset: 0,
 Unsized element
Peach.Core.Cracker.DataCracker lookahead: Blob 'InputModel.TransformMe'
Peach.Core.Cracker.DataCracker getSize: &lt;----- Last Unsized: 224
Peach.Core.Cracker.DataCracker Crack: Blob 'InputModel.TransformMe' Size: 424, B
ytes: 0/53, Bits: 0/424
Peach.Core.Dom.DataElement Blob 'InputModel.TransformMe' value is: 42 5a 68 39 3
1 41 59 26 53 59 a7 83 53 78 00 00 0d 81 80 22 6f 58 00 20 00 31 00 d3 4d 01 55
03.. (Len: 53 bytes)
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Slurp
Peach.Core.Dom.Action Slurp, setting OutputModel.BlobValue from InputModel.Trans
formMe
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher output(53 bytes)
00000000   42 5A 68 39 31 41 59 26  53 59 A7 83 53 78 00 00   BZh91AY&amp;SY??Sx??
00000010   0D 81 80 22 6F 58 00 20  00 31 00 D3 4D 01 55 03   ???"oX? ?1??M?U?
00000020   41 EA 5D 4D A1 1E 44 47  51 18 7C 5D C9 14 E1 42   A?]M??DGQ?|]???B
00000030   42 9E 0D 4D E0                                     B??M?
Peach.Core.Publishers.ConsolePublisher close()
Peach.Core.Publishers.FilePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.ConsolePublisher stop()
Peach.Core.Publishers.FilePublisher stop()
Peach.Core.Publishers.FilePublisher stop()

[*] Test 'Default' finished.</screen>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Transformers_Des">
<title>Des</title>
<informaltable tabstyle="horizontal" frame="none" colsep="0" rowsep="0">
<tgroup cols="2">
<colspec colwidth="15*"/>
<colspec colwidth="85*"/>
<tbody valign="top">
<row>
<entry>
<simpara>Type</simpara>
</entry>
<entry>
<simpara>Cryptography</simpara>
</entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis>Des</emphasis> transforms the parent data element by encrypting the data using DES with the provided Key and Initialization Vector.</simpara>
<simpara>The <link linkend="Transformer">Transformer</link> can bidirectionally encrypt and decrypt data.</simpara>
<section xml:id="_parameters_42">
<title>Parameters</title>
<simpara><emphasis>Required:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>Key</term>
<listitem>
<simpara>User provided symmetric key that is used to encrypt the value. Must be a hex string representation of a 16 byte key.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>IV</term>
<listitem>
<simpara>User provided initialization vector that is used as the first block for the AES128 operation. Must be a hex string representation of an 16 byte value.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>CipherMode</term>
<listitem>
<simpara>Cipher mode to use during encryption. Defauilts to CBC.</simpara>
<itemizedlist>
<listitem>
<simpara>CBC</simpara>
</listitem>
<listitem>
<simpara>ECB</simpara>
</listitem>
<listitem>
<simpara>CFB</simpara>
</listitem>
<listitem>
<simpara>CTS</simpara>
</listitem>
<listitem>
<simpara>OFB</simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term>PaddingMode</term>
<listitem>
<simpara>Padding mode. Defaults to Zeros.</simpara>
<itemizedlist>
<listitem>
<simpara>Zeros</simpara>
</listitem>
<listitem>
<simpara>None</simpara>
</listitem>
<listitem>
<simpara>PKCS7</simpara>
</listitem>
<listitem>
<simpara>ANSIX923</simpara>
</listitem>
<listitem>
<simpara>ISO101026</simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_actions_supported_6">
<title>Actions Supported</title>
<variablelist>
<varlistentry>
<term><link linkend="Action_input">input</link></term>
<listitem>
<simpara>On input, this transformer decrypts the incoming data.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_output">output</link></term>
<listitem>
<simpara>On output, this transformer encrypts the outgoing data.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_86">
<title>Examples</title>
<example>
<title>Simple Encrypt and Decrypt Example</title>
<simpara>This example uses DES on an inline value, writes the transformed value to a file, and reads the value from the file to the console.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach	xmlns="http://peachfuzzer.com/2012/Peach"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xsi:schemaLocation="http://peachfuzzer.com/2012/Peach ../peach.xsd"&gt;

	&lt;DataModel name="Ex1"&gt;
		&lt;String name="TransformMe" value="supersupersecret" &gt;
			&lt;Transformer class="Des"&gt;
				&lt;Param name="Key" value="ae 12 34 56 78 90 ae af"/&gt;
				&lt;Param name="IV"  value="ae ae ae ae ae ae ae ae"/&gt;
			&lt;/Transformer&gt;
		&lt;/String&gt;
	&lt;/DataModel&gt;

	&lt;StateModel name="TheState" initialState="initial"&gt;
		&lt;State name="initial"&gt;
			&lt;!-- Encrypted Output --&gt;
			&lt;Action type="output" publisher="ConsolePub"&gt;
				&lt;DataModel ref="Ex1" /&gt;
			&lt;/Action&gt;

			&lt;!-- Write Encrypted Output to File --&gt;
			&lt;Action type="output" publisher="FilePubWrite"&gt;
				&lt;DataModel ref="Ex1" /&gt;
			&lt;/Action&gt;

			&lt;Action type="close" publisher="FilePubWrite" /&gt;

			&lt;!-- Read and decrypt encrypted file and slurp output to console --&gt;
			&lt;Action type="input" publisher="FilePubRead" &gt;
				&lt;DataModel name="InputModel" ref="Ex1" /&gt;
			&lt;/Action&gt;

			&lt;Action type="slurp" valueXpath="//InputModel//TransformMe" setXpath="//OutputModel//StringValue" /&gt;

			&lt;Action type="output" publisher="ConsolePub"&gt;
				&lt;DataModel name="OutputModel"&gt;
					&lt;String name="StringValue" /&gt;
				&lt;/DataModel&gt;
			&lt;/Action&gt;
		&lt;/State&gt;
	&lt;/StateModel&gt;

	&lt;Test name="Default"&gt;
		&lt;StateModel ref="TheState"/&gt;

		&lt;Publisher class="ConsoleHex" name="ConsolePub"/&gt;

		&lt;Publisher class="File" name="FilePubWrite"&gt;
			&lt;Param name="FileName" value="encrypted.bin" /&gt;
		&lt;/Publisher&gt;

		&lt;Publisher class="File" name="FilePubRead"&gt;
			&lt;Param name="FileName" value="encrypted.bin" /&gt;
			&lt;Param name="Overwrite" value="false" /&gt;
		&lt;/Publisher&gt;
	&lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Output from this example.</simpara>
<screen>&gt; peach -1 --debug example.xml

[*] Web site running at: http://10.0.1.87:8888/

[*] Test 'Default' starting with random seed 56253.
2016-07-08 17:27:30.8520 Peach.Pro.Core.Loggers.JobLogger Writing debug.log to: c:\peach-pro\output\win_x64_debug\bin\Logs\example.xml_20160708172729\debug.log

[R1,-,-] Performing iteration
2016-07-08 17:27:30.9893 Peach.Core.Engine runTest: Performing control recording iteration.
2016-07-08 17:27:31.0193 Peach.Core.Dom.StateModel Run(): Changing to state "initial".
2016-07-08 17:27:31.0193 Peach.Core.Dom.Action Run(Action): Output
2016-07-08 17:27:31.1414 Peach.Pro.Core.Publishers.ConsolePublisher start()
2016-07-08 17:27:31.1414 Peach.Pro.Core.Publishers.ConsolePublisher open()
2016-07-08 17:27:31.1414 Peach.Pro.Core.Publishers.ConsolePublisher output(16 bytes)
00000000   FF 84 0E BF DC 49 70 56  86 80 8A C3 16 61 4F E5   .....IpV.....aO.  <co xml:id="CO43-1"/>
2016-07-08 17:27:31.1414 Peach.Core.Dom.Action Run(Action_1): Output
2016-07-08 17:27:31.1414 Peach.Pro.Core.Publishers.FilePublisher start()
2016-07-08 17:27:31.1414 Peach.Pro.Core.Publishers.FilePublisher open()
2016-07-08 17:27:31.1544 Peach.Pro.Core.Publishers.FilePublisher output(16 bytes)
2016-07-08 17:27:31.1544 Peach.Core.Dom.Action Run(Action_2): Close
2016-07-08 17:27:31.1544 Peach.Pro.Core.Publishers.FilePublisher close()
2016-07-08 17:27:31.1544 Peach.Core.Dom.Action Run(Action_3): Input
2016-07-08 17:27:31.1544 Peach.Pro.Core.Publishers.FilePublisher start()
2016-07-08 17:27:31.1544 Peach.Pro.Core.Publishers.FilePublisher open()
2016-07-08 17:27:31.1544 Peach.Pro.Core.Publishers.FilePublisher input()
2016-07-08 17:27:31.1704 DataCracker -+ DataModel 'InputModel', Bytes: 0/16, Bits: 0/128
2016-07-08 17:27:31.1704 DataCracker  | Size: ??? (Deterministic)
2016-07-08 17:27:31.1704 DataCracker  |-- String 'TransformMe', Bytes: 0/16, Bits: 0/128
2016-07-08 17:27:31.1854 DataCracker  |   Size: 16 bytes | 128 bits (Last Unsized)
2016-07-08 17:27:31.1854 DataCracker  |   Value: supersupersecret
2016-07-08 17:27:31.1854 DataCracker  /
2016-07-08 17:27:31.1854 Peach.Core.Dom.Actions.Input Final pos: 16 length: 16 crack consumed: 16 bytes
2016-07-08 17:27:31.1854 Peach.Core.Dom.Action Run(Action_4): Slurp
2016-07-08 17:27:31.2064 Peach.Core.Dom.Actions.Slurp Slurp, setting OutputModel.StringValue from InputModel.TransformMe
2016-07-08 17:27:31.2064 Peach.Core.Dom.Action Run(Action_5): Output
2016-07-08 17:27:31.2064 Peach.Pro.Core.Publishers.ConsolePublisher output(16 bytes)
00000000   73 75 70 65 72 73 75 70  65 72 73 65 63 72 65 74   supersupersecret  <co xml:id="CO43-2"/>
2016-07-08 17:27:31.2064 Peach.Pro.Core.Publishers.ConsolePublisher close()
2016-07-08 17:27:31.2064 Peach.Pro.Core.Publishers.FilePublisher close()
2016-07-08 17:27:31.2174 Peach.Core.Engine runTest: context.config.singleIteration == true
2016-07-08 17:27:31.2174 Peach.Pro.Core.Publishers.ConsolePublisher stop()
2016-07-08 17:27:31.2174 Peach.Pro.Core.Publishers.FilePublisher stop()
2016-07-08 17:27:31.2174 Peach.Pro.Core.Publishers.FilePublisher stop()
2016-07-08 17:27:31.2174 Peach.Core.Engine EndTest: Stopping all agents and monitors

[*] Test 'Default' finished.</screen>
<calloutlist>
<callout arearefs="CO43-1">
<para>Encrypted output</para>
</callout>
<callout arearefs="CO43-2">
<para>Decrypted output</para>
</callout>
</calloutlist>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Transformers_GzipCompressTransformer">
<title>GzipCompress</title>
<informaltable tabstyle="horizontal" frame="none" colsep="0" rowsep="0">
<tgroup cols="2">
<colspec colwidth="15*"/>
<colspec colwidth="85*"/>
<tbody valign="top">
<row>
<entry>
<simpara>Type</simpara>
</entry>
<entry>
<simpara>Compress</simpara>
</entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis>GzipCompress</emphasis> performs a Gzip compression on the value in the parent <link linkend="DataModel">DataModel</link>.</simpara>
<simpara>The <link linkend="Transformer">Transformer</link> can bidirectionally compress data as well as decompress data.</simpara>
<section xml:id="_parameters_43">
<title>Parameters</title>
<simpara>None.</simpara>
</section>
<section xml:id="_attributes_61">
<title>Attributes</title>
<simpara><emphasis>Required:</emphasis></simpara>
<simpara>None.</simpara>
<simpara><emphasis>Optional:</emphasis></simpara>
<simpara>None.</simpara>
</section>
<section xml:id="_actions_supported_7">
<title>Actions Supported</title>
<variablelist>
<varlistentry>
<term><link linkend="Action_input">input</link></term>
<listitem>
<simpara>On input, GzipCompress decompresses incoming data.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_output">output</link></term>
<listitem>
<simpara>On output, GzipCompress compresses all outgoing data.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_87">
<title>Examples</title>
<example>
<title>Compression To and From File Example</title>
<simpara>This example uses GzipCompress to compress a value, write the value to the console, write to a file, and then reads it from the file to the console.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach ../peach.xsd"&gt;

	&lt;DataModel name="Ex1"&gt;
		&lt;String name="TransformMe" value="shrinkmepleaseshrinkmeplease"&gt;
			&lt;Transformer class="GzipCompress" /&gt;
		&lt;/String&gt;
	&lt;/DataModel&gt;


	&lt;StateModel name="TheState" initialState="initial"&gt;
		&lt;State name="initial"&gt;
			&lt;!-- Compressed Output --&gt;
			&lt;Action type="output" publisher="ConsolePub"&gt;
				&lt;DataModel ref="Ex1" /&gt;
			&lt;/Action&gt;

			&lt;!-- Write Compressed Output to File --&gt;
			&lt;Action type="output" publisher="FilePubWrite"&gt;
				&lt;DataModel ref="Ex1" /&gt;
				&lt;Data&gt;
					&lt;Field name="TransformMe" value="shrinkmepleaseshrinkmeplease" /&gt;
				&lt;/Data&gt;
			&lt;/Action&gt;

			&lt;Action type="close" publisher="FilePubWrite" /&gt;

			&lt;!-- Read and compress file and slurp output to console --&gt;
			&lt;Action type="input" publisher="FilePubRead" &gt;
				&lt;DataModel name="InputModel" ref="Ex1" /&gt;
			&lt;/Action&gt;

			&lt;Action type="slurp" valueXpath="//InputModel//TransformMe" setXpath="//OutputModel//StringValue" /&gt;

			&lt;Action type="output" publisher="ConsolePub"&gt;
				&lt;DataModel name="OutputModel"&gt;
					&lt;String name="StringValue" /&gt;
				&lt;/DataModel&gt;
			&lt;/Action&gt;
		&lt;/State&gt;
	&lt;/StateModel&gt;

	&lt;Test name="Default"&gt;
		&lt;StateModel ref="TheState"/&gt;

		&lt;Publisher class="ConsoleHex" name="ConsolePub"/&gt;

		&lt;Publisher class="File" name="FilePubWrite"&gt;
			&lt;Param name="FileName" value="encrypted.bin" /&gt;
		&lt;/Publisher&gt;

		&lt;Publisher class="File" name="FilePubRead"&gt;
			&lt;Param name="FileName" value="encrypted.bin" /&gt;
			&lt;Param name="Overwrite" value="false" /&gt;
		&lt;/Publisher&gt;
	&lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Output from this example.</simpara>
<screen>&gt; peach -1 --debug example.xml

[*] Test 'Default' starting with random seed 62862.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher start()
Peach.Core.Publishers.ConsolePublisher open()
Peach.Core.Publishers.ConsolePublisher output(37 bytes)
00000000   1F 8B 08 00 00 00 00 00  04 00 2B CE 28 CA CC CB   ??????????+?(???
00000010   CE 4D 2D C8 49 4D 2C 4E  2D 46 E1 01 00 32 B6 7E   ?M-?IM,N-F???2?~
00000020   40 1C 00 00 00                                     @????
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.FilePublisher start()
Peach.Core.Publishers.FilePublisher open()
Peach.Core.Publishers.FilePublisher output(37 bytes)
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Close
Peach.Core.Publishers.FilePublisher close()
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Input
Peach.Core.Publishers.FilePublisher start()
Peach.Core.Publishers.FilePublisher open()
Peach.Core.Publishers.FilePublisher input()
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker DataModel 'InputModel' Bytes: 0/37, Bits: 0/296
Peach.Core.Cracker.DataCracker getSize: -----&gt; DataModel 'InputModel'
Peach.Core.Cracker.DataCracker scan: DataModel 'InputModel'
Peach.Core.Cracker.DataCracker scan: String 'InputModel.TransformMe' -&gt; Offset: 0, Unsized element
Peach.Core.Cracker.DataCracker getSize: &lt;----- Deterministic: ???
Peach.Core.Cracker.DataCracker Crack: DataModel 'InputModel' Size: &lt;null&gt;, Bytes : 0/37, Bits: 0/296
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker String 'InputModel.TransformMe' Bytes: 0/37, Bits : 0/296
Peach.Core.Cracker.DataCracker getSize: -----&gt; String 'InputModel.TransformMe'
Peach.Core.Cracker.DataCracker scan: String 'InputModel.TransformMe' -&gt; Offset: 0, Unsized element
Peach.Core.Cracker.DataCracker lookahead: String 'InputModel.TransformMe'
Peach.Core.Cracker.DataCracker getSize: &lt;----- Last Unsized: 296
Peach.Core.Cracker.DataCracker Crack: String 'InputModel.TransformMe' Size: 224, Bytes: 0/28, Bits: 0/224
Peach.Core.Dom.DataElement String 'InputModel.TransformMe' value is: shrinkmepleaseshrinkmeplease
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Slurp
Peach.Core.Dom.Action Slurp, setting OutputModel.StringValue from InputModel.TransformMe
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher output(28 bytes)
00000000   73 68 72 69 6E 6B 6D 65  70 6C 65 61 73 65 73 68   shrinkmepleasesh
00000010   72 69 6E 6B 6D 65 70 6C  65 61 73 65               rinkmeplease
Peach.Core.Publishers.ConsolePublisher close()
Peach.Core.Publishers.FilePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.ConsolePublisher stop()
Peach.Core.Publishers.FilePublisher stop()
Peach.Core.Publishers.FilePublisher stop()

[*] Test 'Default' finished.</screen>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Transformers_GzipDecompressTransformer">
<title>GzipDecompress</title>
<informaltable tabstyle="horizontal" frame="none" colsep="0" rowsep="0">
<tgroup cols="2">
<colspec colwidth="15*"/>
<colspec colwidth="85*"/>
<tbody valign="top">
<row>
<entry>
<simpara>Type</simpara>
</entry>
<entry>
<simpara>Compress</simpara>
</entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis>GzipDecompress</emphasis> performs a gzip decompression on the value in the parent <link linkend="DataModel">DataModel</link>.</simpara>
<simpara>The <link linkend="Transformer">Transformer</link> can bidirectionally compress data as well as decompress data.</simpara>
<section xml:id="_parameters_44">
<title>Parameters</title>
<simpara>None.</simpara>
</section>
<section xml:id="_attributes_62">
<title>Attributes</title>
<simpara><emphasis>Required:</emphasis></simpara>
<simpara>None.</simpara>
<simpara><emphasis>Optional:</emphasis></simpara>
<simpara>None.</simpara>
</section>
<section xml:id="_actions_supported_8">
<title>Actions Supported</title>
<variablelist>
<varlistentry>
<term><link linkend="Action_input">input</link></term>
<listitem>
<simpara>On input, GzipDecompress compresses incoming data.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_output">output</link></term>
<listitem>
<simpara>On output, GzipDecompress decompresses all outgoing data.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_88">
<title>Examples</title>
<example>
<title>Compression To and From File Example</title>
<simpara>This example uses GzipCompress to compress a value, write the value to the console, write to a file, and then reads it from the file to the console.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach ../peach.xsd"&gt;

	&lt;DataModel name="Ex1"&gt;
		&lt;Blob name="TransformMe" value="1F 8B 08 00 00 00 00 00 04 00 EC BD 07 60 1C 49 96 25 26 2F 6D CA 7B 7F 4A F5 4A D7 E0 74 A1 08 80 60 13 24 D8 90 40 10 EC C1 88 CD E6 92 EC 1D 69 47 23 29 AB 2A 81 CA 65 56 65 5D 66 16 40 CC ED 9D BC F7 DE 7B EF BD F7 DE 7B EF BD F7 BA 3B 9D 4E 27 F7 DF FF 3F 5C 66 64 01 6C F6 CE 4A DA C9 9E 21 80 AA C8 1F 3F 7E 7C 1F 3F 22 9A 79 5D 2C DF 2E F2 55 99 67 4D 1E FE F5 FF 04 00 00 FF FF 32 B6 7E 40 1C 00 00 00" valueType="hex"&gt;
			&lt;Transformer class="GzipDecompress" /&gt;
		&lt;/Blob&gt;
	&lt;/DataModel&gt;

	&lt;StateModel name="TheState" initialState="initial"&gt;
		&lt;State name="initial"&gt;
			&lt;!-- Decompressed Output --&gt;
			&lt;Action type="output" publisher="ConsolePub"&gt;
				&lt;DataModel ref="Ex1" /&gt;
			&lt;/Action&gt;

			&lt;!-- Write Decompressed Output to File --&gt;
			&lt;Action type="output" publisher="FilePubWrite"&gt;
				&lt;DataModel ref="Ex1" /&gt;
			&lt;/Action&gt;

			&lt;Action type="close" publisher="FilePubWrite" /&gt;

			&lt;!-- Read and decompress file and slurp output to console --&gt;
			&lt;Action type="input" publisher="FilePubRead" &gt;
				&lt;DataModel name="InputModel" ref="Ex1" /&gt;
			&lt;/Action&gt;

			&lt;Action type="slurp" valueXpath="//InputModel//TransformMe" setXpath="//OutputModel//BlobValue" /&gt;

			&lt;Action type="output" publisher="ConsolePub"&gt;
				&lt;DataModel name="OutputModel"&gt;
					&lt;Blob name="BlobValue" /&gt;
				&lt;/DataModel&gt;
			&lt;/Action&gt;
		&lt;/State&gt;
	&lt;/StateModel&gt;

	&lt;Test name="Default"&gt;
		&lt;StateModel ref="TheState"/&gt;

		&lt;Publisher class="ConsoleHex" name="ConsolePub"/&gt;

		&lt;Publisher class="File" name="FilePubWrite"&gt;
			&lt;Param name="FileName" value="decompressed.bin" /&gt;
		&lt;/Publisher&gt;

		&lt;Publisher class="File" name="FilePubRead"&gt;
			&lt;Param name="FileName" value="decompressed.bin" /&gt;
			&lt;Param name="Overwrite" value="false" /&gt;
		&lt;/Publisher&gt;
	&lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Output from this example.</simpara>
<screen>&gt; peach -1 --debug example.xml

[*] Test 'Default' starting with random seed 52916.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher start()
Peach.Core.Publishers.ConsolePublisher open()
Peach.Core.Publishers.ConsolePublisher output(28 bytes)
00000000   73 68 72 69 6E 6B 6D 65  70 6C 65 61 73 65 73 68   shrinkmepleasesh
00000010   72 69 6E 6B 6D 65 70 6C  65 61 73 65               rinkmeplease
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.FilePublisher start()
Peach.Core.Publishers.FilePublisher open()
Peach.Core.Publishers.FilePublisher output(28 bytes)
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Close
Peach.Core.Publishers.FilePublisher close()
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Input
Peach.Core.Publishers.FilePublisher start()
Peach.Core.Publishers.FilePublisher open()
Peach.Core.Publishers.FilePublisher input()
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker DataModel 'InputModel' Bytes: 0/28, Bits: 0/224
Peach.Core.Cracker.DataCracker getSize: -----&gt; DataModel 'InputModel'
Peach.Core.Cracker.DataCracker scan: DataModel 'InputModel'
Peach.Core.Cracker.DataCracker scan: Blob 'InputModel.TransformMe' -&gt; Offset: 0
 Unsized element
Peach.Core.Cracker.DataCracker getSize: &lt;----- Deterministic: ???
Peach.Core.Cracker.DataCracker Crack: DataModel 'InputModel' Size: &lt;null&gt;, Byte
: 0/28, Bits: 0/224
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker Blob 'InputModel.TransformMe' Bytes: 0/28, Bits:
0/224
Peach.Core.Cracker.DataCracker getSize: -----&gt; Blob 'InputModel.TransformMe'
Peach.Core.Cracker.DataCracker scan: Blob 'InputModel.TransformMe' -&gt; Offset: 0
 Unsized element
Peach.Core.Cracker.DataCracker lookahead: Blob 'InputModel.TransformMe'
Peach.Core.Cracker.DataCracker getSize: &lt;----- Last Unsized: 224
Peach.Core.Cracker.DataCracker Crack: Blob 'InputModel.TransformMe' Size: 296,
ytes: 0/37, Bits: 0/296
Peach.Core.Dom.DataElement Blob 'InputModel.TransformMe' value is: 1f 8b 08 00
0 00 00 00 04 00 2b ce 28 ca cc cb ce 4d 2d c8 49 4d 2c 4e 2d 46 e1 01 00 32 b6
7e.. (Len: 37 bytes)
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Slurp
Peach.Core.Dom.Action Slurp, setting OutputModel.BlobValue from InputModel.Tran
formMe
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher output(37 bytes)
00000000   1F 8B 08 00 00 00 00 00  04 00 2B CE 28 CA CC CB   ??????????+?(???
00000010   CE 4D 2D C8 49 4D 2C 4E  2D 46 E1 01 00 32 B6 7E   ?M-?IM,N-F???2?~
00000020   40 1C 00 00 00                                     @????
Peach.Core.Publishers.ConsolePublisher close()
Peach.Core.Publishers.FilePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.ConsolePublisher stop()
Peach.Core.Publishers.FilePublisher stop()
Peach.Core.Publishers.FilePublisher stop()

[*] Test 'Default' finished.</screen>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Transformers_HexTransformer">
<title>Hex</title>
<informaltable tabstyle="horizontal" frame="none" colsep="0" rowsep="0">
<tgroup cols="2">
<colspec colwidth="15*"/>
<colspec colwidth="85*"/>
<tbody valign="top">
<row>
<entry>
<simpara>Type</simpara>
</entry>
<entry>
<simpara>Encoder/Decoder</simpara>
</entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis>HexTransformer</emphasis> takes the provided value and produces an ASCII string of hex characters that represent the data.</simpara>
<simpara>The <link linkend="Transformer">Transformer</link> can bidirectionally transform this data from hex to string.</simpara>
<section xml:id="_parameters_45">
<title>Parameters</title>
<simpara>None.</simpara>
</section>
<section xml:id="_attributes_63">
<title>Attributes</title>
<simpara>None.</simpara>
</section>
<section xml:id="_actions_supported_9">
<title>Actions Supported</title>
<variablelist>
<varlistentry>
<term><link linkend="Action_input">input</link></term>
<listitem>
<simpara>On input, HexTransformer converts a hex string into ASCII for the incoming data.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_output">output</link></term>
<listitem>
<simpara>On output, HexTransformer converts ASCII into a hex string for the outgoing data.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_89">
<title>Examples</title>
<example>
<title>Simple Console Example</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach ../peach.xsd"&gt;

	&lt;DataModel name="Ex1"&gt;
		&lt;String name="TransformMe" value="ABCDEF"&gt;
			&lt;Transformer class="Hex" /&gt;
		&lt;/String&gt;
	&lt;/DataModel&gt;

	&lt;StateModel name="TheState" initialState="initial"&gt;
		&lt;State name="initial"&gt;
			&lt;!-- Encoded Output --&gt;
			&lt;Action type="output" publisher="ConsolePub"&gt;
				&lt;DataModel ref="Ex1" /&gt;
			&lt;/Action&gt;

			&lt;!-- Write Encoded Output to File --&gt;
			&lt;Action type="output" publisher="FilePubWrite"&gt;
				&lt;DataModel ref="Ex1" /&gt;
				&lt;Data&gt;
					&lt;Field name="TransformMe" value="ABCDEF" /&gt;
				&lt;/Data&gt;
			&lt;/Action&gt;

			&lt;Action type="close" publisher="FilePubWrite" /&gt;

			&lt;!-- Read and decode encoded file and slurp decoded string to output in console --&gt;
			&lt;Action type="input" publisher="FilePubRead" &gt;
				&lt;DataModel name="InputModel" ref="Ex1" /&gt;
			&lt;/Action&gt;

			&lt;Action type="slurp" valueXpath="//InputModel//TransformMe" setXpath="//OutputModel//StringValue" /&gt;

			&lt;Action type="output" publisher="ConsolePub"&gt;
				&lt;DataModel name="OutputModel"&gt;
					&lt;String name="StringValue" /&gt;
				&lt;/DataModel&gt;
			&lt;/Action&gt;
		&lt;/State&gt;
	&lt;/StateModel&gt;

	&lt;Test name="Default"&gt;
		&lt;StateModel ref="TheState"/&gt;

		&lt;Publisher class="ConsoleHex" name="ConsolePub"/&gt;

		&lt;Publisher class="File" name="FilePubWrite"&gt;
			&lt;Param name="FileName" value="encoded.bin" /&gt;
		&lt;/Publisher&gt;

		&lt;Publisher class="File" name="FilePubRead"&gt;
			&lt;Param name="FileName" value="encoded.bin" /&gt;
			&lt;Param name="Overwrite" value="false" /&gt;
		&lt;/Publisher&gt;
	&lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Output from this example.</simpara>
<screen>&gt; peach -1 --debug example.xml


[*] Test 'Default' starting with random seed 47130.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher start()
Peach.Core.Publishers.ConsolePublisher open()
Peach.Core.Publishers.ConsolePublisher output(12 bytes)
00000000   34 31 34 32 34 33 34 34  34 35 34 36               414243444546
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.FilePublisher start()
Peach.Core.Publishers.FilePublisher open()
Peach.Core.Publishers.FilePublisher output(12 bytes)
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Close
Peach.Core.Publishers.FilePublisher close()
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Input
Peach.Core.Publishers.FilePublisher start()
Peach.Core.Publishers.FilePublisher open()
Peach.Core.Publishers.FilePublisher input()
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker DataModel 'InputModel' Bytes: 0/12, Bits: 0/96
Peach.Core.Cracker.DataCracker getSize: -----&gt; DataModel 'InputModel'
Peach.Core.Cracker.DataCracker scan: DataModel 'InputModel'
Peach.Core.Cracker.DataCracker scan: String 'InputModel.TransformMe' -&gt; Offset: 0, Unsized element
Peach.Core.Cracker.DataCracker getSize: &lt;----- Deterministic: ???
Peach.Core.Cracker.DataCracker Crack: DataModel 'InputModel' Size: &lt;null&gt;, Bytes : 0/12, Bits: 0/96
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker String 'InputModel.TransformMe' Bytes: 0/12, Bits : 0/96
Peach.Core.Cracker.DataCracker getSize: -----&gt; String 'InputModel.TransformMe'
Peach.Core.Cracker.DataCracker scan: String 'InputModel.TransformMe' -&gt; Offset: 0, Unsized element
Peach.Core.Cracker.DataCracker lookahead: String 'InputModel.TransformMe'
Peach.Core.Cracker.DataCracker getSize: &lt;----- Last Unsized: 96
Peach.Core.Cracker.DataCracker Crack: String 'InputModel.TransformMe' Size: 48, Bytes: 0/6, Bits: 0/48
Peach.Core.Dom.DataElement String 'InputModel.TransformMe' value is: ABCDEF
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Slurp
Peach.Core.Dom.Action Slurp, setting OutputModel.StringValue from InputModel.TransformMe
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher output(6 bytes)
00000000   41 42 43 44 45 46                                  ABCDEF
Peach.Core.Publishers.ConsolePublisher close()
Peach.Core.Publishers.FilePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.ConsolePublisher stop()
Peach.Core.Publishers.FilePublisher stop()
Peach.Core.Publishers.FilePublisher stop()

[*] Test 'Default' finished.</screen>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Transformers_HMACTransformer">
<title>Hmac</title>
<informaltable tabstyle="horizontal" frame="none" colsep="0" rowsep="0">
<tgroup cols="2">
<colspec colwidth="15*"/>
<colspec colwidth="85*"/>
<tbody valign="top">
<row>
<entry>
<simpara>Type</simpara>
</entry>
<entry>
<simpara>Cryptography</simpara>
</entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis>HMAC</emphasis> produces an HMAC hash on the value in the parent <link linkend="DataModel">DataModel</link> as described in RFC 2104.</simpara>
<simpara>This <link linkend="Transformer">Transformer</link> can only be applied to outgoing data because hashes are one-way operations.</simpara>
<section xml:id="_parameters_46">
<title>Parameters</title>
<simpara>None.</simpara>
</section>
<section xml:id="_attributes_64">
<title>Attributes</title>
<simpara>None.</simpara>
</section>
<section xml:id="_actions_supported_10">
<title>Actions Supported</title>
<variablelist>
<varlistentry>
<term><link linkend="Action_output">output</link></term>
<listitem>
<simpara>On output, this transformer hashes the outgoing data.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_90">
<title>Examples</title>
<example>
<title>Simple Encode Example</title>
<simpara>This example uses HMAC on an inline value, writes the transformed value to a file, and reads the value from the file to the console.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach ../peach.xsd"&gt;

	&lt;DataModel name="Ex1"&gt;
		&lt;Block name="Main"&gt;
			&lt;String name="TransformMe" value="superdoopersecret"&gt;
				&lt;Transformer class="Hmac" /&gt;
			&lt;/String&gt;
		&lt;/Block&gt;
	&lt;/DataModel&gt;

	&lt;StateModel name="TheState" initialState="initial"&gt;
		&lt;State name="initial"&gt;
			&lt;!-- Encrypted Output --&gt;
			&lt;Action type="output" publisher="ConsolePub"&gt;
				&lt;DataModel ref="Ex1" /&gt;
			&lt;/Action&gt;
		&lt;/State&gt;
	&lt;/StateModel&gt;

	&lt;Test name="Default"&gt;
		&lt;StateModel ref="TheState"/&gt;
		&lt;Publisher class="ConsoleHex" name="ConsolePub"/&gt;
	&lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Output from this example.</simpara>
<screen>&gt; peach -1 --debug example.xml

[*] Test 'Default' starting with random seed 42451.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher start()
Peach.Core.Publishers.ConsolePublisher open()
Peach.Core.Publishers.ConsolePublisher output(20 bytes)
00000000   DF 1B FE 8F 8A 44 D5 87  33 AE DD 18 2A 90 D2 34   ?????D??3???*??4
00000010   7F 7E FD B9                                        ~??
Peach.Core.Publishers.ConsolePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.ConsolePublisher stop()

[*] Test 'Default' finished.</screen>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Transformers_HtmlDecodeTransformer">
<title>HtmlDecode</title>
<informaltable tabstyle="horizontal" frame="none" colsep="0" rowsep="0">
<tgroup cols="2">
<colspec colwidth="15*"/>
<colspec colwidth="85*"/>
<tbody valign="top">
<row>
<entry>
<simpara>Type</simpara>
</entry>
<entry>
<simpara>Encoder/Decoder</simpara>
</entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis>HtmlDecode</emphasis> decodes any HTML/XML-encoded characters in the string in the parent <link linkend="DataModel">DataModel</link>.
The following characters are decoded: less than (&lt;), ampersand (&amp;), apostrophe ('), and quotation mark (").</simpara>
<simpara>The <link linkend="Transformer">Transformer</link> can bidirectionally encode data as well as decode data.</simpara>
<section xml:id="_parameters_47">
<title>Parameters</title>
<simpara>None.</simpara>
</section>
<section xml:id="_attributes_65">
<title>Attributes</title>
<simpara>None.</simpara>
</section>
<section xml:id="_actions_supported_11">
<title>Actions Supported</title>
<variablelist>
<varlistentry>
<term><link linkend="Action_input">input</link></term>
<listitem>
<simpara>On input, this transformer encodes characters to their HTML-encoded character sequences for incoming data.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_output">output</link></term>
<listitem>
<simpara>On output, this transformer decodes HTML-encoded character sequences to single-character representations for outgoing data.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_91">
<title>Examples</title>
<example>
<title>Simple Encode Example</title>
<simpara>This example uses HtmlDecode on an inline value, writes the transformed value to a file, and reads the value from the file to the console.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach ../peach.xsd"&gt;

	&lt;DataModel name="Ex1"&gt;
		&lt;String name="TransformMe" value="&amp;amp;lt;XML&amp;amp;gt;"&gt;
			&lt;Transformer class="HtmlDecode" /&gt;
		&lt;/String&gt;
	&lt;/DataModel&gt;

	&lt;StateModel name="TheState" initialState="initial"&gt;
		&lt;State name="initial"&gt;
			&lt;!-- Decoded HTML Output --&gt;
			&lt;Action type="output" publisher="ConsolePub"&gt;
				&lt;DataModel ref="Ex1" /&gt;
			&lt;/Action&gt;

			&lt;!-- Write Decoded Output to File --&gt;
			&lt;Action type="output" publisher="FilePubWrite"&gt;
				&lt;DataModel ref="Ex1" /&gt;
				&lt;Data&gt;
					&lt;Field name="TransformMe" value="&amp;amp;lt;XML&amp;amp;gt;" /&gt;
				&lt;/Data&gt;
			&lt;/Action&gt;

			&lt;Action type="close" publisher="FilePubWrite" /&gt;

			&lt;!-- Read and Encode file and slurp the HTML to output in console --&gt;
			&lt;!-- Only the special character '&lt;' will be encoded --&gt;
			&lt;Action type="input" publisher="FilePubRead" &gt;
				&lt;DataModel name="InputModel" ref="Ex1" /&gt;
			&lt;/Action&gt;

			&lt;Action type="slurp" valueXpath="//InputModel//TransformMe" setXpath="//OutputModel//StringValue" /&gt;

			&lt;Action type="output" publisher="ConsolePub"&gt;
				&lt;DataModel name="OutputModel"&gt;
					&lt;String name="StringValue" /&gt;
				&lt;/DataModel&gt;
			&lt;/Action&gt;
		&lt;/State&gt;
	&lt;/StateModel&gt;

	&lt;Test name="Default"&gt;
		&lt;StateModel ref="TheState"/&gt;

		&lt;Publisher class="ConsoleHex" name="ConsolePub"/&gt;

		&lt;Publisher class="File" name="FilePubWrite"&gt;
			&lt;Param name="FileName" value="decoded.bin" /&gt;
		&lt;/Publisher&gt;

		&lt;Publisher class="File" name="FilePubRead"&gt;
			&lt;Param name="FileName" value="decoded.bin" /&gt;
			&lt;Param name="Overwrite" value="false" /&gt;
		&lt;/Publisher&gt;
	&lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Output from this example.</simpara>
<screen>&gt; peach -1 --debug example.xml

[*] Test 'Default' starting with random seed 63821.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher start()
Peach.Core.Publishers.ConsolePublisher open()
Peach.Core.Publishers.ConsolePublisher output(5 bytes)
00000000   3C 58 4D 4C 3E                                     &lt;XML&gt;
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.FilePublisher start()
Peach.Core.Publishers.FilePublisher open()
Peach.Core.Publishers.FilePublisher output(5 bytes)
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Close
Peach.Core.Publishers.FilePublisher close()
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Input
Peach.Core.Publishers.FilePublisher start()
Peach.Core.Publishers.FilePublisher open()
Peach.Core.Publishers.FilePublisher input()
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker DataModel 'InputModel' Bytes: 0/5, Bits: 0/40
Peach.Core.Cracker.DataCracker getSize: -----&gt; DataModel 'InputModel'
Peach.Core.Cracker.DataCracker scan: DataModel 'InputModel'
Peach.Core.Cracker.DataCracker scan: String 'InputModel.TransformMe' -&gt; Offset: 0, Unsized element
Peach.Core.Cracker.DataCracker getSize: &lt;----- Deterministic: ???
Peach.Core.Cracker.DataCracker Crack: DataModel 'InputModel' Size: &lt;null&gt;, Bytes : 0/5, Bits: 0/40
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker String 'InputModel.TransformMe' Bytes: 0/5, Bits: 0/40
Peach.Core.Cracker.DataCracker getSize: -----&gt; String 'InputModel.TransformMe'
Peach.Core.Cracker.DataCracker scan: String 'InputModel.TransformMe' -&gt; Offset: 0, Unsized element
Peach.Core.Cracker.DataCracker lookahead: String 'InputModel.TransformMe'
Peach.Core.Cracker.DataCracker getSize: &lt;----- Last Unsized: 40
Peach.Core.Cracker.DataCracker Crack: String 'InputModel.TransformMe' Size: 64, Bytes: 0/8, Bits: 0/64
Peach.Core.Dom.DataElement String 'InputModel.TransformMe' value is: &amp;lt;XML&gt;
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Slurp
Peach.Core.Dom.Action Slurp, setting OutputModel.StringValue from InputModel.TransformMe
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher output(8 bytes)
00000000   26 6C 74 3B 58 4D 4C 3E                            &amp;lt;XML&gt;
Peach.Core.Publishers.ConsolePublisher close()
Peach.Core.Publishers.FilePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.ConsolePublisher stop()
Peach.Core.Publishers.FilePublisher stop()
Peach.Core.Publishers.FilePublisher stop()

[*] Test 'Default' finished.</screen>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Transformers_HtmlEncodeTransformer">
<title>HtmlEncode</title>
<informaltable tabstyle="horizontal" frame="none" colsep="0" rowsep="0">
<tgroup cols="2">
<colspec colwidth="15*"/>
<colspec colwidth="85*"/>
<tbody valign="top">
<row>
<entry>
<simpara>Type</simpara>
</entry>
<entry>
<simpara>Encoder/Decoder</simpara>
</entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis>HtmlEncode</emphasis> produce an HTML/XML-encoded string of the provided value in the parent <link linkend="DataModel">DataModel</link>.
The following characters are encoded: less than (&lt;), ampersand (&amp;), apostrophe ('), and quotation mark (").</simpara>
<simpara>The <link linkend="Transformer">Transformer</link> can bidirectionally encode data as well as decode data.</simpara>
<section xml:id="_parameters_48">
<title>Parameters</title>
<simpara>None.</simpara>
</section>
<section xml:id="_attributes_66">
<title>Attributes</title>
<simpara>None.</simpara>
</section>
<section xml:id="_actions_supported_12">
<title>Actions Supported</title>
<variablelist>
<varlistentry>
<term><link linkend="Action_input">input</link></term>
<listitem>
<simpara>On input, HtmlEncode decodes HTML-encoded character sequences to single-character  representations for incoming data.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_output">output</link></term>
<listitem>
<simpara>On output, HtmlEncode encodes characters to their HTML-encoded character sequences for outgoing data.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_92">
<title>Examples</title>
<example>
<title>Simple Encode Example</title>
<simpara>This example uses HtmlEncode on an inline value, writes the transformed value to a file, and reads the value from the file to the console.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach ../peach.xsd"&gt;

	&lt;DataModel name="Ex1"&gt;
		&lt;String value="&amp;lt;Body&amp;gt; " token="true"/&gt;
		&lt;String name="TransformMe" value="These are encoded: &amp;lt; &amp;amp; &amp;quot; '   These are not: &amp;gt;!$2/\\c*"&gt;
			&lt;Transformer class="HtmlEncode" /&gt;
		&lt;/String&gt;
		&lt;String value=" &amp;lt;/Body&amp;gt;" token="true"/&gt;
	&lt;/DataModel&gt;


	&lt;StateModel name="TheState" initialState="initial"&gt;
		&lt;State name="initial"&gt;
			&lt;!-- Encoded Output --&gt;
			&lt;Action type="output" publisher="ConsolePub"&gt;
				&lt;DataModel ref="Ex1" /&gt;
			&lt;/Action&gt;

			&lt;!-- Write Encoded Output to File --&gt;
			&lt;Action type="output" publisher="FilePubWrite"&gt;
				&lt;DataModel ref="Ex1" /&gt;
				&lt;Data&gt;
					&lt;Field name="TransformMe" value="These are encoded: &amp;lt;, &amp;gt;, &amp;amp;, &amp;quot;\nThese are not: '!$2/\\c*" /&gt;
				&lt;/Data&gt;
			&lt;/Action&gt;

			&lt;Action type="close" publisher="FilePubWrite" /&gt;

			&lt;!-- Read and decode encoded file and slurp the value to output in console --&gt;
			&lt;Action type="input" publisher="FilePubRead" &gt;
				&lt;DataModel name="InputModel" ref="Ex1" /&gt;
			&lt;/Action&gt;

			&lt;Action type="slurp" valueXpath="//InputModel//TransformMe" setXpath="//OutputModel//StringValue" /&gt;

			&lt;Action type="output" publisher="ConsolePub"&gt;
				&lt;DataModel name="OutputModel"&gt;
					&lt;String name="StringValue" /&gt;
				&lt;/DataModel&gt;
			&lt;/Action&gt;
		&lt;/State&gt;
	&lt;/StateModel&gt;

	&lt;Test name="Default"&gt;
		&lt;StateModel ref="TheState"/&gt;

		&lt;Publisher class="ConsoleHex" name="ConsolePub"/&gt;

		&lt;Publisher class="File" name="FilePubWrite"&gt;
			&lt;Param name="FileName" value="encoded.bin" /&gt;
		&lt;/Publisher&gt;

		&lt;Publisher class="File" name="FilePubRead"&gt;
			&lt;Param name="FileName" value="encoded.bin" /&gt;
			&lt;Param name="Overwrite" value="false" /&gt;
		&lt;/Publisher&gt;
	&lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Output from this example.</simpara>
<screen>&gt; peach -1 --debug example.xml

[*] Test 'Default' starting with random seed 52076.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher start()
Peach.Core.Publishers.ConsolePublisher open()
Peach.Core.Publishers.ConsolePublisher output(83 bytes)
00000000   3C 42 6F 64 79 3E 20 54  68 65 73 65 20 61 72 65   &lt;Body&gt; These are
00000010   20 65 6E 63 6F 64 65 64  3A 20 26 6C 74 3B 20 26    encoded: &amp;lt; &amp;
00000020   61 6D 70 3B 20 26 71 75  6F 74 3B 20 26 23 33 39   amp; &amp;quot; &amp;#39
00000030   3B 20 20 20 54 68 65 73  65 20 61 72 65 20 6E 6F   ;   These are no
00000040   74 3A 20 3E 21 24 32 2F  5C 63 2A 20 3C 2F 42 6F   t: &gt;!$2/\c* &lt;/Bo
00000050   64 79 3E                                           dy&gt;
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.FilePublisher start()
Peach.Core.Publishers.FilePublisher open()
Peach.Core.Publishers.FilePublisher output(84 bytes)
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Close
Peach.Core.Publishers.FilePublisher close()
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Input
Peach.Core.Publishers.FilePublisher start()
Peach.Core.Publishers.FilePublisher open()
Peach.Core.Publishers.FilePublisher input()
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker DataModel 'InputModel' Bytes: 0/84, Bits: 0/672
Peach.Core.Cracker.DataCracker getSize: -----&gt; DataModel 'InputModel'
Peach.Core.Cracker.DataCracker scan: DataModel 'InputModel'
Peach.Core.Cracker.DataCracker scan: String 'InputModel.DataElement_0' -&gt; Pos: 0, Saving Token
Peach.Core.Cracker.DataCracker scan: String 'InputModel.DataElement_0' -&gt; Pos: 56, Length: 56
Peach.Core.Cracker.DataCracker getSize: &lt;----- Deterministic: ???
Peach.Core.Cracker.DataCracker Crack: DataModel 'InputModel' Size: &lt;null&gt;, Bytes : 0/84, Bits: 0/672
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker String 'InputModel.DataElement_0' Bytes: 0/84, Bits: 0/672
Peach.Core.Cracker.DataCracker getSize: -----&gt; String 'InputModel.DataElement_0'

Peach.Core.Cracker.DataCracker scan: String 'InputModel.DataElement_0' -&gt; Pos: 0, Saving Token
Peach.Core.Cracker.DataCracker scan: String 'InputModel.DataElement_0' -&gt; Pos: 56, Length: 56
Peach.Core.Cracker.DataCracker getSize: &lt;----- Size: 56
Peach.Core.Cracker.DataCracker Crack: String 'InputModel.DataElement_0' Size: 56, Bytes: 0/84, Bits: 0/672
Peach.Core.Dom.DataElement String 'InputModel.DataElement_0' value is: &lt;Body&gt;
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker String 'InputModel.TransformMe' Bytes: 7/84, Bits : 56/672
Peach.Core.Cracker.DataCracker getSize: -----&gt; String 'InputModel.TransformMe'
Peach.Core.Cracker.DataCracker scan: String 'InputModel.TransformMe' -&gt; Offset:
0, Unsized element
Peach.Core.Cracker.DataCracker lookahead: String 'InputModel.TransformMe'
Peach.Core.Cracker.DataCracker scan: String 'InputModel.DataElement_1' -&gt; Pos: 0, Saving Token
Peach.Core.Cracker.DataCracker scan: String 'InputModel.DataElement_1' -&gt; Pos: 64, Length: 64
Peach.Core.Cracker.DataCracker getSize: &lt;----- Required Token: 552
Peach.Core.Cracker.DataCracker Crack: String 'InputModel.TransformMe' Size: 424, Bytes: 0/53, Bits: 0/424
Peach.Core.Dom.DataElement String 'InputModel.TransformMe' value is: These are encoded: &lt;, &gt;, &amp;, "
These are not: '!$2/\c*
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker String 'InputModel.DataElement_1' Bytes: 76/84, Bits: 608/672
Peach.Core.Cracker.DataCracker getSize: -----&gt; String 'InputModel.DataElement_1'

Peach.Core.Cracker.DataCracker scan: String 'InputModel.DataElement_1' -&gt; Pos: 0, Saving Token
Peach.Core.Cracker.DataCracker scan: String 'InputModel.DataElement_1' -&gt; Pos: 64, Length: 64
Peach.Core.Cracker.DataCracker getSize: &lt;----- Size: 64
Peach.Core.Cracker.DataCracker Crack: String 'InputModel.DataElement_1' Size: 64, Bytes: 76/84, Bits: 608/672
Peach.Core.Dom.DataElement String 'InputModel.DataElement_1' value is:  &lt;/Body&gt;
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Slurp
Peach.Core.Dom.Action Slurp, setting OutputModel.StringValue from InputModel.TransformMe
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher output(53 bytes)
00000000   54 68 65 73 65 20 61 72  65 20 65 6E 63 6F 64 65   These are encode
00000010   64 3A 20 3C 2C 20 3E 2C  20 26 2C 20 22 0A 54 68   d: &lt;, &gt;, &amp;, "?Th
00000020   65 73 65 20 61 72 65 20  6E 6F 74 3A 20 27 21 24   ese are not: '!$
00000030   32 2F 5C 63 2A                                     2/\c*
Peach.Core.Publishers.ConsolePublisher close()
Peach.Core.Publishers.FilePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.ConsolePublisher stop()
Peach.Core.Publishers.FilePublisher stop()
Peach.Core.Publishers.FilePublisher stop()

[*] Test 'Default' finished.</screen>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Transformers_IntToHexTransformer">
<title>IntToHex</title>
<informaltable tabstyle="horizontal" frame="none" colsep="0" rowsep="0">
<tgroup cols="2">
<colspec colwidth="15*"/>
<colspec colwidth="85*"/>
<tbody valign="top">
<row>
<entry>
<simpara>Type</simpara>
</entry>
<entry>
<simpara>Encoder/Decoder</simpara>
</entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis>IntToHex</emphasis> takes a string representation of an integer and produces an ASCII string of hex characters that represent that integer.</simpara>
<simpara>The <link linkend="Transformer">Transformer</link> can bidirectionally transform this data from hex to integer.</simpara>
<section xml:id="_parameters_49">
<title>Parameters</title>
<simpara><emphasis>Required:</emphasis></simpara>
<simpara>None.</simpara>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>FormatString</term>
<listitem>
<simpara>A format string in the Microsoft.NET format. Changing the format string allows controling how the number is converted to hex.  For example a value of <literal>X2</literal> would produce a two digit hex number (00, 01, .., FF).  Defaults to <literal>X</literal>.</simpara>
<simpara>For additional information see <link xl:href="https://docs.microsoft.com/en-us/dotnet/standard/base-types/standard-numeric-format-strings">Standard Numeric Format Strings</link></simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_attributes_67">
<title>Attributes</title>
<simpara>None.</simpara>
</section>
<section xml:id="_actions_supported_13">
<title>Actions Supported</title>
<variablelist>
<varlistentry>
<term><link linkend="Action_input">input</link></term>
<listitem>
<simpara>On input, IntToHex converts a hex string representation of a number into ASCII for the incoming data.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_output">output</link></term>
<listitem>
<simpara>On output, IntToHex converts an ASCII number into a hex string for the outgoing data.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_93">
<title>Examples</title>
<example>
<title>Basic Usage Example</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach ../peach.xsd"&gt;

	&lt;DataModel name="Ex1"&gt;
		&lt;String name="TransformMe" value="1234"&gt;
			&lt;Transformer class="IntToHex" /&gt;
		&lt;/String&gt;
	&lt;/DataModel&gt;

	&lt;StateModel name="TheState" initialState="initial"&gt;
		&lt;State name="initial"&gt;
			&lt;!-- Encoded Output --&gt;
			&lt;Action type="output" publisher="ConsolePub"&gt;
				&lt;DataModel ref="Ex1" /&gt;
			&lt;/Action&gt;

			&lt;!-- Write Encoded Output to File --&gt;
			&lt;Action type="output" publisher="FilePubWrite"&gt;
				&lt;DataModel ref="Ex1" /&gt;
				&lt;Data&gt;
					&lt;Field name="TransformMe" value="1234" /&gt;
				&lt;/Data&gt;
			&lt;/Action&gt;

			&lt;Action type="close" publisher="FilePubWrite" /&gt;

			&lt;!-- Read and decode encoded file and slurp decoded string to output in console --&gt;
			&lt;Action type="input" publisher="FilePubRead" &gt;
				&lt;DataModel name="InputModel" ref="Ex1" /&gt;
			&lt;/Action&gt;

			&lt;Action type="slurp" valueXpath="//InputModel//TransformMe" setXpath="//OutputModel//StringValue" /&gt;

			&lt;Action type="output" publisher="ConsolePub"&gt;
				&lt;DataModel name="OutputModel"&gt;
					&lt;String name="StringValue" /&gt;
				&lt;/DataModel&gt;
			&lt;/Action&gt;
		&lt;/State&gt;
	&lt;/StateModel&gt;

	&lt;Test name="Default"&gt;
		&lt;StateModel ref="TheState"/&gt;

		&lt;Publisher class="ConsoleHex" name="ConsolePub"/&gt;

		&lt;Publisher class="File" name="FilePubWrite"&gt;
			&lt;Param name="FileName" value="encrypted.bin" /&gt;
		&lt;/Publisher&gt;

		&lt;Publisher class="File" name="FilePubRead"&gt;
			&lt;Param name="FileName" value="encrypted.bin" /&gt;
			&lt;Param name="Overwrite" value="false" /&gt;
		&lt;/Publisher&gt;
	&lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Output from this example.</simpara>
<screen>&gt; peach -1 --debug example.xml

[*] Test 'Default' starting with random seed 49496.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher start()
Peach.Core.Publishers.ConsolePublisher open()
Peach.Core.Publishers.ConsolePublisher output(3 bytes)
00000000   34 44 32                                           4D2
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.FilePublisher start()
Peach.Core.Publishers.FilePublisher open()
Peach.Core.Publishers.FilePublisher output(3 bytes)
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Close
Peach.Core.Publishers.FilePublisher close()
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Input
Peach.Core.Publishers.FilePublisher start()
Peach.Core.Publishers.FilePublisher open()
Peach.Core.Publishers.FilePublisher input()
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker DataModel 'InputModel' Bytes: 0/3, Bits: 0/24
Peach.Core.Cracker.DataCracker getSize: -----&gt; DataModel 'InputModel'
Peach.Core.Cracker.DataCracker scan: DataModel 'InputModel'
Peach.Core.Cracker.DataCracker scan: String 'InputModel.TransformMe' -&gt; Offset: 0, Unsized element
Peach.Core.Cracker.DataCracker getSize: &lt;----- Deterministic: ???
Peach.Core.Cracker.DataCracker Crack: DataModel 'InputModel' Size: &lt;null&gt;, Bytes : 0/3, Bits: 0/24
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker String 'InputModel.TransformMe' Bytes: 0/3, Bits: 0/24
Peach.Core.Cracker.DataCracker getSize: -----&gt; String 'InputModel.TransformMe'
Peach.Core.Cracker.DataCracker scan: String 'InputModel.TransformMe' -&gt; Offset: 0, Unsized element
Peach.Core.Cracker.DataCracker lookahead: String 'InputModel.TransformMe'
Peach.Core.Cracker.DataCracker getSize: &lt;----- Last Unsized: 24
Peach.Core.Cracker.DataCracker Crack: String 'InputModel.TransformMe' Size: 32, Bytes: 0/4, Bits: 0/32
Peach.Core.Dom.DataElement String 'InputModel.TransformMe' value is: 1234
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Slurp
Peach.Core.Dom.Action Slurp, setting OutputModel.StringValue from InputModel.TransformMe
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher output(4 bytes)
00000000   31 32 33 34                                        1234
Peach.Core.Publishers.ConsolePublisher close()
Peach.Core.Publishers.FilePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.ConsolePublisher stop()
Peach.Core.Publishers.FilePublisher stop()
Peach.Core.Publishers.FilePublisher stop()

[*] Test 'Default' finished.</screen>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Transformers_Ipv4StringToOctetTransformer">
<title>Ipv4StringToOctet</title>
<informaltable tabstyle="horizontal" frame="none" colsep="0" rowsep="0">
<tgroup cols="2">
<colspec colwidth="15*"/>
<colspec colwidth="85*"/>
<tbody valign="top">
<row>
<entry>
<simpara>Type</simpara>
</entry>
<entry>
<simpara>Encoder/Decoder</simpara>
</entry>
</row>
</tbody>
</tgroup>
</informaltable>
<section xml:id="_transformer_type_encoderdecoder">
<title>Transformer type: Encoder/Decoder</title>
<simpara><emphasis>Ipv4StringToOctet</emphasis> produces the bytes from the string representation of an Internet Protocol version 4 address.
An example would be transforming the string 127.0.0.1 to 0x7F000001.</simpara>
<simpara>The <link linkend="Transformer">Transformer</link> can bidirectionally encode data as well as decode data.</simpara>
</section>
<section xml:id="_parameters_50">
<title>Parameters</title>
<simpara>None.</simpara>
</section>
<section xml:id="_attributes_68">
<title>Attributes</title>
<simpara>None.</simpara>
</section>
<section xml:id="_actions_supported_14">
<title>Actions Supported</title>
<variablelist>
<varlistentry>
<term><link linkend="Action_input">input</link></term>
<listitem>
<simpara>On input, Ipv4StringToOctet converts bytes into an IP address string representation.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_output">output</link></term>
<listitem>
<simpara>On output, Ipv4StringToOctet converts an IP address string representation into bytes.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_94">
<title>Examples</title>
<example>
<title>Simple Encode Example</title>
<simpara>This example uses Ipv4StringToOctet on an inline value, writes the transformed value to a file, and reads the value from the file to the console.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach ../peach.xsd"&gt;

	&lt;DataModel name="Ex1"&gt;
		&lt;String name="TransformMe" value="192.168.1.1"&gt;
			&lt;Transformer class="Ipv4StringToOctet" /&gt;
		&lt;/String&gt;
	&lt;/DataModel&gt;

	&lt;StateModel name="TheState" initialState="initial"&gt;
		&lt;State name="initial"&gt;
			&lt;!-- Encoded Octet Output --&gt;
			&lt;Action type="output" publisher="ConsolePub"&gt;
				&lt;DataModel ref="Ex1" /&gt;
			&lt;/Action&gt;

			&lt;!-- Write Encoded Octet Output to File --&gt;
			&lt;Action type="output" publisher="FilePubWrite"&gt;
				&lt;DataModel ref="Ex1" /&gt;
				&lt;Data&gt;
					&lt;Field name="TransformMe" value="192.168.1.1" /&gt;
				&lt;/Data&gt;
			&lt;/Action&gt;

			&lt;Action type="close" publisher="FilePubWrite" /&gt;

			&lt;!-- Read and Decode file and slurp the IP String to output in console --&gt;
			&lt;Action type="input" publisher="FilePubRead" &gt;
				&lt;DataModel name="InputModel" ref="Ex1" /&gt;
			&lt;/Action&gt;

			&lt;Action type="slurp" valueXpath="//InputModel//TransformMe" setXpath="//OutputModel//StringValue" /&gt;

			&lt;Action type="output" publisher="ConsolePub"&gt;
				&lt;DataModel name="OutputModel"&gt;
					&lt;String name="StringValue" /&gt;
				&lt;/DataModel&gt;
			&lt;/Action&gt;
		&lt;/State&gt;
	&lt;/StateModel&gt;

	&lt;Test name="Default"&gt;
		&lt;StateModel ref="TheState"/&gt;

		&lt;Publisher class="ConsoleHex" name="ConsolePub"/&gt;

		&lt;Publisher class="File" name="FilePubWrite"&gt;
			&lt;Param name="FileName" value="encoded.bin" /&gt;
		&lt;/Publisher&gt;

		&lt;Publisher class="File" name="FilePubRead"&gt;
			&lt;Param name="FileName" value="encoded.bin" /&gt;
			&lt;Param name="Overwrite" value="false" /&gt;
		&lt;/Publisher&gt;
	&lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Output from this example.</simpara>
<screen>&gt; peach -1 --debug example.xml

[*] Test 'Default' starting with random seed 2053.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher start()
Peach.Core.Publishers.ConsolePublisher open()
Peach.Core.Publishers.ConsolePublisher output(4 bytes)
00000000   C0 A8 01 01                                        ????
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.FilePublisher start()
Peach.Core.Publishers.FilePublisher open()
Peach.Core.Publishers.FilePublisher output(4 bytes)
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Close
Peach.Core.Publishers.FilePublisher close()
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Input
Peach.Core.Publishers.FilePublisher start()
Peach.Core.Publishers.FilePublisher open()
Peach.Core.Publishers.FilePublisher input()
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker DataModel 'InputModel' Bytes: 0/4, Bits: 0/32
Peach.Core.Cracker.DataCracker getSize: -----&gt; DataModel 'InputModel'
Peach.Core.Cracker.DataCracker scan: DataModel 'InputModel'
Peach.Core.Cracker.DataCracker scan: String 'InputModel.TransformMe' -&gt; Offset: 0, Unsized element
Peach.Core.Cracker.DataCracker getSize: &lt;----- Deterministic: ???
Peach.Core.Cracker.DataCracker Crack: DataModel 'InputModel' Size: &lt;null&gt;, Bytes : 0/4, Bits: 0/32
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker String 'InputModel.TransformMe' Bytes: 0/4, Bits: 0/32
Peach.Core.Cracker.DataCracker getSize: -----&gt; String 'InputModel.TransformMe'
Peach.Core.Cracker.DataCracker scan: String 'InputModel.TransformMe' -&gt; Offset: 0, Unsized element
Peach.Core.Cracker.DataCracker lookahead: String 'InputModel.TransformMe'
Peach.Core.Cracker.DataCracker getSize: &lt;----- Last Unsized: 32
Peach.Core.Cracker.DataCracker Crack: String 'InputModel.TransformMe' Size: 88, Bytes: 0/11, Bits: 0/88
Peach.Core.Dom.DataElement String 'InputModel.TransformMe' value is: 192.168.1.1

Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Slurp
Peach.Core.Dom.Action Slurp, setting OutputModel.StringValue from InputModel.TransformMe
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher output(11 bytes)
00000000   31 39 32 2E 31 36 38 2E  31 2E 31                  192.168.1.1
Peach.Core.Publishers.ConsolePublisher close()
Peach.Core.Publishers.FilePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.ConsolePublisher stop()
Peach.Core.Publishers.FilePublisher stop()
Peach.Core.Publishers.FilePublisher stop()

[*] Test 'Default' finished.</screen>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Transformers_Ipv6StringToOctetTransformer">
<title>Ipv6StringToOctet</title>
<informaltable tabstyle="horizontal" frame="none" colsep="0" rowsep="0">
<tgroup cols="2">
<colspec colwidth="15*"/>
<colspec colwidth="85*"/>
<tbody valign="top">
<row>
<entry>
<simpara>Type</simpara>
</entry>
<entry>
<simpara>Encoder/Decoder</simpara>
</entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis>Ipv6StringToOctet</emphasis> produces the octet bytes from the string representation of an Internet Protocol version 6 address.
An example would be transforming the string ::1 to 0x00000000000000000000000000000001.</simpara>
<simpara>The <link linkend="Transformer">Transformer</link> can bidirectionally encode data as well as decode data.</simpara>
<section xml:id="_parameters_51">
<title>Parameters</title>
<simpara>None.</simpara>
</section>
<section xml:id="_attributes_69">
<title>Attributes</title>
<simpara>None.</simpara>
</section>
<section xml:id="_actions_supported_15">
<title>Actions Supported</title>
<variablelist>
<varlistentry>
<term><link linkend="Action_input">input</link></term>
<listitem>
<simpara>On input, Ipv6StringToOctet converts bytes into an IP address string representation.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_output">output</link></term>
<listitem>
<simpara>On output, Ipv6StringToOctet converts an IP address string representation into bytes.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_95">
<title>Examples</title>
<example>
<title>Simple Encode Example</title>
<simpara>This example uses Ipv6StringToOctet on an inline value, writes the transformed value to a file, and reads the value from the file to the console.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach ../peach.xsd"&gt;

	&lt;DataModel name="Ex1"&gt;
		&lt;String name="TransformMe" value="fe80::4090:3894:4a88:a6f"&gt;
			&lt;Transformer class="Ipv6StringToOctet" /&gt;
		&lt;/String&gt;
	&lt;/DataModel&gt;

	&lt;StateModel name="TheState" initialState="initial"&gt;
		&lt;State name="initial"&gt;
			&lt;!-- Encoded Octet Output --&gt;
			&lt;Action type="output" publisher="ConsolePub"&gt;
				&lt;DataModel ref="Ex1" /&gt;
			&lt;/Action&gt;

			&lt;!-- Write Encoded Octet Output to File --&gt;
			&lt;Action type="output" publisher="FilePubWrite"&gt;
				&lt;DataModel ref="Ex1" /&gt;
				&lt;Data&gt;
					&lt;Field name="TransformMe" value="fe80::4090:3894:4a88:a6f" /&gt;
				&lt;/Data&gt;
			&lt;/Action&gt;

			&lt;Action type="close" publisher="FilePubWrite" /&gt;

			&lt;!-- Read and Decode file and slurp the IP String to output in console --&gt;

			&lt;Action type="input" publisher="FilePubRead" &gt;
				&lt;DataModel name="InputModel" ref="Ex1" /&gt;
			&lt;/Action&gt;

			&lt;Action type="slurp" valueXpath="//InputModel//TransformMe" setXpath="//OutputModel//StringValue" /&gt;

			&lt;Action type="output" publisher="ConsolePub"&gt;
				&lt;DataModel name="OutputModel"&gt;
					&lt;String name="StringValue" /&gt;
				&lt;/DataModel&gt;
			&lt;/Action&gt;
		&lt;/State&gt;
	&lt;/StateModel&gt;

	&lt;Test name="Default"&gt;
		&lt;StateModel ref="TheState"/&gt;

		&lt;Publisher class="ConsoleHex" name="ConsolePub"/&gt;

		&lt;Publisher class="File" name="FilePubWrite"&gt;
			&lt;Param name="FileName" value="encoded.bin" /&gt;
		&lt;/Publisher&gt;

		&lt;Publisher class="File" name="FilePubRead"&gt;
			&lt;Param name="FileName" value="encoded.bin" /&gt;
			&lt;Param name="Overwrite" value="false" /&gt;
		&lt;/Publisher&gt;
	&lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Output from this example.</simpara>
<screen>&gt; peach -1 --debug example.xml

[*] Test 'Default' starting with random seed 10701.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher start()
Peach.Core.Publishers.ConsolePublisher open()
Peach.Core.Publishers.ConsolePublisher output(16 bytes)
00000000   FE 80 00 00 00 00 00 00  40 90 38 94 4A 88 0A 6F   ????????@?8?J??o
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.FilePublisher start()
Peach.Core.Publishers.FilePublisher open()
Peach.Core.Publishers.FilePublisher output(16 bytes)
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Close
Peach.Core.Publishers.FilePublisher close()
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Input
Peach.Core.Publishers.FilePublisher start()
Peach.Core.Publishers.FilePublisher open()
Peach.Core.Publishers.FilePublisher input()
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker DataModel 'InputModel' Bytes: 0/16, Bits: 0/128
Peach.Core.Cracker.DataCracker getSize: -----&gt; DataModel 'InputModel'
Peach.Core.Cracker.DataCracker scan: DataModel 'InputModel'
Peach.Core.Cracker.DataCracker scan: String 'InputModel.TransformMe' -&gt; Offset: 0, Unsized element
Peach.Core.Cracker.DataCracker getSize: &lt;----- Deterministic: ???
Peach.Core.Cracker.DataCracker Crack: DataModel 'InputModel' Size: &lt;null&gt;, Bytes : 0/16, Bits: 0/128
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker String 'InputModel.TransformMe' Bytes: 0/16, Bits : 0/128
Peach.Core.Cracker.DataCracker getSize: -----&gt; String 'InputModel.TransformMe'
Peach.Core.Cracker.DataCracker scan: String 'InputModel.TransformMe' -&gt; Offset: 0, Unsized element
Peach.Core.Cracker.DataCracker lookahead: String 'InputModel.TransformMe'
Peach.Core.Cracker.DataCracker getSize: &lt;----- Last Unsized: 128
Peach.Core.Cracker.DataCracker Crack: String 'InputModel.TransformMe' Size: 192, Bytes: 0/24, Bits: 0/192
Peach.Core.Dom.DataElement String 'InputModel.TransformMe' value is: fe80::4090:3894:4a88:a6f
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Slurp
Peach.Core.Dom.Action Slurp, setting OutputModel.StringValue from InputModel.TransformMe
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher output(24 bytes)
00000000   66 65 38 30 3A 3A 34 30  39 30 3A 33 38 39 34 3A   fe80::4090:3894:
00000010   34 61 38 38 3A 61 36 66                            4a88:a6f
Peach.Core.Publishers.ConsolePublisher close()
Peach.Core.Publishers.FilePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.ConsolePublisher stop()
Peach.Core.Publishers.FilePublisher stop()
Peach.Core.Publishers.FilePublisher stop()

[*] Test 'Default' finished.</screen>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Transformers_JsEncodeTransformer">
<title>JsEncode</title>
<informaltable tabstyle="horizontal" frame="none" colsep="0" rowsep="0">
<tgroup cols="2">
<colspec colwidth="15*"/>
<colspec colwidth="85*"/>
<tbody valign="top">
<row>
<entry>
<simpara>Type</simpara>
</entry>
<entry>
<simpara>Encoder/Decoder</simpara>
</entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis>JsEncode</emphasis> produces a JavaScript-encoded result of the value in the parent <link linkend="DataModel">DataModel</link>.
All characters are encoded.</simpara>
<simpara>This <link linkend="Transformer">Transformer</link> only encodes the output. <emphasis>JsEncode</emphasis> does not decode any input.</simpara>
<simpara>The <emphasis>JsEncode</emphasis> algorithm filters alphabetic characters (A-Z, a-z), numerals (0-9), spaces, commas, and periods to pass through the transformer unaltered. Other characters are filtered and have formatting applied to them.</simpara>
<section xml:id="_parameters_52">
<title>Parameters</title>
<simpara>None.</simpara>
</section>
<section xml:id="_attributes_70">
<title>Attributes</title>
<simpara>None.</simpara>
</section>
<section xml:id="_actions_supported_16">
<title>Actions Supported</title>
<variablelist>
<varlistentry>
<term><link linkend="Action_output">output</link></term>
<listitem>
<simpara>On output, this transformer encodes the value using the <emphasis>JsEncode</emphasis> algorithm to the outgoing data.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_96">
<title>Examples</title>
<example>
<title>Simple Encode Example</title>
<simpara>This example uses <emphasis>JsEncode</emphasis> on an inline value and writes the transformed value to the console.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach ../peach.xsd"&gt;

	&lt;DataModel name="Ex1"&gt;
		&lt;String value="JSEncoded: " token="true"/&gt;
		&lt;String name="TransformMe" value="~!@#$%^&amp;amp;*()_+-=`?.,"&gt;
			&lt;Transformer class="JsEncode" /&gt;
		&lt;/String&gt;
	&lt;/DataModel&gt;

	&lt;StateModel name="TheState" initialState="initial"&gt;
		&lt;State name="initial"&gt;
			&lt;!-- Encoded XML Output --&gt;
			&lt;Action type="output" publisher="ConsolePub"&gt;
				&lt;DataModel ref="Ex1" /&gt;
			&lt;/Action&gt;
		&lt;/State&gt;
	&lt;/StateModel&gt;

	&lt;Test name="Default"&gt;
		&lt;StateModel ref="TheState"/&gt;

		&lt;Publisher class="ConsoleHex" name="ConsolePub"/&gt;
	&lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Output from this example.</simpara>
<screen>&gt; peach -1 --debug example.xml

[*] Test 'Default' starting with random seed 33041.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher start()
Peach.Core.Publishers.ConsolePublisher open()
Peach.Core.Publishers.ConsolePublisher output(81 bytes)
00000000   4A 53 45 6E 63 6F 64 65  64 3A 20 5C 78 37 45 5C   JSEncoded: \x7E\
00000010   78 32 31 5C 78 34 30 5C  78 32 33 5C 78 32 34 5C   x21\x40\x23\x24\
00000020   78 32 35 5C 78 35 45 5C  78 32 36 5C 78 32 41 5C   x25\x5E\x26\x2A\
00000030   78 32 38 5C 78 32 39 5C  78 35 46 5C 78 32 42 5C   x28\x29\x5F\x2B\
00000040   78 32 44 5C 78 33 44 5C  78 36 30 5C 78 33 46 2E   x2D\x3D\x60\x3F.
00000050   2C                                                 ,
Peach.Core.Publishers.ConsolePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.ConsolePublisher stop()

[*] Test 'Default' finished.</screen>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Transformers_MD5Transformer">
<title>Md5</title>
<informaltable tabstyle="horizontal" frame="none" colsep="0" rowsep="0">
<tgroup cols="2">
<colspec colwidth="15*"/>
<colspec colwidth="85*"/>
<tbody valign="top">
<row>
<entry>
<simpara>Type</simpara>
</entry>
<entry>
<simpara>Cryptography</simpara>
</entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis>MD5</emphasis> creates an MD5 hash of the value in the parent <link linkend="DataModel">DataModel</link>.</simpara>
<simpara>This <link linkend="Transformer">Transformer</link> can only be applied to outgoing data because hashes are one-way operations.</simpara>
<section xml:id="_parameters_53">
<title>Parameters</title>
<simpara>None.</simpara>
</section>
<section xml:id="_attributes_71">
<title>Attributes</title>
<simpara>None.</simpara>
</section>
<section xml:id="_actions_supported_17">
<title>Actions Supported</title>
<variablelist>
<varlistentry>
<term><link linkend="Action_output">output</link></term>
<listitem>
<simpara>On output, this transformer hashes the outgoing data.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_97">
<title>Examples</title>
<example>
<title>Simple Console Example</title>
<simpara>This example uses MD5 on an inline value and writes the transformed value to the console.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach ../peach.xsd"&gt;

	&lt;DataModel name="Ex1"&gt;
		&lt;Block name="Main"&gt;
			&lt;String name="TransformMe" value="superdoopersecret"&gt;
				&lt;Transformer class="Md5" /&gt;
			&lt;/String&gt;
		&lt;/Block&gt;
	&lt;/DataModel&gt;

	&lt;StateModel name="TheState" initialState="initial"&gt;
		&lt;State name="initial"&gt;
			&lt;!-- Encrypted Output --&gt;
			&lt;Action type="output" publisher="ConsolePub"&gt;
				&lt;DataModel ref="Ex1" /&gt;
			&lt;/Action&gt;
		&lt;/State&gt;
	&lt;/StateModel&gt;

	&lt;Test name="Default"&gt;
		&lt;StateModel ref="TheState"/&gt;

		&lt;Publisher class="ConsoleHex" name="ConsolePub"/&gt;
	&lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Output from this example.</simpara>
<screen>&gt; peach -1 --debug example.xml

[*] Test 'Default' starting with random seed 58687.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher start()
Peach.Core.Publishers.ConsolePublisher open()
Peach.Core.Publishers.ConsolePublisher output(16 bytes)
00000000   04 9B F0 86 41 46 4B 3F  3D 49 95 6D D0 81 12 BA   ????AFK?=I?m????
Peach.Core.Publishers.ConsolePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.ConsolePublisher stop()

[*] Test 'Default' finished.</screen>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Transformers_NetBiosDecodeTransformer">
<title>NetBiosDecode</title>
<informaltable tabstyle="horizontal" frame="none" colsep="0" rowsep="0">
<tgroup cols="2">
<colspec colwidth="15*"/>
<colspec colwidth="85*"/>
<tbody valign="top">
<row>
<entry>
<simpara>Type</simpara>
</entry>
<entry>
<simpara>Encoder/Decoder</simpara>
</entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis>NetBiosDecode</emphasis> decodes NetBios-encoded strings.</simpara>
<simpara>The <link linkend="Transformer">Transformer</link> can bidirectionally encode data as well as decode data.</simpara>
<section xml:id="_parameters_54">
<title>Parameters</title>
<simpara><emphasis>Required:</emphasis></simpara>
<simpara>None.</simpara>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>pad</term>
<listitem>
<simpara>Boolean value that determines whether the NetBios name should be padded/trimmed to 32 bytes.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_attributes_72">
<title>Attributes</title>
<simpara>None.</simpara>
</section>
<section xml:id="_actions_supported_18">
<title>Actions Supported</title>
<variablelist>
<varlistentry>
<term><link linkend="Action_input">input</link></term>
<listitem>
<simpara>On input, this transformer encodes incoming data using the NetBios encoding algorithm.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_output">output</link></term>
<listitem>
<simpara>On output, this transformer decodes outgoing data using the NetBios decoding algorithm.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_98">
<title>Examples</title>
<example>
<title>Decoding Value To and From File Example</title>
<simpara>This example uses NetBiosDecode on an inline value, writes the transformed value to a file, and reads the value from the file to the console.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach ../peach.xsd"&gt;

	&lt;DataModel name="Ex1"&gt;
		&lt;String value="NetBiosDecoded: " token="true"/&gt;
		&lt;String name="TransformMe" value="45 4D 45 42 45 4F 45 4E 45 42 45 4F" valueType="hex"&gt;
			&lt;Transformer class="NetBiosDecode" /&gt;
		&lt;/String&gt;
	&lt;/DataModel&gt;


	&lt;StateModel name="TheState" initialState="initial"&gt;
		&lt;State name="initial"&gt;
			&lt;!-- Decoded Output --&gt;
			&lt;Action type="output" publisher="ConsolePub"&gt;
				&lt;DataModel ref="Ex1" /&gt;
			&lt;/Action&gt;

			&lt;!-- Write Encoded Output to File --&gt;
			&lt;Action type="output" publisher="FilePubWrite"&gt;
				&lt;DataModel ref="Ex1" /&gt;
				&lt;Data&gt;
					&lt;Field name="TransformMe" value="45 4D 45 42 45 4F 45 4E 45 42 45 4F" valueType="hex"/&gt;
				&lt;/Data&gt;
			&lt;/Action&gt;
			&lt;Action type="close" publisher="FilePubWrite" /&gt;

			&lt;!-- Read and decode encoded file and slurp the XML body to output in console --&gt;
			&lt;Action type="input" publisher="FilePubRead" &gt;
				&lt;DataModel name="InputModel" ref="Ex1" /&gt;
			&lt;/Action&gt;
			&lt;Action type="slurp" valueXpath="//InputModel//TransformMe" setXpath="//OutputModel//StringValue" /&gt;
			&lt;Action type="output" publisher="ConsolePub"&gt;
				&lt;DataModel name="OutputModel"&gt;
					&lt;String name="StringValue" /&gt;
				&lt;/DataModel&gt;
			&lt;/Action&gt;
		&lt;/State&gt;
	&lt;/StateModel&gt;

	&lt;Test name="Default"&gt;
		&lt;StateModel ref="TheState"/&gt;

		&lt;Publisher class="ConsoleHex" name="ConsolePub"/&gt;

		&lt;Publisher class="File" name="FilePubWrite"&gt;
			&lt;Param name="FileName" value="encrypted.bin" /&gt;
		&lt;/Publisher&gt;

		&lt;Publisher class="File" name="FilePubRead"&gt;
			&lt;Param name="FileName" value="encrypted.bin" /&gt;
			&lt;Param name="Overwrite" value="false" /&gt;
		&lt;/Publisher&gt;
	&lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Output from this example.</simpara>
<screen>&gt; peach -1 --debug example.xml

[*] Test 'Default' starting with random seed 54340.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher start()
Peach.Core.Publishers.ConsolePublisher open()
Peach.Core.Publishers.ConsolePublisher output(22 bytes)
00000000   4E 65 74 42 69 6F 73 44  65 63 6F 64 65 64 3A 20   NetBiosDecoded:
00000010   4C 41 4E 4D 41 4E                                  LANMAN
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.FilePublisher start()
Peach.Core.Publishers.FilePublisher open()
Peach.Core.Publishers.FilePublisher output(22 bytes)
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Close
Peach.Core.Publishers.FilePublisher close()
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Input
Peach.Core.Publishers.FilePublisher start()
Peach.Core.Publishers.FilePublisher open()
Peach.Core.Publishers.FilePublisher input()
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker DataModel 'InputModel' Bytes: 0/22, Bits: 0/176
Peach.Core.Cracker.DataCracker getSize: -----&gt; DataModel 'InputModel'
Peach.Core.Cracker.DataCracker scan: DataModel 'InputModel'
Peach.Core.Cracker.DataCracker scan: String 'InputModel.DataElement_0' -&gt; Pos: 0, Saving Token
Peach.Core.Cracker.DataCracker scan: String 'InputModel.DataElement_0' -&gt; Pos: 128, Length: 128
Peach.Core.Cracker.DataCracker getSize: &lt;----- Deterministic: ???
Peach.Core.Cracker.DataCracker Crack: DataModel 'InputModel' Size: &lt;null&gt;, Bytes
: 0/22, Bits: 0/176
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker String 'InputModel.DataElement_0' Bytes: 0/22, Bits: 0/176
Peach.Core.Cracker.DataCracker getSize: -----&gt; String 'InputModel.DataElement_0'

Peach.Core.Cracker.DataCracker scan: String 'InputModel.DataElement_0' -&gt; Pos: 0, Saving Token
Peach.Core.Cracker.DataCracker scan: String 'InputModel.DataElement_0' -&gt; Pos: 128, Length: 128
Peach.Core.Cracker.DataCracker getSize: &lt;----- Size: 128
Peach.Core.Cracker.DataCracker Crack: String 'InputModel.DataElement_0' Size: 128, Bytes: 0/22, Bits: 0/176
Peach.Core.Dom.DataElement String 'InputModel.DataElement_0' value is: NetBiosDecoded:
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker String 'InputModel.TransformMe' Bytes: 16/22, Bit s: 128/176
Peach.Core.Cracker.DataCracker getSize: -----&gt; String 'InputModel.TransformMe'
Peach.Core.Cracker.DataCracker scan: String 'InputModel.TransformMe' -&gt; Offset: 0, Unsized element
Peach.Core.Cracker.DataCracker lookahead: String 'InputModel.TransformMe'
Peach.Core.Cracker.DataCracker getSize: &lt;----- Last Unsized: 48
Peach.Core.Cracker.DataCracker Crack: String 'InputModel.TransformMe' Size: 96, Bytes: 0/12, Bits: 0/96
Peach.Core.Dom.DataElement String 'InputModel.TransformMe' value is: EMEBEOENEBEO
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Slurp
Peach.Core.Dom.Action Slurp, setting OutputModel.StringValue from InputModel.TransformMe
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher output(12 bytes)
00000000   45 4D 45 42 45 4F 45 4E  45 42 45 4F               EMEBEOENEBEO
Peach.Core.Publishers.ConsolePublisher close()
Peach.Core.Publishers.FilePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.ConsolePublisher stop()
Peach.Core.Publishers.FilePublisher stop()
Peach.Core.Publishers.FilePublisher stop()

[*] Test 'Default' finished.</screen>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Transformers_NetBiosEncodeTransformer">
<title>NetBiosEncode</title>
<informaltable tabstyle="horizontal" frame="none" colsep="0" rowsep="0">
<tgroup cols="2">
<colspec colwidth="15*"/>
<colspec colwidth="85*"/>
<tbody valign="top">
<row>
<entry>
<simpara>Type</simpara>
</entry>
<entry>
<simpara>Encoder/Decoder</simpara>
</entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis>NetBiosEncode</emphasis> performs a NetBios encoding of the value in the parent <link linkend="DataModel">DataModel</link>.</simpara>
<simpara>The <link linkend="Transformer">Transformer</link> can bidirectionally encode data as well as encode data.</simpara>
<section xml:id="_parameters_55">
<title>Parameters</title>
<simpara><emphasis>Required:</emphasis></simpara>
<simpara>None.</simpara>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>pad</term>
<listitem>
<simpara>Boolean value that determines whether the NetBios name should be padded/trimmed to 32 bytes.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_attributes_73">
<title>Attributes</title>
<simpara>None.</simpara>
</section>
<section xml:id="_actions_supported_19">
<title>Actions Supported</title>
<variablelist>
<varlistentry>
<term><link linkend="Action_input">input</link></term>
<listitem>
<simpara>On input, this transformer decodes incoming data using the NetBios decoding algorithm.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_output">output</link></term>
<listitem>
<simpara>On output, this transformer encodes outgoing data using the NetBios encoding algorithm.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_99">
<title>Examples</title>
<example>
<title>Encoding Value To and From File Example</title>
<simpara>This example uses NetBiosEncode on an inline value, writes the transformed value to a file, and reads the value from the file to the console.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach ../peach.xsd"&gt;

	&lt;DataModel name="Ex1"&gt;
		&lt;String value="NetBiosEncoded: " token="true"/&gt;
		&lt;String name="TransformMe" value="LANMAN" &gt;
			&lt;Transformer class="NetBiosEncode" /&gt;
		&lt;/String&gt;
	&lt;/DataModel&gt;


	&lt;StateModel name="TheState" initialState="initial"&gt;
		&lt;State name="initial"&gt;
			&lt;!-- Encoded NetBios Output --&gt;
			&lt;Action type="output" publisher="ConsolePub"&gt;
				&lt;DataModel ref="Ex1" /&gt;
			&lt;/Action&gt;

			&lt;!-- Write Encoded Output to File --&gt;
			&lt;Action type="output" publisher="FilePubWrite"&gt;
				&lt;DataModel ref="Ex1" /&gt;
				&lt;Data&gt;
					&lt;Field name="TransformMe" value="LANMAN" /&gt;
				&lt;/Data&gt;
			&lt;/Action&gt;

			&lt;Action type="close" publisher="FilePubWrite" /&gt;

			&lt;!-- Read and decode encoded file and slurp the XML body to output in console --&gt;
			&lt;Action type="input" publisher="FilePubRead" &gt;
				&lt;DataModel name="InputModel" ref="Ex1" /&gt;
			&lt;/Action&gt;

			&lt;Action type="slurp" valueXpath="//InputModel//TransformMe" setXpath="//OutputModel//StringValue" /&gt;

			&lt;Action type="output" publisher="ConsolePub"&gt;
				&lt;DataModel name="OutputModel"&gt;
					&lt;String name="StringValue" /&gt;
				&lt;/DataModel&gt;
			&lt;/Action&gt;
		&lt;/State&gt;
	&lt;/StateModel&gt;

	&lt;Test name="Default"&gt;
		&lt;StateModel ref="TheState"/&gt;

		&lt;Publisher class="ConsoleHex" name="ConsolePub"/&gt;

		&lt;Publisher class="File" name="FilePubWrite"&gt;
			&lt;Param name="FileName" value="encoded.bin" /&gt;
		&lt;/Publisher&gt;

		&lt;Publisher class="File" name="FilePubRead"&gt;
			&lt;Param name="FileName" value="encoded.bin" /&gt;
			&lt;Param name="Overwrite" value="false" /&gt;
		&lt;/Publisher&gt;
	&lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Output from this example.</simpara>
<screen>&gt; peach -1 --debug example.xml

[*] Test 'Default' starting with random seed 14812.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher start()
Peach.Core.Publishers.ConsolePublisher open()
Peach.Core.Publishers.ConsolePublisher output(28 bytes)
00000000   4E 65 74 42 69 6F 73 45  6E 63 6F 64 65 64 3A 20   NetBiosEncoded:
00000010   45 4D 45 42 45 4F 45 4E  45 42 45 4F               EMEBEOENEBEO
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.FilePublisher start()
Peach.Core.Publishers.FilePublisher open()
Peach.Core.Publishers.FilePublisher output(28 bytes)
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Close
Peach.Core.Publishers.FilePublisher close()
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Input
Peach.Core.Publishers.FilePublisher start()
Peach.Core.Publishers.FilePublisher open()
Peach.Core.Publishers.FilePublisher input()
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker DataModel 'InputModel' Bytes: 0/28, Bits: 0/224
Peach.Core.Cracker.DataCracker getSize: -----&gt; DataModel 'InputModel'
Peach.Core.Cracker.DataCracker scan: DataModel 'InputModel'
Peach.Core.Cracker.DataCracker scan: String 'InputModel.DataElement_0' -&gt; Pos: 0 , Saving Token
Peach.Core.Cracker.DataCracker scan: String 'InputModel.DataElement_0' -&gt; Pos: 1 28, Length: 128
Peach.Core.Cracker.DataCracker getSize: &lt;----- Deterministic: ???
Peach.Core.Cracker.DataCracker Crack: DataModel 'InputModel' Size: &lt;null&gt;, Bytes
: 0/28, Bits: 0/224
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker String 'InputModel.DataElement_0' Bytes: 0/28, Bi ts: 0/224
Peach.Core.Cracker.DataCracker getSize: -----&gt; String 'InputModel.DataElement_0'

Peach.Core.Cracker.DataCracker scan: String 'InputModel.DataElement_0' -&gt; Pos: 0 , Saving Token
Peach.Core.Cracker.DataCracker scan: String 'InputModel.DataElement_0' -&gt; Pos: 1 28, Length: 128
Peach.Core.Cracker.DataCracker getSize: &lt;----- Size: 128
Peach.Core.Cracker.DataCracker Crack: String 'InputModel.DataElement_0' Size: 12 8, Bytes: 0/28, Bits: 0/224
Peach.Core.Dom.DataElement String 'InputModel.DataElement_0' value is: NetBiosEn coded:
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker String 'InputModel.TransformMe' Bytes: 16/28, Bit s: 128/224
Peach.Core.Cracker.DataCracker getSize: -----&gt; String 'InputModel.TransformMe'
Peach.Core.Cracker.DataCracker scan: String 'InputModel.TransformMe' -&gt; Offset:
0, Unsized element
Peach.Core.Cracker.DataCracker lookahead: String 'InputModel.TransformMe'
Peach.Core.Cracker.DataCracker getSize: &lt;----- Last Unsized: 96
Peach.Core.Cracker.DataCracker Crack: String 'InputModel.TransformMe' Size: 48, Bytes: 0/6, Bits: 0/48
Peach.Core.Dom.DataElement String 'InputModel.TransformMe' value is: LANMAN
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Slurp
Peach.Core.Dom.Action Slurp, setting OutputModel.StringValue from InputModel.TransformMe
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher output(6 bytes)
00000000   4C 41 4E 4D 41 4E                                  LANMAN
Peach.Core.Publishers.ConsolePublisher close()
Peach.Core.Publishers.FilePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.ConsolePublisher stop()
Peach.Core.Publishers.FilePublisher stop()
Peach.Core.Publishers.FilePublisher stop()

[*] Test 'Default' finished.</screen>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Transformers_Sha1Transformer">
<title>Sha1</title>
<informaltable tabstyle="horizontal" frame="none" colsep="0" rowsep="0">
<tgroup cols="2">
<colspec colwidth="15*"/>
<colspec colwidth="85*"/>
<tbody valign="top">
<row>
<entry>
<simpara>Type</simpara>
</entry>
<entry>
<simpara>Cryptography</simpara>
</entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis>Sha1</emphasis> produces an SHA1 hash of the value in the parent <link linkend="DataModel">DataModel</link>.</simpara>
<simpara>This <link linkend="Transformer">Transformer</link> can only be applied to outgoing data because hashes are one-way operations.</simpara>
<section xml:id="_parameters_56">
<title>Parameters</title>
<simpara>None.</simpara>
</section>
<section xml:id="_attributes_74">
<title>Attributes</title>
<simpara>None.</simpara>
</section>
<section xml:id="_actions_supported_20">
<title>Actions Supported</title>
<variablelist>
<varlistentry>
<term><link linkend="Action_output">output</link></term>
<listitem>
<simpara>On output, this transformer hashes the outgoing data.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_100">
<title>Examples</title>
<example>
<title>Simple Console Example</title>
<simpara>This example uses Sha256 on an inline value and writes the transformed value to the console.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach ../peach.xsd"&gt;

	&lt;DataModel name="Ex1"&gt;
		&lt;Block name="Main"&gt;
			&lt;String name="TransformMe" value="superdoopersecret"&gt;
				&lt;Transformer class="Sha1" /&gt;
			&lt;/String&gt;
		&lt;/Block&gt;
	&lt;/DataModel&gt;

	&lt;StateModel name="TheState" initialState="initial"&gt;
		&lt;State name="initial"&gt;
			&lt;!-- Hashed Output --&gt;
			&lt;Action type="output" publisher="ConsolePub"&gt;
				&lt;DataModel ref="Ex1" /&gt;
			&lt;/Action&gt;
		&lt;/State&gt;
	&lt;/StateModel&gt;

	&lt;Test name="Default"&gt;
		&lt;StateModel ref="TheState"/&gt;

		&lt;Publisher class="ConsoleHex" name="ConsolePub"/&gt;
	&lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Output from this example.</simpara>
<screen>&gt; peach -1 --debug example.xml

[*] Test 'Default' starting with random seed 30940.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher start()
Peach.Core.Publishers.ConsolePublisher open()
Peach.Core.Publishers.ConsolePublisher output(20 bytes)
00000000   00 93 99 11 AB 4B D1 9C  8E FC 36 41 36 32 E3 AE   ?????K????6A62??
00000010   35 10 19 70                                        5??p
Peach.Core.Publishers.ConsolePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.ConsolePublisher stop()

[*] Test 'Default' finished.</screen>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Transformers_Sha256Transformer">
<title>Sha256</title>
<informaltable tabstyle="horizontal" frame="none" colsep="0" rowsep="0">
<tgroup cols="2">
<colspec colwidth="15*"/>
<colspec colwidth="85*"/>
<tbody valign="top">
<row>
<entry>
<simpara>Type</simpara>
</entry>
<entry>
<simpara>Cryptography</simpara>
</entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis>Sha256</emphasis> produces an SHA256 hash of the value in the parent <link linkend="DataModel">DataModel</link>.</simpara>
<simpara>This <link linkend="Transformer">Transformer</link> can only be applied to outgoing data because hashes are one-way operations.</simpara>
<section xml:id="_parameters_57">
<title>Parameters</title>
<simpara>None.</simpara>
</section>
<section xml:id="_actions_supported_21">
<title>Actions Supported</title>
<variablelist>
<varlistentry>
<term><link linkend="Action_output">output</link></term>
<listitem>
<simpara>On output, this transformer hashes the outgoing data.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_101">
<title>Examples</title>
<example>
<title>Simple Console Example</title>
<simpara>This example uses Sha256 on an inline value and writes the transformed value to the console.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach ../peach.xsd"&gt;

	&lt;DataModel name="Ex1"&gt;
		&lt;Block name="Main"&gt;
			&lt;String name="TransformMe" value="superdoopersecret"&gt;
				&lt;Transformer class="Sha256" /&gt;
			&lt;/String&gt;
		&lt;/Block&gt;
	&lt;/DataModel&gt;

	&lt;StateModel name="TheState" initialState="initial"&gt;
		&lt;State name="initial"&gt;
			&lt;!-- Hash Output --&gt;
			&lt;Action type="output" publisher="ConsolePub"&gt;
				&lt;DataModel ref="Ex1" /&gt;
			&lt;/Action&gt;
		&lt;/State&gt;
	&lt;/StateModel&gt;

	&lt;Test name="Default"&gt;
		&lt;StateModel ref="TheState"/&gt;

		&lt;Publisher class="ConsoleHex" name="ConsolePub"/&gt;
	&lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Output from this example.</simpara>
<screen>&gt; peach -1 --debug example.xml

[*] Test 'Default' starting with random seed 46784.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher start()
Peach.Core.Publishers.ConsolePublisher open()
Peach.Core.Publishers.ConsolePublisher output(32 bytes)
00000000   02 44 19 39 45 FF 4A CD  A8 1B 28 89 15 08 2A 04   ?D?9E?J???(???*?
00000010   9B 07 9A 31 E8 B4 79 B7  AE D0 49 66 0D 92 81 5B   ???1??y???If???[
Peach.Core.Publishers.ConsolePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.ConsolePublisher stop()

[*] Test 'Default' finished.</screen>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Transformers_SidStringToBytesTransformer">
<title>SidStringToBytes</title>
<informaltable tabstyle="horizontal" frame="none" colsep="0" rowsep="0">
<tgroup cols="2">
<colspec colwidth="15*"/>
<colspec colwidth="85*"/>
<tbody valign="top">
<row>
<entry>
<simpara>Type</simpara>
</entry>
<entry>
<simpara>Encoder/Decoder</simpara>
</entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis>SidStringToBytes</emphasis> produces the byte representation from a security identifier (sid) string.</simpara>
<simpara>This <link linkend="Transformer">Transformer</link> can bidirectionally encode data as well as decode data.</simpara>
<section xml:id="_parameters_58">
<title>Parameters</title>
<simpara>None.</simpara>
</section>
<section xml:id="_attributes_75">
<title>Attributes</title>
<simpara>None.</simpara>
</section>
<section xml:id="_actions_supported_22">
<title>Actions Supported</title>
<variablelist>
<varlistentry>
<term><link linkend="Action_input">input</link></term>
<listitem>
<simpara>On input, this transformer converts bytes to a sid string.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_output">output</link></term>
<listitem>
<simpara>On output, this transformer converts a sid string to bytes.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_102">
<title>Examples</title>
<example>
<title>Simple Console Example</title>
<simpara>This example uses the SidStringtoBytes transformer on an inline value and writes the transformed value to a file, reads the value from a file, and outputs it to the console.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach ../peach.xsd"&gt;

	&lt;DataModel name="Ex1"&gt;
		&lt;String name="TransformMe" value="S-1-5-21-2127521184-1604012920-1887927527-1712781"&gt;
			&lt;Transformer class="SidStringToBytes" /&gt;
		&lt;/String&gt;
	&lt;/DataModel&gt;

	&lt;StateModel name="TheState" initialState="initial"&gt;
		&lt;State name="initial"&gt;
			&lt;!-- Byte Output --&gt;
			&lt;Action type="output" publisher="ConsolePub"&gt;
				&lt;DataModel ref="Ex1" /&gt;
			&lt;/Action&gt;

			&lt;!-- Write Byte Output to File --&gt;
			&lt;Action type="output" publisher="FilePubWrite"&gt;
				&lt;DataModel ref="Ex1" /&gt;
				&lt;Data&gt;
					&lt;Field name="TransformMe" value="S-1-5-21-2127521184-1604012920-1887927527-1712781" /&gt;
				&lt;/Data&gt;
			&lt;/Action&gt;

			&lt;Action type="close" publisher="FilePubWrite" /&gt;

			&lt;!-- Read and encode binary file and slurp SID encoded string to output in console --&gt;
			&lt;Action type="input" publisher="FilePubRead" &gt;
				&lt;DataModel name="InputModel" ref="Ex1" /&gt;
			&lt;/Action&gt;

			&lt;Action type="slurp" valueXpath="//InputModel//TransformMe" setXpath="//OutputModel//StringValue" /&gt;

			&lt;Action type="output" publisher="ConsolePub"&gt;
				&lt;DataModel name="OutputModel"&gt;
					&lt;String name="StringValue" /&gt;
				&lt;/DataModel&gt;
			&lt;/Action&gt;
		&lt;/State&gt;
	&lt;/StateModel&gt;

	&lt;Test name="Default"&gt;
		&lt;StateModel ref="TheState"/&gt;

		&lt;Publisher class="ConsoleHex" name="ConsolePub"/&gt;

		&lt;Publisher class="File" name="FilePubWrite"&gt;
			&lt;Param name="FileName" value="encoded.bin" /&gt;
		&lt;/Publisher&gt;

		&lt;Publisher class="File" name="FilePubRead"&gt;
			&lt;Param name="FileName" value="encoded.bin" /&gt;
			&lt;Param name="Overwrite" value="false" /&gt;
		&lt;/Publisher&gt;
	&lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Output from this example.</simpara>
<screen>&gt; peach -1 --debug example.xml

[*] Test 'Default' starting with random seed 32239.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher start()
Peach.Core.Publishers.ConsolePublisher open()
Peach.Core.Publishers.ConsolePublisher output(28 bytes)
00000000   01 05 00 00 00 00 00 05  15 00 00 00 A0 65 CF 7E   ?????????????e?~
00000010   78 4B 9B 5F E7 7C 87 70  8D 22 1A 00               xK?_?|?p?"??
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.FilePublisher start()
Peach.Core.Publishers.FilePublisher open()
Peach.Core.Publishers.FilePublisher output(28 bytes)
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Close
Peach.Core.Publishers.FilePublisher close()
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Input
Peach.Core.Publishers.FilePublisher start()
Peach.Core.Publishers.FilePublisher open()
Peach.Core.Publishers.FilePublisher input()
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker DataModel 'InputModel' Bytes: 0/28, Bits: 0/224
Peach.Core.Cracker.DataCracker getSize: -----&gt; DataModel 'InputModel'
Peach.Core.Cracker.DataCracker scan: DataModel 'InputModel'
Peach.Core.Cracker.DataCracker scan: String 'InputModel.TransformMe' -&gt; Offset: 0, Unsized element
Peach.Core.Cracker.DataCracker getSize: &lt;----- Deterministic: ???
Peach.Core.Cracker.DataCracker Crack: DataModel 'InputModel' Size: &lt;null&gt;, Bytes : 0/28, Bits: 0/224
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker String 'InputModel.TransformMe' Bytes: 0/28, Bits : 0/224
Peach.Core.Cracker.DataCracker getSize: -----&gt; String 'InputModel.TransformMe'
Peach.Core.Cracker.DataCracker scan: String 'InputModel.TransformMe' -&gt; Offset: 0, Unsized element
Peach.Core.Cracker.DataCracker lookahead: String 'InputModel.TransformMe'
Peach.Core.Cracker.DataCracker getSize: &lt;----- Last Unsized: 224
Peach.Core.Cracker.DataCracker Crack: String 'InputModel.TransformMe' Size: 392, Bytes: 0/49, Bits: 0/392
Peach.Core.Dom.DataElement String 'InputModel.TransformMe' value is: S-1-5-21-2127521184-1604012920-1887927527-1712781
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Slurp
Peach.Core.Dom.Action Slurp, setting OutputModel.StringValue from InputModel.TransformMe
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher output(49 bytes)
00000000   53 2D 31 2D 35 2D 32 31  2D 32 31 32 37 35 32 31   S-1-5-21-2127521
00000010   31 38 34 2D 31 36 30 34  30 31 32 39 32 30 2D 31   184-1604012920-1
00000020   38 38 37 39 32 37 35 32  37 2D 31 37 31 32 37 38   887927527-171278
00000030   31                                                 1
Peach.Core.Publishers.ConsolePublisher close()
Peach.Core.Publishers.FilePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.ConsolePublisher stop()
Peach.Core.Publishers.FilePublisher stop()
Peach.Core.Publishers.FilePublisher stop()

[*] Test 'Default' finished.</screen>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Transformers_TripleDesTransformer">
<title>TripleDes</title>
<informaltable tabstyle="horizontal" frame="none" colsep="0" rowsep="0">
<tgroup cols="2">
<colspec colwidth="15*"/>
<colspec colwidth="85*"/>
<tbody valign="top">
<row>
<entry>
<simpara>Type</simpara>
</entry>
<entry>
<simpara>Cryptography</simpara>
</entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>The <emphasis>TripleDesTransformer</emphasis> produces the bytes from a Triple DES encryption of the value in the parent <link linkend="DataModel">DataModel</link>.</simpara>
<simpara>The <link linkend="Transformer">Transformer</link> can bi-directionally encrypt data as well as decrypt data.</simpara>
<section xml:id="_parameters_59">
<title>Parameters</title>
<simpara>None.</simpara>
</section>
<section xml:id="_attributes_76">
<title>Attributes</title>
<simpara><emphasis>Required:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>Key</term>
<listitem>
<simpara>User provided symmetric key used to encrypt the value. Must be a hex string representation of a 24 byte key.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>IV</term>
<listitem>
<simpara>User provided initialization vector used as the first block for the TripleDES operation. Must be a hex string representation of an 8 byte value.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Optional:</emphasis></simpara>
<simpara>None.</simpara>
</section>
<section xml:id="_actions_supported_23">
<title>Actions Supported</title>
<variablelist>
<varlistentry>
<term><link linkend="Action_input">input</link></term>
<listitem>
<simpara>On input, this transformer decrypts the incoming data.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_output">output</link></term>
<listitem>
<simpara>On output, this transformer encrypts the outgoing data.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_103">
<title>Examples</title>
<example>
<title>Simple Console Example</title>
<simpara>This example uses the TripleDes transformer on an inline value and writes the transformed value to a file, reads the value from a file, and outputs it to the console.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach ../peach.xsd"&gt;

	&lt;DataModel name="Ex1"&gt;
		&lt;String name="TransformMe" value="superdoopersecret"&gt;
			&lt;Transformer class="TripleDes"&gt;
				&lt;Param name="Key" value="ae1234567890aeaffeda214354647586fefdfaddefeeaf12"/&gt;
				&lt;Param name="IV" value="aeaeaeaeaeaeaeae"/&gt;
			&lt;/Transformer&gt;
		&lt;/String&gt;
	&lt;/DataModel&gt;

	&lt;StateModel name="TheState" initialState="initial"&gt;
		&lt;State name="initial"&gt;
			&lt;!-- Encrypted Output --&gt;
			&lt;Action type="output" publisher="ConsolePub"&gt;
				&lt;DataModel ref="Ex1" /&gt;
			&lt;/Action&gt;

			&lt;!-- Write Encrypted Output to File --&gt;
			&lt;Action type="output" publisher="FilePubWrite"&gt;
				&lt;DataModel ref="Ex1" /&gt;
				&lt;Data&gt;
					&lt;Field name="TransformMe" value="superdoopersecret" /&gt;
				&lt;/Data&gt;
			&lt;/Action&gt;

			&lt;Action type="close" publisher="FilePubWrite" /&gt;

			&lt;!-- Read and decrypt encrypted file and slurp output to console --&gt;
			&lt;Action type="input" publisher="FilePubRead" &gt;
				&lt;DataModel name="InputModel" ref="Ex1" /&gt;
			&lt;/Action&gt;

			&lt;Action type="slurp" valueXpath="//InputModel//TransformMe" setXpath="//OutputModel//StringValue" /&gt;

			&lt;Action type="output" publisher="ConsolePub"&gt;
				&lt;DataModel name="OutputModel"&gt;
					&lt;String name="StringValue" /&gt;
				&lt;/DataModel&gt;
			&lt;/Action&gt;
		&lt;/State&gt;
	&lt;/StateModel&gt;

	&lt;Test name="Default"&gt;
		&lt;StateModel ref="TheState"/&gt;

		&lt;Publisher class="ConsoleHex" name="ConsolePub"/&gt;

		&lt;Publisher class="File" name="FilePubWrite"&gt;
			&lt;Param name="FileName" value="encrypted.bin" /&gt;
		&lt;/Publisher&gt;

		&lt;Publisher class="File" name="FilePubRead"&gt;
			&lt;Param name="FileName" value="encrypted.bin" /&gt;
			&lt;Param name="Overwrite" value="false" /&gt;
		&lt;/Publisher&gt;
	&lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Output from this example.</simpara>
<screen>&gt; peach -1 --debug example.xml

[*] Test 'Default' starting with random seed 54300.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher start()
Peach.Core.Publishers.ConsolePublisher open()
Peach.Core.Publishers.ConsolePublisher output(24 bytes)
00000000   27 C4 63 A3 AA 09 C1 6D  08 CF DC C8 F5 CD E2 DB   '?c????m????????
00000010   19 31 30 F1 6A C8 28 10                            ?10?j?(?
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.FilePublisher start()
Peach.Core.Publishers.FilePublisher open()
Peach.Core.Publishers.FilePublisher output(24 bytes)
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Close
Peach.Core.Publishers.FilePublisher close()
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Input
Peach.Core.Publishers.FilePublisher start()
Peach.Core.Publishers.FilePublisher open()
Peach.Core.Publishers.FilePublisher input()
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker DataModel 'InputModel' Bytes: 0/24, Bits: 0/192
Peach.Core.Cracker.DataCracker getSize: -----&gt; DataModel 'InputModel'
Peach.Core.Cracker.DataCracker scan: DataModel 'InputModel'
Peach.Core.Cracker.DataCracker scan: String 'InputModel.TransformMe' -&gt; Offset: 0, Unsized element
Peach.Core.Cracker.DataCracker getSize: &lt;----- Deterministic: ???
Peach.Core.Cracker.DataCracker Crack: DataModel 'InputModel' Size: &lt;null&gt;, Bytes : 0/24, Bits: 0/192
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker String 'InputModel.TransformMe' Bytes: 0/24, Bits : 0/192
Peach.Core.Cracker.DataCracker getSize: -----&gt; String 'InputModel.TransformMe'
Peach.Core.Cracker.DataCracker scan: String 'InputModel.TransformMe' -&gt; Offset: 0, Unsized element
Peach.Core.Cracker.DataCracker lookahead: String 'InputModel.TransformMe'
Peach.Core.Cracker.DataCracker getSize: &lt;----- Last Unsized: 192
Peach.Core.Cracker.DataCracker Crack: String 'InputModel.TransformMe' Size: 192, Bytes: 0/24, Bits: 0/192
Peach.Core.Dom.DataElement String 'InputModel.TransformMe' value is: superdoopersecret
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Slurp
Peach.Core.Dom.Action Slurp, setting OutputModel.StringValue from InputModel.TransformMe
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher output(24 bytes)
00000000   73 75 70 65 72 64 6F 6F  70 65 72 73 65 63 72 65   superdoopersecre
00000010   74 00 00 00 00 00 00 00                            t???????
Peach.Core.Publishers.ConsolePublisher close()
Peach.Core.Publishers.FilePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.ConsolePublisher stop()
Peach.Core.Publishers.FilePublisher stop()
Peach.Core.Publishers.FilePublisher stop()

[*] Test 'Default' finished.</screen>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Transformers_TruncateTransformer">
<title>Truncate</title>
<informaltable tabstyle="horizontal" frame="none" colsep="0" rowsep="0">
<tgroup cols="2">
<colspec colwidth="15*"/>
<colspec colwidth="85*"/>
<tbody valign="top">
<row>
<entry>
<simpara>Type</simpara>
</entry>
<entry>
<simpara>Encoder</simpara>
</entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis>Truncate</emphasis> will shrink the value in the parent <link linkend="DataModel">DataModel</link> to <emphasis>Length</emphasis> bytes.</simpara>
<simpara>This <link linkend="Transformer">Transformer</link> can only be applied to outgoing data because shrinking is a one-way operation.</simpara>
<section xml:id="_parameters_60">
<title>Parameters</title>
<variablelist>
<varlistentry>
<term>Length</term>
<listitem>
<simpara>Length of the result value.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>Offset</term>
<listitem>
<simpara>Optional starting index for the resulting substring.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_attributes_77">
<title>Attributes</title>
<simpara>No Attributes are supported by this transformer.</simpara>
</section>
<section xml:id="_actions_supported_24">
<title>Actions Supported</title>
<variablelist>
<varlistentry>
<term><link linkend="Action_output">output</link></term>
<listitem>
<simpara>On output this transformer will truncate the outgoing data.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_104">
<title>Examples</title>
<example>
<title>Simple Console Example</title>
<simpara>This example uses Truncate on an inline value and writes the transformed value to the console.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach ../peach.xsd"&gt;

	&lt;DataModel name="Ex1"&gt;
		&lt;Block name="Main"&gt;
			&lt;String name="TransformMe" value="superdoopersecret"&gt;
				&lt;Transformer class="Truncate"&gt;
					&lt;Param name="Length" value="5" /&gt;
				&lt;/Transformer&gt;
			&lt;/String&gt;
		&lt;/Block&gt;
	&lt;/DataModel&gt;

	&lt;StateModel name="TheState" initialState="initial"&gt;
		&lt;State name="initial"&gt;
			&lt;!-- Truncated Output --&gt;
			&lt;Action type="output" publisher="ConsolePub"&gt;
				&lt;DataModel ref="Ex1" /&gt;
			&lt;/Action&gt;
		&lt;/State&gt;
	&lt;/StateModel&gt;

	&lt;Test name="Default"&gt;
		&lt;StateModel ref="TheState"/&gt;

		&lt;Publisher class="ConsoleHex" name="ConsolePub"/&gt;	&lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Output from this example.</simpara>
<screen>&gt; peach -1 --debug example.xml

[*] Web site running at: http://localhost:8888/

[*] Test 'Default' starting with random seed 3082.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.StateModel Run(): Changing to state "initial".
Peach.Core.Dom.Action Run(Action): Output
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Publishers.ConsolePublisher start()
Peach.Core.Publishers.ConsolePublisher open()
Peach.Core.Publishers.ConsolePublisher output(5 bytes)
00000000   73 75 70 65 72                                     super
Peach.Core.Publishers.ConsolePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.ConsolePublisher stop()

[*] Test 'Default' finished.</screen>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Transformers_UrlEncodeTransformer">
<title>UrlEncode</title>
<informaltable tabstyle="horizontal" frame="none" colsep="0" rowsep="0">
<tgroup cols="2">
<colspec colwidth="15*"/>
<colspec colwidth="85*"/>
<tbody valign="top">
<row>
<entry>
<simpara>Type</simpara>
</entry>
<entry>
<simpara>Encoder/Decoder</simpara>
</entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis>UrlEncode</emphasis> produces a URL-encoded string of the provided value in the parent <link linkend="DataModel">DataModel</link>.</simpara>
<simpara>The <link linkend="Transformer">Transformer</link> can bidirectionally encode data as well as decode data.</simpara>
<section xml:id="_parameters_61">
<title>Parameters</title>
<simpara>None.</simpara>
</section>
<section xml:id="_attributes_78">
<title>Attributes</title>
<simpara>None.</simpara>
</section>
<section xml:id="_actions_supported_25">
<title>Actions Supported</title>
<variablelist>
<varlistentry>
<term><link linkend="Action_input">input</link></term>
<listitem>
<simpara>On input, this transformer decodes a URL-encoded string.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_output">output</link></term>
<listitem>
<simpara>On output, this transformer encodes a URL-encoded string.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_105">
<title>Examples</title>
<example>
<title>Simple Encode Example</title>
<simpara>This example uses UrlEncode on an inline value, writes the transformed value to a file, and reads the value from the file to the console.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach ../peach.xsd"&gt;

	&lt;DataModel name="Ex1"&gt;
		&lt;String value="http://peachfuzzer.com/?q=" token="true"/&gt;
		&lt;String name="TransformMe" value="'abcd=1234'"&gt;
			&lt;Transformer class="UrlEncode" /&gt;
		&lt;/String&gt;
	&lt;/DataModel&gt;

	&lt;StateModel name="TheState" initialState="initial"&gt;
		&lt;State name="initial"&gt;
			&lt;!-- Encoded URL Output --&gt;
			&lt;Action type="output" publisher="ConsolePub"&gt;
				&lt;DataModel ref="Ex1" /&gt;
			&lt;/Action&gt;

			&lt;!-- Write Encoded Output to File --&gt;
			&lt;Action type="output" publisher="FilePubWrite"&gt;
				&lt;DataModel ref="Ex1" /&gt;
				&lt;Data&gt;
					&lt;Field name="TransformMe" value="'abcd=1234'" /&gt;
				&lt;/Data&gt;
			&lt;/Action&gt;

			&lt;Action type="close" publisher="FilePubWrite" /&gt;

			&lt;!-- Read and decode encoded file and slurp URL parameter to output in console --&gt;
			&lt;Action type="input" publisher="FilePubRead" &gt;
				&lt;DataModel name="InputModel" ref="Ex1" /&gt;
			&lt;/Action&gt;

			&lt;Action type="slurp" valueXpath="//InputModel//TransformMe" setXpath="//OutputModel//StringValue" /&gt;

			&lt;Action type="output" publisher="ConsolePub"&gt;
				&lt;DataModel name="OutputModel"&gt;
					&lt;String name="StringValue" /&gt;
				&lt;/DataModel&gt;
			&lt;/Action&gt;
		&lt;/State&gt;
	&lt;/StateModel&gt;

	&lt;Test name="Default"&gt;
		&lt;StateModel ref="TheState"/&gt;

		&lt;Publisher class="ConsoleHex" name="ConsolePub"/&gt;

		&lt;Publisher class="File" name="FilePubWrite"&gt;
			&lt;Param name="FileName" value="encoded.bin" /&gt;
		&lt;/Publisher&gt;

		&lt;Publisher class="File" name="FilePubRead"&gt;
			&lt;Param name="FileName" value="encoded.bin" /&gt;
			&lt;Param name="Overwrite" value="false" /&gt;
		&lt;/Publisher&gt;
	&lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Output from this example.</simpara>
<screen>&gt; peach -1 --debug example.xml


[*] Test 'Default' starting with random seed 29519.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher start()
Peach.Core.Publishers.ConsolePublisher open()
Peach.Core.Publishers.ConsolePublisher output(43 bytes)
00000000   68 74 74 70 3A 2F 2F 70  65 61 63 68 66 75 7A 7A   http://peachfuzz
00000010   65 72 2E 63 6F 6D 2F 3F  71 3D 25 32 37 61 62 63   er.com/?q=%27abc
00000020   64 25 33 64 31 32 33 34  25 32 37                  d%3d1234%27
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.FilePublisher start()
Peach.Core.Publishers.FilePublisher open()
Peach.Core.Publishers.FilePublisher output(43 bytes)
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Close
Peach.Core.Publishers.FilePublisher close()
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Input
Peach.Core.Publishers.FilePublisher start()
Peach.Core.Publishers.FilePublisher open()
Peach.Core.Publishers.FilePublisher input()
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker DataModel 'InputModel' Bytes: 0/43, Bits: 0/344
Peach.Core.Cracker.DataCracker getSize: -----&gt; DataModel 'InputModel'
Peach.Core.Cracker.DataCracker scan: DataModel 'InputModel'
Peach.Core.Cracker.DataCracker scan: String 'InputModel.DataElement_0' -&gt; Pos: 0, Saving Token
Peach.Core.Cracker.DataCracker scan: String 'InputModel.DataElement_0' -&gt; Pos: 208, Length: 208
Peach.Core.Cracker.DataCracker getSize: &lt;----- Deterministic: ???
Peach.Core.Cracker.DataCracker Crack: DataModel 'InputModel' Size: &lt;null&gt;, Bytes: 0/43, Bits: 0/344
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker String 'InputModel.DataElement_0' Bytes: 0/43, Bits: 0/344
Peach.Core.Cracker.DataCracker getSize: -----&gt; String 'InputModel.DataElement_0'
Peach.Core.Cracker.DataCracker scan: String 'InputModel.DataElement_0' -&gt; Pos: 0, Saving Token
Peach.Core.Cracker.DataCracker scan: String 'InputModel.DataElement_0' -&gt; Pos: 208, Length: 208
Peach.Core.Cracker.DataCracker getSize: &lt;----- Size: 208
Peach.Core.Cracker.DataCracker Crack: String 'InputModel.DataElement_0' Size: 208, Bytes: 0/43, Bits: 0/344
Peach.Core.Dom.DataElement String 'InputModel.DataElement_0' value is: http://peachfuzzer.com/?q=
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker String 'InputModel.TransformMe' Bytes: 26/43, Bit s: 208/344
Peach.Core.Cracker.DataCracker getSize: -----&gt; String 'InputModel.TransformMe'
Peach.Core.Cracker.DataCracker scan: String 'InputModel.TransformMe' -&gt; Offset: 0, Unsized element
Peach.Core.Cracker.DataCracker lookahead: String 'InputModel.TransformMe'
Peach.Core.Cracker.DataCracker getSize: &lt;----- Last Unsized: 136
Peach.Core.Cracker.DataCracker Crack: String 'InputModel.TransformMe' Size: 88, Bytes: 0/11, Bits: 0/88
Peach.Core.Dom.DataElement String 'InputModel.TransformMe' value is: 'abcd=1234'
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Slurp
Peach.Core.Dom.Action Slurp, setting OutputModel.StringValue from InputModel.TransformMe
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher output(11 bytes)
00000000   27 61 62 63 64 3D 31 32  33 34 27                  'abcd=1234'
Peach.Core.Publishers.ConsolePublisher close()
Peach.Core.Publishers.FilePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.ConsolePublisher stop()
Peach.Core.Publishers.FilePublisher stop()
Peach.Core.Publishers.FilePublisher stop()

[*] Test 'Default' finished.</screen>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
</section>
<section xml:id="_state_modeling">
<title>State Modeling</title>
<simpara>This section provides reference information for state-modeling-related elements.</simpara>
<section xml:id="StateModel">
<title>StateModel</title>
<simpara>Two Peach models can create a fuzzer, the <link linkend="DataModel">DataModel</link> and the <emphasis>StateModel</emphasis>.</simpara>
<simpara>The <emphasis>StateModel</emphasis> consists of at least one <link linkend="State">State</link> element. <emphasis>StateModel</emphasis> defines how to send data to and receive data from the fuzzing target as well as creating the basic state machine logic needed to test a protocol.</simpara>
<note>
<simpara>Only one <emphasis>StateModel</emphasis> can be used for a given Test.</simpara>
</note>
<simpara><emphasis>StateModel</emphasis> can range from very simple to extremely complex.
When starting out, keep the <emphasis>StateModel</emphasis> simple and expand as needed.</simpara>
<simpara>Multiple <link linkend="State">State</link> elements are required for non-deterministic interactions (such as a target sending an unpredictable command and expecting a certain response from the fuzzer).
In these situations, couple the <link linkend="Action_changeState">changeState</link> action with a <link linkend="Action_when">when</link> attribute to change to the correct state depending on Peach&#8217;s state and data.</simpara>
<simpara><emphasis>StateModel</emphasis> can contain various States to model full interactions with a target.
Many interactions have deterministic I/O and do not need multiple States.
Since actions inside a <link linkend="State">State</link> occur sequentially, top to bottom, that is usually enough control.</simpara>
<simpara>Recursion into States is allowed in Peach.
When a state is re-entered, all data previously set through cracking input or slurping is reset to its default values.</simpara>
<important>
<simpara>Peach is not responsible for guaranteeing an exit condition in recursive state changes; if you need such an exit condition, you will need to create it.</simpara>
</important>
<simpara>Each <link linkend="Action">Action</link> supports various parameters that execute scripts in certain times (such as once an <link linkend="Action">Action</link> has completed or before it starts).
This can be used by complicated StateModels that need counters or other advanced operations.</simpara>
<simpara>Advanced StateModels can use the Peach Statebag dictionaries from within these scripts to store data. The Statebag dictionaries are accessible via class RunContext.</simpara>
<simpara><emphasis>StateModel</emphasis> variables can persist throughout a single iteration with <emphasis>iterationStateStore</emphasis> (or the entire fuzzing session with <emphasis>stateStore</emphasis>) and can be referred to through the scripting environment.</simpara>
<section xml:id="_attributes_79">
<title>Attributes</title>
<simpara><emphasis>Required:</emphasis></simpara>
<variablelist>
<varlistentry>
<term><link linkend="name">name</link></term>
<listitem>
<simpara>The name of the StateModel</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>initialState</term>
<listitem>
<simpara>Name of the State to start executing first</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_child_elements_41">
<title>Child Elements</title>
<variablelist>
<varlistentry>
<term><link linkend="State">State</link></term>
<listitem>
<simpara>One or more State elements are required.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_106">
<title>Examples</title>
<example>
<title>File Fuzzing</title>
<simpara>When file fuzzing, Peach writes data to a file, then calls the target process to open the file.
Peach can uses a single state and three actions for a simple file fuzzer.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

  &lt;DataModel name="TestTemplate"&gt;
    &lt;String value="Hello World!" /&gt;
  &lt;/DataModel&gt;

  &lt;StateModel name="State" initialState="Initial"&gt;
    &lt;State name="Initial"&gt;

	  &lt;!-- Output content of file --&gt;
      &lt;Action type="output"&gt;
        &lt;DataModel ref="TestTemplate" /&gt;
      &lt;/Action&gt;

      &lt;!-- Close file --&gt;
      &lt;Action type="close" /&gt;

      &lt;!-- Launch the file consumer --&gt;
      &lt;Action type="call" method="ScoobySnacks" publisher="Peach.Agent"/&gt;

    &lt;/State&gt;
  &lt;/StateModel&gt;

  &lt;Agent name="LocalAgent"&gt;
    &lt;Monitor class="WindowsDebugger"&gt;
      &lt;Param name="Executable" value="c:\windows\system32\notepad.exe" /&gt;
      &lt;Param name="Arguments" value="fuzzfile.bin" /&gt;
      &lt;Param name="StartOnCall" value="ScoobySnacks" /&gt;
    &lt;/Monitor&gt;
    &lt;Monitor class="PageHeap"&gt;
      &lt;Param name="Executable" value="notepad.exe"/&gt;
    &lt;/Monitor&gt;
  &lt;/Agent&gt;

  &lt;Test name="Default"&gt;
    &lt;Agent ref="LocalAgent" /&gt;
    &lt;StateModel ref="State"/&gt;

    &lt;Publisher class="File"&gt;
      &lt;Param name="FileName" value="fuzzfile.bin" /&gt;
    &lt;/Publisher&gt;
  &lt;/Test&gt;

&lt;/Peach&gt;</programlisting>
</example>
<example>
<title>Simple Network StateModel</title>
<simpara>In this state model, Peach sends and receives a set of packets from a TCP port.</simpara>
<simpara>This example requires Windows XP or newer with Windows Debugging Tools installed.
The sample executable <emphasis>CrashableServer.exe</emphasis> is included with the Peach distribution.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

	&lt;DataModel name="TestTemplate"&gt;
		&lt;String name="TheString" value="Hello World!" /&gt;
	&lt;/DataModel&gt;

	&lt;StateModel name="State" initialState="Initial"&gt;
		&lt;State name="Initial"&gt;

			&lt;Action type="output"&gt;
				&lt;DataModel ref="TestTemplate" /&gt;
			&lt;/Action&gt;

			&lt;Action type="output"&gt;
				&lt;DataModel ref="TestTemplate" /&gt;
			&lt;/Action&gt;

		&lt;/State&gt;
	&lt;/StateModel&gt;

	&lt;Agent name="LocalAgent"&gt;
		&lt;Monitor class="WindowsDebugger"&gt;
			&lt;Param name="Executable" value="CrashableServer.exe" /&gt;
			&lt;Param name="Arguments" value="127.0.0.1 4244" /&gt;
			&lt;!--&lt;Param name="WinDbgPath" value="C:\Program Files (x86)\Debugging Tools for Windows (x86)" /&gt;--&gt;
		&lt;/Monitor&gt;
 		&lt;Monitor class="PageHeap"&gt;
			&lt;Param name="Executable" value="CrashableServer.exe"/&gt;
			&lt;!--&lt;Param name="WinDbgPath" value="C:\Program Files (x86)\Debugging Tools for Windows (x86)" /&gt;--&gt;
		&lt;/Monitor&gt;
		&lt;Monitor class="NetworkCapture"&gt;
			&lt;Param name="Device" value="Local Area Connection"/&gt;
		&lt;/Monitor&gt;
	&lt;/Agent&gt;

	&lt;Test name="Default"&gt;
		&lt;Agent ref="LocalAgent" /&gt;

		&lt;StateModel ref="State"/&gt;
		&lt;Publisher class="Tcp"&gt;
			&lt;Param name="Host" value="127.0.0.1" /&gt;
			&lt;Param name="Port" value="4244" /&gt;
		&lt;/Publisher&gt;
	&lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
</example>
<example>
<title>Multiple State StateModel</title>
<simpara>The following StateModel utilizes multiple states to interact with the fuzzing target.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://peachfuzzer.com/2012/Peach ../peach.xsd"&gt;


	&lt;DataModel name="Question"&gt;
		&lt;String value="Select A,B, or C:" /&gt;
	&lt;/DataModel&gt;

	&lt;DataModel name="CResponse"&gt;
		&lt;String value="C is for Correct" /&gt;
		&lt;String value=" === " /&gt;
		&lt;String value="YOU WIN" /&gt;
	&lt;/DataModel&gt;

	&lt;DataModel name="BResponse"&gt;
		&lt;String value="B is for Bananas" /&gt;
		&lt;String value=":" /&gt;
		&lt;String value=" B - A - N - A - N - A - S" /&gt;
	&lt;/DataModel&gt;

	&lt;DataModel name="AResponse"&gt;
		&lt;String value="A is for Apples" /&gt;
		&lt;String value=". " /&gt;
		&lt;String value="Play Again" /&gt;
		&lt;String value="\n" /&gt;
	&lt;/DataModel&gt;

	&lt;DataModel name="Selection"&gt;
		&lt;String name="Letter" length="1"/&gt;
		&lt;Blob length="1" valueType="hex" value="0A" token="true" /&gt;
	&lt;/DataModel&gt;

	&lt;StateModel name="TheStateModel" initialState="InitialState"&gt;
		&lt;State name="InitialState"&gt;
			&lt;Action type="accept" /&gt;
			&lt;Action type="changeState" ref="AskState" /&gt;
		&lt;/State&gt;

		&lt;State name="AskState"&gt;
			&lt;Action type="output"&gt;
				&lt;DataModel ref="Question" /&gt;
			&lt;/Action&gt;

			&lt;Action type="input"&gt;
				&lt;DataModel name="TheirSelection" ref="Selection"/&gt;
			&lt;/Action&gt;

			&lt;Action type="changeState" ref="SelectedA" when="str(state.actions[1].dataModel.find('Letter').DefaultValue) == 'A'" /&gt;
			&lt;Action type="changeState" ref="SelectedB" when="str(state.actions[1].dataModel.find('Letter').DefaultValue) == 'B'"/&gt;
			&lt;Action type="changeState" ref="SelectedC" when="str(state.actions[1].dataModel.find('Letter').DefaultValue) == 'C'"/&gt;

		&lt;/State&gt;

		&lt;State name="SelectedA"&gt;
			&lt;Action type="output"&gt;
				&lt;DataModel ref="AResponse" /&gt;
			&lt;/Action&gt;
			&lt;Action type="changeState" ref="AskState" /&gt;
		&lt;/State&gt;

		&lt;State name="SelectedB"&gt;
			&lt;Action type="output"&gt;
				&lt;DataModel ref="BResponse" /&gt;
			&lt;/Action&gt;
		&lt;/State&gt;

		&lt;State name="SelectedC"&gt;
			&lt;Action type="output"&gt;
				&lt;DataModel ref="CResponse" /&gt;
			&lt;/Action&gt;
		&lt;/State&gt;

	&lt;/StateModel&gt;

	&lt;Test name="Default"&gt;
		&lt;StateModel ref="TheStateModel"/&gt;
		&lt;Publisher class="TcpListener"&gt;
			&lt;Param name="Interface" value="0.0.0.0" /&gt;
			&lt;Param name="Port" value="31337" /&gt;
			&lt;Param name="AcceptTimeout" value="10000" /&gt;
			&lt;Param name="Timeout" value="10000" /&gt;
		&lt;/Publisher&gt;

		&lt;Logger class="File" &gt;
			&lt;Param name="Path" value="logs"/&gt;
	    &lt;/Logger&gt;
	&lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
</example>
<example>
<title>Loop Using Iteration State Bag</title>
<simpara>This example uses the iteration state bag to simulate a "do while" or "do until" loop.</simpara>
<screen>&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

  &lt;DataModel name="TheDataModel"&gt;
    &lt;String value="Looping!\n" /&gt;
  &lt;/DataModel&gt;

  &lt;StateModel name="State" initialState="Initial"&gt;
    &lt;State name="Initial"&gt;

	  &lt;!-- Initialize our counter --&gt;
	  &lt;Action type="changeState" ref="Loop" onStart="context.iterationStateStore['count'] = 0" /&gt;

	&lt;/State&gt;

	&lt;State name="Loop"&gt;

	  &lt;!-- onStart will increment counter --&gt;
      &lt;Action type="output" onStart="context.iterationStateStore['count'] = context.iterationStateStore['count'] + 1"&gt;
        &lt;DataModel ref="TheDataModel" /&gt;
      &lt;/Action&gt;

	  &lt;!-- Loop until our counter is greater than 3 --&gt;
	  &lt;Action type="changeState" ref="Loop" when="context.iterationStateStore['count'] &amp;lt; 3" /&gt;

    &lt;/State&gt;

  &lt;/StateModel&gt;

  &lt;Test name="Default"&gt;
    &lt;StateModel ref="State"/&gt;

    &lt;Publisher class="Console"/&gt;
  &lt;/Test&gt;

&lt;/Peach&gt;</screen>
<screen>&gt; peach -1 --debug example.xml

[*] Test 'Default' starting with random seed 28742.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.ChangeState
Peach.Core.Dom.Action Changing to state: Loop
Peach.Core.Dom.StateModel Run(): Changing to state "Loop".
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher start()
Peach.Core.Publishers.ConsolePublisher open()
Peach.Core.Publishers.ConsolePublisher output(9 bytes)
Looping!                                                                     <co xml:id="CO44-1"/>
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.ChangeState
Peach.Core.Dom.Action Changing to state: Loop
Peach.Core.Dom.StateModel Run(): Changing to state "Loop".
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher output(9 bytes)
Looping!                                                                     <co xml:id="CO44-2"/>
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.ChangeState
Peach.Core.Dom.Action Changing to state: Loop
Peach.Core.Dom.StateModel Run(): Changing to state "Loop".
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher output(9 bytes)
Looping!                                                                     <co xml:id="CO44-3"/>
Peach.Core.Dom.Action Run: action 'Action_1' when returned false             <co xml:id="CO44-4"/>
Peach.Core.Publishers.ConsolePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.ConsolePublisher stop()

[*] Test 'Default' finished.</screen>
<calloutlist>
<callout arearefs="CO44-1">
<para>Output from iteration 1</para>
</callout>
<callout arearefs="CO44-2">
<para>Output from iteration 2</para>
</callout>
<callout arearefs="CO44-3">
<para>Output from iteration 3</para>
</callout>
<callout arearefs="CO44-4">
<para><emphasis>when</emphasis> expression returning false causing exit from loop</para>
</callout>
</calloutlist>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="State">
<title>State</title>
<simpara>State elements reside in <link linkend="StateModel">StateModels</link>. Each State element contains a logical Peach work unit.</simpara>
<simpara>Each <link linkend="StateModel">StateModel</link> must contain at least one State element. If you wish to model complex protocols or systems, use multiple State elements within your <link linkend="StateModel">StateModel</link>.</simpara>
<section xml:id="_syntax_72">
<title>Syntax</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;StateModel name="StateModel" initialState="InitialState"&gt;
	&lt;State name="InitialState"&gt;

		&lt;Action name="SendData1" type="output"&gt;
  			&lt;DataModel ref="MyDataModel1" /&gt;
		&lt;/Action&gt;

		&lt;Action name="SendData2" type="output"&gt;
  			&lt;DataModel ref="MyDataModel2" /&gt;
		&lt;/Action&gt;

	&lt;/State&gt;
&lt;/StateModel&gt;</programlisting>
<simpara>State elements contain one or more Action elements. Each Action element can perform tasks related to how the individual State element consolidates logic.</simpara>
<simpara>Within a State element, actions execute in sequence from top to bottom, in the same order they appear in the State definition.</simpara>
<simpara>State elements can occur linearly by chaining from one state to another. Yet,
Peach supports state changes that permit branching and looping among the State
elements. Branches and loops in the StateModel are common in fuzzing scenarios
where the input drives a response or a choice of responses.</simpara>
<itemizedlist>
<listitem>
<simpara>The <emphasis>intitialState</emphasis> attribute in the <link linkend="StateModel">StateModel</link> declaration determines the first State element of the <link linkend="StateModel">StateModel</link> to run.</simpara>
</listitem>
<listitem>
<simpara>Peach transitions into a new State after a <emphasis>changeState</emphasis> action.</simpara>
</listitem>
</itemizedlist>
<tip>
<simpara>If a set of Action elements always executes in the same order, place the set of actions in a single State element.</simpara>
</tip>
</section>
<section xml:id="_attributes_80">
<title>Attributes</title>
<simpara><emphasis>Required:</emphasis></simpara>
<variablelist>
<varlistentry>
<term><link linkend="name">name</link></term>
<listitem>
<simpara>The name of the State element.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term><link linkend="State_onStart">onStart</link></term>
<listitem>
<simpara>Scripting statement run prior to any actions.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="State_onComplete">onComplete</link></term>
<listitem>
<simpara>Scripting statement run after explicit actions.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_child_elements_42">
<title>Child Elements</title>
<variablelist>
<varlistentry>
<term><link linkend="Action">Action</link></term>
<listitem>
<simpara>One or more Actions are required.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_107">
<title>Examples</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

	&lt;DataModel name="Hello"&gt;
		&lt;String value="Hello\n" token="true"/&gt;
	&lt;/DataModel&gt;

	&lt;DataModel name="Question"&gt;
		&lt;String value="Pick a number between 1 and 5!" /&gt;
	&lt;/DataModel&gt;

	&lt;DataModel name="Wrong"&gt;
		&lt;String value="Wrong!" /&gt;
	&lt;/DataModel&gt;

	&lt;DataModel name="Close"&gt;
		&lt;String value="Very Close! Try Again!\n" /&gt;
	&lt;/DataModel&gt;

	&lt;DataModel name="Correct"&gt;
		&lt;String value="Correct!" /&gt;
	&lt;/DataModel&gt;

	&lt;DataModel name="Selection"&gt;
		&lt;Choice name="TheSelection"&gt;
			&lt;String name="one" value="1" length="1" token="true" /&gt;
			&lt;String name="two" value="2" length="1" token="true" /&gt;
			&lt;String name="three" value="3" length="1" token="true" /&gt;
			&lt;String name="rest" length="1" /&gt;
		&lt;/Choice&gt;
		&lt;String value="\n" token="true"/&gt;
	&lt;/DataModel&gt;

	&lt;StateModel name="TheStateModel" initialState="InitialState"&gt;
		&lt;State name="InitialState"&gt;
			&lt;Action name="AcceptConnection" type="accept" /&gt;

			&lt;Action name="HelloIn" type="input"&gt;
				&lt;DataModel ref="Hello"/&gt;
			&lt;/Action&gt;

			&lt;Action type="changeState" ref="AskState" /&gt;
		&lt;/State&gt;

		&lt;State name="AskState"&gt;
			&lt;Action name="AskTheQuestion" type="output"&gt;
				&lt;DataModel ref="Question" /&gt;
			&lt;/Action&gt;

			&lt;Action name="TheirAnswer" type="input"&gt;
				&lt;DataModel name="TheirSelection" ref="Selection"/&gt;
			&lt;/Action&gt;

			&lt;Action type="changeState" ref="TryAgain" when="state.actions[1].dataModel.find('one') is not None or State.actions[1].dataModel.find('three') is not None"/&gt;
			&lt;Action type="changeState" ref="Win" when="state.actions[1].dataModel.find('two') is not None"/&gt;
			&lt;Action type="changeState" ref="Lose" /&gt;

		&lt;/State&gt;

		&lt;State name="TryAgain"&gt;
			&lt;Action type="output"&gt;
				&lt;DataModel ref="Close" /&gt;
			&lt;/Action&gt;
			&lt;Action type="changeState" ref="AskState" /&gt;
		&lt;/State&gt;

		&lt;State name="Win"&gt;
			&lt;Action type="output"&gt;
				&lt;DataModel ref="Correct" /&gt;
			&lt;/Action&gt;
		&lt;/State&gt;

		&lt;State name="Lose"&gt;
			&lt;Action type="output"&gt;
				&lt;DataModel ref="Wrong" /&gt;
			&lt;/Action&gt;
		&lt;/State&gt;

	&lt;/StateModel&gt;

	&lt;Test name="Default"&gt;
		&lt;StateModel ref="TheStateModel"/&gt;
		&lt;Publisher class="TcpListener"&gt;
			&lt;Param name="Interface" value="0.0.0.0" /&gt;
			&lt;Param name="Port" value="31337" /&gt;
			&lt;Param name="AcceptTimeout" value="10000" /&gt;
			&lt;Param name="Timeout" value="10000" /&gt;
		&lt;/Publisher&gt;

		&lt;Strategy class="Random"/&gt;

		&lt;Logger class="File" &gt;
			&lt;Param name="Path" value="logs"/&gt;
	    &lt;/Logger&gt;
	&lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Action">
<title>Action</title>
<simpara>Action elements are part of the <link linkend="StateModel">StateModel</link>, and send commands to a <link linkend="Publisher">Publisher</link>. Within the StateModel, Action elements are child elements of <link linkend="State">State</link>.</simpara>
<simpara>Action elements set up and manage state in a fuzzing session. They issue commands to set up and control the Peach environment. For example, the <emphasis>open</emphasis> action initializes a listener by initiating a network connection or opening a file handle. And, the <emphasis>close</emphasis> action releases resources at the end of a fuzzing iteration.</simpara>
<simpara>Action elements provide control over state changes, movement of data between data models, and calling custom methods defined by agents. For example, the <emphasis>changeState</emphasis> action initiates a transition to a new state in the <emphasis>StateModel</emphasis>.</simpara>
<simpara>Additionally, Action elements issue directives to Publishers to do things such as read input, send output, and access a property.</simpara>
<simpara>Four Actions elements are implicit: <emphasis>start</emphasis>, <emphasis>stop</emphasis>, <emphasis>open</emphasis>, and <emphasis>close</emphasis>. They execute automatically and do not need to be declared in the StateModel.</simpara>
<itemizedlist>
<listitem>
<simpara>The <emphasis>start</emphasis> and <emphasis>stop</emphasis> actions occur at the start and end of a fuzzing session.</simpara>
</listitem>
<listitem>
<simpara>The <emphasis>open</emphasis> and <emphasis>close</emphasis> actions occur at the start and end of each iteration in a fuzzing session.</simpara>
</listitem>
</itemizedlist>
<simpara>Other actions require explicit declarations in order to execute.</simpara>
<sidebar>
<title>Default Order of Actions</title>
<simpara>The following is the default order in which Actions are performed when fuzzing:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara><emphasis>start</emphasis> - Implicit, once per session</simpara>
</listitem>
<listitem>
<simpara><emphasis>open</emphasis> - Implicit, once per iteration</simpara>
</listitem>
<listitem>
<simpara>Explicit actions (<emphasis>accept</emphasis>, <emphasis>input</emphasis>, <emphasis>output</emphasis>, <emphasis>web</emphasis>, etc.)</simpara>
</listitem>
<listitem>
<simpara><emphasis>close</emphasis> - Implicit, once per iteration</simpara>
</listitem>
<listitem>
<simpara><emphasis>stop</emphasis> - Implicit, once per session</simpara>
</listitem>
</orderedlist>
</sidebar>
<section xml:id="_syntax_73">
<title>Syntax</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;StateModel name="StateModel" initialState="InitialState"&gt;
	&lt;State name="InitialState"&gt;

		&lt;Action name="SendData" type="output"&gt;
  			&lt;DataModel ref="MyDataModel" /&gt;

  			&lt;!-- Optional data element --&gt;
  			&lt;Data name="load defaults" fileName="template.bin" /&gt;
		&lt;/Action&gt;

	&lt;/State&gt;
&lt;/StateModel&gt;</programlisting>
<simpara>Complicated StateModels that have counters (or other advanced operations) use Action parameters that execute scripts at certain times (such as before the Action starts or once it has completed).</simpara>
<simpara>Since Pits can contain multiple Publishers within a Test, many Actions have a parameter to declare the specific Publisher that carries out the command.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://peachfuzzer.com/2012/Peach ../peach.xsd"&gt;

	&lt;DataModel name="Ping"&gt;
		&lt;String value="PING" token="true"/&gt;
	&lt;/DataModel&gt;

	&lt;StateModel name="TheStateModel" initialState="InitialState"&gt;
		&lt;State name="InitialState"&gt;

			&lt;Action name="PingPacket" type="output" publisher="TheTCPPub"&gt;
				&lt;DataModel ref="Ping"/&gt;
			&lt;/Action&gt;

			&lt;Action name="PingUDPPacket" type="output" publisher="TheUDPPub"&gt;
				&lt;DataModel ref="Ping"/&gt;
			&lt;/Action&gt;

		&lt;/State&gt;
	&lt;/StateModel&gt;

	&lt;Test name="Default"&gt;
		&lt;StateModel ref="TheStateModel"/&gt;
		&lt;Publisher name="TheTCPPub" class="Tcp"&gt;
			&lt;Param name="Host" value="127.0.0.1" /&gt;
			&lt;Param name="Port" value="31337" /&gt;
		&lt;/Publisher&gt;
		&lt;Publisher name="TheUDPPub" class="Udp"&gt;
			&lt;Param name="Host" value="127.0.0.1" /&gt;
			&lt;Param name="Port" value="1337" /&gt;
		&lt;/Publisher&gt;

		&lt;Strategy class="Random"/&gt;

		&lt;Logger class="File" &gt;
			&lt;Param name="Path" value="logs"/&gt;
	    &lt;/Logger&gt;
	&lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
</section>
<section xml:id="_attributes_81">
<title>Attributes</title>
<simpara><emphasis>Required:</emphasis></simpara>
<variablelist>
<varlistentry>
<term><link linkend="name">name</link></term>
<listitem>
<simpara>Name of the action.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>type</term>
<listitem>
<simpara>Action type. The following enumeration summarizes the available action types. Detailed descriptions of the actions follow the child elements.</simpara>
<itemizedlist>
<listitem>
<simpara><link linkend="Action_accept">accept</link> - temporarily blocks execution.</simpara>
</listitem>
<listitem>
<simpara><link linkend="Action_call">call</link> - provides a method-calling metaphor.</simpara>
</listitem>
<listitem>
<simpara><link linkend="Action_changeState">changeState</link> - transitions from one state to another within the <link linkend="StateModel">StateModel</link>.</simpara>
</listitem>
<listitem>
<simpara><link linkend="Action_close">close</link> - causes the associated Publisher to close.</simpara>
</listitem>
<listitem>
<simpara><link linkend="Action_getProperty">getProperty</link> - provides the retrieval function of a property metaphor (get function).</simpara>
</listitem>
<listitem>
<simpara><link linkend="Action_input">input</link> - reads input data using the Publisher.</simpara>
</listitem>
<listitem>
<simpara><link linkend="Action_infrag">infrag</link> - perform one or more input actions to support protocol fragmentation.</simpara>
</listitem>
<listitem>
<simpara><link linkend="Action_open">open (or connect)</link> - causes the associated Publisher to open its resources.</simpara>
</listitem>
<listitem>
<simpara><link linkend="Action_output">output</link> - causes the associated Publisher to write data.</simpara>
</listitem>
<listitem>
<simpara><link linkend="Action_outfrag">outfrag</link> - perform one or more output actions to support protocol fragmentation.</simpara>
</listitem>
<listitem>
<simpara><link linkend="Action_setProperty">setProperty</link> - provides the output function of a property metaphor (set function) that modifies the value of the property.</simpara>
</listitem>
<listitem>
<simpara><link linkend="Action_slurp">slurp</link> - copies a value from a data element in one DataModel to a data element in another DataModel.</simpara>
</listitem>
<listitem>
<simpara><link linkend="Action_start">start</link> - causes a Publisher to perform its initialization tasks.</simpara>
</listitem>
<listitem>
<simpara><link linkend="Action_stop">stop</link> - causes a Publisher to perform final cleanup.</simpara>
</listitem>
<listitem>
<simpara><link linkend="Action_web">web</link> - sent web api/http requests via WebApi publisher.</simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Required Based on Type:</emphasis></simpara>
<variablelist>
<varlistentry>
<term><link linkend="xpath">valueXpath</link></term>
<listitem>
<simpara>Path to the source element defined using XPath notation when the Action type is <literal>slurp</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="xpath">setXpath</link></term>
<listitem>
<simpara>Path to the destination element defined using XPath notation when Action type is <literal>slurp</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="ref">ref</link></term>
<listitem>
<simpara>Reference of the state to change to when the Action type is <literal>changeState</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>property</term>
<listitem>
<simpara>Name of the property to get or set in the publisher when the Action type is <literal>setProperty</literal> or <literal>getProperty</literal>.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>publisher</term>
<listitem>
<simpara>Name of the Publisher, or <emphasis role="strong">Peach.Agent</emphasis>, to perform the action.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_onComplete">onComplete</link></term>
<listitem>
<simpara>Expression to evaluate when an action completes.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_onStart">onStart</link></term>
<listitem>
<simpara>Expression to evaluate at the start of an action.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_when">when</link></term>
<listitem>
<simpara>Perform the action if the provided expression evaluates to true.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_child_elements_43">
<title>Child Elements</title>
<variablelist>
<varlistentry>
<term><link linkend="DataModel">DataModel</link></term>
<listitem>
<simpara>DataModel to fuzz.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Data">Data</link></term>
<listitem>
<simpara>Set of initial data to crack into the DataModel before fuzzing.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Param">Param</link></term>
<listitem>
<simpara>Argument passed with the call. The argument will be fuzzed.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Result">Result</link></term>
<listitem>
<simpara>Output of the call Action. The result will be cracked into a DataModel.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
<section xml:id="Action_start">
<title>start</title>
<simpara>The <emphasis>start</emphasis> action causes a <link linkend="Publisher">Publisher</link> to perform the initialization that usually occurs at the start of a fuzzing session. <emphasis>start</emphasis> normally occurs once per fuzzing session, at the start of session. Another Action element, <link linkend="Action_stop"><emphasis>stop</emphasis></link>, also normally occurs once per fuzzing session, at the end of the session.</simpara>
<simpara><emphasis>start</emphasis> is an implicit Peach action that should not be declared in the <link linkend="StateModel">StateModel</link> unless a change is needed in the default behavior.</simpara>
<simpara><emphasis role="strong">NOTE:</emphasis> Including the <emphasis>start</emphasis> or <emphasis>stop</emphasis> action in the StateModel causes the action to run every iteration instead of once per session. This declaration should be avoided unless specifically required.</simpara>
<simpara>Not all <link linkend="Publisher">Publishers</link> make use of <emphasis>start</emphasis> and <emphasis>stop</emphasis>.</simpara>
<sidebar>
<title>Default Order of Actions</title>
<simpara>The following is the default Actions order when fuzzing:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara><emphasis>start</emphasis> - Implicit, once per session</simpara>
</listitem>
<listitem>
<simpara><emphasis>open</emphasis> - Implicit, once per iteration</simpara>
</listitem>
<listitem>
<simpara>Explicit actions (such as <emphasis>accept</emphasis>, <emphasis>input</emphasis> and <emphasis>output</emphasis>)</simpara>
</listitem>
<listitem>
<simpara><emphasis>close</emphasis> - Implicit, once per iteration</simpara>
</listitem>
<listitem>
<simpara><emphasis>stop</emphasis> - Implicit, once per session</simpara>
</listitem>
</orderedlist>
</sidebar>
<section xml:id="_syntax_74">
<title>Syntax</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;StateModel name="TheStateModel" initialState="InitialState"&gt;
	&lt;State name="InitialState"&gt;
		&lt;Action type="start" /&gt;
	&lt;/State&gt;
&lt;/StateModel&gt;</programlisting>
</section>
<section xml:id="_attributes_82">
<title>Attributes</title>
<simpara><emphasis>Required:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>type</term>
<listitem>
<simpara>Action type, must be set to "start"</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>name</term>
<listitem>
<simpara>Name used to identify the action</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>publisher</term>
<listitem>
<simpara>Name of the publisher to perform this action</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_when">when</link></term>
<listitem>
<simpara>Only perform the action if the provided expression evaluates to true</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_onStart">onStart</link></term>
<listitem>
<simpara>Expression to run at the start of an action.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_onComplete">onComplete</link></term>
<listitem>
<simpara>Expression to run at the completion of an action</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_child_elements_44">
<title>Child Elements</title>
<simpara>None.</simpara>
</section>
<section xml:id="_examples_108">
<title>Examples</title>
<example>
<title>Default behavior</title>
<simpara>The Example Pit shows normal (default) behavior.
Declarations for <emphasis>start</emphasis> and <emphasis>stop</emphasis> are unnecessary and not included.
The output follows the Pit definition.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

  &lt;DataModel name="Ping"&gt;
    &lt;String value="PING" token="true"/&gt;
  &lt;/DataModel&gt;

  &lt;StateModel name="TheStateModel" initialState="InitialState"&gt;
    &lt;State name="InitialState"&gt;

      &lt;!-- Start action is implicitly called once per session by Peach.
           It will cause the Publisher to perform any initialization. --&gt;

      &lt;!-- Open action is implicitly called on every iteration by Peach.
           It will cause the Publisher to open a connection to the remote host. --&gt;

      &lt;!-- This action is called on every iteration. It will output data from
           the data model "Ping" using our Publisher. --&gt;
      &lt;Action type="output"&gt;
        &lt;DataModel ref="Ping"/&gt;
      &lt;/Action&gt;

      &lt;!-- Close action is implicitly called on every iteration by Peach.
           It will cause the Publisher to close its connection to the remote
           host if it's still open. --&gt;

      &lt;!-- This action is implicitly called once per fuzzing session. It will perform any
           final clean up actions to fully stop the Publisher. --&gt;

    &lt;/State&gt;
  &lt;/StateModel&gt;

  &lt;Test name="Default"&gt;
    &lt;StateModel ref="TheStateModel"/&gt;
    &lt;Publisher class="Tcp"&gt;
      &lt;Param name="Host" value="127.0.0.1" /&gt;
      &lt;Param name="Port" value="31337" /&gt;
    &lt;/Publisher&gt;

    &lt;Logger class="File" &gt;
      &lt;Param name="Path" value="logs"/&gt;
    &lt;/Logger&gt;
  &lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Output showing the default behavior of the sample pit where the <emphasis>start</emphasis> action is called once at the beginning of the fuzzing session and the <emphasis>stop</emphasis> action is called once at the end of the fuzzing session.</simpara>
<screen>&gt; peach --range 1,3 --seed 51405 example.xml

[[ Peach Professional v3.0.0
[[ Copyright (c) Peach Fuzzer LLC
Peach.Core.Engine runTest: context.config.range == true, start: 1, stop: 3

[*] Test 'Default' starting with random seed 51405.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.TcpClientPublisher start()                             <co xml:id="CO45-1"/>
Peach.Core.Publishers.TcpClientPublisher open()
Peach.Core.Publishers.TcpClientPublisher output(4 bytes)
Peach.Core.Publishers.TcpClientPublisher

00000000   50 49 4E 47                                        PING

Peach.Core.Publishers.TcpClientPublisher close()
Peach.Core.Publishers.TcpClientPublisher Shutting down connection to 127.0.0.1:31337
Peach.Core.Publishers.TcpClientPublisher Read 0 bytes from 127.0.0.1:31337, closing client connection.
Peach.Core.Publishers.TcpClientPublisher Closing connection to 127.0.0.1:31337

[1,3,0:00:01.614] Performing iteration
[*] Fuzzing: Ping.DataElement_0
[*] Mutator: DataElementSwapNearNodesMutator
Peach.Core.MutationStrategies.RandomStrategy Action_Starting: Fuzzing: Ping.DataElement_0
Peach.Core.MutationStrategies.RandomStrategy Action_Starting: Mutator: DataElementSwapNearNodesMutator
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.TcpClientPublisher open()
Peach.Core.Publishers.TcpClientPublisher output(4 bytes)
Peach.Core.Publishers.TcpClientPublisher

00000000   50 49 4E 47                                        PING

Peach.Core.Publishers.TcpClientPublisher close()
Peach.Core.Publishers.TcpClientPublisher Shutting down connection to 127.0.0.1:31337
Peach.Core.Publishers.TcpClientPublisher Read 0 bytes from 127.0.0.1:31337, closing client connection.
Peach.Core.Publishers.TcpClientPublisher Closing connection to 127.0.0.1:31337

[2,3,0:00:03.438] Performing iteration
[*] Fuzzing: Ping.DataElement_0
[*] Mutator: UnicodeUtf8ThreeCharMutator
Peach.Core.MutationStrategies.RandomStrategy Action_Starting: Fuzzing: Ping.DataElement_0
Peach.Core.MutationStrategies.RandomStrategy Action_Starting: Mutator: UnicodeUtf8ThreeCharMutator
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.TcpClientPublisher open()
Peach.Core.Publishers.TcpClientPublisher output(522 bytes)
Peach.Core.Publishers.TcpClientPublisher

00000000   EF 83 B0 EF 83 B0 EF 83  B0 EF 83 B0 EF 83 B0 EF   ................
00000010   83 B0 EF 83 B0 EF 83 B0  EF 83 B0 EF 83 B0 EF 83   ................
00000020   B0 EF 83 B0 EF 83 B0 EF  83 B0 EF 83 B0 EF 83 B0   ................
00000030   EF 83 B0 EF 83 B0 EF 83  B0 EF 83 B0 EF 83 B0 EF   ................
00000040   83 B0 EF 83 B0 EF 83 B0  EF 83 B0 EF 83 B0 EF 83   ................
00000050   B0 EF 83 B0 EF 83 B0 EF  83 B0 EF 83 B0 EF 83 B0   ................
00000060   EF 83 B0 EF 83 B0 EF 83  B0 EF 83 B0 EF 83 B0 EF   ................
00000070   83 B0 EF 83 B0 EF 83 B0  EF 83 B0 EF 83 B0 EF 83   ................
00000080   B0 EF 83 B0 EF 83 B0 EF  83 B0 EF 83 B0 EF 83 B0   ................
00000090   EF 83 B0 EF 83 B0 EF 83  B0 EF 83 B0 EF 83 B0 EF   ................
000000A0   83 B0 EF 83 B0 EF 83 B0  EF 83 B0 EF 83 B0 EF 83   ................
000000B0   B0 EF 83 B0 EF 83 B0 EF  83 B0 EF 83 B0 EF 83 B0   ................
000000C0   EF 83 B0 EF 83 B0 EF 83  B0 EF 83 B0 EF 83 B0 EF   ................
000000D0   83 B0 EF 83 B0 EF 83 B0  EF 83 B0 EF 83 B0 EF 83   ................
000000E0   B0 EF 83 B0 EF 83 B0 EF  83 B0 EF 83 B0 EF 83 B0   ................
000000F0   EF 83 B0 EF 83 B0 EF 83  B0 EF 83 B0 EF 83 B0 EF   ................
00000100   83 B0 EF 83 B0 EF 83 B0  EF 83 B0 EF 83 B0 EF 83   ................
00000110   B0 EF 83 B0 EF 83 B0 EF  83 B0 EF 83 B0 EF 83 B0   ................
00000120   EF 83 B0 EF 83 B0 EF 83  B0 EF 83 B0 EF 83 B0 EF   ................
00000130   83 B0 EF 83 B0 EF 83 B0  EF 83 B0 EF 83 B0 EF 83   ................
00000140   B0 EF 83 B0 EF 83 B0 EF  83 B0 EF 83 B0 EF 83 B0   ................
00000150   EF 83 B0 EF 83 B0 EF 83  B0 EF 83 B0 EF 83 B0 EF   ................
00000160   83 B0 EF 83 B0 EF 83 B0  EF 83 B0 EF 83 B0 EF 83   ................
00000170   B0 EF 83 B0 EF 83 B0 EF  83 B0 EF 83 B0 EF 83 B0   ................
00000180   EF 83 B0 EF 83 B0 EF 83  B0 EF 83 B0 EF 83 B0 EF   ................
00000190   83 B0 EF 83 B0 EF 83 B0  EF 83 B0 EF 83 B0 EF 83   ................
000001A0   B0 EF 83 B0 EF 83 B0 EF  83 B0 EF 83 B0 EF 83 B0   ................
000001B0   EF 83 B0 EF 83 B0 EF 83  B0 EF 83 B0 EF 83 B0 EF   ................
000001C0   83 B0 EF 83 B0 EF 83 B0  EF 83 B0 EF 83 B0 EF 83   ................
000001D0   B0 EF 83 B0 EF 83 B0 EF  83 B0 EF 83 B0 EF 83 B0   ................
000001E0   EF 83 B0 EF 83 B0 EF 83  B0 EF 83 B0 EF 83 B0 EF   ................
000001F0   83 B0 EF 83 B0 EF 83 B0  EF 83 B0 EF 83 B0 EF 83   ................
00000200   B0 EF 83 B0 EF 83 B0 EF  83 B0                     ..........

Peach.Core.Publishers.TcpClientPublisher close()
Peach.Core.Publishers.TcpClientPublisher Shutting down connection to 127.0.0.1:31337
Peach.Core.Publishers.TcpClientPublisher Read 0 bytes from 127.0.0.1:31337, closing client connection.
Peach.Core.Publishers.TcpClientPublisher Closing connection to 127.0.0.1:31337

[3,3,0:00:01.454] Performing iteration
[*] Fuzzing: Ping.DataElement_0
[*] Mutator: UnicodeUtf8ThreeCharMutator
Peach.Core.MutationStrategies.RandomStrategy Action_Starting: Fuzzing: Ping.DataElement_0
Peach.Core.MutationStrategies.RandomStrategy Action_Starting: Mutator: UnicodeUtf8ThreeCharMutator
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.TcpClientPublisher open()
Peach.Core.Publishers.TcpClientPublisher output(1968 bytes)
Peach.Core.Publishers.TcpClientPublisher

00000000   EF 83 B0 EF 83 B0 EF 83  B0 EF 83 B0 EF 83 B0 EF   ................
00000010   83 B0 EF 83 B0 EF 83 B0  EF 83 B0 EF 83 B0 EF 83   ................
00000020   B0 EF 83 B0 EF 83 B0 EF  83 B0 EF 83 B0 EF 83 B0   ................
00000030   EF 83 B0 EF 83 B0 EF 83  B0 EF 83 B0 EF 83 B0 EF   ................
00000040   83 B0 EF 83 B0 EF 83 B0  EF 83 B0 EF 83 B0 EF 83   ................
00000050   B0 EF 83 B0 EF 83 B0 EF  83 B0 EF 83 B0 EF 83 B0   ................
00000060   EF 83 B0 EF 83 B0 EF 83  B0 EF 83 B0 EF 83 B0 EF   ................
00000070   83 B0 EF 83 B0 EF 83 B0  EF 83 B0 EF 83 B0 EF 83   ................
00000080   B0 EF 83 B0 EF 83 B0 EF  83 B0 EF 83 B0 EF 83 B0   ................
....

Peach.Core.Publishers.TcpClientPublisher close()
Peach.Core.Publishers.TcpClientPublisher Shutting down connection to 127.0.0.1:31337
Peach.Core.Publishers.TcpClientPublisher Read 0 bytes from 127.0.0.1:31337, closing client connection.
Peach.Core.Publishers.TcpClientPublisher Closing connection to 127.0.0.1:31337
Peach.Core.Publishers.TcpClientPublisher stop()                              <co xml:id="CO45-2"/>

[*] Test 'Default' finished.</screen>
<calloutlist>
<callout arearefs="CO45-1">
<para><emphasis>Start</emphasis> action at beginning of fuzzing session</para>
</callout>
<callout arearefs="CO45-2">
<para><emphasis>Stop</emphasis> action at end of fuzzing session</para>
</callout>
</calloutlist>
</example>
<example>
<title>Explicit calling of start</title>
<simpara>The Example Pit shows explicit declaration of the <emphasis>start</emphasis> and <emphasis>stop</emphasis> actions.
The <emphasis>start</emphasis> and <emphasis>stop</emphasis> declarations cause them to be called every iteration, as seen in the output listing.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

  &lt;DataModel name="Ping"&gt;
    &lt;String value="PING" token="true"/&gt;
  &lt;/DataModel&gt;

  &lt;StateModel name="TheStateModel" initialState="InitialState"&gt;
    &lt;State name="InitialState"&gt;

      &lt;!-- This action is called on every iteration. It will cause
           the Tcp Publisher to perform any initialization. --&gt;
      &lt;Action type="start" /&gt;

      &lt;!-- This action is called on every iteration. It will cause the
           Tcp Publisher to open a connection to the remote host. --&gt;
      &lt;Action type="open" /&gt;

      &lt;!-- This action is called on every iteration. It will output data from
           the data model "Ping" using our Publisher. --&gt;
      &lt;Action type="output"&gt;
        &lt;DataModel ref="Ping"/&gt;
      &lt;/Action&gt;

      &lt;!-- This action is called on every iteration. It will cause the
           Tcp Publisher to close its connection to the remote host if it's
           still open. --&gt;
      &lt;Action type="close" /&gt;

      &lt;!-- This action is called on every iteration. It will perform any
           final clean up actions to fully stop the Publisher. --&gt;
      &lt;Action type="stop" /&gt;

    &lt;/State&gt;
  &lt;/StateModel&gt;

  &lt;Test name="Default"&gt;
    &lt;StateModel ref="TheStateModel"/&gt;
    &lt;Publisher class="Tcp"&gt;
      &lt;Param name="Host" value="127.0.0.1" /&gt;
      &lt;Param name="Port" value="31337" /&gt;
    &lt;/Publisher&gt;

    &lt;Logger class="File" &gt;
      &lt;Param name="Path" value="logs"/&gt;
    &lt;/Logger&gt;
  &lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>In the following output, the <emphasis>start</emphasis> action executes at the beginning of every iteration and the <emphasis>stop</emphasis> action follows at the end of every iteration.</simpara>
<screen>&gt; peach --range 1,3 --seed 51405 example.xml

[[ Peach Professional v3.0.0
[[ Copyright (c) Peach Fuzzer LLC
Peach.Core.Engine runTest: context.config.range == true, start: 1, stop: 3

[*] Test 'Default' starting with random seed 51405.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Start
Peach.Core.Publishers.TcpClientPublisher start()                             <co xml:id="CO46-1"/>
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Open
Peach.Core.Publishers.TcpClientPublisher open()
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.TcpClientPublisher output(4 bytes)
Peach.Core.Publishers.TcpClientPublisher

00000000   50 49 4E 47                                        PING

Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Close
Peach.Core.Publishers.TcpClientPublisher close()
Peach.Core.Publishers.TcpClientPublisher Shutting down connection to 127.0.0.1:31337
Peach.Core.Publishers.TcpClientPublisher Read 0 bytes from 127.0.0.1:31337, closing client connection.
Peach.Core.Publishers.TcpClientPublisher Closing connection to 127.0.0.1:31337
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Stop
Peach.Core.Publishers.TcpClientPublisher stop()                              <co xml:id="CO46-2"/>

[1,3,0:00:04.512] Performing iteration
Peach.Core.Dom.Action ActionType.Start
Peach.Core.Publishers.TcpClientPublisher start()                             <co xml:id="CO46-3"/>
Peach.Core.Dom.Action ActionType.Open
Peach.Core.Publishers.TcpClientPublisher open()
[*] Fuzzing: Ping.DataElement_0
[*] Mutator: DataElementSwapNearNodesMutator
Peach.Core.MutationStrategies.RandomStrategy Action_Starting: Fuzzing: Ping.DataElement_0
Peach.Core.MutationStrategies.RandomStrategy Action_Starting: Mutator: DataElementSwapNearNodesMutator
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.TcpClientPublisher output(4 bytes)
Peach.Core.Publishers.TcpClientPublisher

00000000   50 49 4E 47                                        PING

Peach.Core.Dom.Action ActionType.Close
Peach.Core.Publishers.TcpClientPublisher close()
Peach.Core.Publishers.TcpClientPublisher Shutting down connection to 127.0.0.1:31337
Peach.Core.Publishers.TcpClientPublisher Read 0 bytes from 127.0.0.1:31337, closing client connection.
Peach.Core.Publishers.TcpClientPublisher Closing connection to 127.0.0.1:31337
Peach.Core.Dom.Action ActionType.Stop
Peach.Core.Publishers.TcpClientPublisher stop()                              <co xml:id="CO46-4"/>

[2,3,0:00:05.246] Performing iteration
Peach.Core.Dom.Action ActionType.Start
Peach.Core.Publishers.TcpClientPublisher start()                             <co xml:id="CO46-5"/>
Peach.Core.Dom.Action ActionType.Open
Peach.Core.Publishers.TcpClientPublisher open()
[*] Fuzzing: Ping.DataElement_0
[*] Mutator: UnicodeUtf8ThreeCharMutator
Peach.Core.MutationStrategies.RandomStrategy Action_Starting: Fuzzing: Ping.DataElement_0
Peach.Core.MutationStrategies.RandomStrategy Action_Starting: Mutator: UnicodeUtf8ThreeCharMutator
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.TcpClientPublisher output(522 bytes)
Peach.Core.Publishers.TcpClientPublisher

00000000   EF 83 B0 EF 83 B0 EF 83  B0 EF 83 B0 EF 83 B0 EF   ................
00000010   83 B0 EF 83 B0 EF 83 B0  EF 83 B0 EF 83 B0 EF 83   ................
00000020   B0 EF 83 B0 EF 83 B0 EF  83 B0 EF 83 B0 EF 83 B0   ................
00000030   EF 83 B0 EF 83 B0 EF 83  B0 EF 83 B0 EF 83 B0 EF   ................
00000040   83 B0 EF 83 B0 EF 83 B0  EF 83 B0 EF 83 B0 EF 83   ................
00000050   B0 EF 83 B0 EF 83 B0 EF  83 B0 EF 83 B0 EF 83 B0   ................
00000060   EF 83 B0 EF 83 B0 EF 83  B0 EF 83 B0 EF 83 B0 EF   ................
00000070   83 B0 EF 83 B0 EF 83 B0  EF 83 B0 EF 83 B0 EF 83   ................
00000080   B0 EF 83 B0 EF 83 B0 EF  83 B0 EF 83 B0 EF 83 B0   ................
00000090   EF 83 B0 EF 83 B0 EF 83  B0 EF 83 B0 EF 83 B0 EF   ................
000000A0   83 B0 EF 83 B0 EF 83 B0  EF 83 B0 EF 83 B0 EF 83   ................
000000B0   B0 EF 83 B0 EF 83 B0 EF  83 B0 EF 83 B0 EF 83 B0   ................
000000C0   EF 83 B0 EF 83 B0 EF 83  B0 EF 83 B0 EF 83 B0 EF   ................
000000D0   83 B0 EF 83 B0 EF 83 B0  EF 83 B0 EF 83 B0 EF 83   ................
000000E0   B0 EF 83 B0 EF 83 B0 EF  83 B0 EF 83 B0 EF 83 B0   ................
000000F0   EF 83 B0 EF 83 B0 EF 83  B0 EF 83 B0 EF 83 B0 EF   ................
00000100   83 B0 EF 83 B0 EF 83 B0  EF 83 B0 EF 83 B0 EF 83   ................
00000110   B0 EF 83 B0 EF 83 B0 EF  83 B0 EF 83 B0 EF 83 B0   ................
00000120   EF 83 B0 EF 83 B0 EF 83  B0 EF 83 B0 EF 83 B0 EF   ................
00000130   83 B0 EF 83 B0 EF 83 B0  EF 83 B0 EF 83 B0 EF 83   ................
00000140   B0 EF 83 B0 EF 83 B0 EF  83 B0 EF 83 B0 EF 83 B0   ................
00000150   EF 83 B0 EF 83 B0 EF 83  B0 EF 83 B0 EF 83 B0 EF   ................
00000160   83 B0 EF 83 B0 EF 83 B0  EF 83 B0 EF 83 B0 EF 83   ................
00000170   B0 EF 83 B0 EF 83 B0 EF  83 B0 EF 83 B0 EF 83 B0   ................
00000180   EF 83 B0 EF 83 B0 EF 83  B0 EF 83 B0 EF 83 B0 EF   ................
00000190   83 B0 EF 83 B0 EF 83 B0  EF 83 B0 EF 83 B0 EF 83   ................
000001A0   B0 EF 83 B0 EF 83 B0 EF  83 B0 EF 83 B0 EF 83 B0   ................
000001B0   EF 83 B0 EF 83 B0 EF 83  B0 EF 83 B0 EF 83 B0 EF   ................
000001C0   83 B0 EF 83 B0 EF 83 B0  EF 83 B0 EF 83 B0 EF 83   ................
000001D0   B0 EF 83 B0 EF 83 B0 EF  83 B0 EF 83 B0 EF 83 B0   ................
000001E0   EF 83 B0 EF 83 B0 EF 83  B0 EF 83 B0 EF 83 B0 EF   ................
000001F0   83 B0 EF 83 B0 EF 83 B0  EF 83 B0 EF 83 B0 EF 83   ................
00000200   B0 EF 83 B0 EF 83 B0 EF  83 B0                     ..........

Peach.Core.Dom.Action ActionType.Close
Peach.Core.Publishers.TcpClientPublisher close()
Peach.Core.Publishers.TcpClientPublisher Shutting down connection to 127.0.0.1:31337
Peach.Core.Publishers.TcpClientPublisher Read 0 bytes from 127.0.0.1:31337, closing client connection.
Peach.Core.Publishers.TcpClientPublisher Closing connection to 127.0.0.1:31337
Peach.Core.Dom.Action ActionType.Stop
Peach.Core.Publishers.TcpClientPublisher stop()                              <co xml:id="CO46-6"/>

[3,3,0:00:01.705] Performing iteration
Peach.Core.Dom.Action ActionType.Start
Peach.Core.Publishers.TcpClientPublisher start()                             <co xml:id="CO46-7"/>
Peach.Core.Dom.Action ActionType.Open
Peach.Core.Publishers.TcpClientPublisher open()
[*] Fuzzing: Ping.DataElement_0
[*] Mutator: UnicodeUtf8ThreeCharMutator
Peach.Core.MutationStrategies.RandomStrategy Action_Starting: Fuzzing: Ping.DataElement_0
Peach.Core.MutationStrategies.RandomStrategy Action_Starting: Mutator: UnicodeUtf8ThreeCharMutator
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.TcpClientPublisher output(1968 bytes)
Peach.Core.Publishers.TcpClientPublisher


00000000   EF 83 B0 EF 83 B0 EF 83  B0 EF 83 B0 EF 83 B0 EF   ................
00000010   83 B0 EF 83 B0 EF 83 B0  EF 83 B0 EF 83 B0 EF 83   ................
00000020   B0 EF 83 B0 EF 83 B0 EF  83 B0 EF 83 B0 EF 83 B0   ................
00000030   EF 83 B0 EF 83 B0 EF 83  B0 EF 83 B0 EF 83 B0 EF   ................
00000040   83 B0 EF 83 B0 EF 83 B0  EF 83 B0 EF 83 B0 EF 83   ................
00000050   B0 EF 83 B0 EF 83 B0 EF  83 B0 EF 83 B0 EF 83 B0   ................
00000060   EF 83 B0 EF 83 B0 EF 83  B0 EF 83 B0 EF 83 B0 EF   ................
00000070   83 B0 EF 83 B0 EF 83 B0  EF 83 B0 EF 83 B0 EF 83   ................
00000080   B0 EF 83 B0 EF 83 B0 EF  83 B0 EF 83 B0 EF 83 B0   ................
....



Peach.Core.Dom.Action ActionType.Close
Peach.Core.Publishers.TcpClientPublisher close()
Peach.Core.Publishers.TcpClientPublisher Shutting down connection to 127.0.0.1:31337
Peach.Core.Publishers.TcpClientPublisher Read 0 bytes from 127.0.0.1:31337, closing client connection.
Peach.Core.Publishers.TcpClientPublisher Closing connection to 127.0.0.1:31337
Peach.Core.Dom.Action ActionType.Stop
Peach.Core.Publishers.TcpClientPublisher stop()                              <co xml:id="CO46-8"/></screen>
<calloutlist>
<callout arearefs="CO46-1">
<para><emphasis>Start</emphasis> action at beginning of iteration</para>
</callout>
<callout arearefs="CO46-2">
<para><emphasis>Stop</emphasis> action at end of iteration</para>
</callout>
<callout arearefs="CO46-3">
<para><emphasis>Start</emphasis> action at beginning of iteration</para>
</callout>
<callout arearefs="CO46-4">
<para><emphasis>Stop</emphasis> action at end of iteration</para>
</callout>
<callout arearefs="CO46-5">
<para><emphasis>Start</emphasis> action at beginning of iteration</para>
</callout>
<callout arearefs="CO46-6">
<para><emphasis>Stop</emphasis> action at end of iteration</para>
</callout>
<callout arearefs="CO46-7">
<para><emphasis>Start</emphasis> action at beginning of iteration</para>
</callout>
<callout arearefs="CO46-8">
<para><emphasis>Stop</emphasis> action at end of iteration</para>
</callout>
</calloutlist>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Action_stop">
<title>stop</title>
<simpara>The <emphasis>stop</emphasis> action causes a <link linkend="Publisher">Publisher</link> to perform the final cleanup that usually occurs once, at the end of a fuzzing session. Another Action element, <link linkend="Action_start"><emphasis>start</emphasis></link>, also normally occurs once per fuzzing session, at the start of the session.</simpara>
<simpara><emphasis>stop</emphasis> is an implicit Peach action that should not be declared in the <link linkend="StateModel">StateModel</link> unless a change is needed in the default behavior.</simpara>
<simpara><emphasis role="strong">NOTE:</emphasis> Including the <emphasis>stop</emphasis> or <emphasis>start</emphasis> action in the StateModel causes the action to run every iteration instead of once per session. This declaration should be avoided unless specifically required.</simpara>
<simpara>Not all <link linkend="Publisher">Publishers</link> make use of stop and start.</simpara>
<sidebar>
<title>Default Order of Actions</title>
<simpara>The following is the default Actions order when fuzzing:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>start - Implicit, once per session</simpara>
</listitem>
<listitem>
<simpara>open - Implicit, once per iteration</simpara>
</listitem>
<listitem>
<simpara>Explicit actions (such as accept, input and output)</simpara>
</listitem>
<listitem>
<simpara>close - Implicit, once per iteration</simpara>
</listitem>
<listitem>
<simpara>stop - Implicit, once per session</simpara>
</listitem>
</orderedlist>
</sidebar>
<section xml:id="_syntax_75">
<title>Syntax</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;StateModel name="TheStateModel" initialState="InitialState"&gt;
	&lt;State name="InitialState"&gt;

		&lt;Action type="stop" /&gt;

	&lt;/State&gt;
&lt;/StateModel&gt;</programlisting>
</section>
<section xml:id="_attributes_83">
<title>Attributes</title>
<simpara><emphasis>Required:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>type</term>
<listitem>
<simpara>Action type, must be set to "stop"</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>name</term>
<listitem>
<simpara>Name used to identify the action</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>publisher</term>
<listitem>
<simpara>Name of the publisher that this action should be called on</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_when">when</link></term>
<listitem>
<simpara>Only perform action if the expression provided evaluates to true</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_onStart">onStart</link></term>
<listitem>
<simpara>Expression to run on start of an action.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_onComplete">onComplete</link></term>
<listitem>
<simpara>Expression to run on completion of an action</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_child_elements_45">
<title>Child Elements</title>
<simpara>None.</simpara>
</section>
<section xml:id="_examples_109">
<title>Examples</title>
<example>
<title>Default behavior</title>
<simpara>Example Pit shows normal (default) behavior.
Note that the <emphasis>stop</emphasis> and <emphasis>start</emphasis> actions are not declared.
The output follows the example pit.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

  &lt;DataModel name="Ping"&gt;
    &lt;String value="PING" token="true"/&gt;
  &lt;/DataModel&gt;

  &lt;StateModel name="TheStateModel" initialState="InitialState"&gt;
    &lt;State name="InitialState"&gt;

      &lt;!-- Start action is implicitly called once per session by Peach.
           It will cause the Publisher to perform any initialization. --&gt;

      &lt;!-- Open action is implicitly called on every iteration by Peach.
           It will cause the Publisher to open a connection to the remote host. --&gt;

      &lt;!-- This action is called on every iteration. It will output data from
           the data model "Ping" using our Publisher. --&gt;
      &lt;Action type="output"&gt;
        &lt;DataModel ref="Ping"/&gt;
      &lt;/Action&gt;

      &lt;!-- Close action is implicitly called on every iteration by Peach.
           It will cause the Publisher to close its connection to the remote
           host if it's still open. --&gt;

      &lt;!-- This action is implicitly called once per fuzzing session. It will perform any
           final clean up actions to fully stop the Publisher. --&gt;

    &lt;/State&gt;
  &lt;/StateModel&gt;

  &lt;Test name="Default"&gt;
    &lt;StateModel ref="TheStateModel"/&gt;
    &lt;Publisher class="Tcp"&gt;
      &lt;Param name="Host" value="127.0.0.1" /&gt;
      &lt;Param name="Port" value="31337" /&gt;
    &lt;/Publisher&gt;

    &lt;Logger class="File" &gt;
      &lt;Param name="Path" value="logs"/&gt;
    &lt;/Logger&gt;
  &lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Output showing the default behavior of the sample pit with implicit usage for <emphasis>start</emphasis> and <emphasis>stop</emphasis>. The <emphasis>start</emphasis> action is called once at the beginning of the fuzzing session and the <emphasis>stop</emphasis> action is called once at the end of the fuzzing session.</simpara>
<screen>&gt; peach --range 1,3 --seed 51405 example.xml

[[ Peach Professional v3.0.0
[[ Copyright (c) Peach Fuzzer LLC
Peach.Core.Engine runTest: context.config.range == true, start: 1, stop: 3

[*] Test 'Default' starting with random seed 51405.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.TcpClientPublisher start()                             <co xml:id="CO47-1"/>
Peach.Core.Publishers.TcpClientPublisher open()
Peach.Core.Publishers.TcpClientPublisher output(4 bytes)
Peach.Core.Publishers.TcpClientPublisher

00000000   50 49 4E 47                                        PING

Peach.Core.Publishers.TcpClientPublisher close()
Peach.Core.Publishers.TcpClientPublisher Shutting down connection to 127.0.0.1:31337
Peach.Core.Publishers.TcpClientPublisher Read 0 bytes from 127.0.0.1:31337, closing client connection.
Peach.Core.Publishers.TcpClientPublisher Closing connection to 127.0.0.1:31337

[1,3,0:00:01.614] Performing iteration
[*] Fuzzing: Ping.DataElement_0
[*] Mutator: DataElementSwapNearNodesMutator
Peach.Core.MutationStrategies.RandomStrategy Action_Starting: Fuzzing: Ping.DataElement_0
Peach.Core.MutationStrategies.RandomStrategy Action_Starting: Mutator: DataElementSwapNearNodesMutator
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.TcpClientPublisher open()
Peach.Core.Publishers.TcpClientPublisher output(4 bytes)
Peach.Core.Publishers.TcpClientPublisher

00000000   50 49 4E 47                                        PING

Peach.Core.Publishers.TcpClientPublisher close()
Peach.Core.Publishers.TcpClientPublisher Shutting down connection to 127.0.0.1:31337
Peach.Core.Publishers.TcpClientPublisher Read 0 bytes from 127.0.0.1:31337, closing client connection.
Peach.Core.Publishers.TcpClientPublisher Closing connection to 127.0.0.1:31337

[2,3,0:00:03.438] Performing iteration
[*] Fuzzing: Ping.DataElement_0
[*] Mutator: UnicodeUtf8ThreeCharMutator
Peach.Core.MutationStrategies.RandomStrategy Action_Starting: Fuzzing: Ping.DataElement_0
Peach.Core.MutationStrategies.RandomStrategy Action_Starting: Mutator: UnicodeUtf8ThreeCharMutator
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.TcpClientPublisher open()
Peach.Core.Publishers.TcpClientPublisher output(522 bytes)
Peach.Core.Publishers.TcpClientPublisher

00000000   EF 83 B0 EF 83 B0 EF 83  B0 EF 83 B0 EF 83 B0 EF   ................
00000010   83 B0 EF 83 B0 EF 83 B0  EF 83 B0 EF 83 B0 EF 83   ................
00000020   B0 EF 83 B0 EF 83 B0 EF  83 B0 EF 83 B0 EF 83 B0   ................
00000030   EF 83 B0 EF 83 B0 EF 83  B0 EF 83 B0 EF 83 B0 EF   ................
00000040   83 B0 EF 83 B0 EF 83 B0  EF 83 B0 EF 83 B0 EF 83   ................
00000050   B0 EF 83 B0 EF 83 B0 EF  83 B0 EF 83 B0 EF 83 B0   ................
00000060   EF 83 B0 EF 83 B0 EF 83  B0 EF 83 B0 EF 83 B0 EF   ................
00000070   83 B0 EF 83 B0 EF 83 B0  EF 83 B0 EF 83 B0 EF 83   ................
00000080   B0 EF 83 B0 EF 83 B0 EF  83 B0 EF 83 B0 EF 83 B0   ................
00000090   EF 83 B0 EF 83 B0 EF 83  B0 EF 83 B0 EF 83 B0 EF   ................
000000A0   83 B0 EF 83 B0 EF 83 B0  EF 83 B0 EF 83 B0 EF 83   ................
000000B0   B0 EF 83 B0 EF 83 B0 EF  83 B0 EF 83 B0 EF 83 B0   ................
000000C0   EF 83 B0 EF 83 B0 EF 83  B0 EF 83 B0 EF 83 B0 EF   ................
000000D0   83 B0 EF 83 B0 EF 83 B0  EF 83 B0 EF 83 B0 EF 83   ................
000000E0   B0 EF 83 B0 EF 83 B0 EF  83 B0 EF 83 B0 EF 83 B0   ................
000000F0   EF 83 B0 EF 83 B0 EF 83  B0 EF 83 B0 EF 83 B0 EF   ................
00000100   83 B0 EF 83 B0 EF 83 B0  EF 83 B0 EF 83 B0 EF 83   ................
00000110   B0 EF 83 B0 EF 83 B0 EF  83 B0 EF 83 B0 EF 83 B0   ................
00000120   EF 83 B0 EF 83 B0 EF 83  B0 EF 83 B0 EF 83 B0 EF   ................
00000130   83 B0 EF 83 B0 EF 83 B0  EF 83 B0 EF 83 B0 EF 83   ................
00000140   B0 EF 83 B0 EF 83 B0 EF  83 B0 EF 83 B0 EF 83 B0   ................
00000150   EF 83 B0 EF 83 B0 EF 83  B0 EF 83 B0 EF 83 B0 EF   ................
00000160   83 B0 EF 83 B0 EF 83 B0  EF 83 B0 EF 83 B0 EF 83   ................
00000170   B0 EF 83 B0 EF 83 B0 EF  83 B0 EF 83 B0 EF 83 B0   ................
00000180   EF 83 B0 EF 83 B0 EF 83  B0 EF 83 B0 EF 83 B0 EF   ................
00000190   83 B0 EF 83 B0 EF 83 B0  EF 83 B0 EF 83 B0 EF 83   ................
000001A0   B0 EF 83 B0 EF 83 B0 EF  83 B0 EF 83 B0 EF 83 B0   ................
000001B0   EF 83 B0 EF 83 B0 EF 83  B0 EF 83 B0 EF 83 B0 EF   ................
000001C0   83 B0 EF 83 B0 EF 83 B0  EF 83 B0 EF 83 B0 EF 83   ................
000001D0   B0 EF 83 B0 EF 83 B0 EF  83 B0 EF 83 B0 EF 83 B0   ................
000001E0   EF 83 B0 EF 83 B0 EF 83  B0 EF 83 B0 EF 83 B0 EF   ................
000001F0   83 B0 EF 83 B0 EF 83 B0  EF 83 B0 EF 83 B0 EF 83   ................
00000200   B0 EF 83 B0 EF 83 B0 EF  83 B0                     ..........

Peach.Core.Publishers.TcpClientPublisher close()
Peach.Core.Publishers.TcpClientPublisher Shutting down connection to 127.0.0.1:31337
Peach.Core.Publishers.TcpClientPublisher Read 0 bytes from 127.0.0.1:31337, closing client connection.
Peach.Core.Publishers.TcpClientPublisher Closing connection to 127.0.0.1:31337

[3,3,0:00:01.454] Performing iteration
[*] Fuzzing: Ping.DataElement_0
[*] Mutator: UnicodeUtf8ThreeCharMutator
Peach.Core.MutationStrategies.RandomStrategy Action_Starting: Fuzzing: Ping.DataElement_0
Peach.Core.MutationStrategies.RandomStrategy Action_Starting: Mutator: UnicodeUtf8ThreeCharMutator
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.TcpClientPublisher open()
Peach.Core.Publishers.TcpClientPublisher output(1968 bytes)
Peach.Core.Publishers.TcpClientPublisher

00000000   EF 83 B0 EF 83 B0 EF 83  B0 EF 83 B0 EF 83 B0 EF   ................
00000010   83 B0 EF 83 B0 EF 83 B0  EF 83 B0 EF 83 B0 EF 83   ................
00000020   B0 EF 83 B0 EF 83 B0 EF  83 B0 EF 83 B0 EF 83 B0   ................
00000030   EF 83 B0 EF 83 B0 EF 83  B0 EF 83 B0 EF 83 B0 EF   ................
00000040   83 B0 EF 83 B0 EF 83 B0  EF 83 B0 EF 83 B0 EF 83   ................
00000050   B0 EF 83 B0 EF 83 B0 EF  83 B0 EF 83 B0 EF 83 B0   ................
00000060   EF 83 B0 EF 83 B0 EF 83  B0 EF 83 B0 EF 83 B0 EF   ................
00000070   83 B0 EF 83 B0 EF 83 B0  EF 83 B0 EF 83 B0 EF 83   ................
00000080   B0 EF 83 B0 EF 83 B0 EF  83 B0 EF 83 B0 EF 83 B0   ................
....

Peach.Core.Publishers.TcpClientPublisher close()
Peach.Core.Publishers.TcpClientPublisher Shutting down connection to 127.0.0.1:31337
Peach.Core.Publishers.TcpClientPublisher Read 0 bytes from 127.0.0.1:31337, closing client connection.
Peach.Core.Publishers.TcpClientPublisher Closing connection to 127.0.0.1:31337
Peach.Core.Publishers.TcpClientPublisher stop()                              <co xml:id="CO47-2"/>

[*] Test 'Default' finished.</screen>
<calloutlist>
<callout arearefs="CO47-1">
<para><emphasis>Start</emphasis> action at beginning of fuzzing session</para>
</callout>
<callout arearefs="CO47-2">
<para><emphasis>Stop</emphasis> action at end of fuzzing session</para>
</callout>
</calloutlist>
</example>
<example>
<title>Explicit calling of stop</title>
<simpara>Example Pit that declares the <emphasis>start</emphasis> and <emphasis>stop</emphasis> actions.
The declaration causes <emphasis>start</emphasis> and <emphasis>stop</emphasis> to execute on every iteration, as indicated in the output listing.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

  &lt;DataModel name="Ping"&gt;
    &lt;String value="PING" token="true"/&gt;
  &lt;/DataModel&gt;

  &lt;StateModel name="TheStateModel" initialState="InitialState"&gt;
    &lt;State name="InitialState"&gt;

      &lt;!-- This action is called on every iteration. It will cause
           the Tcp Publisher to perform any initialization. --&gt;
      &lt;Action type="start" /&gt;

      &lt;!-- This action is called on every iteration. It will cause the
           Tcp Publisher to open a connection to the remote host. --&gt;
      &lt;Action type="open" /&gt;

      &lt;!-- This action is called on every iteration. It will output data from
           the data model "Ping" using our Publisher. --&gt;
      &lt;Action type="output"&gt;
        &lt;DataModel ref="Ping"/&gt;
      &lt;/Action&gt;

      &lt;!-- This action is called on every iteration. It will cause the
           Tcp Publisher to close its connection to the remote host if it's
           still open. --&gt;
      &lt;Action type="close" /&gt;

      &lt;!-- This action is called on every iteration. It will perform any
           final clean up actions to fully stop the Publisher. --&gt;
      &lt;Action type="stop" /&gt;

    &lt;/State&gt;
  &lt;/StateModel&gt;

  &lt;Test name="Default"&gt;
    &lt;StateModel ref="TheStateModel"/&gt;
    &lt;Publisher class="Tcp"&gt;
      &lt;Param name="Host" value="127.0.0.1" /&gt;
      &lt;Param name="Port" value="31337" /&gt;
    &lt;/Publisher&gt;

    &lt;Logger class="File" &gt;
      &lt;Param name="Path" value="logs"/&gt;
    &lt;/Logger&gt;
  &lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>In the following output, the <emphasis>start</emphasis> action executes at the beginning of every iteration and is followed by a <emphasis>stop</emphasis> action at the end of every iteration.</simpara>
<screen>&gt; peach --range 1,3 --seed 51405 example.xml

[[ Peach Professional v3.0.0
[[ Copyright (c) Peach Fuzzer LLC
Peach.Core.Engine runTest: context.config.range == true, start: 1, stop: 3

[*] Test 'Default' starting with random seed 51405.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Start
Peach.Core.Publishers.TcpClientPublisher start()                             <co xml:id="CO48-1"/>
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Open
Peach.Core.Publishers.TcpClientPublisher open()
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.TcpClientPublisher output(4 bytes)
Peach.Core.Publishers.TcpClientPublisher

00000000   50 49 4E 47                                        PING

Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Close
Peach.Core.Publishers.TcpClientPublisher close()
Peach.Core.Publishers.TcpClientPublisher Shutting down connection to 127.0.0.1:31337
Peach.Core.Publishers.TcpClientPublisher Read 0 bytes from 127.0.0.1:31337, closing client connection.
Peach.Core.Publishers.TcpClientPublisher Closing connection to 127.0.0.1:31337
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Stop
Peach.Core.Publishers.TcpClientPublisher stop()                              <co xml:id="CO48-2"/>

[1,3,0:00:04.512] Performing iteration
Peach.Core.Dom.Action ActionType.Start
Peach.Core.Publishers.TcpClientPublisher start()                             <co xml:id="CO48-3"/>
Peach.Core.Dom.Action ActionType.Open
Peach.Core.Publishers.TcpClientPublisher open()
[*] Fuzzing: Ping.DataElement_0
[*] Mutator: DataElementSwapNearNodesMutator
Peach.Core.MutationStrategies.RandomStrategy Action_Starting: Fuzzing: Ping.DataElement_0
Peach.Core.MutationStrategies.RandomStrategy Action_Starting: Mutator: DataElementSwapNearNodesMutator
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.TcpClientPublisher output(4 bytes)
Peach.Core.Publishers.TcpClientPublisher

00000000   50 49 4E 47                                        PING

Peach.Core.Dom.Action ActionType.Close
Peach.Core.Publishers.TcpClientPublisher close()
Peach.Core.Publishers.TcpClientPublisher Shutting down connection to 127.0.0.1:31337
Peach.Core.Publishers.TcpClientPublisher Read 0 bytes from 127.0.0.1:31337, closing client connection.
Peach.Core.Publishers.TcpClientPublisher Closing connection to 127.0.0.1:31337
Peach.Core.Dom.Action ActionType.Stop
Peach.Core.Publishers.TcpClientPublisher stop()                              <co xml:id="CO48-4"/>

[2,3,0:00:05.246] Performing iteration
Peach.Core.Dom.Action ActionType.Start
Peach.Core.Publishers.TcpClientPublisher start()                             <co xml:id="CO48-5"/>
Peach.Core.Dom.Action ActionType.Open
Peach.Core.Publishers.TcpClientPublisher open()
[*] Fuzzing: Ping.DataElement_0
[*] Mutator: UnicodeUtf8ThreeCharMutator
Peach.Core.MutationStrategies.RandomStrategy Action_Starting: Fuzzing: Ping.DataElement_0
Peach.Core.MutationStrategies.RandomStrategy Action_Starting: Mutator: UnicodeUtf8ThreeCharMutator
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.TcpClientPublisher output(522 bytes)
Peach.Core.Publishers.TcpClientPublisher

00000000   EF 83 B0 EF 83 B0 EF 83  B0 EF 83 B0 EF 83 B0 EF   ................
00000010   83 B0 EF 83 B0 EF 83 B0  EF 83 B0 EF 83 B0 EF 83   ................
00000020   B0 EF 83 B0 EF 83 B0 EF  83 B0 EF 83 B0 EF 83 B0   ................
00000030   EF 83 B0 EF 83 B0 EF 83  B0 EF 83 B0 EF 83 B0 EF   ................
00000040   83 B0 EF 83 B0 EF 83 B0  EF 83 B0 EF 83 B0 EF 83   ................
00000050   B0 EF 83 B0 EF 83 B0 EF  83 B0 EF 83 B0 EF 83 B0   ................
00000060   EF 83 B0 EF 83 B0 EF 83  B0 EF 83 B0 EF 83 B0 EF   ................
00000070   83 B0 EF 83 B0 EF 83 B0  EF 83 B0 EF 83 B0 EF 83   ................
00000080   B0 EF 83 B0 EF 83 B0 EF  83 B0 EF 83 B0 EF 83 B0   ................
00000090   EF 83 B0 EF 83 B0 EF 83  B0 EF 83 B0 EF 83 B0 EF   ................
000000A0   83 B0 EF 83 B0 EF 83 B0  EF 83 B0 EF 83 B0 EF 83   ................
000000B0   B0 EF 83 B0 EF 83 B0 EF  83 B0 EF 83 B0 EF 83 B0   ................
000000C0   EF 83 B0 EF 83 B0 EF 83  B0 EF 83 B0 EF 83 B0 EF   ................
000000D0   83 B0 EF 83 B0 EF 83 B0  EF 83 B0 EF 83 B0 EF 83   ................
000000E0   B0 EF 83 B0 EF 83 B0 EF  83 B0 EF 83 B0 EF 83 B0   ................
000000F0   EF 83 B0 EF 83 B0 EF 83  B0 EF 83 B0 EF 83 B0 EF   ................
00000100   83 B0 EF 83 B0 EF 83 B0  EF 83 B0 EF 83 B0 EF 83   ................
00000110   B0 EF 83 B0 EF 83 B0 EF  83 B0 EF 83 B0 EF 83 B0   ................
00000120   EF 83 B0 EF 83 B0 EF 83  B0 EF 83 B0 EF 83 B0 EF   ................
00000130   83 B0 EF 83 B0 EF 83 B0  EF 83 B0 EF 83 B0 EF 83   ................
00000140   B0 EF 83 B0 EF 83 B0 EF  83 B0 EF 83 B0 EF 83 B0   ................
00000150   EF 83 B0 EF 83 B0 EF 83  B0 EF 83 B0 EF 83 B0 EF   ................
00000160   83 B0 EF 83 B0 EF 83 B0  EF 83 B0 EF 83 B0 EF 83   ................
00000170   B0 EF 83 B0 EF 83 B0 EF  83 B0 EF 83 B0 EF 83 B0   ................
00000180   EF 83 B0 EF 83 B0 EF 83  B0 EF 83 B0 EF 83 B0 EF   ................
00000190   83 B0 EF 83 B0 EF 83 B0  EF 83 B0 EF 83 B0 EF 83   ................
000001A0   B0 EF 83 B0 EF 83 B0 EF  83 B0 EF 83 B0 EF 83 B0   ................
000001B0   EF 83 B0 EF 83 B0 EF 83  B0 EF 83 B0 EF 83 B0 EF   ................
000001C0   83 B0 EF 83 B0 EF 83 B0  EF 83 B0 EF 83 B0 EF 83   ................
000001D0   B0 EF 83 B0 EF 83 B0 EF  83 B0 EF 83 B0 EF 83 B0   ................
000001E0   EF 83 B0 EF 83 B0 EF 83  B0 EF 83 B0 EF 83 B0 EF   ................
000001F0   83 B0 EF 83 B0 EF 83 B0  EF 83 B0 EF 83 B0 EF 83   ................
00000200   B0 EF 83 B0 EF 83 B0 EF  83 B0                     ..........

Peach.Core.Dom.Action ActionType.Close
Peach.Core.Publishers.TcpClientPublisher close()
Peach.Core.Publishers.TcpClientPublisher Shutting down connection to 127.0.0.1:31337
Peach.Core.Publishers.TcpClientPublisher Read 0 bytes from 127.0.0.1:31337, closing client connection.
Peach.Core.Publishers.TcpClientPublisher Closing connection to 127.0.0.1:31337
Peach.Core.Dom.Action ActionType.Stop
Peach.Core.Publishers.TcpClientPublisher stop()                              <co xml:id="CO48-6"/>

[3,3,0:00:01.705] Performing iteration
Peach.Core.Dom.Action ActionType.Start
Peach.Core.Publishers.TcpClientPublisher start()                             <co xml:id="CO48-7"/>
Peach.Core.Dom.Action ActionType.Open
Peach.Core.Publishers.TcpClientPublisher open()
[*] Fuzzing: Ping.DataElement_0
[*] Mutator: UnicodeUtf8ThreeCharMutator
Peach.Core.MutationStrategies.RandomStrategy Action_Starting: Fuzzing: Ping.DataElement_0
Peach.Core.MutationStrategies.RandomStrategy Action_Starting: Mutator: UnicodeUtf8ThreeCharMutator
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.TcpClientPublisher output(1968 bytes)
Peach.Core.Publishers.TcpClientPublisher


00000000   EF 83 B0 EF 83 B0 EF 83  B0 EF 83 B0 EF 83 B0 EF   ................
00000010   83 B0 EF 83 B0 EF 83 B0  EF 83 B0 EF 83 B0 EF 83   ................
00000020   B0 EF 83 B0 EF 83 B0 EF  83 B0 EF 83 B0 EF 83 B0   ................
00000030   EF 83 B0 EF 83 B0 EF 83  B0 EF 83 B0 EF 83 B0 EF   ................
00000040   83 B0 EF 83 B0 EF 83 B0  EF 83 B0 EF 83 B0 EF 83   ................
00000050   B0 EF 83 B0 EF 83 B0 EF  83 B0 EF 83 B0 EF 83 B0   ................
00000060   EF 83 B0 EF 83 B0 EF 83  B0 EF 83 B0 EF 83 B0 EF   ................
00000070   83 B0 EF 83 B0 EF 83 B0  EF 83 B0 EF 83 B0 EF 83   ................
00000080   B0 EF 83 B0 EF 83 B0 EF  83 B0 EF 83 B0 EF 83 B0   ................
....



Peach.Core.Dom.Action ActionType.Close
Peach.Core.Publishers.TcpClientPublisher close()
Peach.Core.Publishers.TcpClientPublisher Shutting down connection to 127.0.0.1:31337
Peach.Core.Publishers.TcpClientPublisher Read 0 bytes from 127.0.0.1:31337, closing client connection.
Peach.Core.Publishers.TcpClientPublisher Closing connection to 127.0.0.1:31337
Peach.Core.Dom.Action ActionType.Stop
Peach.Core.Publishers.TcpClientPublisher stop()                              <co xml:id="CO48-8"/></screen>
<calloutlist>
<callout arearefs="CO48-1">
<para><emphasis>Start</emphasis> action at beginning of iteration</para>
</callout>
<callout arearefs="CO48-2">
<para><emphasis>Stop</emphasis> action at end of iteration</para>
</callout>
<callout arearefs="CO48-3">
<para><emphasis>Start</emphasis> action at beginning of iteration</para>
</callout>
<callout arearefs="CO48-4">
<para><emphasis>Stop</emphasis> action at end of iteration</para>
</callout>
<callout arearefs="CO48-5">
<para><emphasis>Start</emphasis> action at beginning of iteration</para>
</callout>
<callout arearefs="CO48-6">
<para><emphasis>Stop</emphasis> action at end of iteration</para>
</callout>
<callout arearefs="CO48-7">
<para><emphasis>Start</emphasis> action at beginning of iteration</para>
</callout>
<callout arearefs="CO48-8">
<para><emphasis>Stop</emphasis> action at end of iteration</para>
</callout>
</calloutlist>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Action_open">
<title>open, connect</title>
<simpara>The <emphasis>open</emphasis> (or <emphasis>connect</emphasis>) action is an implicit action that causes the associated publisher to open its resource.
The <emphasis>open</emphasis> Action executes by default at the start of each iteration.</simpara>
<simpara>Each Publisher is an I/O adapter and performs the <emphasis>open</emphasis> Action according to its resource needs, as in the following examples:</simpara>
<itemizedlist>
<listitem>
<simpara>The <link linkend="Publishers_File">File publisher</link> opens a file handle.</simpara>
</listitem>
<listitem>
<simpara>The <link linkend="Publishers_Tcp">TCP publisher</link> initiates a network connection.</simpara>
</listitem>
</itemizedlist>
<simpara>The only time to declare the <emphasis>open</emphasis> action in the StateModel is when the default behavior needs to be modified.</simpara>
<note>
<simpara><emphasis>connect</emphasis> is an alias for <emphasis>open</emphasis>. Both names can be used interchangeably.</simpara>
</note>
<sidebar>
<title>Default Order of Actions</title>
<simpara>The following is the default order in which Actions are performed when fuzzing:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara><emphasis>start</emphasis> - Implicit, once per session</simpara>
</listitem>
<listitem>
<simpara><emphasis>open</emphasis> - Implicit, once per iteration</simpara>
</listitem>
<listitem>
<simpara>Explicit actions (<emphasis>accept</emphasis>, <emphasis>input</emphasis>, <emphasis>output</emphasis>, etc.)</simpara>
</listitem>
<listitem>
<simpara><emphasis>close</emphasis> - Implicit, once per iteration</simpara>
</listitem>
<listitem>
<simpara><emphasis>stop</emphasis> - Implicit, once per session</simpara>
</listitem>
</orderedlist>
</sidebar>
<section xml:id="_syntax_76">
<title>Syntax</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;StateModel name="TheStateModel" initialState="InitialState"&gt;
	&lt;State name="InitialState"&gt;

		&lt;Action type="open" /&gt;

		&lt;Action type="output"&gt;
			&lt;DataModel ref="DataModelToWrite"/&gt;
		&lt;/Action&gt;

	&lt;/State&gt;
&lt;/StateModel&gt;</programlisting>
<programlisting language="xml" linenumbering="unnumbered">&lt;StateModel name="TheStateModel" initialState="InitialState"&gt;
	&lt;State name="InitialState"&gt;

		&lt;Action type="connect" /&gt;

		&lt;Action type="output"&gt;
			&lt;DataModel ref="DataModelToSend"/&gt;
		&lt;/Action&gt;

	&lt;/State&gt;
&lt;/StateModel&gt;</programlisting>
</section>
<section xml:id="_attributes_84">
<title>Attributes</title>
<simpara><emphasis>Required:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>type</term>
<listitem>
<simpara>Action type, must be set to "open" or "connect"</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>name</term>
<listitem>
<simpara>Name used to identify the action</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>publisher</term>
<listitem>
<simpara>Name of the publisher to perform this action</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_when">when</link></term>
<listitem>
<simpara>Perform action if the provided expression evaluates to true</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_onStart">onStart</link></term>
<listitem>
<simpara>Evaluate the expression at the start of an action</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_onComplete">onComplete</link></term>
<listitem>
<simpara>Evaluate the expression upon completion of an action</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_child_elements_46">
<title>Child Elements</title>
<simpara>None.</simpara>
</section>
<section xml:id="_examples_110">
<title>Examples</title>
<example>
<title>Implicit Use of <emphasis>open</emphasis> Action</title>
<simpara>This is an example of the default implicit behavior of <emphasis>open</emphasis>. Note the absence of any declaration for <emphasis>open</emphasis>.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

  &lt;DataModel name="TestTemplate"&gt;
    &lt;String value="Hello World!" /&gt;
  &lt;/DataModel&gt;

  &lt;StateModel name="State" initialState="Initial"&gt;
    &lt;State name="Initial"&gt;

      &lt;Action type="output"&gt;
        &lt;DataModel ref="TestTemplate" /&gt;
      &lt;/Action&gt;

    &lt;/State&gt;
  &lt;/StateModel&gt;

  &lt;Test name="Default"&gt;
    &lt;StateModel ref="State"/&gt;

    &lt;Publisher class="File"&gt;
      &lt;Param name="FileName" value="fuzzed.txt" /&gt;
    &lt;/Publisher&gt;
  &lt;/Test&gt;

&lt;/Peach&gt;
&lt;!-- end --&gt;</programlisting>
<simpara>Output from executing the previous pit.</simpara>
<screen>&gt; peach -1 --debug C:\temp\example.xml

[*] Test 'Default' starting with random seed 18872.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.FilePublisher start()
Peach.Core.Publishers.FilePublisher open()                                   <co xml:id="CO49-1"/>
Peach.Core.Publishers.FilePublisher output(12 bytes)
Peach.Core.Publishers.FilePublisher close()                                  <co xml:id="CO49-2"/>
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.FilePublisher stop()

[*] Test 'Default' finished.</screen>
<calloutlist>
<callout arearefs="CO49-1">
<para>Implicit <link linkend="Action_open"><emphasis>open</emphasis></link> Action occurring at start of iteration</para>
</callout>
<callout arearefs="CO49-2">
<para>Implicit <emphasis>close</emphasis> Action occurring prior to end of iteration</para>
</callout>
</calloutlist>
</example>
<example>
<title>Explicit Use of <emphasis>open</emphasis> Action</title>
<simpara>In this example, the <emphasis>open</emphasis> and <link linkend="Action_close"><emphasis>close</emphasis></link> actions are used explicitly to perform two connections using the same publisher.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

  &lt;DataModel name="TestTemplate"&gt;
    &lt;String name="Value" /&gt;
  &lt;/DataModel&gt;

  &lt;StateModel name="State" initialState="Initial"&gt;
    &lt;State name="Initial"&gt;

      &lt;Action type="output"&gt;
        &lt;DataModel ref="TestTemplate" /&gt;
        &lt;Data&gt;
          &lt;Field name="Value" value="Connection #1\n" /&gt;
        &lt;/Data&gt;
      &lt;/Action&gt;

      &lt;Action type="close" /&gt;

      &lt;Action type="open" /&gt;

      &lt;Action type="output"&gt;
        &lt;DataModel ref="TestTemplate" /&gt;
        &lt;Data&gt;
          &lt;Field name="Value" value="Connection #2\n" /&gt;
        &lt;/Data&gt;
      &lt;/Action&gt;

    &lt;/State&gt;
  &lt;/StateModel&gt;

  &lt;Test name="Default"&gt;
    &lt;StateModel ref="State"/&gt;

    &lt;Publisher class="Tcp"&gt;
      &lt;Param name="Host" value="127.0.0.1" /&gt;
      &lt;Param name="Port" value="31337" /&gt;
    &lt;/Publisher&gt;
  &lt;/Test&gt;

&lt;/Peach&gt;</programlisting>
<simpara>The netcat program can be used to simulate a listener. Netcat runs twice, once per connection.</simpara>
<screen>&gt; nc -l 31337 ; echo "====" ; nc -l 31337
Connection #1
====
Connection #2</screen>
<simpara>Output from this example.</simpara>
<screen>&gt; peach -1 --debug example.xml

[*] Test 'Default' starting with random seed 61010.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.TcpClientPublisher start()
Peach.Core.Publishers.TcpClientPublisher open()                              <co xml:id="CO50-1"/>
Peach.Core.Publishers.TcpClientPublisher output(14 bytes)
Peach.Core.Publishers.TcpClientPublisher

00000000   43 6F 6E 6E 65 63 74 69  6F 6E 20 23 31 0A         Connection #1

Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Close
Peach.Core.Publishers.TcpClientPublisher close()                             <co xml:id="CO50-2"/>
Peach.Core.Publishers.TcpClientPublisher Shutting down connection to 127.0.0.1:31337
Peach.Core.Publishers.TcpClientPublisher Read 0 bytes from 127.0.0.1:31337, closing client connection.
Peach.Core.Publishers.TcpClientPublisher Closing connection to 127.0.0.1:31337
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Open
Peach.Core.Publishers.TcpClientPublisher open()                              <co xml:id="CO50-3"/>
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.TcpClientPublisher output(14 bytes)
Peach.Core.Publishers.TcpClientPublisher

00000000   43 6F 6E 6E 65 63 74 69  6F 6E 20 23 32 0A         Connection #2

Peach.Core.Publishers.TcpClientPublisher close()                             <co xml:id="CO50-4"/>
Peach.Core.Publishers.TcpClientPublisher Shutting down connection to 127.0.0.1:31337
Peach.Core.Publishers.TcpClientPublisher Read 0 bytes from 127.0.0.1:31337, closing client connection.
Peach.Core.Publishers.TcpClientPublisher Closing connection to 127.0.0.1:31337
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.TcpClientPublisher stop()

[*] Test 'Default' finished.</screen>
<calloutlist>
<callout arearefs="CO50-1">
<para>Implicit <link linkend="Action_open"><emphasis>open</emphasis></link></para>
</callout>
<callout arearefs="CO50-2">
<para>Explicit <emphasis>close</emphasis></para>
</callout>
<callout arearefs="CO50-3">
<para>Explicit <link linkend="Action_open"><emphasis>open</emphasis></link></para>
</callout>
<callout arearefs="CO50-4">
<para>Implicit <emphasis>close</emphasis></para>
</callout>
</calloutlist>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Action_close">
<title>close</title>
<simpara>The <emphasis>close</emphasis> Action causes the associated publisher to close its resource.</simpara>
<itemizedlist>
<listitem>
<simpara>For the <link linkend="Publishers_File">File Publisher</link>, this action closes the file handle.</simpara>
</listitem>
<listitem>
<simpara>For the <link linkend="Publishers_Tcp">TCP Publisher</link>, this action closes the network connection.</simpara>
</listitem>
</itemizedlist>
<simpara>Close is an implicit action that occurs by default at the end of each iteration.</simpara>
<simpara>The only time you need to explicitly call the <emphasis>close</emphasis> action is when the default behavior needs to be changed. For example, during file fuzzing, the target application is launched after closing:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>the <link linkend="Action_output"><emphasis>output</emphasis></link> Action initiates writing the data</simpara>
</listitem>
<listitem>
<simpara>the <emphasis>close</emphasis> Action closes the target</simpara>
</listitem>
<listitem>
<simpara>the target application subsequently launches using the <link linkend="Action_call"><emphasis>call</emphasis></link> Action</simpara>
</listitem>
</orderedlist>
<sidebar>
<title>Default Order of Actions</title>
<simpara>The following is the default order in which Actions are performed when fuzzing:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>start - Implicit, once per session</simpara>
</listitem>
<listitem>
<simpara>open - Implicit, once per iteration</simpara>
</listitem>
<listitem>
<simpara>Explicit actions (such as accept, input, and output)</simpara>
</listitem>
<listitem>
<simpara>close - Implicit, once per iteration</simpara>
</listitem>
<listitem>
<simpara>stop - Implicit, once per session</simpara>
</listitem>
</orderedlist>
</sidebar>
<section xml:id="_syntax_77">
<title>Syntax</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;StateModel name="TheStateModel" initialState="InitialState"&gt;
  &lt;State name="InitialState"&gt;

    &lt;Action type="output"&gt;
      &lt;DataModel ref="FileHeader"/&gt;
    &lt;/Action&gt;

    &lt;Action type="close" /&gt;

    &lt;Action type="call" method="LaunchTarget" publisher="Peach.Agent" /&gt;

  &lt;/State&gt;
&lt;/StateModel&gt;</programlisting>
</section>
<section xml:id="_attributes_85">
<title>Attributes</title>
<simpara><emphasis>Required:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>type</term>
<listitem>
<simpara>Action type, must be set to "close"</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>name</term>
<listitem>
<simpara>Name used to identify the action</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>publisher</term>
<listitem>
<simpara>Name of the publisher that this action should be called on</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_when">when</link></term>
<listitem>
<simpara>Only perform action if the expression provided evaluates to true</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_onStart">onStart</link></term>
<listitem>
<simpara>Expression to run on start of an action.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_onComplete">onComplete</link></term>
<listitem>
<simpara>Expression to run on completion of an action</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_child_elements_47">
<title>Child Elements</title>
<simpara>No child elements are supported by this element.</simpara>
</section>
<section xml:id="_examples_111">
<title>Examples</title>
<example>
<title>Implicit Use of <emphasis>close</emphasis> Action</title>
<simpara>This is an example of the default implicit behavior of <emphasis>close</emphasis>.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

  &lt;DataModel name="TestTemplate"&gt;
    &lt;String value="Hello World!" /&gt;
  &lt;/DataModel&gt;

  &lt;StateModel name="State" initialState="Initial"&gt;
    &lt;State name="Initial"&gt;

      &lt;Action type="output"&gt;
        &lt;DataModel ref="TestTemplate" /&gt;
      &lt;/Action&gt;

    &lt;/State&gt;
  &lt;/StateModel&gt;

  &lt;Test name="Default"&gt;
    &lt;StateModel ref="State"/&gt;

    &lt;Publisher class="File"&gt;
      &lt;Param name="FileName" value="fuzzed.txt" /&gt;
    &lt;/Publisher&gt;
  &lt;/Test&gt;

&lt;/Peach&gt;
&lt;!-- end --&gt;</programlisting>
<simpara>When run the following output is generated.</simpara>
<screen>&gt; peach -1 --debug C:\temp\example.xml

[*] Test 'Default' starting with random seed 18872.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.FilePublisher start()
Peach.Core.Publishers.FilePublisher open()                                   <co xml:id="CO51-1"/>
Peach.Core.Publishers.FilePublisher output(12 bytes)
Peach.Core.Publishers.FilePublisher close()                                  <co xml:id="CO51-2"/>
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.FilePublisher stop()

[*] Test 'Default' finished.</screen>
<calloutlist>
<callout arearefs="CO51-1">
<para>Implicit <link linkend="Action_open"><emphasis>open</emphasis></link> Action occurring at start of iteration</para>
</callout>
<callout arearefs="CO51-2">
<para>Implicit <emphasis>close</emphasis> Action occurring prior to end of iteration</para>
</callout>
</calloutlist>
</example>
<example>
<title>Explicit Use of <emphasis>close</emphasis> Action</title>
<simpara>This is an example of needed to call <emphasis>close</emphasis> in a different order than the default order.
When file fuzzing, the file data is written using an <emphasis><link linkend="Action_output">output</link></emphasis>, then the file is closed using a <emphasis>close</emphasis> action.
And finally the target is launched using a <emphasis><link linkend="Action_call">call</link></emphasis> action with the special Publisher name of <emphasis>Peach.Agent</emphasis>.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

  &lt;DataModel name="TestTemplate"&gt;
    &lt;String value="Hello World!" /&gt;
  &lt;/DataModel&gt;

  &lt;StateModel name="State" initialState="Initial"&gt;
    &lt;State name="Initial"&gt;

      &lt;Action type="output"&gt;
        &lt;DataModel ref="TestTemplate" /&gt;
      &lt;/Action&gt;

      &lt;!-- Close file --&gt;
      &lt;Action type="close" /&gt;

      &lt;!-- Launch the file consumer --&gt;
      &lt;Action type="call" method="ScoobySnacks" publisher="Peach.Agent"/&gt;

    &lt;/State&gt;
  &lt;/StateModel&gt;

  &lt;Agent name="LocalAgent"&gt;
    &lt;Monitor class="WindowsDebugger"&gt;
      &lt;Param name="Executable" value="c:\windows\system32\notepad.exe /&gt;
      &lt;Param name="Arguments" value="fuzzfile.bin" /&gt;
      &lt;Param name="StartOnCall" value="ScoobySnacks" /&gt;
    &lt;/Monitor&gt;
    &lt;Monitor class="PageHeap"&gt;
      &lt;Param name="Executable" value="notepad.exe"/&gt;
    &lt;/Monitor&gt;
  &lt;/Agent&gt;

  &lt;Test name="Default"&gt;
    &lt;Agent ref="LocalAgent" /&gt;
    &lt;StateModel ref="State"/&gt;

    &lt;Publisher class="File"&gt;
      &lt;Param name="FileName" value="fuzzfile.bin" /&gt;
    &lt;/Publisher&gt;
  &lt;/Test&gt;

&lt;/Peach&gt;
&lt;!-- end --&gt;</programlisting>
<simpara>When run the following output is generated.</simpara>
<screen>&gt; peach -1 --debug example.xml

[*] Test 'Default' starting with random seed 14756.
Peach.Core.Agent.Agent StartMonitor: Monitor WindowsDebugger
Peach.Core.Agent.Agent StartMonitor: Monitor_1 PageHeap
Peach.Core.Agent.Agent SessionStarting: Monitor
Peach.Core.Agent.Monitors.WindowsDebuggerHybrid SessionStarting
Peach.Core.Agent.Agent SessionStarting: Monitor_1

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.FilePublisher start()
Peach.Core.Publishers.FilePublisher open()                                   <co xml:id="CO52-1"/>
Peach.Core.Publishers.FilePublisher output(12 bytes)
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Close                                       <co xml:id="CO52-2"/>
Peach.Core.Publishers.FilePublisher close()
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Call
Peach.Core.Agent.AgentManager Message: Action.Call =&gt; ScoobySnacks
Peach.Core.Agent.Monitors.WindowsDebuggerHybrid _StopDebugger
Peach.Core.Agent.Monitors.WindowsDebuggerHybrid Cpu is idle, stopping process.
Peach.Core.Agent.Monitors.WindowsDebuggerHybrid _StopDebugger
Peach.Core.Agent.Monitors.WindowsDebuggerHybrid DetectedFault()
Peach.Core.Agent.Monitors.WindowsDebuggerHybrid DetectedFault() - No fault detected
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.FilePublisher stop()
Peach.Core.Agent.Agent SessionFinished: Monitor_1
Peach.Core.Agent.Agent SessionFinished: Monitor
Peach.Core.Agent.Monitors.WindowsDebuggerHybrid SessionFinished
Peach.Core.Agent.Monitors.WindowsDebuggerHybrid _StopDebugger
Peach.Core.Agent.Monitors.WindowsDebuggerHybrid _FinishDebugger
Peach.Core.Agent.Monitors.WindowsDebuggerHybrid _StopDebugger
Peach.Core.Agent.Monitors.WindowsDebuggerHybrid _StopDebugger
Peach.Core.Agent.Monitors.WindowsDebuggerHybrid _FinishDebugger
Peach.Core.Agent.Monitors.WindowsDebuggerHybrid _StopDebugger

[*] Test 'Default' finished.</screen>
<calloutlist>
<callout arearefs="CO52-1">
<para>Implicit <emphasis><link linkend="Action_open">open</link></emphasis> Action</para>
</callout>
<callout arearefs="CO52-2">
<para>Explicit <emphasis>close</emphasis> Action occurring prior to call Action</para>
</callout>
</calloutlist>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Action_accept">
<title>accept</title>
<simpara>The <emphasis>accept</emphasis> Action blocks execution until an incoming connection is available, made, and accepted; or a timeout occurs. This action is most common in situations where a target application initiates the communication and Peach acts as a server.</simpara>
<simpara>Not all <link linkend="Publisher">Publishers</link> support the <emphasis>accept</emphasis> action type. <link linkend="Publishers_TcpListener">TcpListener</link> is an example of a Publisher that supports <emphasis>accept</emphasis>.</simpara>
<simpara>Peach is single-threaded so it can&#8217;t execute any other task (including scripts) while waiting for a target connection.</simpara>
<sidebar>
<title>Accept Timeout</title>
<simpara>Some Publishers use an <emphasis>AcceptTimeout</emphasis> parameter to limit the wait for a connection. If the timeout occurs prior to accepting an incoming connection, Peach behaves as follows:</simpara>
<variablelist>
<varlistentry>
<term><link linkend="Iteration_record">Timeout occurs during a record iteration</link></term>
<listitem>
<simpara>Peach throws an exception and stops. The results of a record iteration are used as a standard for comparing with results of control iterations.
When things do not work correctly during a record iteration, the environment is not working correctly or the pit is not correct.
In either case, the fuzzing session cannot continue.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Iteration_control">Timeout occurs during a control iteration</link></term>
<listitem>
<simpara>Peach triggers a fault. Control iterations are used as checkpoints to verify that the target is operating correctly.
The pit must enable Control iterations to reach this state.
During control iterations, Peach assumes any error results from the target entering an unwanted state.
Such transitions are considered faults and logged accordingly.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Iteration_fuzzing">Timeout occurs during a fuzzing iteration</link></term>
<listitem>
<simpara>Peach continues to the next iteration.
During normal fuzzing iterations, Peach ignores odd behavior from the target unless it occurs during a control iteration.</simpara>
</listitem>
</varlistentry>
</variablelist>
</sidebar>
<sidebar>
<title>Default Order of Actions</title>
<simpara>When fuzzing occurs, actions are performed in the following (default) order:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara><emphasis>start</emphasis> - Implicit, once per session</simpara>
</listitem>
<listitem>
<simpara><emphasis>open</emphasis> - Implicit, once per iteration</simpara>
</listitem>
<listitem>
<simpara>Explicit actions (like <emphasis>accept</emphasis>, <emphasis>input</emphasis>, and <emphasis>output</emphasis>)</simpara>
</listitem>
<listitem>
<simpara><emphasis>close</emphasis> - Implicit, once per iteration</simpara>
</listitem>
<listitem>
<simpara><emphasis>stop</emphasis> - Implicit, once per session</simpara>
</listitem>
</orderedlist>
</sidebar>
<section xml:id="_syntax_78">
<title>Syntax</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;StateModel name="TheStateModel" initialState="InitialState"&gt;
  &lt;State name="InitialState"&gt;

  &lt;Action type="accept" /&gt;

  &lt;Action type="output"&gt;
    &lt;DataModel ref="PacketModel"/&gt;
  &lt;/Action&gt;

  &lt;/State&gt;
&lt;/StateModel&gt;</programlisting>
</section>
<section xml:id="_attributes_86">
<title>Attributes</title>
<simpara><emphasis>Required:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>type</term>
<listitem>
<simpara>Action type, must be set to "accept"</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>name</term>
<listitem>
<simpara>Name used to identify the action</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>publisher</term>
<listitem>
<simpara>Name of the publisher to perform this action</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_when">when</link></term>
<listitem>
<simpara>Perform this action if the provided expression evaluates to true</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_onStart">onStart</link></term>
<listitem>
<simpara>Evaluate the expression at the start of an action</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_onComplete">onComplete</link></term>
<listitem>
<simpara>Evaluate the expression upon completion of an action</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_child_elements_48">
<title>Child Elements</title>
<simpara>None.</simpara>
</section>
<section xml:id="_examples_112">
<title>Examples</title>
<example>
<title>Ping-Pong Accept Example</title>
<simpara>This is a simple example of using the <emphasis>accept</emphasis> action. Netcat (nc) is used in this example as the client.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

  &lt;DataModel name="Ping"&gt;
    &lt;String value="PING" token="true"/&gt;
  &lt;/DataModel&gt;

  &lt;DataModel name="Pong"&gt;
    &lt;String value="PONG" /&gt;
  &lt;/DataModel&gt;

  &lt;StateModel name="TheStateModel" initialState="InitialState"&gt;
    &lt;State name="InitialState"&gt;
      &lt;Action type="accept" /&gt;

      &lt;Action type="input"&gt;
        &lt;DataModel ref="Ping"/&gt;
      &lt;/Action&gt;

      &lt;Action type="output"&gt;
        &lt;DataModel ref="Pong"/&gt;
      &lt;/Action&gt;
    &lt;/State&gt;
  &lt;/StateModel&gt;

  &lt;Test name="Default"&gt;
    &lt;StateModel ref="TheStateModel"/&gt;

    &lt;Publisher class="TcpListener"&gt;
      &lt;Param name="Interface" value="0.0.0.0" /&gt;
      &lt;Param name="Port" value="31337" /&gt;
      &lt;Param name="AcceptTimeout" value="10000" /&gt;
      &lt;Param name="Timeout" value="10000" /&gt;
    &lt;/Publisher&gt;

    &lt;Logger class="File" &gt;
      &lt;Param name="Path" value="logs"/&gt;
    &lt;/Logger&gt;
  &lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Output from this example that the server produces.</simpara>
<simpara>Once Peach starts, type the following command line and press RETURN to recreate the output. Again, <emphasis>nc</emphasis> is netcat.</simpara>
<simpara>nc -vv 127.0.0.1 31337</simpara>
<screen>&gt; peach -1 --debug example.xml

[*] Test 'Default' starting with random seed 32331.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Accept
Peach.Core.Publishers.TcpListenerPublisher start()
Peach.Core.Publishers.TcpListenerPublisher open()
Peach.Core.Publishers.TcpListenerPublisher accept()                          <co xml:id="CO53-1"/>
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Input
Peach.Core.Publishers.TcpListenerPublisher input()
Peach.Core.Publishers.TcpListenerPublisher Read 5 bytes from 127.0.0.1:62407
Peach.Core.Publishers.TcpListenerPublisher

00000000   50 49 4E 47 0A                                     PING

Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker DataModel 'Ping' Bytes: 0/5, Bits: 0/40
Peach.Core.Cracker.DataCracker getSize: -----&gt; DataModel 'Ping'
Peach.Core.Cracker.DataCracker scan: DataModel 'Ping'
Peach.Core.Cracker.DataCracker scan: String 'Ping.DataElement_0' -&gt; Pos: 0, Saving Token
Peach.Core.Cracker.DataCracker scan: String 'Ping.DataElement_0' -&gt; Pos: 32, Length: 32
Peach.Core.Cracker.DataCracker getSize: &lt;----- Deterministic: ???
Peach.Core.Cracker.DataCracker Crack: DataModel 'Ping' Size: &lt;null&gt;, Bytes: 0/5, Bits: 0/40
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker String 'Ping.DataElement_0' Bytes: 0/5, Bits: 0/40
Peach.Core.Cracker.DataCracker getSize: -----&gt; String 'Ping.DataElement_0'
Peach.Core.Cracker.DataCracker scan: String 'Ping.DataElement_0' -&gt; Pos: 0, Saving Token
Peach.Core.Cracker.DataCracker scan: String 'Ping.DataElement_0' -&gt; Pos: 32, Length: 32
Peach.Core.Cracker.DataCracker getSize: &lt;----- Size: 32
Peach.Core.Cracker.DataCracker Crack: String 'Ping.DataElement_0' Size: 32, Bytes: 0/5, Bits: 0/40
Peach.Core.Dom.DataElement String 'Ping.DataElement_0' value is: PING
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.TcpListenerPublisher output(4 bytes)
Peach.Core.Publishers.TcpListenerPublisher

00000000   50 4F 4E 47                                        PONG

Peach.Core.Publishers.TcpListenerPublisher close()
Peach.Core.Publishers.TcpListenerPublisher Shutting down connection to 127.0.0.1:62407
Peach.Core.Publishers.TcpListenerPublisher Read 0 bytes from 127.0.0.1:62407, closing client connection.
Peach.Core.Publishers.TcpListenerPublisher Closing connection to 127.0.0.1:62407

Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.TcpListenerPublisher stop()

[*] Test 'Default' finished.</screen>
<calloutlist>
<callout arearefs="CO53-1">
<para>Peach waits here for the incoming connection.</para>
</callout>
</calloutlist>
<simpara>Interaction from the client, including the Netcat command line.</simpara>
<simpara>Once Netcat is running, type "PING" in upper case and press RETURN. "PONG" will be sent back by Peach.</simpara>
<screen>&gt; nc -vv 127.0.0.1 31337
Connection to 127.0.0.1 31337 port [tcp/*] succeeded!
PING
PONG</screen>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Action_input">
<title>input</title>
<simpara>The <emphasis>input</emphasis> Action receives or reads in data using a <link linkend="Publisher">Publisher</link>.</simpara>
<simpara>The most common use for <emphasis>input</emphasis> actions is to receive data that will be fuzzed.
Once received and <link linkend="Cracking">cracked</link> into a data model, the data is available for other uses, such as:</simpara>
<itemizedlist>
<listitem>
<simpara>copying in <link linkend="Action_output"><emphasis>output</emphasis></link> actions</simpara>
</listitem>
<listitem>
<simpara>using in conditional expressions, such as with the <link linkend="Action_when"><emphasis>when</emphasis></link> attribute.</simpara>
</listitem>
</itemizedlist>
<simpara><emphasis>input</emphasis> Actions are associated with a <link linkend="DataModel">DataModel</link> (provided as a child element) that drives the amount of requested data.
For stream-based publishers that can read forever (such as TCP), the DataModel must prevent the potential of infinite data read operations, such as setting a timeout value.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Stream Publisher versus Datagram Publisher</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Stream</entry>
<entry align="left" valign="top">Datagram</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>TCP</simpara></entry>
<entry align="left" valign="top"><simpara>UDP</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Number of packets unimportant</simpara></entry>
<entry align="left" valign="top"><simpara>Number of packets important</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Implicit data length not included</simpara></entry>
<entry align="left" valign="top"><simpara>Includes implicit data length</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<sidebar>
<simpara>With a stream based publisher, the number of underlying packets received is not important; the data is accessed as a continual stream of incoming data. This does not apply to non-stream based publishers such as the datagram protocol <link linkend="Publishers_Udp">UDP</link>. Non-stream based publishers need to know the number of underlying packets received.
In UDP, each input and output action receives or sends a single datagram. When cracking the UDP data into a DataModel only the data in the single packet can be used. There is an implicit length to the data that is not present in <link linkend="Publishers_Tcp">TCP</link>.</simpara>
</sidebar>
<sidebar>
<title>Input Timeout</title>
<simpara>If the input time out is reached prior to all incoming data being received, Peach behaves as follows:</simpara>
<variablelist>
<varlistentry>
<term><link linkend="Iteration_record">Timeout during a record iteration</link></term>
<listitem>
<simpara>When a record iteration generates errors, Peach assumes the environment is not working correctly or the pit is incorrect.   In both cases, fuzzing cannot continue.
Peach throws an exception and stops.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Iteration_control">Timeout during a control iteration</link></term>
<listitem>
<simpara>Control iterations must be enabled to reach for this state.
Control iterations assume that any error is the result of the target entering an unwanted state. Peach triggers a fault.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Iteration_fuzzing">Timeout during a fuzzing iteration</link></term>
<listitem>
<simpara>Peach continues fuzzing with the  next iteration.
During normal fuzzing iterations, Peach assumes fuzzing causes odd behaviors from the target that are ignored, unless they occur during a control iteration.</simpara>
</listitem>
</varlistentry>
</variablelist>
</sidebar>
<sidebar>
<title>Default Order of Actions</title>
<simpara>The following is the default order in which Actions are performed when fuzzing:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara><emphasis>start</emphasis> - Implicit, once per session</simpara>
</listitem>
<listitem>
<simpara><emphasis>open</emphasis> - Implicit, once per iteration</simpara>
</listitem>
<listitem>
<simpara>Explicit actions (such as <emphasis>accept</emphasis>, <emphasis>input</emphasis>, and <emphasis>output</emphasis>)</simpara>
</listitem>
<listitem>
<simpara><emphasis>close</emphasis> - Implicit, once per iteration</simpara>
</listitem>
<listitem>
<simpara><emphasis>stop</emphasis> - Implicit, once per session</simpara>
</listitem>
</orderedlist>
</sidebar>
<section xml:id="_syntax_79">
<title>Syntax</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;StateModel name="TheStateModel" initialState="InitialState"&gt;
  &lt;State name="InitialState"&gt;

    &lt;Action type="input"&gt;
      &lt;DataModel ref="InputModel" /&gt;
    &lt;/Action&gt;

  &lt;/State&gt;
&lt;/StateModel&gt;</programlisting>
</section>
<section xml:id="_attributes_87">
<title>Attributes</title>
<simpara><emphasis>Required:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>type</term>
<listitem>
<simpara>Action type, must be set to "input"</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>name</term>
<listitem>
<simpara>Name used to identify the action</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>publisher</term>
<listitem>
<simpara>Name of the publisher to perform this action</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_when">when</link></term>
<listitem>
<simpara>Perform action if the provided expression evaluates to true</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_onStart">onStart</link></term>
<listitem>
<simpara>Evaluate expression at the start of an action.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_onComplete">onComplete</link></term>
<listitem>
<simpara>Evaluate expression upon completion of an action</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_child_elements_49">
<title>Child Elements</title>
<variablelist>
<varlistentry>
<term><link linkend="DataModel">DataModel</link></term>
<listitem>
<simpara>Reference to a DataModel that will receive cracked input data</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_113">
<title>Examples</title>
<example>
<title>Receiving Input from TCP Publisher</title>
<simpara>This is a simple example of using the <emphasis>input</emphasis> action to receive data. Netcat (nc) is used in this example as the client.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

  &lt;!-- Marking the string as a token will imply a length of 4 characters --&gt;
  &lt;DataModel name="Ping"&gt;
    &lt;String value="PING" token="true"/&gt;
  &lt;/DataModel&gt;

  &lt;DataModel name="Pong"&gt;
    &lt;String value="PONG" /&gt;
  &lt;/DataModel&gt;

  &lt;StateModel name="TheStateModel" initialState="InitialState"&gt;
    &lt;State name="InitialState"&gt;
      &lt;Action type="accept" /&gt;

      &lt;Action type="input"&gt;
        &lt;DataModel ref="Ping"/&gt;
      &lt;/Action&gt;

      &lt;Action type="output"&gt;
        &lt;DataModel ref="Pong"/&gt;
      &lt;/Action&gt;
    &lt;/State&gt;
  &lt;/StateModel&gt;

  &lt;Test name="Default"&gt;
    &lt;StateModel ref="TheStateModel"/&gt;

    &lt;Publisher class="TcpListener"&gt;
      &lt;Param name="Interface" value="0.0.0.0" /&gt;
      &lt;Param name="Port" value="31337" /&gt;
      &lt;Param name="AcceptTimeout" value="10000" /&gt;
      &lt;Param name="Timeout" value="10000" /&gt;
    &lt;/Publisher&gt;

    &lt;Logger class="File" &gt;
      &lt;Param name="Path" value="logs"/&gt;
    &lt;/Logger&gt;
  &lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Output from this example. Once Peach is started, use the netcat command (nc) to recreate output. Type the following command line and press RETURN to continue.</simpara>
<literallayout class="monospaced">nc -vv 127.0.0.1 31337</literallayout>
<screen>&gt; peach -1 --debug example.xml

[*] Test 'Default' starting with random seed 32331.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Accept
Peach.Core.Publishers.TcpListenerPublisher start()
Peach.Core.Publishers.TcpListenerPublisher open()
Peach.Core.Publishers.TcpListenerPublisher accept()
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Input
Peach.Core.Publishers.TcpListenerPublisher input()                           <co xml:id="CO54-1"/>
Peach.Core.Publishers.TcpListenerPublisher Read 5 bytes from 127.0.0.1:62407
Peach.Core.Publishers.TcpListenerPublisher

00000000   50 49 4E 47 0A                                     PING

Peach.Core.Cracker.DataCracker ------------------------------------          <co xml:id="CO54-2"/>
Peach.Core.Cracker.DataCracker DataModel 'Ping' Bytes: 0/5, Bits: 0/40
Peach.Core.Cracker.DataCracker getSize: -----&gt; DataModel 'Ping'
Peach.Core.Cracker.DataCracker scan: DataModel 'Ping'
Peach.Core.Cracker.DataCracker scan: String 'Ping.DataElement_0' -&gt; Pos: 0, Saving Token
Peach.Core.Cracker.DataCracker scan: String 'Ping.DataElement_0' -&gt; Pos: 32, Length: 32
Peach.Core.Cracker.DataCracker getSize: &lt;----- Deterministic: ???
Peach.Core.Cracker.DataCracker Crack: DataModel 'Ping' Size: &lt;null&gt;, Bytes: 0/5, Bits: 0/40
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker String 'Ping.DataElement_0' Bytes: 0/5, Bits: 0/40
Peach.Core.Cracker.DataCracker getSize: -----&gt; String 'Ping.DataElement_0'
Peach.Core.Cracker.DataCracker scan: String 'Ping.DataElement_0' -&gt; Pos: 0, Saving Token
Peach.Core.Cracker.DataCracker scan: String 'Ping.DataElement_0' -&gt; Pos: 32, Length: 32
Peach.Core.Cracker.DataCracker getSize: &lt;----- Size: 32
Peach.Core.Cracker.DataCracker Crack: String 'Ping.DataElement_0' Size: 32, Bytes: 0/5, Bits: 0/40
Peach.Core.Dom.DataElement String 'Ping.DataElement_0' value is: PING
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.TcpListenerPublisher output(4 bytes)
Peach.Core.Publishers.TcpListenerPublisher

00000000   50 4F 4E 47                                        PONG

Peach.Core.Publishers.TcpListenerPublisher close()
Peach.Core.Publishers.TcpListenerPublisher Shutting down connection to 127.0.0.1:62407
Peach.Core.Publishers.TcpListenerPublisher Read 0 bytes from 127.0.0.1:62407, closing client connection.
Peach.Core.Publishers.TcpListenerPublisher Closing connection to 127.0.0.1:62407

Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.TcpListenerPublisher stop()

[*] Test 'Default' finished.</screen>
<calloutlist>
<callout arearefs="CO54-1">
<para>Data received by TCP publisher</para>
</callout>
<callout arearefs="CO54-2">
<para>Debugging output from the data cracker</para>
</callout>
</calloutlist>
<simpara>Netcat command line. Once Netcat is running, type "PING" in upper case letters and press RETURN. Peach responds with "PONG".</simpara>
<screen>&gt; nc -vv 127.0.0.1 31337
Connection to 127.0.0.1 31337 port [tcp/*] succeeded!
PING
PONG</screen>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Action_infrag">
<title>infrag</title>
<simpara>The <emphasis>infrag</emphasis> action is a special action to perform fragemented input. It must be used inconjunction with a data model that contains the <link linkend="Frag">Frag</link> element as it&#8217;s first and only element. The <emphasis>infrag</emphasis> action will utalize the fragmentation algorithm from the <emphasis>Frag</emphasis> element to identify when to stop receiving fragments. One or more <link linkend="Action_input">input</link> actions will be performed until the fragmentation algorithm is satisfied or a timeout occurs. Each <emphasis>input</emphasis> action that occurs will crack incoming data into a copy of the <emphasis>Frag</emphasis>'s <emphasis>Template</emphasis> element and added to the <emphasis>Rendering</emphasis> sequence element.</simpara>
<simpara>Once all of the fragments have been received they will be reconstructed and cracked into the <emphasis>Frag</emphasis> elements <emphasis>Payload</emphasis> element. After the <emphasis>infrag</emphasis> action has successfully been run values can be slurped from the <emphasis>Payload</emphasis> element or the <emphasis>Rendering</emphasis> sequence element.</simpara>
<simpara>See also: <link linkend="Frag">Frag</link>, <link linkend="Action_outfrag">outfrag</link>, <link linkend="Action_input">input</link>.</simpara>
<sidebar>
<title>Input Timeout</title>
<simpara>If the input time out is reached prior to all incoming data being received, Peach behaves as follows:</simpara>
<variablelist>
<varlistentry>
<term><link linkend="Iteration_record">Timeout during a record iteration</link></term>
<listitem>
<simpara>When a record iteration generates errors, Peach assumes the environment is not working correctly or the pit is incorrect.   In both cases, fuzzing cannot continue.
Peach throws an exception and stops.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Iteration_control">Timeout during a control iteration</link></term>
<listitem>
<simpara>Control iterations must be enabled to reach for this state.
Control iterations assume that any error is the result of the target entering an unwanted state. Peach triggers a fault.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Iteration_fuzzing">Timeout during a fuzzing iteration</link></term>
<listitem>
<simpara>Peach continues fuzzing with the  next iteration.
During normal fuzzing iterations, Peach assumes fuzzing causes odd behaviors from the target that are ignored, unless they occur during a control iteration.</simpara>
</listitem>
</varlistentry>
</variablelist>
</sidebar>
<sidebar>
<title>Default Order of Actions</title>
<simpara>The following is the default order in which Actions are performed when fuzzing:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara><emphasis>start</emphasis> - Implicit, once per session</simpara>
</listitem>
<listitem>
<simpara><emphasis>open</emphasis> - Implicit, once per iteration</simpara>
</listitem>
<listitem>
<simpara>Explicit actions (such as <emphasis>accept</emphasis>, <emphasis>input</emphasis>, <emphasis>infrag</emphasis>, <emphasis>output</emphasis> and <emphasis>outfrag</emphasis>)</simpara>
</listitem>
<listitem>
<simpara><emphasis>close</emphasis> - Implicit, once per iteration</simpara>
</listitem>
<listitem>
<simpara><emphasis>stop</emphasis> - Implicit, once per session</simpara>
</listitem>
</orderedlist>
</sidebar>
<section xml:id="_syntax_80">
<title>Syntax</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;StateModel name="TheStateModel" initialState="InitialState"&gt;
  &lt;State name="InitialState"&gt;

    &lt;Action type="infrag"&gt;
      &lt;DataModel ref="ModelWithFragElement" /&gt;
    &lt;/Action&gt;

  &lt;/State&gt;
&lt;/StateModel&gt;</programlisting>
</section>
<section xml:id="_attributes_88">
<title>Attributes</title>
<simpara><emphasis>Required:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>type</term>
<listitem>
<simpara>Action type, must be set to "infrag"</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>name</term>
<listitem>
<simpara>Name used to identify the action</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>publisher</term>
<listitem>
<simpara>Name of the publisher to perform this action</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_when">when</link></term>
<listitem>
<simpara>Perform action if the provided expression evaluates to true</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_onStart">onStart</link></term>
<listitem>
<simpara>Evaluate expression at the start of an action.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_onComplete">onComplete</link></term>
<listitem>
<simpara>Evaluate expression upon completion of an action</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_child_elements_50">
<title>Child Elements</title>
<variablelist>
<varlistentry>
<term><link linkend="DataModel">DataModel</link></term>
<listitem>
<simpara>Reference to a DataModel that will receive cracked input data</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_114">
<title>Examples</title>
<example>
<title>Receiving Input from TCP Publisher</title>
<simpara>A simple fragmented protocol in which each fragment has a single byte of payload data prefixed with the total length of data expected. The provided payload <literal>example.txt</literal> contains 4 bytes of data resulting in 4 fragments.</simpara>
<formalpara>
<title>example.xml</title>
<para>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach	xmlns="http://peachfuzzer.com/2012/Peach"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xsi:schemaLocation="http://peachfuzzer.com/2012/Peach /peach/peach.xsd"&gt;

    &lt;DataModel name="Fragmented"&gt;
        &lt;Frag fragLength="1" totalLengthField="TotalLength"&gt;

            &lt;Block name="Template"&gt;
                &lt;String name="TotalLength" length="1"/&gt;
                &lt;Blob name="FragData" length="1" /&gt;
            &lt;/Block&gt;

            &lt;Block name="Payload"&gt;
                &lt;String name="Value" /&gt;
            &lt;/Block&gt;
        &lt;/Frag&gt;
	&lt;/DataModel&gt;

	&lt;StateModel name="TheState" initialState="Initial"&gt;
		&lt;State name="Initial"&gt;
			&lt;Action type="infrag"&gt;
				&lt;DataModel ref="Fragmented"/&gt;
			&lt;/Action&gt;
		&lt;/State&gt;
	&lt;/StateModel&gt;

	&lt;Test name="Default"&gt;
		&lt;StateModel ref="TheState"/&gt;
		&lt;Publisher class="Tcp"&gt;
			&lt;Param name="Host" value="127.0.0.1"/&gt;
			&lt;Param name="Port" value="6666"/&gt;
		&lt;/Publisher&gt;
	&lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
</para>
</formalpara>
<formalpara>
<title>example.txt</title>
<para>
<screen>4T4e4s4t</screen>
</para>
</formalpara>
<simpara>Prior to running Peach start a netcat listener using the following command line.  This will provide the fragments to Peach.</simpara>
<literallayout class="monospaced">nc -vv 127.0.0.1 6666 &lt; example.txt</literallayout>
<simpara>Run peach:</simpara>
<screen>&gt; peach -1 --debug example.xml

[*] Web site running at: http://10.0.1.87:8888/

[*] Test 'Default' starting with random seed 61424.
2016-07-07 16:59:13.0764 Peach.Pro.Core.Loggers.JobLogger Writing debug.log to: C:\peach-pro\output\win_x64_debug\bin\Logs\example.xml_20160707165911\debug.log

[R1,-,-] Performing iteration
2016-07-07 16:59:13.2186 Peach.Core.Engine runTest: Performing control recording iteration.
2016-07-07 16:59:13.2344 Peach.Pro.Core.Dom.Frag Generating fragments:
2016-07-07 16:59:13.2344 Peach.Core.Dom.StateModel Run(): Changing to state "Initial".
2016-07-07 16:59:13.2554 Peach.Core.Dom.Action Run(Action): Infrag
2016-07-07 16:59:13.2554 Peach.Pro.Core.Publishers.TcpClientPublisher start()
2016-07-07 16:59:13.2554 Peach.Pro.Core.Publishers.TcpClientPublisher open()
2016-07-07 16:59:13.2684 Peach.Pro.Core.Publishers.TcpClientPublisher input()
2016-07-07 16:59:13.2684 Peach.Pro.Core.Publishers.TcpClientPublisher Read 8 bytes from 127.0.0.1:6666
2016-07-07 16:59:13.2684 Peach.Pro.Core.Publishers.TcpClientPublisher

00000000   34 54 34 65 34 73 34 74                            4T4e4s4t

2016-07-07 16:59:13.2684 Peach.Pro.Core.Publishers.TcpClientPublisher Read 0 bytes from 127.0.0.1:6666, closing client connection.
2016-07-07 16:59:13.2684 Peach.Pro.Core.Publishers.TcpClientPublisher Closing connection to 127.0.0.1:6666
2016-07-07 16:59:13.2854 DataCracker -+ Block 'Frag_1', Bytes: 0/8, Bits: 0/64
2016-07-07 16:59:13.2964 DataCracker  | Size: ??? (Deterministic)
2016-07-07 16:59:13.2964 DataCracker  |-- String 'TotalLength', Bytes: 0/8, Bits: 0/64
2016-07-07 16:59:13.2964 DataCracker  |   Size: 1 bytes | 8 bits (Has Length)
2016-07-07 16:59:13.2964 DataCracker  |   Value: 4
2016-07-07 16:59:13.3135 DataCracker  |-- Blob 'FragData', Bytes: 1/8, Bits: 8/64
2016-07-07 16:59:13.3135 DataCracker  |   Size: 1 bytes | 8 bits (Has Length)
2016-07-07 16:59:13.3135 DataCracker  |   Value: 54
2016-07-07 16:59:13.3135 DataCracker  /
2016-07-07 16:59:13.3135 Peach.Pro.Core.Dom.Actions.Infrag Fragment 1: pos: 2 length: 8 crack consumed: 2 bytes <co xml:id="CO55-1"/>
2016-07-07 16:59:13.3135 Peach.Pro.Core.Publishers.TcpClientPublisher input()
2016-07-07 16:59:13.3135 DataCracker -+ Block 'Frag_2', Bytes: 2/8, Bits: 16/64
2016-07-07 16:59:13.3135 DataCracker  | Size: ??? (Deterministic)
2016-07-07 16:59:13.3135 DataCracker  |-- String 'TotalLength', Bytes: 2/8, Bits: 16/64
2016-07-07 16:59:13.3135 DataCracker  |   Size: 1 bytes | 8 bits (Has Length)
2016-07-07 16:59:13.3135 DataCracker  |   Value: 4
2016-07-07 16:59:13.3135 DataCracker  |-- Blob 'FragData', Bytes: 3/8, Bits: 24/64
2016-07-07 16:59:13.3135 DataCracker  |   Size: 1 bytes | 8 bits (Has Length)
2016-07-07 16:59:13.3135 DataCracker  |   Value: 65
2016-07-07 16:59:13.3135 DataCracker  /
2016-07-07 16:59:13.3135 Peach.Pro.Core.Dom.Actions.Infrag Fragment 2: pos: 4 length: 8 crack consumed: 2 bytes <co xml:id="CO55-2"/>
2016-07-07 16:59:13.3135 Peach.Pro.Core.Publishers.TcpClientPublisher input()
2016-07-07 16:59:13.3135 DataCracker -+ Block 'Frag_3', Bytes: 4/8, Bits: 32/64
2016-07-07 16:59:13.3135 DataCracker  | Size: ??? (Deterministic)
2016-07-07 16:59:13.3135 DataCracker  |-- String 'TotalLength', Bytes: 4/8, Bits: 32/64
2016-07-07 16:59:13.3135 DataCracker  |   Size: 1 bytes | 8 bits (Has Length)
2016-07-07 16:59:13.3135 DataCracker  |   Value: 4
2016-07-07 16:59:13.3135 DataCracker  |-- Blob 'FragData', Bytes: 5/8, Bits: 40/64
2016-07-07 16:59:13.3135 DataCracker  |   Size: 1 bytes | 8 bits (Has Length)
2016-07-07 16:59:13.3135 DataCracker  |   Value: 73
2016-07-07 16:59:13.3135 DataCracker  /
2016-07-07 16:59:13.3135 Peach.Pro.Core.Dom.Actions.Infrag Fragment 3: pos: 6 length: 8 crack consumed: 2 bytes <co xml:id="CO55-3"/>
2016-07-07 16:59:13.3135 Peach.Pro.Core.Publishers.TcpClientPublisher input()
2016-07-07 16:59:13.3135 DataCracker -+ Block 'Frag_4', Bytes: 6/8, Bits: 48/64
2016-07-07 16:59:13.3135 DataCracker  | Size: ??? (Deterministic)
2016-07-07 16:59:13.3135 DataCracker  |-- String 'TotalLength', Bytes: 6/8, Bits: 48/64
2016-07-07 16:59:13.3135 DataCracker  |   Size: 1 bytes | 8 bits (Has Length)
2016-07-07 16:59:13.3135 DataCracker  |   Value: 4
2016-07-07 16:59:13.3135 DataCracker  |-- Blob 'FragData', Bytes: 7/8, Bits: 56/64
2016-07-07 16:59:13.3135 DataCracker  |   Size: 1 bytes | 8 bits (Has Length)
2016-07-07 16:59:13.3135 DataCracker  |   Value: 74
2016-07-07 16:59:13.3135 DataCracker  /
2016-07-07 16:59:13.3135 Peach.Pro.Core.Dom.Actions.Infrag Fragment 4: pos: 8 length: 8 crack consumed: 2 bytes <co xml:id="CO55-4"/>
2016-07-07 16:59:13.3265 Peach.Pro.Core.Dom.Actions.Infrag Reassembled fragment is 4 bytes <co xml:id="CO55-5"/>
2016-07-07 16:59:13.3265 DataCracker -+ DataModel 'Fragmented', Bytes: 8/8, Bits: 64/64
2016-07-07 16:59:13.3265 DataCracker  | Size: ??? (Deterministic)
2016-07-07 16:59:13.3265 DataCracker  |-+ Frag 'DataElement_0', Bytes: 8/8, Bits: 64/64
2016-07-07 16:59:13.3265 DataCracker  | | Size: ??? (Deterministic)
2016-07-07 16:59:13.3265 DataCracker  | | Cracking Payload
2016-07-07 16:59:13.3265 DataCracker  | |-+ Block 'Payload', Bytes: 0/4, Bits: 0/32
2016-07-07 16:59:13.3265 DataCracker  | | | Size: ??? (Deterministic)
2016-07-07 16:59:13.3265 DataCracker  | | |-- String 'Value', Bytes: 0/4, Bits: 0/32
2016-07-07 16:59:13.3265 DataCracker  | | |   Size: 4 bytes | 32 bits (Last Unsized)
2016-07-07 16:59:13.3265 DataCracker  | | |   Value: Test
2016-07-07 16:59:13.3265 DataCracker  | | /
2016-07-07 16:59:13.3265 DataCracker  | /
2016-07-07 16:59:13.3265 DataCracker  /
2016-07-07 16:59:13.3265 Peach.Pro.Core.Dom.Actions.Infrag Final pos: 8 length: 8 crack consumed: 8 bytes
2016-07-07 16:59:13.3265 Peach.Pro.Core.Publishers.TcpClientPublisher close()
2016-07-07 16:59:13.3495 Peach.Core.Engine runTest: context.config.singleIteration == true
2016-07-07 16:59:13.3495 Peach.Pro.Core.Publishers.TcpClientPublisher stop()
2016-07-07 16:59:13.3495 Peach.Core.Engine EndTest: Stopping all agents and monitors

[*] Test 'Default' finished.</screen>
<calloutlist>
<callout arearefs="CO55-1">
<para>First fragment cracked</para>
</callout>
<callout arearefs="CO55-2">
<para>Second fragment cracked</para>
</callout>
<callout arearefs="CO55-3">
<para>Third fragment cracked</para>
</callout>
<callout arearefs="CO55-4">
<para>Forth and final fragment cracked</para>
</callout>
<callout arearefs="CO55-5">
<para>Data reassembled and starting crack into Payload element.</para>
</callout>
</calloutlist>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Action_output">
<title>output</title>
<simpara>The <emphasis>output</emphasis> action writes or sends data using a <link linkend="Publisher">Publisher</link>.
<emphasis>output</emphasis> Actions are associated with a <link linkend="DataModel">DataModel</link> (specified as a child element) that produces the data to be sent.</simpara>
<simpara>Along with a DataModel, data sets can be provided using the <link linkend="Data">Data</link> element.
Multiple Data elements can be provided that are switched between during fuzzing depending on the fuzzing strategy used.
<emphasis>Output</emphasis> actions are fuzzed by Peach.</simpara>
<simpara>When output is called, the fuzzer implicitly calls <link linkend="Action_start"><emphasis>start</emphasis></link> then <link linkend="Action_open"><emphasis>open</emphasis></link>, if they have not yet been called.
If a Pit defines multiple publishers, the <emphasis>publisher</emphasis> attribute specifies the publisher that performs the write/send request.
The exact behavior of an <emphasis>output</emphasis> action is Publisher dependent. Review the documentation for a specific Publisher for details on its implementation actions. For example, calling output multiple times in succession on a stream publisher such as <link linkend="Publishers_Tcp">TCP</link> appears in the logs as one output, whereas issuing multiple outputs in succession for the <link linkend="Publishers_Udp">UDP</link> publisher sends the data as separate UDP Packets and lists in the logs as separate calls.</simpara>
<sidebar>
<title>Default Order of Actions</title>
<simpara>The following is the default order in which Actions are performed when fuzzing:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara><emphasis>start</emphasis> - Implicit, once per session</simpara>
</listitem>
<listitem>
<simpara><emphasis>open</emphasis> - Implicit, once per iteration</simpara>
</listitem>
<listitem>
<simpara>Explicit actions (such as <emphasis>accept</emphasis>, <emphasis>input</emphasis>, and <emphasis>output</emphasis>)</simpara>
</listitem>
<listitem>
<simpara><emphasis>close</emphasis> - Implicit, once per iteration</simpara>
</listitem>
<listitem>
<simpara><emphasis>stop</emphasis> - Implicit, once per session</simpara>
</listitem>
</orderedlist>
</sidebar>
<section xml:id="_syntax_81">
<title>Syntax</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;StateModel name="TheStateModel" initialState="InitialState"&gt;
  &lt;State name="InitialState"&gt;
    &lt;Action type="output"&gt;
       &lt;DataModel ref="SomeDataModel" /&gt;
    &lt;/Action&gt;

    &lt;Action type="output"&gt;
       &lt;DataModel ref="SomeDataModel" /&gt;
       &lt;Data name="SomeSampleData" fileName="sample.bin" /&gt;
    &lt;/Action&gt;
  &lt;/State&gt;
&lt;/StateModel&gt;</programlisting>
</section>
<section xml:id="_attributes_89">
<title>Attributes</title>
<simpara><emphasis>Required:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>type</term>
<listitem>
<simpara>Action type, must be set to "output"</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>name</term>
<listitem>
<simpara>Name used to identify the action</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>publisher</term>
<listitem>
<simpara>Name of the publisher to perform this action</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_when">when</link></term>
<listitem>
<simpara>Perform the action if the provided expression evaluates to true</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_onStart">onStart</link></term>
<listitem>
<simpara>Evaluate expression at the start of an action.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_onComplete">onComplete</link></term>
<listitem>
<simpara>Evaluate expression upon completion of an action</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_child_elements_51">
<title>Child Elements</title>
<variablelist>
<varlistentry>
<term><link linkend="DataModel">DataModel</link></term>
<listitem>
<simpara>Reference to a DataModel supplying data to fuzz</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Data">Data</link></term>
<listitem>
<simpara>Set of initial data to crack into the above DataModel before fuzzing</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_115">
<title>Examples</title>
<example>
<title>File fuzzing with <emphasis>output</emphasis> action</title>
<simpara>Example of using the <emphasis>output</emphasis> action with multiple data sets to perform file fuzzing.
This is a typical configuration for dumb file fuzzing.</simpara>
<simpara>Notice the special publisher <emphasis>Peach.Agent</emphasis>.
This publisher sends the <emphasis>call</emphasis> action to all Agents, who in turn, forward the <emphasis>call</emphasis>  to each associated Monitor.
The method call is handled by the WindowsDebugger monitor, causing it to launch <emphasis>notepad.exe</emphasis>.
For file fuzzing, note that the target is launched after creating the new fuzzed file.</simpara>
<simpara>This example runs on the Windows&#174; Operating System, version XP or newer, with Windows Debugging Tools installed.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Save example Pit as "example.xml"</simpara>
</listitem>
<listitem>
<simpara>Run "Peach.exe --range 1,10 --debug example.xml"</simpara>
</listitem>
<listitem>
<simpara>You should see <emphasis>mspaint.exe</emphasis> open and close several times.</simpara>
</listitem>
</orderedlist>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

  &lt;DataModel name="DumbModel"&gt;
    &lt;Blob /&gt;
  &lt;/DataModel&gt;

  &lt;StateModel name="State" initialState="Initial"&gt;
    &lt;State name="Initial"&gt;

      &lt;Action type="output"&gt;
        &lt;DataModel ref="DumbModel" /&gt;

		&lt;!-- provide a folder of files to fuzz --&gt;
		&lt;Data fileName="##Peach.Pwd##\samples_png" /&gt;
      &lt;/Action&gt;

      &lt;!-- Close file --&gt;
      &lt;Action type="close" /&gt;

      &lt;!-- Launch the file consumer --&gt;
      &lt;Action type="call" method="ScoobySnacks" publisher="Peach.Agent"/&gt;

    &lt;/State&gt;
  &lt;/StateModel&gt;

  &lt;Agent name="LocalAgent"&gt;
    &lt;Monitor class="WindowsDebugger"&gt;
      &lt;Param name="Executable" value="c:\windows\system32\mspaint.exe /&gt;
      &lt;Param name="Arguments" value="fuzzed.png" /&gt;
      &lt;Param name="StartOnCall" value="ScoobySnacks" /&gt;
    &lt;/Monitor&gt;
  &lt;/Agent&gt;

  &lt;Test name="Default"&gt;
    &lt;Agent ref="LocalAgent" /&gt;
    &lt;StateModel ref="State"/&gt;

    &lt;Publisher class="File"&gt;
      &lt;Param name="FileName" value="fuzzed.png" /&gt;
    &lt;/Publisher&gt;
  &lt;/Test&gt;

&lt;/Peach&gt;</programlisting>
</example>
<example>
<title>Sending Output with TCP Publisher</title>
<simpara>This example uses the <emphasis>output</emphasis> action to send data. Netcat (nc) is used in this example as the client.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

  &lt;!-- Marking the string as a token will imply a length of 4 characters --&gt;
  &lt;DataModel name="Ping"&gt;
    &lt;String value="PING" token="true"/&gt;
  &lt;/DataModel&gt;

  &lt;DataModel name="Pong"&gt;
    &lt;String value="PONG" /&gt;
  &lt;/DataModel&gt;

  &lt;StateModel name="TheStateModel" initialState="InitialState"&gt;
    &lt;State name="InitialState"&gt;
      &lt;Action type="accept" /&gt;

      &lt;Action type="input"&gt;
        &lt;DataModel ref="Ping"/&gt;
      &lt;/Action&gt;

      &lt;Action type="output"&gt;
        &lt;DataModel ref="Pong"/&gt;
      &lt;/Action&gt;
    &lt;/State&gt;
  &lt;/StateModel&gt;

  &lt;Test name="Default"&gt;
    &lt;StateModel ref="TheStateModel"/&gt;

    &lt;Publisher class="TcpListener"&gt;
      &lt;Param name="Interface" value="0.0.0.0" /&gt;
      &lt;Param name="Port" value="31337" /&gt;
      &lt;Param name="AcceptTimeout" value="10000" /&gt;
      &lt;Param name="Timeout" value="10000" /&gt;
    &lt;/Publisher&gt;

    &lt;Logger class="File" &gt;
      &lt;Param name="Path" value="logs"/&gt;
    &lt;/Logger&gt;
  &lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Output from this example. Once Peach is started, use the netcat command line to recreate output. Type the following command line and press RETURN to start netcat.</simpara>
<simpara>nc -vv 127.0.0.1 31337</simpara>
<screen>&gt; peach -1 --debug example.xml

[*] Test 'Default' starting with random seed 32331.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Accept
Peach.Core.Publishers.TcpListenerPublisher start()
Peach.Core.Publishers.TcpListenerPublisher open()
Peach.Core.Publishers.TcpListenerPublisher accept()
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Input
Peach.Core.Publishers.TcpListenerPublisher input()                           <co xml:id="CO56-1"/>
Peach.Core.Publishers.TcpListenerPublisher Read 5 bytes from 127.0.0.1:62407
Peach.Core.Publishers.TcpListenerPublisher

00000000   50 49 4E 47 0A                                     PING.

Peach.Core.Cracker.DataCracker ------------------------------------          <co xml:id="CO56-2"/>
Peach.Core.Cracker.DataCracker DataModel 'Ping' Bytes: 0/5, Bits: 0/40
Peach.Core.Cracker.DataCracker getSize: -----&gt; DataModel 'Ping'
Peach.Core.Cracker.DataCracker scan: DataModel 'Ping'
Peach.Core.Cracker.DataCracker scan: String 'Ping.DataElement_0' -&gt; Pos: 0, Saving Token
Peach.Core.Cracker.DataCracker scan: String 'Ping.DataElement_0' -&gt; Pos: 32, Length: 32
Peach.Core.Cracker.DataCracker getSize: &lt;----- Deterministic: ???
Peach.Core.Cracker.DataCracker Crack: DataModel 'Ping' Size: &lt;null&gt;, Bytes: 0/5, Bits: 0/40
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker String 'Ping.DataElement_0' Bytes: 0/5, Bits: 0/40
Peach.Core.Cracker.DataCracker getSize: -----&gt; String 'Ping.DataElement_0'
Peach.Core.Cracker.DataCracker scan: String 'Ping.DataElement_0' -&gt; Pos: 0, Saving Token
Peach.Core.Cracker.DataCracker scan: String 'Ping.DataElement_0' -&gt; Pos: 32, Length: 32
Peach.Core.Cracker.DataCracker getSize: &lt;----- Size: 32
Peach.Core.Cracker.DataCracker Crack: String 'Ping.DataElement_0' Size: 32, Bytes: 0/5, Bits: 0/40
Peach.Core.Dom.DataElement String 'Ping.DataElement_0' value is: PING
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.TcpListenerPublisher output(4 bytes)
Peach.Core.Publishers.TcpListenerPublisher

00000000   50 4F 4E 47                                        PONG

Peach.Core.Publishers.TcpListenerPublisher close()
Peach.Core.Publishers.TcpListenerPublisher Shutting down connection to 127.0.0.1:62407
Peach.Core.Publishers.TcpListenerPublisher Read 0 bytes from 127.0.0.1:62407, closing client connection.
Peach.Core.Publishers.TcpListenerPublisher Closing connection to 127.0.0.1:62407

Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.TcpListenerPublisher stop()

[*] Test 'Default' finished.</screen>
<calloutlist>
<callout arearefs="CO56-1">
<para>Data received by TCP publisher</para>
</callout>
<callout arearefs="CO56-2">
<para>Debugging output from the data cracker</para>
</callout>
</calloutlist>
<simpara>Netcat command line. Once Netcat is running, type "PING" in upper case letters and press RETURN. Peach responds with "PONG".</simpara>
<screen>&gt; nc -vv 127.0.0.1 31337
Connection to 127.0.0.1 31337 port [tcp/*] succeeded!
PING
PONG</screen>
</example>
<example>
<title>Multiple Publishers with <emphasis>output</emphasis> Action</title>
<simpara>This example uses the <emphasis>output</emphasis> action with multiple publishers to write two files out on every iteration.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Save example Pit as "example.xml"</simpara>
</listitem>
<listitem>
<simpara>Run "Peach.exe -1 --debug example.xml"</simpara>
</listitem>
<listitem>
<simpara>You should see two files, fuzzed1.txt and fuzzed2.txt, created.</simpara>
</listitem>
</orderedlist>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

  &lt;DataModel name="File1Model"&gt;
    &lt;String value="I'm file #1" /&gt;
  &lt;/DataModel&gt;

  &lt;DataModel name="File2Model"&gt;
    &lt;String value="I'm file #2" /&gt;
  &lt;/DataModel&gt;

  &lt;StateModel name="State" initialState="Initial"&gt;
    &lt;State name="Initial"&gt;

      &lt;Action type="output" publisher="File1"&gt;
        &lt;DataModel ref="File1Model" /&gt;
      &lt;/Action&gt;

      &lt;Action type="output" publisher="File2"&gt;
        &lt;DataModel ref="File2Model" /&gt;
      &lt;/Action&gt;

    &lt;/State&gt;
  &lt;/StateModel&gt;

  &lt;Test name="Default"&gt;
    &lt;StateModel ref="State"/&gt;

    &lt;Publisher name="File1" class="File"&gt;
      &lt;Param name="FileName" value="fuzzed1.txt" /&gt;
    &lt;/Publisher&gt;

    &lt;Publisher name="File2" class="File"&gt;
      &lt;Param name="FileName" value="fuzzed2.txt" /&gt;
    &lt;/Publisher&gt;
  &lt;/Test&gt;

&lt;/Peach&gt;</programlisting>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Action_outfrag">
<title>outfrag</title>
<simpara>The <emphasis>outfrag</emphasis> action is a special action to perform fragemented output. It must be used inconjunction with a data model that contains the <link linkend="Frag">Frag</link> element as it&#8217;s first and only element. The <emphasis>outfrag</emphasis> action will perform multiple <link linkend="Action_output">output</link> actions to send all the fragments in the <emphasis>Rendering</emphasis> sequence collection. These fragments are generated by the fragmentation algorithm associated with the <emphasis>Frag</emphasis> element.</simpara>
<simpara>See also: <link linkend="Frag">Frag</link>, <link linkend="Action_infrag">infrag</link>, <link linkend="Action_output">output</link>.</simpara>
<sidebar>
<title>Default Order of Actions</title>
<simpara>The following is the default order in which Actions are performed when fuzzing:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara><emphasis>start</emphasis> - Implicit, once per session</simpara>
</listitem>
<listitem>
<simpara><emphasis>open</emphasis> - Implicit, once per iteration</simpara>
</listitem>
<listitem>
<simpara>Explicit actions (such as <emphasis>accept</emphasis>, <emphasis>input</emphasis>, <emphasis>infrag</emphasis>, <emphasis>output</emphasis> and <emphasis>outfrag</emphasis>)</simpara>
</listitem>
<listitem>
<simpara><emphasis>close</emphasis> - Implicit, once per iteration</simpara>
</listitem>
<listitem>
<simpara><emphasis>stop</emphasis> - Implicit, once per session</simpara>
</listitem>
</orderedlist>
</sidebar>
<section xml:id="_syntax_82">
<title>Syntax</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;StateModel name="TheStateModel" initialState="InitialState"&gt;
  &lt;State name="InitialState"&gt;

    &lt;Action type="outfrag"&gt;
      &lt;DataModel ref="ModelWithFragElement" /&gt;
    &lt;/Action&gt;

  &lt;/State&gt;
&lt;/StateModel&gt;</programlisting>
</section>
<section xml:id="_attributes_90">
<title>Attributes</title>
<simpara><emphasis>Required:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>type</term>
<listitem>
<simpara>Action type, must be set to "outfrag"</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>name</term>
<listitem>
<simpara>Name used to identify the action</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>publisher</term>
<listitem>
<simpara>Name of the publisher to perform this action</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_when">when</link></term>
<listitem>
<simpara>Perform action if the provided expression evaluates to true</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_onStart">onStart</link></term>
<listitem>
<simpara>Evaluate expression at the start of an action.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_onComplete">onComplete</link></term>
<listitem>
<simpara>Evaluate expression upon completion of an action</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_child_elements_52">
<title>Child Elements</title>
<variablelist>
<varlistentry>
<term><link linkend="DataModel">DataModel</link></term>
<listitem>
<simpara>Reference to a DataModel supplying data to fuzz</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Data">Data</link></term>
<listitem>
<simpara>Set of initial data to crack into the above DataModel before fuzzing</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_116">
<title>Examples</title>
<example>
<title>Simple Example</title>
<simpara>Produce three fragments with each fragment contianing the current fragment lenght, fragement sequence and total length of data. The Payload is 30 bytes of 0x41.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
			 xsi:schemaLocation="http://peachfuzzer.com/2012/Peach /peach/peach.xsd"&gt;

    &lt;DataModel name="Fragmented"&gt;
        &lt;Frag fragLength="10"
              totalLengthField="TotalLength"
              fragmentLengthField="FragLength"
              fragmentIndexField="FragIndex"&gt;

            &lt;Block name="Template"&gt;
                &lt;Number name="FragLength" size="32"/&gt;
                &lt;Number name="FragIndex" size="32"/&gt;
                &lt;Number name="TotalLength" size="32"/&gt;

                &lt;Blob name="FragData" /&gt;
            &lt;/Block&gt;

            &lt;Block name="Payload"&gt;
                &lt;Blob valueType="hex" value="
                    41 41 41 41 41 41 41 41 41 41
                    41 41 41 41 41 41 41 41 41 41
                    41 41 41 41 41 41 41 41 41 41"/&gt;
            &lt;/Block&gt;
        &lt;/Frag&gt;
	&lt;/DataModel&gt;

	&lt;StateModel name="TheState" initialState="Initial"&gt;
		&lt;State name="Initial"&gt;
			&lt;Action type="outfrag"&gt;
				&lt;DataModel ref="Fragmented"/&gt;
			&lt;/Action&gt;
		&lt;/State&gt;
	&lt;/StateModel&gt;

	&lt;Test name="Default"&gt;
		&lt;StateModel ref="TheState"/&gt;
		&lt;Publisher class="ConsoleHex"/&gt;
	&lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>The example pit will produce three fragments with 10 bytes of payload per-fragment.</simpara>
<simpara>Output from this example:</simpara>
<screen>&gt;peach -1 --debug BoolExample1.xml

[*] Web site running at: http://10.0.1.87:8888/

[*] Test 'Default' starting with random seed 7010.
2016-07-07 14:26:22.2979 Peach.Pro.Core.Loggers.JobLogger Writing debug.log to: C:\peach-pro\output\win_x64_debug\bin\Logs\example.xml_20160707142621\debug.log

[R1,-,-] Performing iteration
2016-07-07 14:26:22.4288 Peach.Core.Engine runTest: Performing control recording iteration.
2016-07-07 14:26:22.4690 Peach.Pro.Core.Dom.Frag Generating fragments:
2016-07-07 14:26:22.4870 Peach.Core.Dom.StateModel Run(): Changing to state "Initial".
2016-07-07 14:26:22.4951 Peach.Core.Dom.Action Run(Action): Outfrag
2016-07-07 14:26:22.6139 Peach.Pro.Core.Publishers.ConsolePublisher start()
2016-07-07 14:26:22.6139 Peach.Pro.Core.Publishers.ConsolePublisher open()
2016-07-07 14:26:22.6188 Peach.Pro.Core.Publishers.ConsolePublisher output(22 bytes) <co xml:id="CO57-1"/>
00000000   0A 00 00 00 01 00 00 00  1E 00 00 00 41 41 41 41   ............AAAA
00000010   41 41 41 41 41 41                                  AAAAAA
2016-07-07 14:26:22.6188 Peach.Pro.Core.Publishers.ConsolePublisher output(22 bytes) <co xml:id="CO57-2"/>
00000000   0A 00 00 00 02 00 00 00  1E 00 00 00 41 41 41 41   ............AAAA
00000010   41 41 41 41 41 41                                  AAAAAA
2016-07-07 14:26:22.6188 Peach.Pro.Core.Publishers.ConsolePublisher output(22 bytes) <co xml:id="CO57-3"/>
00000000   0A 00 00 00 03 00 00 00  1E 00 00 00 41 41 41 41   ............AAAA
00000010   41 41 41 41 41 41                                  AAAAAA
2016-07-07 14:26:22.6188 Peach.Pro.Core.Publishers.ConsolePublisher close()
2016-07-07 14:26:22.6329 Peach.Core.Engine runTest: context.config.singleIteration == true
2016-07-07 14:26:22.6329 Peach.Pro.Core.Publishers.ConsolePublisher stop()
2016-07-07 14:26:22.6329 Peach.Core.Engine EndTest: Stopping all agents and monitors

[*] Test 'Default' finished.</screen>
<calloutlist>
<callout arearefs="CO57-1">
<para>First fragment. Notice sequence number is 1.</para>
</callout>
<callout arearefs="CO57-2">
<para>Second fragment. Notice sequence number is 2.</para>
</callout>
<callout arearefs="CO57-3">
<para>Third fragment. Notice sequence number is 3.</para>
</callout>
</calloutlist>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Action_call">
<title>call</title>
<simpara>The <emphasis>call</emphasis> action provides a method-calling metaphor in Peach state models. The <emphasis>call</emphasis> action is useful
when fuzzing targets interact with the method metaphor. In these instances, the interesting fuzzing data
is typically in the calling parameters. Examples of interactions that use a method-call metaphor
include Microsoft COM/DCOM, Web Services, and RPC.</simpara>
<simpara>Call actions support zero or more (user-defined and supplied) parameters and a resulting return value.</simpara>
<itemizedlist>
<listitem>
<simpara>If the method has no parameters, the <emphasis>call</emphasis> action performs the call.</simpara>
</listitem>
<listitem>
<simpara>If the method has user-supplied parameters, the <emphasis>call</emphasis> action includes the parameters as items to fuzz.</simpara>
</listitem>
<listitem>
<simpara>If the method has a return value, the <emphasis>call</emphasis> action can captures the return value and cracks the data into the provided <emphasis>DataModel</emphasis>.</simpara>
</listitem>
</itemizedlist>
<simpara>As with the <link linkend="Action_output"><emphasis>output</emphasis></link> action, a single data model can represent a single parameter along with zero or more <link linkend="Data">Data</link> sets.
If the resulting return value is captured, Peach considers it input and cracks the return value in the provided DataModel.</simpara>
<sidebar>
<title>Interacting with Agents and Monitors</title>
<simpara>Peach supports a specialized use of the <emphasis>call</emphasis> action to interact with <link linkend="Agent">Agents</link> and <link linkend="Monitors">Monitors</link>.
A special Publisher called <emphasis>Peach.Agent</emphasis> sends the <emphasis>call</emphasis> action to all configured Agents. In turn, each Agent forwards
the <emphasis>call</emphasis> action to its associated monitors. If a monitor supports interaction via the <emphasis>call</emphasis> action,
documentation for that monitor will describe the interaction associated with <emphasis>call</emphasis>.</simpara>
<simpara>An instance of using the <emphasis>call</emphasis> action to interact with <link linkend="Agent">Agents</link> and <link linkend="Monitors">Monitors</link> is provided in the examples section.</simpara>
<note>
<simpara>Pits in the Peach Pit Library have two pre-defined methods for the <emphasis>call</emphasis> action that some monitors use for iteration-based interaction:<?asciidoc-br?>
* <emphasis>StartIterationEvent</emphasis> performs actions at the start of each iteration<?asciidoc-br?>
* <emphasis>ExitIterationEvent</emphasis> performs actions at the end of each iteration</simpara>
</note>
</sidebar>
<formalpara>
<title><emphasis>Param</emphasis> and the <emphasis>call</emphasis> action</title>
<para>
<literallayout class="monospaced">xref:Param[Param] can be used as a _call_ action argument. It is used for configuration settings and provides a key-value pair to the parent element.</literallayout>
</para>
</formalpara>
<sidebar>
<title>Default Order of Actions</title>
<simpara>The following is the default order in which Actions are performed when fuzzing:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>start - Implicit, once per session</simpara>
</listitem>
<listitem>
<simpara>open - Implicit, once per iteration</simpara>
</listitem>
<listitem>
<simpara>Explicit actions (such as accept, input, and output)</simpara>
</listitem>
<listitem>
<simpara>close - Implicit, once per iteration</simpara>
</listitem>
<listitem>
<simpara>stop - Implicit, once per session</simpara>
</listitem>
</orderedlist>
</sidebar>
<section xml:id="_syntax_83">
<title>Syntax</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;StateModel name="TheStateModel" initialState="InitialState"&gt;
	&lt;State name="InitialState"&gt;
		&lt;Action type="call" method="openUrl"&gt;

		  &lt;Param name="p1"&gt;
        &lt;DataModel ref="Param1DataModel" /&gt;
      &lt;/Param&gt;

      &lt;Param name="p2"&gt;
        &lt;DataModel ref="Param2DataModel" /&gt;
        &lt;Data name="p2data"&gt;
          &lt;Field name="value" value="http://foo.com" /&gt;
        &lt;/Data&gt;
			&lt;/Param&gt;

      &lt;Result&gt;
        &lt;DataModel ref="ResultDataModel" /&gt;
      &lt;/Result&gt;

		&lt;/Action&gt;
	&lt;/State&gt;
&lt;/StateModel&gt;</programlisting>
</section>
<section xml:id="_attributes_91">
<title>Attributes</title>
<simpara><emphasis>Required:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>type</term>
<listitem>
<simpara>Action type, must be set to "call"</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>name</term>
<listitem>
<simpara>Name used to identify the action</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>method</term>
<listitem>
<simpara>String describing the method to execute</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>publisher</term>
<listitem>
<simpara>Name of the publisher that this action should be called on or Peach.Agent</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_when">when</link></term>
<listitem>
<simpara>Only perform action if the expression provided evaluates to true</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_onStart">onStart</link></term>
<listitem>
<simpara>Expression to run on start of an action.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_onComplete">onComplete</link></term>
<listitem>
<simpara>Expression to run on completion of an action</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_child_elements_53">
<title>Child Elements</title>
<variablelist>
<varlistentry>
<term><link linkend="Param">Param</link></term>
<listitem>
<simpara>Argument to be passed with the call.
Zero or more Param elements can be provided.
Param is considered an action that outputs data and as such, Peach fuzzes output data by default.
Each parameter contains a single <link linkend="DataModel">DataModel</link> as a child element and zero or more <link linkend="Data">Data sets</link>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Result">Result</link></term>
<listitem>
<simpara>Captures result of the call Action.
Zero or one Result element can be provided.
The result data is cracked into the specified <link linkend="DataModel">DataModel</link>.
Result elements are treated as input and can be used with <link linkend="Action_slurp"><emphasis>slurp</emphasis></link> actions.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_117">
<title>Examples</title>
<example>
<title>Call action using Com Publisher</title>
<simpara>This example fuzzes the name of a video file, not the contents of the video file. Also, this example requires
a QuickTime movie file to run.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Start QuickTime</simpara>
</listitem>
<listitem>
<simpara>Verify that a QuickTime movie with the filename "video.mov" exists in current folder.</simpara>
</listitem>
<listitem>
<simpara>Save example to "example.xml".</simpara>
</listitem>
<listitem>
<simpara>Run "Peach.Core.ComContainer.exe".</simpara>
</listitem>
<listitem>
<simpara>Run "Peach.exe -1 --debug example.xml".</simpara>
</listitem>
<listitem>
<simpara>You should see the QuickTime movie start to play.</simpara>
</listitem>
</orderedlist>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

  &lt;!-- Import python module so we can sleep after saying play --&gt;
  &lt;Import import="time"/&gt;

  &lt;DataModel name="TheDataModel"&gt;
    &lt;String name="Value" /&gt;
  &lt;/DataModel&gt;

  &lt;StateModel name="TheState" initialState="Initial"&gt;

    &lt;State name="Initial"&gt;

      &lt;Action type="call" method="Players[1].OpenURL"&gt;
        &lt;!-- This parameter will be fuzzed --&gt;
        &lt;Param name="P1"&gt;
          &lt;DataModel ref="TheDataModel" /&gt;

          &lt;Data&gt;
            &lt;Field name="Value" value="https://archive.org/download/AppleComputersQuicktimeSample/sample.mp4"/&gt;
          &lt;/Data&gt;
        &lt;/Param&gt;
      &lt;/Action&gt;

      &lt;!-- The onComplete expression will pause the fuzzer to let
           the video play for 6 seconds. --&gt;
      &lt;Action type="call" method="Players[1].QTControl.Movie.Play" onComplete="time.sleep(6)"/&gt;

    &lt;/State&gt;

  &lt;/StateModel&gt;

  &lt;Test name="Default"&gt;
    &lt;StateModel ref="TheState"/&gt;

    &lt;Publisher class="Com"&gt;
      &lt;Param name="clsid" value="QuickTimePlayerLib.QuickTimePlayerApp"/&gt;
    &lt;/Publisher&gt;
  &lt;/Test&gt;

&lt;/Peach&gt;</programlisting>
</example>
<example>
<title>Interacting with Agents and Monitors</title>
<simpara>This example controls when the WindowsDebugger monitor launches a target executable (notepad.exe) under a debugger.
This configuration is common with file fuzzing.</simpara>
<simpara>Note the special <emphasis>Peach.Agent</emphasis> publisher name.
This Publisher causes the <emphasis>call</emphasis> action to be sent to all Agents. In turn, each Agent forwards the <emphasis>call</emphasis> action to its associated Monitors.
The method call will be handled by the WindowsDebugger monitor, causing it to launch <emphasis>notepad.exe</emphasis>.
For file fuzzing, ensure the target is launched <emphasis role="strong">after</emphasis> writing out the new fuzzed file.</simpara>
<simpara>This example requires a machine running the Windows&#174; Operating system, version XP or newer, with the Windows Debugging Tools installed.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Save the example Pit as "example.xml"</simpara>
</listitem>
<listitem>
<simpara>Run "Peach.exe --range 1,10 --debug example.xml"</simpara>
</listitem>
<listitem>
<simpara>You should see <emphasis>notepad.exe</emphasis> open and close several times.</simpara>
</listitem>
</orderedlist>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

  &lt;DataModel name="TestTemplate"&gt;
    &lt;String value="Hello World!" /&gt;
  &lt;/DataModel&gt;

  &lt;StateModel name="State" initialState="Initial"&gt;
    &lt;State name="Initial"&gt;

      &lt;Action type="output"&gt;
        &lt;DataModel ref="TestTemplate" /&gt;
      &lt;/Action&gt;

      &lt;!-- Close file --&gt;
      &lt;Action type="close" /&gt;

      &lt;!-- Launch the file consumer --&gt;
      &lt;Action type="call" method="ScoobySnacks" publisher="Peach.Agent"/&gt;

    &lt;/State&gt;
  &lt;/StateModel&gt;

  &lt;Agent name="LocalAgent"&gt;
    &lt;Monitor class="WindowsDebugger"&gt;
      &lt;Param name="Executable" value="c:\windows\system32\notepad.exe /&gt;
      &lt;Param name="Arguments" value="fuzzfile.bin" /&gt;
      &lt;Param name="StartOnCall" value="ScoobySnacks" /&gt;
    &lt;/Monitor&gt;
  &lt;/Agent&gt;

  &lt;Test name="Default"&gt;
    &lt;Agent ref="LocalAgent" /&gt;
    &lt;StateModel ref="State"/&gt;

    &lt;Publisher class="File"&gt;
      &lt;Param name="FileName" value="fuzzfile.bin" /&gt;
    &lt;/Publisher&gt;
  &lt;/Test&gt;

&lt;/Peach&gt;</programlisting>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Action_getProperty">
<title>getProperty</title>
<simpara>The <emphasis>getProperty</emphasis> Action retrieves the value of a property from an object that uses the property metaphor and stores the value in a DataModel. <emphasis>getProperty</emphasis> Actions specify in a child element the <link linkend="DataModel">DataModel</link> that receives the retrieved data.</simpara>
<simpara><emphasis>getProperty</emphasis> provides one half of a property metaphor in Peach state models. <emphasis>getProperty</emphasis> actions are considered input actions. <link linkend="Action_setProperty"><emphasis>setProperty</emphasis></link> is the other half (output) of the property metaphor.</simpara>
<simpara>The <emphasis>getProperty</emphasis> Action has two main uses:</simpara>
<itemizedlist>
<listitem>
<simpara>when fuzzing targets such as Microsoft COM/DCOM objects that use the property metaphor. The <emphasis>getProperty</emphasis> Action instructs a Publisher to retrieve the value of a specified property.</simpara>
</listitem>
<listitem>
<simpara>when accessing properties in a Publisher that supports the property metaphor. Some Publishers support using properties to get or set values, such as the UDP, RawV4, RawIPv4, and RawV6 Publishers) . An instance of this type of Publisher is in the examples section.</simpara>
</listitem>
</itemizedlist>
<note>
<simpara>Properties exposed by publishers are described in the publisher documentation.</simpara>
</note>
<sidebar>
<title>Default Order of Actions</title>
<simpara>The following is the default order in which Actions are performed when fuzzing:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara><emphasis>start</emphasis> - Implicit, once per session</simpara>
</listitem>
<listitem>
<simpara><emphasis>open</emphasis> - Implicit, once per iteration</simpara>
</listitem>
<listitem>
<simpara>Explicit actions (<emphasis>accept</emphasis>, <emphasis>input</emphasis>, <emphasis>output</emphasis>, etc.)</simpara>
</listitem>
<listitem>
<simpara><emphasis>close</emphasis> - Implicit, once per iteration</simpara>
</listitem>
<listitem>
<simpara><emphasis>stop</emphasis> - Implicit, once per session</simpara>
</listitem>
</orderedlist>
</sidebar>
<section xml:id="_syntax_84">
<title>Syntax</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;StateModel name="TheStateModel" initialState="InitialState"&gt;
  &lt;State name="InitialState"&gt;
    &lt;Action type="getProperty" property="Name"&gt;
      &lt;DataModel ref="NameModel"/&gt;
    &lt;/Action&gt;
  &lt;/State&gt;
&lt;/StateModel&gt;</programlisting>
</section>
<section xml:id="_attributes_92">
<title>Attributes</title>
<simpara><emphasis>Required:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>type</term>
<listitem>
<simpara>Action type, must be set to "getProperty"</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>name</term>
<listitem>
<simpara>Name used to identify the action</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>property</term>
<listitem>
<simpara>Name of the property to retrieve</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>publisher</term>
<listitem>
<simpara>Name of the publisher to perform this action, or the Name publisher with the property to retrieve</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_when">when</link></term>
<listitem>
<simpara>Perform this action if the provided expression evaluates to true</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_onStart">onStart</link></term>
<listitem>
<simpara>Evaluate expression at the start of an action</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_onComplete">onComplete</link></term>
<listitem>
<simpara>Evaluate expression upon completion of an action</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_child_elements_54">
<title>Child Elements</title>
<variablelist>
<varlistentry>
<term><link linkend="DataModel">DataModel</link></term>
<listitem>
<simpara>Reference to a DataModel store the retrieved data</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_118">
<title>Examples</title>
<example>
<title>Accessing a Property using Microsoft COM Publisher</title>
<simpara>This example shows interacting with the QuickTime COM object.</simpara>
<simpara><emphasis>getProperty</emphasis> retrieves the height of the player window.
Since <emphasis>getProperty</emphasis> is considered a data input, it is not fuzzed.
To fuzz the height property, <link linkend="Action_setProperty"><emphasis>setProperty</emphasis></link> would be used.</simpara>
<simpara>This example requires a Windows XP or newer machine with Apple QuickTime installed.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Start QuickTime</simpara>
</listitem>
<listitem>
<simpara>Save example to "example.xml"</simpara>
</listitem>
<listitem>
<simpara>Run "Peach.Core.ComContainer.exe"</simpara>
</listitem>
<listitem>
<simpara>Run "Peach.exe -1 --debug example.xml"</simpara>
</listitem>
<listitem>
<simpara>You should see the QuickTime movie start to play</simpara>
</listitem>
</orderedlist>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

  &lt;!-- Import python module so we can sleep after saying play --&gt;
  &lt;Import import="time"/&gt;

  &lt;DataModel name="TheDataModel"&gt;
    &lt;String name="Value" /&gt;
  &lt;/DataModel&gt;

  &lt;StateModel name="TheState" initialState="Initial"&gt;

    &lt;State name="Initial"&gt;

      &lt;Action type="call" method="Players[1].OpenURL"&gt;
        &lt;!-- This parameter will be fuzzed --&gt;
        &lt;Param name="P1"&gt;
          &lt;DataModel ref="TheDataModel" /&gt;

          &lt;Data&gt;
            &lt;Field name="Value" value="https://archive.org/download/AppleComputersQuicktimeSample/sample.mp4"/&gt;
          &lt;/Data&gt;
        &lt;/Param&gt;
      &lt;/Action&gt;

      &lt;Action type="getProperty" property="Players[1].Height"&gt;
        &lt;DataModel ref="TheDataModel" /&gt;
      &lt;/Action&gt;

      &lt;!-- The onComplete expression will pause the fuzzer to let
           the video play for 6 seconds. --&gt;
      &lt;Action type="call" method="Players[1].QTControl.Movie.Play" onComplete="time.sleep(6)"/&gt;

    &lt;/State&gt;

  &lt;/StateModel&gt;

  &lt;Test name="Default"&gt;
    &lt;StateModel ref="TheState"/&gt;

    &lt;Publisher class="Com"&gt;
      &lt;Param name="clsid" value="QuickTimePlayerLib.QuickTimePlayerApp"/&gt;
    &lt;/Publisher&gt;
  &lt;/Test&gt;

&lt;/Peach&gt;</programlisting>
</example>
<example>
<title>Accessing Publisher Properties using <emphasis>getProperty</emphasis> Action</title>
<simpara>This example retrieves a property from the <link linkend="Publishers_Udp">UDP Publisher</link>.</simpara>
<simpara>This example uses netcat as the client connecting to Peach.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Save the example Pit to "example.xml"</simpara>
</listitem>
<listitem>
<simpara>Run "peach -1 --debug example.xml"</simpara>
</listitem>
<listitem>
<simpara>Run "echo -n "WHATSMYIP" | nc -4u -w1 localhost 1234"</simpara>
</listitem>
</orderedlist>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

  &lt;DataModel name="Ping"&gt;
    &lt;String name="PingStr" value="WHATSMYIP" token="true"/&gt;
  &lt;/DataModel&gt;

  &lt;DataModel name="IpAddress"&gt;
    &lt;Number size="32" name="IP" value="9999" /&gt;
  &lt;/DataModel&gt;

  &lt;StateModel name="TheStateModel" initialState="InitialState"&gt;
    &lt;State name="InitialState"&gt;
      &lt;Action type="open" /&gt;

      &lt;Action type="input"&gt;
        &lt;DataModel ref="Ping"/&gt;
      &lt;/Action&gt;

      &lt;Action name="GetIpAddress" type="getProperty" property="LastRecvAddr"&gt;
        &lt;DataModel ref="IpAddress" /&gt;
      &lt;/Action&gt;

      &lt;Action type="slurp" valueXpath="//GetIpAddress//IP" setXpath="//IpResponse//IP" /&gt;

      &lt;Action name="IpResponse" type="output"&gt;
        &lt;DataModel ref="IpAddress"/&gt;
      &lt;/Action&gt;
    &lt;/State&gt;
  &lt;/StateModel&gt;

  &lt;Test name="Default"&gt;
    &lt;StateModel ref="TheStateModel"/&gt;
    &lt;Publisher class="Udp"&gt;
      &lt;Param name="Host" value="127.0.0.1" /&gt;
      &lt;Param name="SrcPort" value="1234" /&gt;
      &lt;Param name="Timeout" value="10000" /&gt;
    &lt;/Publisher&gt;

    &lt;Logger class="File" &gt;
      &lt;Param name="Path" value="logs"/&gt;
    &lt;/Logger&gt;
  &lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Action_setProperty">
<title>setProperty</title>
<simpara>The <emphasis>setProperty</emphasis> Action allows Peach to modify values of properties in the target or to modify properties of a Publisher while fuzzing. <emphasis>setProperty</emphasis> Actions specify the <link linkend="DataModel">DataModel</link> property in the target that receives fuzzing.</simpara>
<simpara><emphasis>setProperty</emphasis> provides one half of a property metaphor in Peach state models. <emphasis>setProperty</emphasis> actions are considered output actions. <link linkend="Action_getProperty"><emphasis>getProperty</emphasis></link> is the other half (input) of the property metaphor.</simpara>
<simpara>Properties that are modified receive fuzzing in the same way an output action would be.
For example, a test target, such as a COM object, can have a property set and mutated by Peach, as in the following example.</simpara>
<simpara>The second use, setting and mutating a property in a publisher, is fuzzing the MTU attribute of the <link linkend="Publishers_RawEther">RawEther</link> Publisher. Some Publishers support the use of properties.</simpara>
<note>
<simpara>If you do not want to fuzz a property that is set using <emphasis>setProperty</emphasis>, set the mutable attribute of the data item to false. The item declaration is located in the DataModel.</simpara>
</note>
<sidebar>
<title>Default Order of Actions</title>
<simpara>The following is the default order in which Actions are performed when fuzzing:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara><emphasis>start</emphasis> - Implicit, once per session</simpara>
</listitem>
<listitem>
<simpara><emphasis>open</emphasis> - Implicit, once per iteration</simpara>
</listitem>
<listitem>
<simpara>Explicit actions (<emphasis>accept</emphasis>, <emphasis>input</emphasis>, <emphasis>output</emphasis>, etc.)</simpara>
</listitem>
<listitem>
<simpara><emphasis>close</emphasis> - Implicit, once per iteration</simpara>
</listitem>
<listitem>
<simpara><emphasis>stop</emphasis> - Implicit, once per session</simpara>
</listitem>
</orderedlist>
</sidebar>
<section xml:id="_syntax_85">
<title>Syntax</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;StateModel name="TheStateModel" initialState="InitialState"&gt;
	&lt;State name="InitialState"&gt;
		&lt;Action type="setProperty" property="Name"&gt;
			&lt;DataModel ref="NameModel"/&gt;
		&lt;/Action&gt;
	&lt;/State&gt;
&lt;/StateModel&gt;</programlisting>
</section>
<section xml:id="_attributes_93">
<title>Attributes</title>
<simpara><emphasis>Required:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>type</term>
<listitem>
<simpara>Action type, must be set to "setProperty"</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>name</term>
<listitem>
<simpara>Name used to identify the action</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>property</term>
<listitem>
<simpara>Name of property to set in the fuzzing target, or in the publisher</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>publisher</term>
<listitem>
<simpara>Name of the publisher to perform this action, or the Name publisher with the property to modify</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_when">when</link></term>
<listitem>
<simpara>Perform action if the provided expression evaluates to true</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_onStart">onStart</link></term>
<listitem>
<simpara>Evaluate expression at the start of an action</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_onComplete">onComplete</link></term>
<listitem>
<simpara>Evaluate expression upon completion of an action</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_child_elements_55">
<title>Child Elements</title>
<variablelist>
<varlistentry>
<term><link linkend="DataModel">DataModel</link></term>
<listitem>
<simpara>Reference to a DataModel containing data to fuzz</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Data">Data</link></term>
<listitem>
<simpara>Set of initial data crack into the above DataModel before fuzzing</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_119">
<title>Examples</title>
<example>
<title>Accessing a Property using Microsoft COM Publisher</title>
<simpara>This example fuzzes property values of a QuickTime COM object.
<emphasis>setProperty</emphasis> sets the height of the player window.
Since <emphasis>setProperty</emphasis> is considered data output, it is fuzzed.</simpara>
<simpara>This example requires a machine with the Windows Operating System, version XP or newer,   with Apple QuickTime installed.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Start QuickTime</simpara>
</listitem>
<listitem>
<simpara>Save example to "example.xml"</simpara>
</listitem>
<listitem>
<simpara>Run "Peach.Core.ComContainer.exe"</simpara>
</listitem>
<listitem>
<simpara>Run "Peach.exe -1 --debug example.xml"</simpara>
</listitem>
<listitem>
<simpara>You should see the QuickTime movie start to play</simpara>
</listitem>
</orderedlist>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

  &lt;!-- Import python module so we can sleep after saying play --&gt;
  &lt;Import import="time"/&gt;

  &lt;DataModel name="TheDataModel"&gt;
    &lt;String name="Value" /&gt;
  &lt;/DataModel&gt;

  &lt;StateModel name="TheState" initialState="Initial"&gt;

    &lt;State name="Initial"&gt;

      &lt;Action type="call" method="Players[1].OpenURL"&gt;
        &lt;!-- This parameter will be fuzzed --&gt;
        &lt;Param name="P1"&gt;
          &lt;DataModel ref="TheDataModel" /&gt;

          &lt;Data&gt;
            &lt;Field name="Value" value="https://archive.org/download/AppleComputersQuicktimeSample/sample.mp4"/&gt;
          &lt;/Data&gt;
        &lt;/Param&gt;
      &lt;/Action&gt;

      &lt;!-- This property will be fuzzed --&gt;
      &lt;Action type="setProperty" property="Players[1].Height"&gt;
        &lt;DataModel ref="TheDataModel" /&gt;
        &lt;Data&gt;
          &lt;Field name="Value" value="100" /&gt;
        &lt;/Data&gt;
      &lt;/Action&gt;

      &lt;!-- The onComplete expression will pause the fuzzer to let
           the video play for 6 seconds. --&gt;
      &lt;Action type="call" method="Players[1].QTControl.Movie.Play" onComplete="time.sleep(6)"/&gt;

    &lt;/State&gt;

  &lt;/StateModel&gt;

  &lt;Test name="Default"&gt;
    &lt;StateModel ref="TheState"/&gt;

    &lt;Publisher class="Com"&gt;
      &lt;Param name="clsid" value="QuickTimePlayerLib.QuickTimePlayerApp"/&gt;
    &lt;/Publisher&gt;
  &lt;/Test&gt;

&lt;/Peach&gt;</programlisting>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Action_web">
<title>web</title>
<simpara>Model web api/http requests. Provides full control over the request being modeled. Must be used in conjunction with the <link linkend="Publishers_WebApi">WebApi</link> publisher.</simpara>
<simpara>This action gives full control over:</simpara>
<itemizedlist>
<listitem>
<simpara>Path</simpara>
</listitem>
<listitem>
<simpara>Query string</simpara>
</listitem>
<listitem>
<simpara>Headers</simpara>
</listitem>
<listitem>
<simpara>Form data</simpara>
</listitem>
<listitem>
<simpara>Multipart requests</simpara>
</listitem>
<listitem>
<simpara>Body</simpara>
<itemizedlist>
<listitem>
<simpara>Binary</simpara>
</listitem>
<listitem>
<simpara>Json</simpara>
</listitem>
<listitem>
<simpara>Text</simpara>
</listitem>
<listitem>
<simpara>XML</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
<simpara>Several analyzers are useful when building Pits using this action type:</simpara>
<variablelist>
<varlistentry>
<term><link linkend="Analyzers_Json">Json</link></term>
<listitem>
<simpara>Converts JSON documents or strings into Peach data models.
Can be used both inside of DataModels with the String element or also via the command line.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Analyzers_Postman">Postman</link></term>
<listitem>
<simpara>Converts Postman Catalogs to Peach Pits.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Analyzers_Swagger">Swagger</link></term>
<listitem>
<simpara>Converts Swagger JSON to Peach Pits</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Analyzers_WebRecordProxy">WebRecordProxy</link></term>
<listitem>
<simpara>Recording proxy captures web requests and generates full pit.
This makes creating the base pit easy, simply use as your HTTP proxy.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Analyzers_Xml">Xml</link></term>
<listitem>
<simpara>Converts XML documents or string into Peach data models.
Can be used both inside of DataModels with the String element or also via the command line.</simpara>
</listitem>
</varlistentry>
</variablelist>
<tip>
<simpara>SSL/TLS is supported, just use <literal>https</literal> as the protocol in the URL.</simpara>
</tip>
<note>
<simpara>Must be used with <link linkend="Publishers_WebApi">WebApi</link> publisher.</simpara>
</note>
<section xml:id="_syntax_86">
<title>Syntax</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;StateModel name="TheStateModel" initialState="InitialState"&gt;
	&lt;State name="InitialState"&gt;
		&lt;Action type="web" method="GET" url="http://localhost/product/{id}"&gt;
            &lt;Path key="id" value="100" /&gt;
            &lt;Query key="first" value="Mike" /&gt;
            &lt;Query key="last" value="Smith" /&gt;
            &lt;Header key="Content-Type" value="application/json"/&gt;
            &lt;Body name="Json"&gt;
                &lt;DataModel ref="JsonBody" /&gt;
            &lt;/Body&gt;
            &lt;Response/&gt;
		&lt;/Action&gt;
	&lt;/State&gt;
&lt;/StateModel&gt;</programlisting>
</section>
<section xml:id="_attributes_94">
<title>Attributes</title>
<simpara><emphasis>Required:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>type</term>
<listitem>
<simpara>Action type, must be set to "web"</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>method</term>
<listitem>
<simpara>HTTP method verb (GET, DELETE, POST, PUT, etc.)</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>url</term>
<listitem>
<simpara>Fully qualified URL including path.  Excludes query string.</simpara>
<simpara>URL can include path subsitution identifiers in the form <literal>{id}</literal>, where <emphasis>id</emphasis> matches
the <literal>id</literal> attribute of a child <literal>Path</literal> element (see examples below). Multiple path
substitutions can be performed.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>name</term>
<listitem>
<simpara>Name used to identify the action</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>publisher</term>
<listitem>
<simpara>Name of the publisher that this action should be called on or Peach.Agent</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_when">when</link></term>
<listitem>
<simpara>Only perform action if the expression provided evaluates to true</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_onStart">onStart</link></term>
<listitem>
<simpara>Expression to run on start of an action.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_onComplete">onComplete</link></term>
<listitem>
<simpara>Expression to run on completion of an action</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_child_elements_56">
<title>Child Elements</title>
<variablelist>
<varlistentry>
<term><link linkend="web_Path">Path</link></term>
<listitem>
<simpara>Each subsitution identifier defined in the <literal>url</literal> attribute of the web action must have a corresponding
Path child element. This provides a default value and data model for the path variable.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="web_Query">Query</link></term>
<listitem>
<simpara>Defines a querystring key/value pair.  The query portion of the URL will be built using these child elements.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="web_Header">Header</link></term>
<listitem>
<simpara>Define an HTTP header.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="web_FormData">FormData</link></term>
<listitem>
<simpara>Define a key/value pair of form data. These values are transmitted via the request body. It is not possible to combine FormData with a Body or Part child.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="web_Body">Body</link></term>
<listitem>
<simpara>Define the request body. Only one Body child element is allowed.  Body elements cannot be mixed with FormData or Part elements.  Only one type of body is allowed.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="web_Part">Part</link></term>
<listitem>
<simpara>Define a part of a multipart request. Each part can contain <link linkend="web_Header">Header</link>, <link linkend="web_FormData">FormData</link> and <link linkend="web_Body">Body</link> child elements. Part elements cannot be used with FormData or Body elements.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="web_Response">Response</link></term>
<listitem>
<simpara>Capture the response with an optional custom data model. Exposes status code, headers and body to scripting and <emphasis>slurp</emphasis> actions.  If omitted, a default Response element is generated to capture the request response.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_120">
<title>Examples</title>
<example>
<title>Calling WebApi Services with Result</title>
<simpara>The following example provides three fragments using the GET and POST methods.
For the GET request, the Result element is used to capture any returned data.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

&lt;DataModel name="PostData"&gt;
    &lt;JsonObject&gt;
        &lt;JsonString propertyName="Name" value="Widget" /&gt;
        &lt;JsonDouble propertyName="Price" value="1.99" /&gt;
        &lt;JsonInteger propertyName="Quantify" value="1" /&gt;
    &lt;/JsonObject&gt;
&lt;/DataModel&gt;

&lt;DataModel name="WebApiResult"&gt;
	&lt;Choice name="ResultOrEmpty"&gt;
		&lt;String name="Result"&gt;
			&lt;Analyzer class="Json" /&gt;
		&lt;/String&gt;
		&lt;Block name="Empty" /&gt;
	&lt;/Choice&gt;
&lt;/DataModel&gt;

&lt;StateModel name="Default" initialState="FirstState"&gt;
    &lt;State name="FirstState"&gt;
        &lt;Action type="web" method="GET" url="http://www.example.com/product/{id}"&gt;
            &lt;Path name="Id" key="id" value="1"/&gt;

            &lt;Response /&gt;
                &lt;DataModel ref="WebApiResult" /&gt;
            &lt;/Response&gt;
        &lt;/Action&gt;

        &lt;Action type="web" method="GET" url="http://www.example.com/invoices"&gt;
            &lt;Query name="StartDate" key="start_date" value="11-21-2011" /&gt;
            &lt;Query name="EndDate" key="end_date" value="11-21-2015" /&gt;

            &lt;Response&gt;
                &lt;DataModel ref="WebApiResult" /&gt;
            &lt;/Response&gt;
        &lt;/Action&gt;

        &lt;Action type="call" method="POST" url="http://www.example.com/product/{id}"&gt;
            &lt;Path name="Id" key="id" value="100" /&gt;
            &lt;Body name="PostData"&gt;
                &lt;DataModel ref="PostData" /&gt;
            &lt;/Body&gt;
        &lt;/Action&gt;
    &lt;/State&gt;
&lt;/StateModel&gt;

&lt;Test name="Default"&gt;
    &lt;StateModel ref="Default" /&gt;
    &lt;Publisher class="WebApi" /&gt;
&lt;/Test&gt;

&lt;/Peach&gt;</programlisting>
</example>
<example>
<title>Posting XML</title>
<simpara>The following example provides three fragments using the GET and POST methods.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

&lt;DataModel name="PostData"&gt;
    &lt;XmlElement elementName="Product"&gt;
        &lt;XmlAttribute attributeName="Name"&gt;
            &lt;String value="Widget" /&gt;
        &lt;/XmlAttribute&gt;
        &lt;XmlAttribute attributeName="Price"&gt;
            &lt;String value="1.99" /&gt;
        &lt;/XmlAttribute&gt;
        &lt;XmlAttribute attributeName="Quantity"&gt;
            &lt;String value="1" /&gt;
        &lt;/XmlAttribute&gt;
    &lt;/XmlElement&gt;
&lt;/DataModel&gt;

&lt;StateModel name="Default" initialState="FirstState"&gt;
    &lt;State name="FirstState"&gt;

        &lt;Action type="web" method="POST" url="http://www.example.com/product/{id}"&gt;
            &lt;Path key="id" value="1"/&gt;

            &lt;Body name="PostData"&gt;
                &lt;DataModel ref="PostData" /&gt;
            &lt;/Body&gt;
        &lt;/Action&gt;

    &lt;/State&gt;
&lt;/StateModel&gt;

&lt;Test name="Default"&gt;
    &lt;StateModel ref="Default" /&gt;
    &lt;Publisher class="WebApi" /&gt;
&lt;/Test&gt;

&lt;/Peach&gt;</programlisting>
</example>
<example>
<title>Posting Binary</title>
<simpara>The following example provides three fragments using the GET and POST methods.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

&lt;DataModel name="PostData"&gt;
    &lt;Blob /&gt;
&lt;/DataModel&gt;

&lt;StateModel name="Default" initialState="FirstState"&gt;
    &lt;State name="FirstState"&gt;

        &lt;Action type="web" method="POST" url="http://www.example.com/product/{id}/image"&gt;
            &lt;Path key="id" value="1"/&gt;
            &lt;Body name="PostData"&gt;
                &lt;DataModel ref="PostData" /&gt;
                &lt;Data fileName="image.png" /&gt;
            &lt;/Body&gt;
        &lt;/Action&gt;

    &lt;/State&gt;
&lt;/StateModel&gt;

&lt;Test name="Default"&gt;

    &lt;StateModel ref="Default"/&gt;
    &lt;Publisher class="WebApi"/&gt;

&lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
</example>
<example>
<title>Setting Custom Header via Pit</title>
<simpara>The following example shows how to set a custom header via the Pit XML.
The custom header is named "X-CustomeHeader" with a value of "Hello World!".</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

&lt;StateModel name="Default" initialState="FirstState"&gt;
    &lt;State name="FirstState"&gt;

        &lt;Action type="web" method="GET" url="http://www.example.com/product/{id}"&gt;
            &lt;Path key="id" value="1"/&gt;
            &lt;Header name="x-custom" key="X-CustomHeader" value="Hello World!" /&gt;
            &lt;Response/&gt;
        &lt;/Action&gt;

    &lt;/State&gt;
&lt;/StateModel&gt;

&lt;Test name="Default"&gt;
    &lt;StateModel ref="Default" /&gt;
    &lt;Publisher class="WebApi" /&gt;
&lt;/Test&gt;

&lt;/Peach&gt;</programlisting>
</example>
<example>
<title>Setting Custom Authentication Header via Python</title>
<simpara>The following example shows how to add custom authentication via a python script.
In this example we will configure a pit for fuzzing an Amazon AWS S3 service endpoint.
This is only an example and should not actually be used to fuzz AWS.</simpara>
<programlisting language="python" linenumbering="unnumbered">import base64
import hmac
from hashlib import sha1
from email.Utils import formatdate

AWS_ACCESS_KEY_ID = "44CF9590006BF252F707"
AWS_SECRET_KEY = "OtxrzxIsfpFjA7SwPzILwy8Bw21TLhquhboDYROV"

def AwsAuthGen(context, action):

    # Get the Publisher (WebApiPublisher)
    if action.publisher:
        publisher = context.test.publishers[action.publisher]
    else:
        publisher = context.test.publishers[0]

    XAmzDate = formatdate()

    h = hmac.new(AWS_SECRET_KEY, "PUT\n\napplication/json\n\nx-amz-date:%s\n/?policy" % XAmzDate, sha1)
    authToken = base64.encodestring(h.digest()).strip()

    publisher.Headers.Add("x-amz-date", XAmzDate)
    publisher.Headers.Add("Authorization", "AWS %s:%s" % (AWS_ACCESS_KEY_ID, authToken))

# end</programlisting>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

  &lt;Import import="aws_s3_example"/&gt;

  &lt;!--
{
"Version":"2008-10-17",
"Id":"aaaa-bbbb-cccc-dddd",
"Statement" : [
    {
        "Effect":"Allow",
        "Sid":"1",
        "Principal" : {
            "AWS":["111122223333","444455556666"]
        },
        "Action":["s3:*"],
        "Resource":"arn:aws:s3:::bucket/*"
    }
 ]
}
  --&gt;
  &lt;!-- Generated using the JSON analyzer --&gt;
  &lt;DataModel name="Policy"&gt;
    &lt;JsonObject&gt;
      &lt;JsonString propertyName="Version" name="Version" value="2008-10-17" /&gt;
      &lt;JsonString propertyName="Id" name="Id" value="aaaa-bbbb-cccc-dddd" /&gt;
      &lt;JsonArray propertyName="Statement" name="Statement"&gt;
        &lt;JsonObject propertyName="Statement" name="Statement"&gt;
          &lt;JsonString propertyName="Effect" name="Effect" value="Allow" /&gt;
          &lt;JsonString propertyName="Sid" name="Sid" value="1" /&gt;
          &lt;JsonObject propertyName="Principal" name="Principal"&gt;
            &lt;JsonArray propertyName="AWS" name="AWS"&gt;
              &lt;JsonString propertyName="AWS" name="AWS" value="111122223333" /&gt;
              &lt;JsonString value="444455556666" /&gt;
            &lt;/JsonArray&gt;
          &lt;/JsonObject&gt;
          &lt;JsonArray propertyName="Action" name="Action"&gt;
            &lt;JsonString propertyName="Action" name="Action" value="s3:*" /&gt;
          &lt;/JsonArray&gt;
          &lt;JsonString propertyName="Resource" name="Resource" value="arn:aws:s3:::bucket/*" /&gt;
        &lt;/JsonObject&gt;
      &lt;/JsonArray&gt;
    &lt;/JsonObject&gt;
  &lt;/DataModel&gt;

  &lt;StateModel name="TheStateModel" initialState="Initial"&gt;
    &lt;State name="Initial"&gt;

      &lt;Action type="web" method="PUT" url="http://XXXXX.s3.amazonaws.com/?policy"
              onStart="aws_s3_example.AwsAuthGen(context, action)"&gt;

        &lt;Body name="Body"&gt;
          &lt;DataModel ref="Policy" /&gt;
        &lt;/Body&gt;
      &lt;/Action&gt;

    &lt;/State&gt;
  &lt;/StateModel&gt;

  &lt;Test name="Default" maxOutputSize="20000000"&gt;
    &lt;StateModel ref="TheStateModel"/&gt;
    &lt;Publisher class="WebApi"&gt;
      &lt;Param name="FaultOnStatusCodes" value="500,501,502,503,504,505" /&gt;
    &lt;/Publisher&gt;
  &lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Action_slurp">
<title>slurp</title>
<simpara>Slurp moves data between two DataModels. The Slurp Action copies a data value from one non-container element in one DataModel to another non-container element in a separate DataModel.</simpara>
<simpara>A non-container element is an element that does not contain other elements. Number, string, and blob are types of non-container elements. In contrast, array, <link linkend="Block">Block</link>, <link linkend="Choice">Choice</link>, and <link linkend="DataModel">DataModel</link>) are types of container elements.</simpara>
<itemizedlist>
<listitem>
<simpara>The <link linkend="xpath">valueXpath</link> attribute defines the input element. The data model and the element in valueXpath were previously referenced by a prior input action.</simpara>
</listitem>
<listitem>
<simpara>The <link linkend="xpath">setXpath</link> attribute defines the output element.  The data model and the element in setXpath will be referenced by a future action.</simpara>
</listitem>
</itemizedlist>
<simpara>The XML Path (XPath) language is used by valueXpath and setXpath to specify the data to move. XPath targets a specific element for the <link linkend="xpath">valueXpath</link> and <link linkend="xpath">setXpath</link> parameters. This allows a variety of ways to access these elements in the Document Object Model (DOM).</simpara>
<simpara>A common use for slurp is during a protocol sequence where a sequence id or a challenge id needs to round-trip from the server to the client and back to the server (see the Challenge Response example below). The <emphasis>slurp</emphasis> Action copies the data received from the server (valueXpath attribute) into the response packet (setXpath attribute). When the response packet is populated, it is sent back to the server using another Action.</simpara>
<simpara>Potential Slurp errors include the following:</simpara>
<itemizedlist>
<listitem>
<simpara>Copying from a container element or copying to a container element (Copying is restricted to simple types, such as number, string, or blob.)</simpara>
</listitem>
<listitem>
<simpara>The valueXpath parameter does not return a single element (One element is required; no more; no less. If you need to move more than one set of data, issue multiple slurp commands.)</simpara>
</listitem>
<listitem>
<simpara>The valueXpath and setXpath parameters return the same element</simpara>
</listitem>
<listitem>
<simpara>The setXpath parameter does not return any elements (The element has no content or the path is non-existent.)</simpara>
</listitem>
</itemizedlist>
<simpara>Assigning unique names to elements simplifies targeting those elements with the valueXpath and setXpath attributes. Using XPath wildcards with unique element names allows an element to be targeted using its name instead of using the full path to the element. See the following examples for slurp actions with and without unique element names.</simpara>
<sidebar>
<title>XPath Further Reading</title>
<simpara>The following links provide additional information regarding XPath.</simpara>
<itemizedlist>
<listitem>
<simpara><link xl:href="http://www.w3schools.com/xpath/">XPath Tutorial</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="http://www.w3schools.com/xpath/xpath_syntax.asp">XPath Syntax</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="http://www.w3.org/TR/xpath/">XPath Specification</link></simpara>
</listitem>
</itemizedlist>
</sidebar>
<section xml:id="_syntax_87">
<title>Syntax</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;DataModel name="ReceiveChallenge"&gt;
  &lt;String name="Challenge" /&gt;
&lt;/DataModel&gt;

&lt;DataModel name="SendChallenge"&gt;
  &lt;String name="Challenge" /&gt;
&lt;/DataModel&gt;

&lt;StateModel name="TheStateModel" initialState="InitialState"&gt;
	&lt;State name="InitialState"&gt;
		&lt;Action name="ReceiveChallenge" type="input"&gt;
			&lt;DataModel name="TheReceiveChallenge" ref="ReceiveChallenge"/&gt;
		&lt;/Action&gt;

		&lt;Action type="slurp" valueXpath="//TheReceiveChallenge/Challenge" setXpath="//TheSendChallenge/Challenge" /&gt;

		&lt;Action name="SendChallenge" type="output"&gt;
			&lt;DataModel name="TheSendChallenge" ref="SendChallenge"/&gt;
		&lt;/Action&gt;
	&lt;/State&gt;
&lt;/StateModel&gt;</programlisting>
</section>
<section xml:id="_attributes_95">
<title>Attributes</title>
<simpara><emphasis>Required:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>type</term>
<listitem>
<simpara>Action type, must be set to "slurp"</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>name</term>
<listitem>
<simpara>Name used to identify the action</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="xpath">valueXpath</link></term>
<listitem>
<simpara>Path to the source element. Must evaluate to match a single element.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="xpath">setXpath</link></term>
<listitem>
<simpara>Path to the destination element. Can match multiple elements on which to set the value.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_when">when</link></term>
<listitem>
<simpara>Perform action if the provided expression evaluates to true</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_onStart">onStart</link></term>
<listitem>
<simpara>Evaluate expression to run at the start of an action</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_onComplete">onComplete</link></term>
<listitem>
<simpara>Evaluate expression upon completion of an action</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_child_elements_57">
<title>Child Elements</title>
<simpara>None.</simpara>
</section>
<section xml:id="_examples_121">
<title>Examples</title>
<example>
<title>Non-unique Names</title>
<simpara>This example uses fully specified names in the xpath query to identify elements.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

  &lt;DataModel name="Ping"&gt;
    &lt;String name="PingStr" value="Stop Copying Me" token="true"/&gt;
  &lt;/DataModel&gt;

  &lt;DataModel name="Pong"&gt;
    &lt;String name="Resp" value="I am not" /&gt;
  &lt;/DataModel&gt;

  &lt;StateModel name="TheStateModel" initialState="InitialState"&gt;
    &lt;State name="InitialState"&gt;
      &lt;Action name="PingPacket" type="input"&gt;
        &lt;DataModel ref="Ping"/&gt;
      &lt;/Action&gt;

      &lt;Action type="slurp" valueXpath="//PingPacket/Ping/PingStr" setXpath="//PongPacket/CopyResponse/Resp" /&gt;

      &lt;Action name="PongPacket" type="output"&gt;
        &lt;DataModel name="CopyResponse" ref="Pong"/&gt;
      &lt;/Action&gt;
    &lt;/State&gt;
  &lt;/StateModel&gt;

  &lt;Test name="Default"&gt;
    &lt;StateModel ref="TheStateModel"/&gt;
    &lt;Publisher class="Udp"&gt;
      &lt;Param name="Host" value="127.0.0.1" /&gt;
      &lt;Param name="SrcPort" value="1234" /&gt;
      &lt;Param name="Timeout" value="10000" /&gt;
    &lt;/Publisher&gt;

    &lt;!-- Test with following command --&gt;
    &lt;!-- echo -n "Stop Copying Me" | nc -4u -w1 localhost 1234 --&gt;

    &lt;Strategy class="Random"/&gt;

    &lt;Logger class="File" &gt;
      &lt;Param name="Path" value="logs"/&gt;
    &lt;/Logger&gt;
  &lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
</example>
<example>
<title>Unique Names</title>
<simpara>This example uses unique names for the source element (input) and for the destination element (output) involved in the slurp.
Having unique names allows the simpler xpath notation that uses wildcards (//) instead of using a full name.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

	&lt;DataModel name="Ping"&gt;
		&lt;String name="PingStr" value="Stop Copying Me" token="true"/&gt;
	&lt;/DataModel&gt;

	&lt;DataModel name="Pong"&gt;
		&lt;String name="Resp" value="I am not" /&gt;
	&lt;/DataModel&gt;

	&lt;StateModel name="TheStateModel" initialState="InitialState"&gt;
		&lt;State name="InitialState"&gt;
			&lt;Action name="PingPacket" type="input"&gt;
				&lt;DataModel ref="Ping"/&gt;
			&lt;/Action&gt;

			&lt;Action type="slurp" valueXpath="//PingStr" setXpath="//Resp" /&gt;

			&lt;Action name="PongPacket" type="output"&gt;
				&lt;DataModel name="CopyResponse" ref="Pong"/&gt;
			&lt;/Action&gt;
		&lt;/State&gt;
	&lt;/StateModel&gt;

	&lt;Test name="Default"&gt;
		&lt;StateModel ref="TheStateModel"/&gt;
		&lt;Publisher class="Udp"&gt;
			&lt;Param name="Host" value="127.0.0.1" /&gt;
			&lt;Param name="SrcPort" value="1234" /&gt;
			&lt;Param name="Timeout" value="10000" /&gt;
		&lt;/Publisher&gt;

		&lt;!-- Test with following command --&gt;
		&lt;!-- echo -n "Stop Copying Me" | nc -4u -w1 localhost 1234 --&gt;

		&lt;Strategy class="Random"/&gt;

		&lt;Logger class="File" &gt;
			&lt;Param name="Path" value="logs"/&gt;
	    &lt;/Logger&gt;
	&lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
</example>
<example>
<title>Setting Multiple Elements</title>
<simpara>This example copies a value to multiple elements at once.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach ../peach.xsd"&gt;

  &lt;DataModel name="Ping"&gt;
    &lt;String name="PingStr" value="Stop Copying Me" token="true"/&gt;
  &lt;/DataModel&gt;

  &lt;DataModel name="Pong"&gt;
    &lt;String name="Resp" value="I am not" /&gt;
  &lt;/DataModel&gt;

  &lt;StateModel name="TheStateModel" initialState="InitialState"&gt;
    &lt;State name="InitialState"&gt;
      &lt;Action type="input"&gt;
        &lt;DataModel ref="Ping"/&gt;
      &lt;/Action&gt;

      &lt;!-- Will copy value from our input action to all of our output actions. --&gt;
      &lt;Action type="slurp" valueXpath="//PingStr" setXpath="//Resp" /&gt;

      &lt;Action type="output"&gt;
        &lt;DataModel ref="Pong"/&gt;
      &lt;/Action&gt;

      &lt;Action type="output"&gt;
        &lt;DataModel ref="Pong"/&gt;
      &lt;/Action&gt;

      &lt;Action type="output"&gt;
        &lt;DataModel ref="Pong"/&gt;
      &lt;/Action&gt;

      &lt;Action type="output"&gt;
        &lt;DataModel ref="Pong"/&gt;
      &lt;/Action&gt;
    &lt;/State&gt;
  &lt;/StateModel&gt;

  &lt;Test name="Default"&gt;
    &lt;StateModel ref="TheStateModel"/&gt;
    &lt;Publisher class="Udp"&gt;
      &lt;Param name="Host" value="127.0.0.1" /&gt;
      &lt;Param name="SrcPort" value="1234" /&gt;
      &lt;Param name="Timeout" value="10000" /&gt;
    &lt;/Publisher&gt;

    &lt;!-- Test with following command --&gt;
    &lt;!-- echo -n "Stop Copying Me" | nc -4u -w1 localhost 1234 --&gt;

    &lt;Strategy class="Random"/&gt;

    &lt;Logger class="File" &gt;
      &lt;Param name="Path" value="logs"/&gt;
    &lt;/Logger&gt;
  &lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
</example>
<example>
<title>Challenge Response</title>
<simpara>This example shows how to use slurp for round-tripping a challenge id just issued by a server in the next response packet to the server.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

  &lt;DataModel name="ReceiveChallenge"&gt;
    &lt;String name="Challenge" /&gt;
  &lt;/DataModel&gt;

  &lt;DataModel name="SendChallenge"&gt;
    &lt;String name="Challenge" /&gt;
  &lt;/DataModel&gt;

  &lt;StateModel name="TheStateModel" initialState="InitialState"&gt;
    &lt;State name="InitialState"&gt;
      &lt;Action name="ReceiveChallenge" type="input"&gt;
        &lt;DataModel name="TheReceiveChallenge" ref="ReceiveChallenge"/&gt;
      &lt;/Action&gt;

      &lt;Action type="slurp" valueXpath="//TheReceiveChallenge/Challenge" setXpath="//TheSendChallenge/Challenge" /&gt;

      &lt;Action name="SendChallenge" type="output"&gt;
        &lt;DataModel name="TheSendChallenge" ref="SendChallenge"/&gt;
      &lt;/Action&gt;
    &lt;/State&gt;
  &lt;/StateModel&gt;

  &lt;Test name="Default"&gt;
    &lt;StateModel ref="TheStateModel"/&gt;
    &lt;Publisher class="Udp"&gt;
      &lt;Param name="Host" value="127.0.0.1" /&gt;
      &lt;Param name="SrcPort" value="1234" /&gt;
      &lt;Param name="Timeout" value="10000" /&gt;
    &lt;/Publisher&gt;

    &lt;!-- Test with following command --&gt;
    &lt;!-- echo -n "Stop Copying Me" | nc -4u -w1 localhost 1234 --&gt;

    &lt;Strategy class="Random"/&gt;

    &lt;Logger class="File" &gt;
      &lt;Param name="Path" value="logs"/&gt;
      &lt;/Logger&gt;
  &lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Action_changeState">
<title>changeState</title>
<simpara>The <emphasis>changeState</emphasis> Action transitions to a different state within the <link linkend="StateModel">StateModel</link>.
The <emphasis>changeState</emphasis> Action typically includes the <link linkend="Action_when">when</link> attribute to identify when to switch states based on received data.</simpara>
<simpara><emphasis>changeState</emphasis> is useful for network protocols that select response data based on an input code.
The test target usually progresses sequentially through the StateModel, often removing the need to change states if the path of events are predefined.</simpara>
<section xml:id="_syntax_88">
<title>Syntax</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;StateModel name="TheStateModel" initialState="InitialState"&gt;
  &lt;State name="InitialState"&gt;

    &lt;Action type="input"&gt;
      &lt;DataModel ref="InputModel" /&gt;
    &lt;/Action&gt;

    &lt;Action type="changeState" ref="State2"
      when="self.dataModel.find('Value').InternalValue == 'FOO' /&gt;

  &lt;/State&gt;

  &lt;State name="State2"&gt;
    &lt;Action type="output"&gt;
      &lt;DataModel ref="OutputModel" /&gt;
    &lt;/Action&gt;
  &lt;/State&gt;
&lt;/StateModel&gt;</programlisting>
</section>
<section xml:id="_attributes_96">
<title>Attributes</title>
<simpara><emphasis>Required:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>type</term>
<listitem>
<simpara>Action type, must be set to "changeState"</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>name</term>
<listitem>
<simpara>Name used to identify the action</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>ref</term>
<listitem>
<simpara>Name of the State to transition to in StateModel</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_when">when</link></term>
<listitem>
<simpara>Perform action if the provided expression evaluates to true</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_onStart">onStart</link></term>
<listitem>
<simpara>Evaluate expression at start of an action</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_onComplete">onComplete</link></term>
<listitem>
<simpara>Evaluate expression upon completion of an action</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_child_elements_58">
<title>Child Elements</title>
<simpara>None.</simpara>
</section>
<section xml:id="_examples_122">
<title>Examples</title>
<example>
<title>Action changeState Example</title>
<simpara>The following example changes behavior based on input received from the target client.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

  &lt;DataModel name="Ping"&gt;
    &lt;Choice&gt;
      &lt;String name="PingPingStr" value="PINGPING" token="true" /&gt;
      &lt;String name="PingStr" value="PING" token="true"/&gt;
    &lt;/Choice&gt;
  &lt;/DataModel&gt;

  &lt;DataModel name="Pong"&gt;
    &lt;String value="PONG" /&gt;
  &lt;/DataModel&gt;

  &lt;DataModel name="PongPong"&gt;
    &lt;String value="PONGPONG" /&gt;
  &lt;/DataModel&gt;

  &lt;StateModel name="TheStateModel" initialState="InitialState"&gt;
    &lt;State name="InitialState"&gt;

      &lt;Action type="accept" /&gt;

      &lt;Action type="input"&gt;
        &lt;DataModel ref="Ping"/&gt;
      &lt;/Action&gt;

      &lt;!-- Switch states only when input was PINGPING --&gt;
      &lt;Action type="changeState" ref="PongPongBack"
        when="state.actions[1].dataModel.find('PingPingStr') != None" /&gt;

      &lt;Action type="output"&gt;
        &lt;DataModel ref="Pong"/&gt;
      &lt;/Action&gt;

    &lt;/State&gt;

    &lt;!-- This state is only reached when input was PINGPING --&gt;
    &lt;State name="PongPongBack"&gt;

      &lt;Action type="output"&gt;
        &lt;DataModel ref="PongPong"/&gt;
      &lt;/Action&gt;

    &lt;/State&gt;

  &lt;/StateModel&gt;

  &lt;Test name="Default"&gt;
    &lt;StateModel ref="TheStateModel"/&gt;
    &lt;Publisher class="TcpListener"&gt;
      &lt;Param name="Interface" value="0.0.0.0" /&gt;
      &lt;Param name="Port" value="31337" /&gt;
      &lt;Param name="AcceptTimeout" value="10000" /&gt;
      &lt;Param name="Timeout" value="10000" /&gt;
    &lt;/Publisher&gt;

    &lt;Logger class="File" &gt;
      &lt;Param name="Path" value="logs"/&gt;
      &lt;/Logger&gt;
  &lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
</example>
<example>
<title>Looping Based on Input</title>
<simpara>The following example loops through received input until the string "PING' is found.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

  &lt;DataModel name="Ping"&gt;
    &lt;Choice&gt;
      &lt;String name="PingPingStr" value="PINGPING" token="true" /&gt;
      &lt;String name="PingStr" value="PING" token="true"/&gt;
    &lt;/Choice&gt;
  &lt;/DataModel&gt;

  &lt;DataModel name="Pong"&gt;
    &lt;String value="PONG" /&gt;
  &lt;/DataModel&gt;

  &lt;StateModel name="TheStateModel" initialState="InitialState"&gt;
    &lt;State name="InitialState"&gt;

      &lt;Action type="accept" /&gt;

      &lt;Action type="checkState" ref="ReceiveInput" /&gt;

    &lt;/State&gt;

    &lt;State name="ReceiveInput"&gt;

      &lt;Action type="input"&gt;
        &lt;DataModel ref="Ping"/&gt;
      &lt;/Action&gt;

      &lt;!-- Switch states only when input was PINGPING --&gt;
      &lt;Action type="changeState" ref="PongPongBack"
        when="state.actions[0].dataModel.find('PingPingStr') != None" /&gt;

      &lt;!-- Run this state again --&gt;
      &lt;Action type="changeState" ref="ReceiveInput" /&gt;

    &lt;/State&gt;

    &lt;!-- This state is only reached when input was PINGPING --&gt;
    &lt;State name="SendOutput"&gt;

      &lt;Action type="output"&gt;
        &lt;DataModel ref="Pong"/&gt;
      &lt;/Action&gt;

    &lt;/State&gt;

  &lt;/StateModel&gt;

  &lt;Test name="Default"&gt;
    &lt;StateModel ref="TheStateModel"/&gt;
    &lt;Publisher class="TcpListener"&gt;
      &lt;Param name="Interface" value="0.0.0.0" /&gt;
      &lt;Param name="Port" value="31337" /&gt;
      &lt;Param name="AcceptTimeout" value="10000" /&gt;
      &lt;Param name="Timeout" value="10000" /&gt;
    &lt;/Publisher&gt;

    &lt;Logger class="File" &gt;
      &lt;Param name="Path" value="logs"/&gt;
      &lt;/Logger&gt;
  &lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Result">
<title>Result</title>
<simpara>Result is a child of the <link linkend="Action_call">call</link> Action.</simpara>
<simpara>Methods run with a call Action often return useful data.
Result allows cracking this returned data into a DataModel.
This data can then be slurped into other DataModels and re-used for various purposes.</simpara>
<section xml:id="_syntax_89">
<title>Syntax</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;Action type="call" method="Players[1].GetUrl"&gt;
  &lt;Result&gt;
    &lt;DataModel ref="TheDataModel" /&gt;
  &lt;/Result&gt;
&lt;/Action&gt;</programlisting>
<simpara><emphasis>Attributes:</emphasis></simpara>
<variablelist>
<varlistentry>
<term><link linkend="name">name</link></term>
<listitem>
<simpara>Name of parameter [optional].</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Valid Child Elements:</emphasis></simpara>
<variablelist>
<varlistentry>
<term><link linkend="DataModel">DataModel</link></term>
<listitem>
<simpara>Reference to a DataModel to contain the cracked data.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Godel">
<title>Godel</title>
<simpara>Godel elements allow scripting expressions to be evaluated when the Peach StateModel executes.
If any of the Godel scripting expressions evaluates to false, Peach generates a fault.</simpara>
<simpara>A single Godel element can be placed as a child of <link linkend="StateModel">StateModel</link>, <link linkend="State">State</link> or <link linkend="Action">Action</link>:</simpara>
<itemizedlist>
<listitem>
<simpara>When a Godel element is a child of <link linkend="StateModel">StateModel</link>, the expression evaluates when the StateModel starts and when the StateModel finishes.</simpara>
</listitem>
<listitem>
<simpara>When a Godel element is a child of <link linkend="State">State</link>, the expression evaluates when the State starts and when the State finishes.</simpara>
</listitem>
<listitem>
<simpara>When a Godel element is a child of <link linkend="Action">Action</link>, the expression evaluate when the Action starts and finishes.</simpara>
</listitem>
</itemizedlist>
<simpara>Godel elements support the following scripting expressions:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis>inv</emphasis> - An invariant expression that evaluates both at the start and at the finish of the appropriate level of the StateModel (StateModel, State, or Action)</simpara>
</listitem>
<listitem>
<simpara><emphasis>pre</emphasis> - An expression evaluates at start of the appropriate level of the StateModel</simpara>
</listitem>
<listitem>
<simpara><emphasis>post</emphasis> - A expression that is evaluated upon completion of the appropriate level of the StateModel</simpara>
</listitem>
</itemizedlist>
<section xml:id="_syntax_90">
<title>Syntax</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;Godel inv="self != None"/&gt;</programlisting>
</section>
<section xml:id="_attributes_97">
<title>Attributes</title>
<simpara><emphasis>Required:</emphasis></simpara>
<simpara>None.</simpara>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term><link linkend="name">name</link></term>
<listitem>
<simpara>Name of the data model</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="ref">ref</link></term>
<listitem>
<simpara>Reference to a [Godel] to use as a template.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>inv</term>
<listitem>
<simpara>Scripting expression that evaluates to true or false. Default is null.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>pre</term>
<listitem>
<simpara>Scripting expression that evaluates to true or false. Default is null.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>post</term>
<listitem>
<simpara>Scripting expression that evaluates to true or false. Default is null.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_scripting_expressions">
<title>Scripting Expressions</title>
<simpara>When evaluating the <emphasis>inv</emphasis> and <emphasis>pre</emphasis> scripting expressions two variables are provided: <emphasis>self</emphasis> and <emphasis>context</emphasis>:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis>self</emphasis> is a reference to the parent element.</simpara>
<simpara>For example, when a Godel element is a child of State, <emphasis>self</emphasis> is the state.</simpara>
</listitem>
<listitem>
<simpara><emphasis>context</emphasis> is a reference to the Peach RunContext that contains all state information regarding the current fuzzing run.</simpara>
</listitem>
</itemizedlist>
<simpara>When evaluating the <emphasis>post</emphasis> scripting expressions, an additional variable <emphasis>pre</emphasis> is provided.</simpara>
<itemizedlist>
<listitem>
<simpara>The <emphasis>pre</emphasis> variable is a reference to the previous self from when the parent element started.</simpara>
<simpara>For example, when a <emphasis>post</emphasis> expression is placed on an Action, this expression can access the action as it was prior to completing with the <emphasis>pre</emphasis> variable.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="_examples_123">
<title>Examples</title>
<simpara>The following example uses a simple Godel pre-condition on StateModel, State and Action</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

	&lt;DataModel name="DM"&gt;
		&lt;String name="str" value="Hello"/&gt;
	&lt;/DataModel&gt;

	&lt;StateModel name="SM" initialState="Initial"&gt;
		&lt;Godel pre="str(self.states[0].actions[0].dataModel.find('str').InternalValue) == 'Hello'"/&gt;

		&lt;State name="Initial"&gt;
			&lt;Godel pre="str(self.actions[0].dataModel.find('str').InternalValue) == 'Hello'"/&gt;

			&lt;Action type="output"&gt;
				&lt;Godel pre="str(self.dataModel.find('str').InternalValue) == 'Hello'"/&gt;

				&lt;DataModel ref="DM"/&gt;
			&lt;/Action&gt;

		&lt;/State&gt;

	&lt;/StateModel&gt;

	&lt;Test name="Default"&gt;
		&lt;StateModel ref="SM"/&gt;
		&lt;Publisher class="Console"/&gt;
	&lt;/Test&gt;

&lt;/Peach&gt;</programlisting>
<simpara>Produces the following output:</simpara>
<screen>&gt;peach -1 example.xml --debug

Godel.Core.GodelPitParser Attached godel node to Action 'SM.Initial.Action'.
Godel.Core.GodelPitParser Attached godel node to State 'SM.Initial'.
Godel.Core.GodelPitParser Attached godel node to StateModel 'SM'.

[*] Test 'Default' starting with random seed 56278.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Godel.Core.GodelContext Godel pre: Passed. (StateModel 'SM')
Godel.Core.GodelContext Godel pre: Passed. (State 'SM.Initial')
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Godel.Core.GodelContext Godel pre: Passed. (Action 'SM.Initial.Action')
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher start()
Peach.Core.Publishers.ConsolePublisher open()
Peach.Core.Publishers.ConsolePublisher output(5 bytes)
HelloPeach.Core.Publishers.ConsolePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.ConsolePublisher stop()

[*] Test 'Default' finished.</screen>
<simpara>The following example shows using a reference to a Godel template</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

	&lt;DataModel name="DM"&gt;
		&lt;String name="str" value="Hello"/&gt;
	&lt;/DataModel&gt;

	&lt;Godel name="check" pre="str(self.dataModel.find('str').InternalValue) == 'Hello'"/&gt;

	&lt;StateModel name="SM" initialState="Initial"&gt;
		&lt;State name="Initial"&gt;
			&lt;Action type="output"&gt;
				&lt;Godel ref="check"/&gt;
				&lt;DataModel ref="DM"/&gt;
			&lt;/Action&gt;

			&lt;Action type="output"&gt;
				&lt;Godel ref="check"/&gt;
				&lt;DataModel ref="DM"/&gt;
			&lt;/Action&gt;
		&lt;/State&gt;

	&lt;/StateModel&gt;

	&lt;Test name="Default"&gt;
		&lt;StateModel ref="SM"/&gt;
		&lt;Publisher class="Console"/&gt;
	&lt;/Test&gt;

&lt;/Peach&gt;</programlisting>
<simpara>Produces the following output:</simpara>
<screen>&gt;peach -1 example.xml --debug

Godel.Core.GodelPitParser Attached godel node to Action 'SM.Initial.Action'.
Godel.Core.GodelPitParser Attached godel node to Action 'SM.Initial.Action_1'.

[*] Test 'Default' starting with random seed 54985.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Godel.Core.GodelContext Godel pre: Passed. (Action 'SM.Initial.Action')
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher start()
Peach.Core.Publishers.ConsolePublisher open()
Peach.Core.Publishers.ConsolePublisher output(5 bytes)
HelloPeach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Godel.Core.GodelContext Godel pre: Passed. (Action 'SM.Initial.Action_1')
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher output(5 bytes)
HelloPeach.Core.Publishers.ConsolePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.ConsolePublisher stop()

[*] Test 'Default' finished.</screen>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
</section>
</section>
<section xml:id="Agent">
<title>Agents</title>
<simpara>A Peach agent is a light weight process that can host multiple monitors.
These monitors perform tasks such as fault detection, data collection and automation.</simpara>
<simpara>The Peach agent communicates over a network channel to the main Peach process where all captured information is reported.
This allows the main Peach process to perform monitoring locally or on the device under test.</simpara>
<simpara>Monitors that perform fault detection provide methods to identify when a problem with the target under test during testing. For example, you might use a debugger monitor to detect when a target crashes and collect information about the crash. Peach finds more issues when robust fault detection is configured.</simpara>
<simpara>Data collection monitors are used to gather additional information about a fault that has occured. This can include taking a network capture of the test traffic, collecting log files and running scripts to collect information about the target state. The goal is to collect any information that will be useful in tracking down the root cause of the faulting condition.</simpara>
<simpara>Automation monitors are used to automate the target and target environment. This can include startup automation such as configuring an environment and starting the target. Restarting the environment when a fault occurs so testing can continue. And finally shutting down the target/environment when testing has completed. Some configurations may also require triggering the target to connect/consume data.</simpara>
<figure>
<title>Peach Agent Block Diagram</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/AgentDiagram.svg" align="center"/>
</imageobject>
<textobject><phrase>AgentDiagram</phrase></textobject>
</mediaobject>
</figure>
<sidebar>
<title>Agent Privileges</title>
<simpara>Some monitors or publishers hosted by an agent process sometimes require heightened privileges.
If you receive an error regarding permissions, try running the agent with root or administrative priviledges.</simpara>
<simpara><emphasis role="strong">OS X/Linux/Unix</emphasis></simpara>
<simpara>On OS X, Linux and other Unix systems, a process can be launched as root using the <emphasis>sudo</emphasis> utility.</simpara>
<simpara>For local agents:</simpara>
<literallayout class="monospaced">sudo ./peach</literallayout>
<simpara>For remote agents:</simpara>
<literallayout class="monospaced">sudo ./peachagent</literallayout>
<simpara><emphasis role="strong">Windows</emphasis></simpara>
<simpara>On Windows a process can be started with administrator rights by right-clicking and selecting "Run as Adminsitrator". Optionally the user can be given additional needed priviledges by the system administrator.</simpara>
<simpara><emphasis role="strong">Privileged Monitors</emphasis></simpara>
<simpara>Which monitors require additional privileges depends on the specific OS and privileges of the user, but typically the following require special rights:</simpara>
<itemizedlist>
<listitem>
<simpara>PageHeap (Windows)</simpara>
</listitem>
<listitem>
<simpara>NetworkCapture (OS X/Linux/Unix)</simpara>
</listitem>
</itemizedlist>
</sidebar>
<sidebar>
<title>Network Firewall</title>
<simpara>Many modern operating systems such as Windows and Linux come with a firewall that prevents incoming or outgoing network traffic.
This can prevent a remote agent from communicating with Peach.
On Windows the user is asked when program first runs if a firewall rule should be added.</simpara>
<simpara>On Linux, specifically Ubuntu distributions, this command allows packets through the firewall using port 9001 (default the port for remote agents).</simpara>
<screen>sudo ufw allow 9001</screen>
</sidebar>
<section xml:id="_agent_channels">
<title>Agent Channels</title>
<variablelist>
<varlistentry>
<term>Local Agent (local)</term>
<listitem>
<simpara>The agent is hosted in the current Peach process. This is the default channel. An example agent URL is <literal>local://</literal></simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Remote Agent (tcp)</term>
<listitem>
<simpara>The external Peach agent communicates using network calls over TCP. Peach can run as a remote agent using the <link linkend="Program_PeachAgent">PeachAgent</link> program. Remote agents do not require a valid license and are only used to host monitors or remote publishers. An example agent URL is <literal>tcp://192.168.1.2:9002</literal></simpara>
</listitem>
</varlistentry>
</variablelist>
<section xml:id="_local_agent">
<title>Local Agent</title>
<simpara>The peach runtime supports a local agent that runs in process. LocalAgent is the default agent unless another agent type is specified.</simpara>
<simpara>Agent URL:</simpara>
<literallayout class="monospaced">local://</literallayout>
<formalpara>
<title>Configuring a local agent</title>
<para>
<programlisting language="xml" linenumbering="unnumbered">&lt;Agent name="local"&gt;
   &lt;!-- Monitors --&gt;
&lt;/Agent&gt;</programlisting>
</para>
</formalpara>
</section>
<section xml:id="_remote_agent">
<title>Remote Agent</title>
<simpara>Peach includes a remote <link linkend="Program_PeachAgent">agent server</link> that can be used to host Monitors and Publishers on remote machines. Usage of a remote agent requires a location URL of the following format:</simpara>
<simpara>Agent URL:</simpara>
<literallayout class="monospaced">tcp://HOST:PORT</literallayout>
<variablelist>
<varlistentry>
<term>HOST</term>
<listitem>
<simpara>Remote host the agent is running on</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>PORT</term>
<listitem>
<simpara>Remote port the agent is bound to (defaults to 9001)</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>Example:</simpara>
<literallayout class="monospaced">tcp://192.168.1.100:9001</literallayout>
<formalpara>
<title>Configuring a local agent</title>
<para>
<programlisting language="xml" linenumbering="unnumbered">&lt;Agent name="local" location="tcp://192.168.1.100:9001"&gt;
   &lt;!-- Monitors --&gt;
&lt;/Agent&gt;</programlisting>
</para>
</formalpara>
</section>
<section xml:id="_rest_json_agent">
<title>REST JSON Agent</title>
<simpara>This agent is intended to communicate with custom remote agents written in other languages.</simpara>
<formalpara>
<title>Example configuration with remote publisher</title>
<para>
<programlisting language="xml" linenumbering="unnumbered">&lt;Agent name="TheAgent" location="http://127.0.0.1:9980"&gt;
	&lt;Monitor class="WindowsDebugger"&gt;
		&lt;Param name="Executable" value="c:\windows\system32\mspaint.exe /&gt;
		&lt;Param name="Arguments" value="fuzzed.png" /&gt;
		&lt;Param name="WinDbgPath" value="C:\Program Files (x86)\Debugging Tools for Windows (x86)" /&gt;
		&lt;Param name="StartOnCall" value="ScoobySnacks"/&gt;
	&lt;/Monitor&gt;
	&lt;Monitor class="PageHeap"&gt;
		&lt;Param name="Executable" value="c:\windows\system32\mspaint.exe /&gt;
		&lt;Param name="WinDbgPath" value="C:\Program Files (x86)\Debugging Tools for Windows (x86)" /&gt;
	&lt;/Monitor&gt;
&lt;/Agent&gt;

&lt;Test name="Default"&gt;
	&lt;Agent ref="TheAgent"/&gt;
	&lt;StateModel ref="TheState"/&gt;

	&lt;Publisher class="Remote"&gt;
		&lt;Param name="Agent" value="TheAgent"/&gt;
		&lt;Param name="Class" value="File"/&gt;
		&lt;Param name="FileName" value="fuzzed.png"/&gt;
	&lt;/Publisher&gt;

&lt;/Test&gt;</programlisting>
</para>
</formalpara>
<section xml:id="Rest-API-AgentConnect">
<title>GET /Agent/AgentConnect (Required)</title>
<simpara>Peach instance is connecting to a remote agent.  When called, remote agent should reset it&#8217;s current state, closing any open monitors or publishers.  This method is called once per fuzzing session, unless the connection was lost due to the target system crashing or being reset by post-fault automation.</simpara>
<section xml:id="_responses">
<title>Responses</title>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="16.6666*"/>
<colspec colname="col_2" colwidth="66.6666*"/>
<colspec colname="col_3" colwidth="16.6668*"/>
<thead>
<row>
<entry align="left" valign="top">HTTP Code</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Schema</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>200</simpara></entry>
<entry align="left" valign="top"><simpara>OK</simpara></entry>
<entry align="left" valign="top"><simpara>No Content</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
</section>
<section xml:id="Rest-API-AgentDisconnect">
<title>GET /Agent/AgentDisconnect (Required)</title>
<simpara>Peach instance is disconnecting from the remote agent. When called, the remote agent should release any resources created, including monitors and publishers. This method is called once at the end of a fuzzing session.  This method should never return an error.</simpara>
<section xml:id="_responses_2">
<title>Responses</title>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="16.6666*"/>
<colspec colname="col_2" colwidth="66.6666*"/>
<colspec colname="col_3" colwidth="16.6668*"/>
<thead>
<row>
<entry align="left" valign="top">HTTP Code</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Schema</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>200</simpara></entry>
<entry align="left" valign="top"><simpara>OK</simpara></entry>
<entry align="left" valign="top"><simpara>No Content</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
</section>
<section xml:id="Rest-API-StartMonitor">
<title>POST /Agent/StartMonitor</title>
<simpara>Start a monitor. This is called after <link linkend="Rest-API-AgentConnect">AgentConnect</link> to start an instance of a monitor. The parameters contain the information configured in the <literal>Monitor</literal> element of the Pit file.</simpara>
<section xml:id="_parameters_62">
<title>Parameters</title>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="5">
<colspec colname="col_1" colwidth="7.1428*"/>
<colspec colname="col_2" colwidth="14.2857*"/>
<colspec colname="col_3" colwidth="57.1428*"/>
<colspec colname="col_4" colwidth="7.1428*"/>
<colspec colname="col_5" colwidth="14.2859*"/>
<thead>
<row>
<entry align="left" valign="top">Type</entry>
<entry align="left" valign="top">Name</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Required</entry>
<entry align="left" valign="top">Schema</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Query</simpara></entry>
<entry align="left" valign="top"><simpara>name</simpara></entry>
<entry align="left" valign="top"><simpara>Name of monitor</simpara></entry>
<entry align="left" valign="top"><simpara>True</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Query</simpara></entry>
<entry align="left" valign="top"><simpara>cls</simpara></entry>
<entry align="left" valign="top"><simpara>Monitor class. Value from <literal>class</literal> attribute.</simpara></entry>
<entry align="left" valign="top"><simpara>True</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Body</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>Arguments for monitor.</simpara></entry>
<entry align="left" valign="top"><simpara>True</simpara></entry>
<entry align="left" valign="top"><simpara><link linkend="Agent-Rest-Schema-Args">Args</link></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
<section xml:id="_responses_3">
<title>Responses</title>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="16.6666*"/>
<colspec colname="col_2" colwidth="66.6666*"/>
<colspec colname="col_3" colwidth="16.6668*"/>
<thead>
<row>
<entry align="left" valign="top">HTTP Code</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Schema</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>200</simpara></entry>
<entry align="left" valign="top"><simpara>OK</simpara></entry>
<entry align="left" valign="top"><simpara>No Content</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
</section>
<section xml:id="Rest-API-StopAllMonitors">
<title>GET /Agent/StopAllMonitors (Required)</title>
<simpara>Stop all active monitors. Typically called prior to <link linkend="Rest-API-AgentDisconnect">AgentDisconnect</link>.</simpara>
<section xml:id="_responses_4">
<title>Responses</title>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="16.6666*"/>
<colspec colname="col_2" colwidth="66.6666*"/>
<colspec colname="col_3" colwidth="16.6668*"/>
<thead>
<row>
<entry align="left" valign="top">HTTP Code</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Schema</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>200</simpara></entry>
<entry align="left" valign="top"><simpara>OK</simpara></entry>
<entry align="left" valign="top"><simpara>No Content</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
</section>
<section xml:id="Rest-API-SessionStarting">
<title>GET /Agent/SessionStarting (Required)</title>
<simpara>Session starting. Called once to indicate a fuzzing job is starting.</simpara>
<section xml:id="_responses_5">
<title>Responses</title>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="16.6666*"/>
<colspec colname="col_2" colwidth="66.6666*"/>
<colspec colname="col_3" colwidth="16.6668*"/>
<thead>
<row>
<entry align="left" valign="top">HTTP Code</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Schema</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>200</simpara></entry>
<entry align="left" valign="top"><simpara>OK</simpara></entry>
<entry align="left" valign="top"><simpara>No Content</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
</section>
<section xml:id="Rest-API-SessionFinished">
<title>GET /Agent/SessionFinished (Required)</title>
<simpara>Session finished. Called once to indicate a fuzzing job has finished.  Typically called prior to <link linkend="Rest-API-StopAllMonitors">StopAllMonitors</link> and <link linkend="Rest-API-AgentDisconnect">AgentDisconnect</link>.</simpara>
<section xml:id="_responses_6">
<title>Responses</title>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="16.6666*"/>
<colspec colname="col_2" colwidth="66.6666*"/>
<colspec colname="col_3" colwidth="16.6668*"/>
<thead>
<row>
<entry align="left" valign="top">HTTP Code</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Schema</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>200</simpara></entry>
<entry align="left" valign="top"><simpara>OK</simpara></entry>
<entry align="left" valign="top"><simpara>No Content</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
</section>
<section xml:id="Rest-API-IterationStarting">
<title>GET /Agent/IterationStarting (Required)</title>
<simpara>Iteration starting. Called at the start of each test case.</simpara>
<section xml:id="_parameters_63">
<title>Parameters</title>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="5">
<colspec colname="col_1" colwidth="7.1428*"/>
<colspec colname="col_2" colwidth="14.2857*"/>
<colspec colname="col_3" colwidth="57.1428*"/>
<colspec colname="col_4" colwidth="7.1428*"/>
<colspec colname="col_5" colwidth="14.2859*"/>
<thead>
<row>
<entry align="left" valign="top">Type</entry>
<entry align="left" valign="top">Name</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Required</entry>
<entry align="left" valign="top">Schema</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Query</simpara></entry>
<entry align="left" valign="top"><simpara>isReproduction</simpara></entry>
<entry align="left" valign="top"><simpara>Is current test case part of fault reproduction?</simpara></entry>
<entry align="left" valign="top"><simpara>true</simpara></entry>
<entry align="left" valign="top"><simpara>Boolean</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Query</simpara></entry>
<entry align="left" valign="top"><simpara>lastWasFault</simpara></entry>
<entry align="left" valign="top"><simpara>Was last iteration a fault?</simpara></entry>
<entry align="left" valign="top"><simpara>true</simpara></entry>
<entry align="left" valign="top"><simpara>Boolean</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Query</simpara></entry>
<entry align="left" valign="top"><simpara>iterationCount</simpara></entry>
<entry align="left" valign="top"><simpara>DEPRECATED, always 0</simpara></entry>
<entry align="left" valign="top"><simpara>true</simpara></entry>
<entry align="left" valign="top"><simpara>Integer</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
<section xml:id="_responses_7">
<title>Responses</title>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="16.6666*"/>
<colspec colname="col_2" colwidth="66.6666*"/>
<colspec colname="col_3" colwidth="16.6668*"/>
<thead>
<row>
<entry align="left" valign="top">HTTP Code</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Schema</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>200</simpara></entry>
<entry align="left" valign="top"><simpara>OK</simpara></entry>
<entry align="left" valign="top"><simpara>No Content</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
</section>
<section xml:id="Rest-API-IterationFinished">
<title>GET /Agent/IterationFinished (Required)</title>
<simpara>Iteration finished. Called at the end of each test case.</simpara>
<section xml:id="_responses_8">
<title>Responses</title>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="16.6666*"/>
<colspec colname="col_2" colwidth="66.6666*"/>
<colspec colname="col_3" colwidth="16.6668*"/>
<thead>
<row>
<entry align="left" valign="top">HTTP Code</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Schema</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>200</simpara></entry>
<entry align="left" valign="top"><simpara>OK</simpara></entry>
<entry align="left" valign="top"><simpara>No Content</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
</section>
<section xml:id="Rest-API-DetectedFault">
<title>GET /Agent/DetectedFault (Required)</title>
<simpara>Was a fault detected? Called after <link linkend="Rest-API-IterationFinished">IterationFinished</link> for each test case.</simpara>
<section xml:id="_responses_9">
<title>Responses</title>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="16.6666*"/>
<colspec colname="col_2" colwidth="66.6666*"/>
<colspec colname="col_3" colwidth="16.6668*"/>
<thead>
<row>
<entry align="left" valign="top">HTTP Code</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Schema</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>200</simpara></entry>
<entry align="left" valign="top"><simpara>OK</simpara></entry>
<entry align="left" valign="top"><simpara><link linkend="Agent-Rest-Schema-DetectedFault">DetectedFault Response</link></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
</section>
<section xml:id="Rest-API-GetMonitorData">
<title>GET /Agent/GetMonitorData (Required)</title>
<simpara>Return monitor data. Called when a fault has been detected on the current test case and the engine is collecting data from the agents/monitors. Data for each monitor that has been started is returned in the results of this call.</simpara>
<note>
<simpara>GetMonitorData can be called even if <link linkend="Rest-API-DetectedFault">DetectedFault</link> returns false if another peach component (agent, publisher, etc.) indicates a fault has occured.</simpara>
</note>
<section xml:id="_responses_10">
<title>Responses</title>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="16.6666*"/>
<colspec colname="col_2" colwidth="66.6666*"/>
<colspec colname="col_3" colwidth="16.6668*"/>
<thead>
<row>
<entry align="left" valign="top">HTTP Code</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Schema</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>200</simpara></entry>
<entry align="left" valign="top"><simpara>OK</simpara></entry>
<entry align="left" valign="top"><simpara><link linkend="Agent-Rest-Schema-GetMonitorData">GetMonitorData Response</link></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
</section>
<section xml:id="Rest-API-Message">
<title>GET /Agent/Message (Required)</title>
<simpara>Message (Event) from state model. Called when an event is broadcast from the StateModel using
an action type <emphasis>call</emphasis> with a publisher of <emphasis>Peach.Agent</emphasis>.</simpara>
<section xml:id="_parameters_64">
<title>Parameters</title>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="5">
<colspec colname="col_1" colwidth="7.1428*"/>
<colspec colname="col_2" colwidth="14.2857*"/>
<colspec colname="col_3" colwidth="57.1428*"/>
<colspec colname="col_4" colwidth="7.1428*"/>
<colspec colname="col_5" colwidth="14.2859*"/>
<thead>
<row>
<entry align="left" valign="top">Type</entry>
<entry align="left" valign="top">Name</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Required</entry>
<entry align="left" valign="top">Schema</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Query</simpara></entry>
<entry align="left" valign="top"><simpara>msg</simpara></entry>
<entry align="left" valign="top"><simpara>Message/event</simpara></entry>
<entry align="left" valign="top"><simpara>True</simpara></entry>
<entry align="left" valign="top"><simpara>String</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
<section xml:id="_responses_11">
<title>Responses</title>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="16.6666*"/>
<colspec colname="col_2" colwidth="66.6666*"/>
<colspec colname="col_3" colwidth="16.6668*"/>
<thead>
<row>
<entry align="left" valign="top">HTTP Code</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Schema</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>200</simpara></entry>
<entry align="left" valign="top"><simpara>OK</simpara></entry>
<entry align="left" valign="top"><simpara>No Content</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
</section>
<section xml:id="Rest-API-Pub-CreatePublisher">
<title>POST /Publisher/CreatePublisher</title>
<simpara>Create a publisher hosted in the remote agent. Only a single Publisher can be created per
remote agent.</simpara>
<section xml:id="_parameters_65">
<title>Parameters</title>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="5">
<colspec colname="col_1" colwidth="7.1428*"/>
<colspec colname="col_2" colwidth="14.2857*"/>
<colspec colname="col_3" colwidth="57.1428*"/>
<colspec colname="col_4" colwidth="7.1428*"/>
<colspec colname="col_5" colwidth="14.2859*"/>
<thead>
<row>
<entry align="left" valign="top">Type</entry>
<entry align="left" valign="top">Name</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Required</entry>
<entry align="left" valign="top">Schema</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Body</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>True</simpara></entry>
<entry align="left" valign="top"><simpara><link linkend="Agent-Rest-Schema-CreatePublisher">CreatePublisher Request</link></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
<section xml:id="_responses_12">
<title>Responses</title>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="16.6666*"/>
<colspec colname="col_2" colwidth="66.6666*"/>
<colspec colname="col_3" colwidth="16.6668*"/>
<thead>
<row>
<entry align="left" valign="top">HTTP Code</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Schema</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>200</simpara></entry>
<entry align="left" valign="top"><simpara>OK</simpara></entry>
<entry align="left" valign="top"><simpara><link linkend="Agent-Rest-Schema-PublisherResponse">PublisherResponse</link></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
</section>
<section xml:id="Rest-API-Pub-Start">
<title>GET /Publisher/start</title>
<simpara>Action of type <emphasis>start</emphasis> called on publisher.</simpara>
<section xml:id="_responses_13">
<title>Responses</title>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="16.6666*"/>
<colspec colname="col_2" colwidth="66.6666*"/>
<colspec colname="col_3" colwidth="16.6668*"/>
<thead>
<row>
<entry align="left" valign="top">HTTP Code</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Schema</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>200</simpara></entry>
<entry align="left" valign="top"><simpara>OK</simpara></entry>
<entry align="left" valign="top"><simpara><link linkend="Agent-Rest-Schema-PublisherResponse">PublisherResponse</link></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
</section>
<section xml:id="Rest-API-Pub-Stop">
<title>GET /Publisher/stop</title>
<simpara>Action of type <emphasis>stop</emphasis> called on publisher.</simpara>
<section xml:id="_responses_14">
<title>Responses</title>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="16.6666*"/>
<colspec colname="col_2" colwidth="66.6666*"/>
<colspec colname="col_3" colwidth="16.6668*"/>
<thead>
<row>
<entry align="left" valign="top">HTTP Code</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Schema</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>200</simpara></entry>
<entry align="left" valign="top"><simpara>OK</simpara></entry>
<entry align="left" valign="top"><simpara><link linkend="Agent-Rest-Schema-PublisherResponse">PublisherResponse</link></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
</section>
<section xml:id="Rest-API-Pub-Open">
<title>GET /Publisher/open</title>
<simpara>Action of type <emphasis>open</emphasis> called on publisher. Prior to <emphasis>open</emphasis> being called both <link linkend="Rest-API-Pub-Set_Iteration">Set_Iteration</link> and <link linkend="Rest-API-Pub-Set_IsControlIteration">Set_IsControlIteration</link> are called.</simpara>
<section xml:id="_responses_15">
<title>Responses</title>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="16.6666*"/>
<colspec colname="col_2" colwidth="66.6666*"/>
<colspec colname="col_3" colwidth="16.6668*"/>
<thead>
<row>
<entry align="left" valign="top">HTTP Code</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Schema</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>200</simpara></entry>
<entry align="left" valign="top"><simpara>OK</simpara></entry>
<entry align="left" valign="top"><simpara><link linkend="Agent-Rest-Schema-PublisherResponse">PublisherResponse</link></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
</section>
<section xml:id="Rest-API-Pub-Set_Iteration">
<title>GET /Publisher/Set_Iteration</title>
<simpara>Provide the current iteration number to the publisher. This is called prior to the first <link linkend="Rest-API-Pub-Open">open</link> or <link linkend="Rest-API-Pub-Call">call</link>.</simpara>
<section xml:id="_parameters_66">
<title>Parameters</title>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="5">
<colspec colname="col_1" colwidth="7.1428*"/>
<colspec colname="col_2" colwidth="14.2857*"/>
<colspec colname="col_3" colwidth="57.1428*"/>
<colspec colname="col_4" colwidth="7.1428*"/>
<colspec colname="col_5" colwidth="14.2859*"/>
<thead>
<row>
<entry align="left" valign="top">Type</entry>
<entry align="left" valign="top">Name</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Required</entry>
<entry align="left" valign="top">Schema</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Body</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>true</simpara></entry>
<entry align="left" valign="top"><simpara><link linkend="Agent-Rest-Schema-Iteration">Iteration</link></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
<section xml:id="_responses_16">
<title>Responses</title>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="16.6666*"/>
<colspec colname="col_2" colwidth="66.6666*"/>
<colspec colname="col_3" colwidth="16.6668*"/>
<thead>
<row>
<entry align="left" valign="top">HTTP Code</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Schema</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>200</simpara></entry>
<entry align="left" valign="top"><simpara>OK</simpara></entry>
<entry align="left" valign="top"><simpara><link linkend="Agent-Rest-Schema-PublisherResponse">PublisherResponse</link></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
</section>
<section xml:id="Rest-API-Pub-Set_IsControlIteration">
<title>GET /Publisher/Set_IsControlIteration</title>
<simpara>Provide the current iteration number to the publisher. This is called prior to the first <link linkend="Rest-API-Pub-Open">open</link> or <link linkend="Rest-API-Pub-Call">call</link>.</simpara>
<section xml:id="_parameters_67">
<title>Parameters</title>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="5">
<colspec colname="col_1" colwidth="7.1428*"/>
<colspec colname="col_2" colwidth="14.2857*"/>
<colspec colname="col_3" colwidth="57.1428*"/>
<colspec colname="col_4" colwidth="7.1428*"/>
<colspec colname="col_5" colwidth="14.2859*"/>
<thead>
<row>
<entry align="left" valign="top">Type</entry>
<entry align="left" valign="top">Name</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Required</entry>
<entry align="left" valign="top">Schema</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Body</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>true</simpara></entry>
<entry align="left" valign="top"><simpara><link linkend="Agent-Rest-Schema-IsControlIteration">IsControlIteration</link></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
<section xml:id="_responses_17">
<title>Responses</title>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="16.6666*"/>
<colspec colname="col_2" colwidth="66.6666*"/>
<colspec colname="col_3" colwidth="16.6668*"/>
<thead>
<row>
<entry align="left" valign="top">HTTP Code</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Schema</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>200</simpara></entry>
<entry align="left" valign="top"><simpara>OK</simpara></entry>
<entry align="left" valign="top"><simpara><link linkend="Agent-Rest-Schema-PublisherResponse">PublisherResponse</link></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
</section>
<section xml:id="Rest-API-Pub-Close">
<title>GET /Publisher/close</title>
<simpara>Action of type <emphasis>open</emphasis> called on publisher.</simpara>
<section xml:id="_responses_18">
<title>Responses</title>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="16.6666*"/>
<colspec colname="col_2" colwidth="66.6666*"/>
<colspec colname="col_3" colwidth="16.6668*"/>
<thead>
<row>
<entry align="left" valign="top">HTTP Code</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Schema</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>200</simpara></entry>
<entry align="left" valign="top"><simpara>OK</simpara></entry>
<entry align="left" valign="top"><simpara><link linkend="Agent-Rest-Schema-PublisherResponse">PublisherResponse</link></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
</section>
<section xml:id="Rest-API-Pub-Accept">
<title>GET /Publisher/accept</title>
<simpara>Action of type <emphasis>accept</emphasis> called on publisher.  Call should block until completion.</simpara>
<section xml:id="_responses_19">
<title>Responses</title>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="16.6666*"/>
<colspec colname="col_2" colwidth="66.6666*"/>
<colspec colname="col_3" colwidth="16.6668*"/>
<thead>
<row>
<entry align="left" valign="top">HTTP Code</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Schema</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>200</simpara></entry>
<entry align="left" valign="top"><simpara>OK</simpara></entry>
<entry align="left" valign="top"><simpara><link linkend="Agent-Rest-Schema-PublisherResponse">PublisherResponse</link></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
</section>
<section xml:id="Rest-API-Pub-Call">
<title>GET /Publisher/call</title>
<simpara>Action of type <emphasis>call</emphasis> called on publisher.</simpara>
<section xml:id="_parameters_68">
<title>Parameters</title>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="5">
<colspec colname="col_1" colwidth="7.1428*"/>
<colspec colname="col_2" colwidth="14.2857*"/>
<colspec colname="col_3" colwidth="57.1428*"/>
<colspec colname="col_4" colwidth="7.1428*"/>
<colspec colname="col_5" colwidth="14.2859*"/>
<thead>
<row>
<entry align="left" valign="top">Type</entry>
<entry align="left" valign="top">Name</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Required</entry>
<entry align="left" valign="top">Schema</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Body</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>true</simpara></entry>
<entry align="left" valign="top"><simpara><link linkend="Agent-Rest-Schema-Call">Call</link></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
<section xml:id="_responses_20">
<title>Responses</title>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="16.6666*"/>
<colspec colname="col_2" colwidth="66.6666*"/>
<colspec colname="col_3" colwidth="16.6668*"/>
<thead>
<row>
<entry align="left" valign="top">HTTP Code</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Schema</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>200</simpara></entry>
<entry align="left" valign="top"><simpara>OK</simpara></entry>
<entry align="left" valign="top"><simpara><link linkend="Agent-Rest-Schema-Result">Result</link></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
</section>
<section xml:id="Rest-API-Pub-SetProperty">
<title>POST /Publisher/setProperty</title>
<simpara>Action of type <emphasis>setProperty</emphasis> called on publisher.</simpara>
<section xml:id="_parameters_69">
<title>Parameters</title>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="5">
<colspec colname="col_1" colwidth="7.1428*"/>
<colspec colname="col_2" colwidth="14.2857*"/>
<colspec colname="col_3" colwidth="57.1428*"/>
<colspec colname="col_4" colwidth="7.1428*"/>
<colspec colname="col_5" colwidth="14.2859*"/>
<thead>
<row>
<entry align="left" valign="top">Type</entry>
<entry align="left" valign="top">Name</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Required</entry>
<entry align="left" valign="top">Schema</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Body</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>true</simpara></entry>
<entry align="left" valign="top"><simpara><link linkend="Agent-Rest-Schema-SetProperty">SetProperty</link></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
<section xml:id="_responses_21">
<title>Responses</title>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="16.6666*"/>
<colspec colname="col_2" colwidth="66.6666*"/>
<colspec colname="col_3" colwidth="16.6668*"/>
<thead>
<row>
<entry align="left" valign="top">HTTP Code</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Schema</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>200</simpara></entry>
<entry align="left" valign="top"><simpara>OK</simpara></entry>
<entry align="left" valign="top"><simpara><link linkend="Agent-Rest-Schema-PublisherResponse">PublisherResponse</link></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
</section>
<section xml:id="Rest-API-Pub-GetProperty">
<title>GET /Publisher/getProperty</title>
<simpara>Action of type <emphasis>getProperty</emphasis> called on publisher.</simpara>
<section xml:id="_parameters_70">
<title>Parameters</title>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="5">
<colspec colname="col_1" colwidth="7.1428*"/>
<colspec colname="col_2" colwidth="14.2857*"/>
<colspec colname="col_3" colwidth="57.1428*"/>
<colspec colname="col_4" colwidth="7.1428*"/>
<colspec colname="col_5" colwidth="14.2859*"/>
<thead>
<row>
<entry align="left" valign="top">Type</entry>
<entry align="left" valign="top">Name</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Required</entry>
<entry align="left" valign="top">Schema</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Body</simpara></entry>
<entry align="left" valign="top"><simpara>property</simpara></entry>
<entry align="left" valign="top"><simpara>The property to retrive the value of.</simpara></entry>
<entry align="left" valign="top"><simpara>true</simpara></entry>
<entry align="left" valign="top"><simpara>Json String</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
<section xml:id="_responses_22">
<title>Responses</title>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="16.6666*"/>
<colspec colname="col_2" colwidth="66.6666*"/>
<colspec colname="col_3" colwidth="16.6668*"/>
<thead>
<row>
<entry align="left" valign="top">HTTP Code</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Schema</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>200</simpara></entry>
<entry align="left" valign="top"><simpara>OK</simpara></entry>
<entry align="left" valign="top"><simpara><link linkend="Agent-Rest-Schema-Result">Result</link></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
</section>
<section xml:id="Rest-API-Pub-Output">
<title>POST /Publisher/output</title>
<simpara>Action of type <emphasis>output</emphasis> called on publisher.</simpara>
<section xml:id="_parameters_71">
<title>Parameters</title>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="5">
<colspec colname="col_1" colwidth="7.1428*"/>
<colspec colname="col_2" colwidth="14.2857*"/>
<colspec colname="col_3" colwidth="57.1428*"/>
<colspec colname="col_4" colwidth="7.1428*"/>
<colspec colname="col_5" colwidth="14.2859*"/>
<thead>
<row>
<entry align="left" valign="top">Type</entry>
<entry align="left" valign="top">Name</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Required</entry>
<entry align="left" valign="top">Schema</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Body</simpara></entry>
<entry align="left" valign="top"><simpara>data</simpara></entry>
<entry align="left" valign="top"><simpara>Data to output</simpara></entry>
<entry align="left" valign="top"><simpara>true</simpara></entry>
<entry align="left" valign="top"><simpara><link linkend="Agent-Rest-Schema-Output">Output</link></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
<section xml:id="_responses_23">
<title>Responses</title>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="16.6666*"/>
<colspec colname="col_2" colwidth="66.6666*"/>
<colspec colname="col_3" colwidth="16.6668*"/>
<thead>
<row>
<entry align="left" valign="top">HTTP Code</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Schema</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>200</simpara></entry>
<entry align="left" valign="top"><simpara>OK</simpara></entry>
<entry align="left" valign="top"><simpara><link linkend="Agent-Rest-Schema-PublisherResponse">PublisherResponse</link></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
</section>
<section xml:id="Rest-API-Pub-Input">
<title>GET /Publisher/input</title>
<simpara>Action of type <emphasis>intput</emphasis> called on publisher. Calls to <link linkend="Rest-API-Pub-WantBytes">WantBytes</link> will be made to read the input data as needed by the data cracker following an <emphasis>input</emphasis> call.</simpara>
<section xml:id="_responses_24">
<title>Responses</title>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="16.6666*"/>
<colspec colname="col_2" colwidth="66.6666*"/>
<colspec colname="col_3" colwidth="16.6668*"/>
<thead>
<row>
<entry align="left" valign="top">HTTP Code</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Schema</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>200</simpara></entry>
<entry align="left" valign="top"><simpara>OK</simpara></entry>
<entry align="left" valign="top"><simpara><link linkend="Agent-Rest-Schema-PublisherResponse">PublisherResponse</link></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
</section>
<section xml:id="Rest-API-Pub-WantBytes">
<title>GET /Publisher/WantBytes</title>
<simpara>Called to read data during an <emphasis>input</emphasis> action. Always follows a call to <link linkend="Rest-API-Pub-Input">input</link>.</simpara>
<section xml:id="_parameters_72">
<title>Parameters</title>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="5">
<colspec colname="col_1" colwidth="7.1428*"/>
<colspec colname="col_2" colwidth="14.2857*"/>
<colspec colname="col_3" colwidth="57.1428*"/>
<colspec colname="col_4" colwidth="7.1428*"/>
<colspec colname="col_5" colwidth="14.2859*"/>
<thead>
<row>
<entry align="left" valign="top">Type</entry>
<entry align="left" valign="top">Name</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Required</entry>
<entry align="left" valign="top">Schema</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Body</simpara></entry>
<entry align="left" valign="top"><simpara>count</simpara></entry>
<entry align="left" valign="top"><simpara>Number of bytes to read</simpara></entry>
<entry align="left" valign="top"><simpara>true</simpara></entry>
<entry align="left" valign="top"><simpara><link linkend="Agent-Rest-Schema-Count">Count</link></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
<section xml:id="_responses_25">
<title>Responses</title>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="16.6666*"/>
<colspec colname="col_2" colwidth="66.6666*"/>
<colspec colname="col_3" colwidth="16.6668*"/>
<thead>
<row>
<entry align="left" valign="top">HTTP Code</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Schema</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>200</simpara></entry>
<entry align="left" valign="top"><simpara>OK</simpara></entry>
<entry align="left" valign="top"><simpara><link linkend="Agent-Rest-Schema-DataResponse">DataResponse</link></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
</section>
<section xml:id="_schemas">
<title>Schemas</title>
<simpara>The following are sent/received in the JSON format.</simpara>
<section xml:id="Agent-Rest-Schema-Args">
<title>Args</title>
<simpara>Variable set of arguments passed into our out of a call.
Used by StartMonitor to pass monitor arguments.</simpara>
<formalpara>
<title>Example monitor definition</title>
<para>
<programlisting language="xml" linenumbering="unnumbered">&lt;Monitor class="WindowsDebugger"&gt;
    &lt;Param name="Executable" value="c:\windows\system32\mspaint.exe" /&gt;
    &lt;Param name="Arguments" value="fuzzed.png" /&gt;
    &lt;Param name="WinDbgPath" value="C:\Program Files (x86)\Debugging Tools for Windows (x86)" /&gt;
    &lt;Param name="StartOnCall" value="ScoobySnacks"/&gt;
&lt;/Monitor&gt;</programlisting>
</para>
</formalpara>
<formalpara>
<title>Resulting arguments object</title>
<para>
<programlisting language="java" linenumbering="unnumbered">{
    "args" : {
        "Executable" : "c:\\windows\\system32\\mspaint.exe",
        "Arguments" : "fuzzed.png",
        "WinDbgPath" : "C:\\Program Files (x86)\\Debugging Tools for Windows (x86)",
        "StartOnCall" : "ScoobySnacks"
    }
}</programlisting>
</para>
</formalpara>
</section>
<section xml:id="Agent-Rest-Schema-DetectedFault">
<title>DetectedFault Response</title>
<simpara>Generic status response object.</simpara>
<programlisting language="java" linenumbering="unnumbered">{
    "Status" : "true",
}</programlisting>
<table frame="all" rowsep="1" colsep="1">
<title>Parameters</title>
<tgroup cols="4">
<colspec colname="col_1" colwidth="15.3846*"/>
<colspec colname="col_2" colwidth="61.5384*"/>
<colspec colname="col_3" colwidth="7.6923*"/>
<colspec colname="col_4" colwidth="15.3847*"/>
<thead>
<row>
<entry align="left" valign="top">Name</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Required</entry>
<entry align="left" valign="top">Schema</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Status</simpara></entry>
<entry align="left" valign="top"><simpara>Was a fault detected?</simpara></entry>
<entry align="left" valign="top"><simpara>true</simpara></entry>
<entry align="left" valign="top"><simpara>Bool</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
</section>
<section xml:id="Agent-Rest-Schema-GetMonitorData">
<title>GetMonitorData Response</title>
<simpara>Collection of monitor data.</simpara>
<programlisting language="java" linenumbering="unnumbered">{
    "Results": [
        {
            "detectionSource":"",
            "monitorName":"",
            "collectedData":[
                {"":"data1","Value":"AA=="}
            ]
        }
    ]
}</programlisting>
<table frame="all" rowsep="1" colsep="1">
<title>Parameters</title>
<tgroup cols="4">
<colspec colname="col_1" colwidth="15.3846*"/>
<colspec colname="col_2" colwidth="61.5384*"/>
<colspec colname="col_3" colwidth="7.6923*"/>
<colspec colname="col_4" colwidth="15.3847*"/>
<thead>
<row>
<entry align="left" valign="top">Name</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Required</entry>
<entry align="left" valign="top">Schema</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Results</simpara></entry>
<entry align="left" valign="top"><simpara>Array of monitor data, one entry per monitor</simpara></entry>
<entry align="left" valign="top"><simpara>true</simpara></entry>
<entry align="left" valign="top"><simpara><link linkend="Agent-Rest-Schema-MonitorData">MonitorData</link></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
</section>
<section xml:id="Agent-Rest-Schema-MonitorData">
<title>MonitorData Response</title>
<simpara>Data collected by a monitor.</simpara>
<programlisting language="java" linenumbering="unnumbered">{
    "detectionSource":"RunCommand",
    "monitorName":"CheckPid",
    "collectedData":[
        {"Key":"stdout.txt","Value":"AA=="}
    ]
}</programlisting>
<table frame="all" rowsep="1" colsep="1">
<title>Parameters</title>
<tgroup cols="4">
<colspec colname="col_1" colwidth="15.3846*"/>
<colspec colname="col_2" colwidth="61.5384*"/>
<colspec colname="col_3" colwidth="7.6923*"/>
<colspec colname="col_4" colwidth="15.3847*"/>
<thead>
<row>
<entry align="left" valign="top">Name</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Required</entry>
<entry align="left" valign="top">Schema</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>detectionSource</simpara></entry>
<entry align="left" valign="top"><simpara>Monitors class name</simpara></entry>
<entry align="left" valign="top"><simpara>true</simpara></entry>
<entry align="left" valign="top"><simpara>String</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>monitorName</simpara></entry>
<entry align="left" valign="top"><simpara>Name attribute from monitor definition</simpara></entry>
<entry align="left" valign="top"><simpara>true</simpara></entry>
<entry align="left" valign="top"><simpara>String</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>collectedData</simpara></entry>
<entry align="left" valign="top"><simpara>Array of assets collected/created by monitor</simpara></entry>
<entry align="left" valign="top"><simpara>true</simpara></entry>
<entry align="left" valign="top"><simpara><link linkend="Agent-Rest-Schema-Data">Data</link></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
</section>
<section xml:id="Agent-Rest-Schema-Data">
<title>Data Response</title>
<simpara>Named binary data.</simpara>
<programlisting language="java" linenumbering="unnumbered">{
    "Key":"stdout.txt",
    "Value":"AA=="}
}</programlisting>
<table frame="all" rowsep="1" colsep="1">
<title>Parameters</title>
<tgroup cols="4">
<colspec colname="col_1" colwidth="15.3846*"/>
<colspec colname="col_2" colwidth="61.5384*"/>
<colspec colname="col_3" colwidth="7.6923*"/>
<colspec colname="col_4" colwidth="15.3847*"/>
<thead>
<row>
<entry align="left" valign="top">Name</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Required</entry>
<entry align="left" valign="top">Schema</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Key</simpara></entry>
<entry align="left" valign="top"><simpara>Filename for data</simpara></entry>
<entry align="left" valign="top"><simpara>true</simpara></entry>
<entry align="left" valign="top"><simpara>String</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Value</simpara></entry>
<entry align="left" valign="top"><simpara>Data (base64 encoded)</simpara></entry>
<entry align="left" valign="top"><simpara>true</simpara></entry>
<entry align="left" valign="top"><simpara>Bytes</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
</section>
<section xml:id="Agent-Rest-Schema-PublisherResponse">
<title>PublisherResponse Response</title>
<simpara>Response for Publisher API</simpara>
<formalpara>
<title>Exmaple of non-error result</title>
<para>
<programlisting language="java" linenumbering="unnumbered">{
    "error": false,
}</programlisting>
</para>
</formalpara>
<formalpara>
<title>Exmaple of error result</title>
<para>
<programlisting language="java" linenumbering="unnumbered">{
    "error": true,
    "errorString": "Error creating publisher XYZ"
}</programlisting>
</para>
</formalpara>
<table frame="all" rowsep="1" colsep="1">
<title>Parameters</title>
<tgroup cols="4">
<colspec colname="col_1" colwidth="15.3846*"/>
<colspec colname="col_2" colwidth="61.5384*"/>
<colspec colname="col_3" colwidth="7.6923*"/>
<colspec colname="col_4" colwidth="15.3847*"/>
<thead>
<row>
<entry align="left" valign="top">Name</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Required</entry>
<entry align="left" valign="top">Schema</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>error</simpara></entry>
<entry align="left" valign="top"><simpara>Has an error occured?</simpara></entry>
<entry align="left" valign="top"><simpara>true</simpara></entry>
<entry align="left" valign="top"><simpara>Boolean</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>errorString</simpara></entry>
<entry align="left" valign="top"><simpara>Error message</simpara></entry>
<entry align="left" valign="top"><simpara>false</simpara></entry>
<entry align="left" valign="top"><simpara>String</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
</section>
<section xml:id="Agent-Rest-Schema-CreatePublisher">
<title>CreatePublisher Request</title>
<simpara>Create publisher request object.</simpara>
<programlisting language="java" linenumbering="unnumbered">{
    "iteration": 1,
    "isControlIteration": false,
    "Cls": "Ioctl",
    "args":{
        "arg1":"xyz",
        "arg2":"xyz",
        "arg3":"xyz",
    }
}</programlisting>
<table frame="all" rowsep="1" colsep="1">
<title>Parameters</title>
<tgroup cols="4">
<colspec colname="col_1" colwidth="15.3846*"/>
<colspec colname="col_2" colwidth="61.5384*"/>
<colspec colname="col_3" colwidth="7.6923*"/>
<colspec colname="col_4" colwidth="15.3847*"/>
<thead>
<row>
<entry align="left" valign="top">Name</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Required</entry>
<entry align="left" valign="top">Schema</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>iteration</simpara></entry>
<entry align="left" valign="top"><simpara>Iteration/testcase number</simpara></entry>
<entry align="left" valign="top"><simpara>true</simpara></entry>
<entry align="left" valign="top"><simpara>Integer</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>isControlIteration</simpara></entry>
<entry align="left" valign="top"><simpara>Is this a control iteration</simpara></entry>
<entry align="left" valign="top"><simpara>true</simpara></entry>
<entry align="left" valign="top"><simpara>Boolean</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Cls</simpara></entry>
<entry align="left" valign="top"><simpara>Publisher class attribute</simpara></entry>
<entry align="left" valign="top"><simpara>true</simpara></entry>
<entry align="left" valign="top"><simpara>String</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>args</simpara></entry>
<entry align="left" valign="top"><simpara>Publisher arguments</simpara></entry>
<entry align="left" valign="top"><simpara>true</simpara></entry>
<entry align="left" valign="top"><simpara>Object</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
</section>
<section xml:id="Agent-Rest-Schema-Iteration">
<title>Iteration</title>
<simpara>Create publisher request object.</simpara>
<programlisting language="java" linenumbering="unnumbered">{
    "iteration": 1
}</programlisting>
<table frame="all" rowsep="1" colsep="1">
<title>Parameters</title>
<tgroup cols="4">
<colspec colname="col_1" colwidth="15.3846*"/>
<colspec colname="col_2" colwidth="61.5384*"/>
<colspec colname="col_3" colwidth="7.6923*"/>
<colspec colname="col_4" colwidth="15.3847*"/>
<thead>
<row>
<entry align="left" valign="top">Name</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Required</entry>
<entry align="left" valign="top">Schema</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>iteration</simpara></entry>
<entry align="left" valign="top"><simpara>Iteration/testcase number</simpara></entry>
<entry align="left" valign="top"><simpara>true</simpara></entry>
<entry align="left" valign="top"><simpara>Integer</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
</section>
<section xml:id="Agent-Rest-Schema-IsControlIteration">
<title>IsControlIteration</title>
<simpara>Create publisher request object.</simpara>
<programlisting language="java" linenumbering="unnumbered">{
    "isControlIteration": false
}</programlisting>
<table frame="all" rowsep="1" colsep="1">
<title>Parameters</title>
<tgroup cols="4">
<colspec colname="col_1" colwidth="15.3846*"/>
<colspec colname="col_2" colwidth="61.5384*"/>
<colspec colname="col_3" colwidth="7.6923*"/>
<colspec colname="col_4" colwidth="15.3847*"/>
<thead>
<row>
<entry align="left" valign="top">Name</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Required</entry>
<entry align="left" valign="top">Schema</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>isControlIteration</simpara></entry>
<entry align="left" valign="top"><simpara>Is this a control iteration</simpara></entry>
<entry align="left" valign="top"><simpara>true</simpara></entry>
<entry align="left" valign="top"><simpara>Boolean</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
</section>
<section xml:id="Agent-Rest-Schema-Call">
<title>Call</title>
<simpara>Information needed to complete a <emphasis>call</emphasis> action.</simpara>
<programlisting language="java" linenumbering="unnumbered">{
    "method": "PerformWork",
    "args"  : [
        {"name":"firstName", "data":"AA==", "type":"in" }
    ]
}</programlisting>
<table frame="all" rowsep="1" colsep="1">
<title>Parameters</title>
<tgroup cols="4">
<colspec colname="col_1" colwidth="15.3846*"/>
<colspec colname="col_2" colwidth="61.5384*"/>
<colspec colname="col_3" colwidth="7.6923*"/>
<colspec colname="col_4" colwidth="15.3847*"/>
<thead>
<row>
<entry align="left" valign="top">Name</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Required</entry>
<entry align="left" valign="top">Schema</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>method</simpara></entry>
<entry align="left" valign="top"><simpara>Method to call, maps to the <emphasis>method</emphasis> attribute of a <emphasis>call</emphasis> action.</simpara></entry>
<entry align="left" valign="top"><simpara>true</simpara></entry>
<entry align="left" valign="top"><simpara>String</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>args</simpara></entry>
<entry align="left" valign="top"><simpara>Arugments for call. Zero or more.</simpara></entry>
<entry align="left" valign="top"><simpara>true</simpara></entry>
<entry align="left" valign="top"><simpara>Array of <link linkend="Agent-Rest-Schema-CallArg">CallArg</link></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
</section>
<section xml:id="Agent-Rest-Schema-CallArg">
<title>CallArg</title>
<simpara>Argument for a call action.</simpara>
<programlisting language="java" linenumbering="unnumbered">{
    "name" : "firstName",
    "data" : "AA==",
    "type" : "in"
}</programlisting>
<table frame="all" rowsep="1" colsep="1">
<title>Parameters</title>
<tgroup cols="4">
<colspec colname="col_1" colwidth="15.3846*"/>
<colspec colname="col_2" colwidth="61.5384*"/>
<colspec colname="col_3" colwidth="7.6923*"/>
<colspec colname="col_4" colwidth="15.3847*"/>
<thead>
<row>
<entry align="left" valign="top">Name</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Required</entry>
<entry align="left" valign="top">Schema</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>name</simpara></entry>
<entry align="left" valign="top"><simpara>Argument/parameter name</simpara></entry>
<entry align="left" valign="top"><simpara>true</simpara></entry>
<entry align="left" valign="top"><simpara>String</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>data</simpara></entry>
<entry align="left" valign="top"><simpara>Binary data base64 encoded</simpara></entry>
<entry align="left" valign="top"><simpara>true</simpara></entry>
<entry align="left" valign="top"><simpara>Bytes</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>type</simpara></entry>
<entry align="left" valign="top"><simpara>DEPRECATED, always <emphasis>in</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara>true</simpara></entry>
<entry align="left" valign="top"><simpara>String</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
</section>
<section xml:id="Agent-Rest-Schema-Result">
<title>Result</title>
<simpara>The result of a <emphasis>call</emphasis> or <emphasis>getProperty</emphasis> action.</simpara>
<formalpara>
<title>Example of successful result</title>
<para>
<programlisting language="java" linenumbering="unnumbered">{
    "value": "AA==",
    "error": false,
}</programlisting>
</para>
</formalpara>
<formalpara>
<title>Example of error result</title>
<para>
<programlisting language="java" linenumbering="unnumbered">{
    "value": null,
    "error": true,
    "errorString": "Error call method"
}</programlisting>
</para>
</formalpara>
<table frame="all" rowsep="1" colsep="1">
<title>Parameters</title>
<tgroup cols="4">
<colspec colname="col_1" colwidth="15.3846*"/>
<colspec colname="col_2" colwidth="61.5384*"/>
<colspec colname="col_3" colwidth="7.6923*"/>
<colspec colname="col_4" colwidth="15.3847*"/>
<thead>
<row>
<entry align="left" valign="top">Name</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Required</entry>
<entry align="left" valign="top">Schema</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>value</simpara></entry>
<entry align="left" valign="top"><simpara>Resulting data, can be null. Base64 encoded.</simpara></entry>
<entry align="left" valign="top"><simpara>true</simpara></entry>
<entry align="left" valign="top"><simpara>Bytes</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>error</simpara></entry>
<entry align="left" valign="top"><simpara>Has an error occured?</simpara></entry>
<entry align="left" valign="top"><simpara>true</simpara></entry>
<entry align="left" valign="top"><simpara>Boolean</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>errorString</simpara></entry>
<entry align="left" valign="top"><simpara>Error message</simpara></entry>
<entry align="left" valign="top"><simpara>false</simpara></entry>
<entry align="left" valign="top"><simpara>String</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
</section>
<section xml:id="Agent-Rest-Schema-DataResponse">
<title>DataResponse</title>
<simpara>The result of a <emphasis>call</emphasis> or <emphasis>getProperty</emphasis> action.</simpara>
<formalpara>
<title>Example of successful result</title>
<para>
<programlisting language="java" linenumbering="unnumbered">{
    "data": "AA==",
    "error": false,
}</programlisting>
</para>
</formalpara>
<formalpara>
<title>Example of error result</title>
<para>
<programlisting language="java" linenumbering="unnumbered">{
    "data": null,
    "error": true,
    "errorString": "Error call method"
}</programlisting>
</para>
</formalpara>
<table frame="all" rowsep="1" colsep="1">
<title>Parameters</title>
<tgroup cols="4">
<colspec colname="col_1" colwidth="15.3846*"/>
<colspec colname="col_2" colwidth="61.5384*"/>
<colspec colname="col_3" colwidth="7.6923*"/>
<colspec colname="col_4" colwidth="15.3847*"/>
<thead>
<row>
<entry align="left" valign="top">Name</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Required</entry>
<entry align="left" valign="top">Schema</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>data</simpara></entry>
<entry align="left" valign="top"><simpara>Resulting data, can be null. Base64 encoded.</simpara></entry>
<entry align="left" valign="top"><simpara>true</simpara></entry>
<entry align="left" valign="top"><simpara>Bytes</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>error</simpara></entry>
<entry align="left" valign="top"><simpara>Has an error occured?</simpara></entry>
<entry align="left" valign="top"><simpara>true</simpara></entry>
<entry align="left" valign="top"><simpara>Boolean</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>errorString</simpara></entry>
<entry align="left" valign="top"><simpara>Error message</simpara></entry>
<entry align="left" valign="top"><simpara>false</simpara></entry>
<entry align="left" valign="top"><simpara>String</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
</section>
<section xml:id="Agent-Rest-Schema-Output">
<title>Output</title>
<simpara>Data to output</simpara>
<programlisting language="java" linenumbering="unnumbered">{
    "data"    : "AA=="
}</programlisting>
<table frame="all" rowsep="1" colsep="1">
<title>Parameters</title>
<tgroup cols="4">
<colspec colname="col_1" colwidth="15.3846*"/>
<colspec colname="col_2" colwidth="61.5384*"/>
<colspec colname="col_3" colwidth="7.6923*"/>
<colspec colname="col_4" colwidth="15.3847*"/>
<thead>
<row>
<entry align="left" valign="top">Name</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Required</entry>
<entry align="left" valign="top">Schema</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>data</simpara></entry>
<entry align="left" valign="top"><simpara>Property value. Base64 encoded.</simpara></entry>
<entry align="left" valign="top"><simpara>true</simpara></entry>
<entry align="left" valign="top"><simpara>Bytes</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
</section>
<section xml:id="Agent-Rest-Schema-SetProperty">
<title>SetProperty</title>
<simpara>Contains information required to make a SetProperty call.</simpara>
<programlisting language="java" linenumbering="unnumbered">{
    "property": "FirstName",
    "data"    : "AA=="
}</programlisting>
<table frame="all" rowsep="1" colsep="1">
<title>Parameters</title>
<tgroup cols="4">
<colspec colname="col_1" colwidth="15.3846*"/>
<colspec colname="col_2" colwidth="61.5384*"/>
<colspec colname="col_3" colwidth="7.6923*"/>
<colspec colname="col_4" colwidth="15.3847*"/>
<thead>
<row>
<entry align="left" valign="top">Name</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Required</entry>
<entry align="left" valign="top">Schema</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>property</simpara></entry>
<entry align="left" valign="top"><simpara>Property to set data on</simpara></entry>
<entry align="left" valign="top"><simpara>true</simpara></entry>
<entry align="left" valign="top"><simpara>String</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>data</simpara></entry>
<entry align="left" valign="top"><simpara>Property value. Base64 encoded.</simpara></entry>
<entry align="left" valign="top"><simpara>true</simpara></entry>
<entry align="left" valign="top"><simpara>Bytes</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
</section>
<section xml:id="Agent-Rest-Schema-Count">
<title>Count</title>
<simpara>Count of bytes requested.</simpara>
<programlisting language="java" linenumbering="unnumbered">{
    "count": 1000,
}</programlisting>
<table frame="all" rowsep="1" colsep="1">
<title>Parameters</title>
<tgroup cols="4">
<colspec colname="col_1" colwidth="15.3846*"/>
<colspec colname="col_2" colwidth="61.5384*"/>
<colspec colname="col_3" colwidth="7.6923*"/>
<colspec colname="col_4" colwidth="15.3847*"/>
<thead>
<row>
<entry align="left" valign="top">Name</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Required</entry>
<entry align="left" valign="top">Schema</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>count</simpara></entry>
<entry align="left" valign="top"><simpara>Property to set data on</simpara></entry>
<entry align="left" valign="top"><simpara>true</simpara></entry>
<entry align="left" valign="top"><simpara>Integer</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara><?asciidoc-pagebreak?></simpara>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
</section>
</section>
</section>
<section xml:id="Monitors">
<title>Monitors</title>
<simpara><link linkend="Agent">Agents</link> are special Peach processes that can be run locally or remotely.
These processes host one or more Monitors that can perform such actions as attaching debuggers,
watching memory consumption,
or detecting faults.</simpara>
<simpara>The following table lists each monitor by name,
function type (Fault detection, Data collection, Automation),
and by the operating systems that support the monitor.
If the operating systems column is blank for an entry,
that monitor is available in all supported operating systems.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Monitors</title>
<tgroup cols="5">
<colspec colname="col_1" colwidth="30*"/>
<colspec colname="col_2" colwidth="10*"/>
<colspec colname="col_3" colwidth="10*"/>
<colspec colname="col_4" colwidth="20*"/>
<colspec colname="col_5" colwidth="30*"/>
<thead>
<row>
<entry align="left" valign="top">Monitor</entry>
<entry align="left" valign="top">Fault Detection</entry>
<entry align="left" valign="top">Data Collection</entry>
<entry align="left" valign="top">Automation</entry>
<entry align="left" valign="top">Operating Systems <footnote><simpara>When an operating system is listed, the monitor is available only for the listed operating system. A blank entry indicates the monitor is available for Windows, Linux, and OS X operating systems.</simpara></footnote></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><link linkend="Monitors_Android">Android</link></simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="Monitors_AndroidEmulator">Android Emulator</link></simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="Monitors_ApcPower">APC Power</link></simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="Monitors_ButtonClicker">ButtonClicker</link></simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"><simpara>Windows</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="Monitors_CanaKitRelay">CanaKit Relay</link></simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="Monitors_CanCapture">CAN Capture</link></simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="Monitors_CanErrorFrame">CAN Error Frame</link></simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="Monitors_CanSendFrame">CAN Send Frame</link></simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="Monitors_CanTiming">CAN Timing</link></simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="Monitors_CanThreshold">CAN Threshold</link></simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="Monitors_CleanupFolder">Cleanup Folder</link></simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="Monitors_CleanupRegistry">Cleanup Registry</link></simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"><simpara>Windows</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="Monitors_CrashReporter">Crash Reporter</link></simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>OS X</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="Monitors_CrashWrangler">Crash Wrangler</link></simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"><simpara>OS X</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="Monitors_Gdb">Gdb</link></simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"><simpara>Linux, OS X</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="Monitors_GdbServer">GdbServer</link></simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"><simpara>Linux, OS X</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="Monitors_IpPower9258">IpPower9258</link></simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="Monitors_LinuxCoreFile">LinuxCoreFile</link></simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>Linux</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="Monitors_MemoryMonitor">Memory</link></simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="Monitors_NetworkCapture">NetworkCapture</link></simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="Monitors_PageHeap">Page Heap</link></simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"><simpara>Windows</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="Monitors_Ping">Ping</link></simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="Monitors_PopupWatcher">Popup Watcher</link></simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"><simpara>Windows</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="Monitors_Process">Process Launcher</link></simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="Monitors_ProcessKiller">Process Killer</link></simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="Monitors_RunCommand">Run Command</link></simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="Monitors_SaveFile">Save File</link></simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="Monitors_Serial">Serial Port</link></simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="Monitors_SnmpPower">SNMP Power</link></simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="Monitors_Socket">Socket Listener</link></simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="Monitors_SshCommand">SSH Command</link></simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="Monitors_SshDownloader">SSH Downloader</link></simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="Monitors_Syslog">Syslog</link></simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="Monitors_TcpPort">TcpPort</link></simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="Monitors_Vmware">Vmware Control</link></simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="Monitors_WindowsDebugger">Windows Debugger</link></simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"><simpara>Windows</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="Monitors_WindowsService">Windows Service</link></simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"><simpara>Windows</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara><?asciidoc-pagebreak?></simpara>
<section xml:id="Monitors_Android">
<title>Android Monitor</title>
<simpara><emphasis role="strong">Monitor Categories</emphasis>: <emphasis role="strong">Automation</emphasis>, <emphasis role="strong">Fault detection</emphasis></simpara>
<simpara>The <emphasis>Android</emphasis> monitor examines both targeted Android applications and the state of the
Android OS. Peach supports Android OS versions 4.0 to 5.1, inclusively.</simpara>
<simpara>Two expected use cases are:</simpara>
<itemizedlist>
<listitem>
<simpara>Maintaining state while fuzzing native code</simpara>
</listitem>
<listitem>
<simpara>Launching and monitoring Android Java applications.</simpara>
</listitem>
</itemizedlist>
<simpara>The <emphasis>Android</emphasis> monitor can start or restart the device at the following times:</simpara>
<itemizedlist>
<listitem>
<simpara>The start of a fuzzing run</simpara>
</listitem>
<listitem>
<simpara>The start of each test iteration</simpara>
</listitem>
<listitem>
<simpara>The start of an iteration that immediately follows a fault</simpara>
</listitem>
<listitem>
<simpara>When called from the state model</simpara>
</listitem>
</itemizedlist>
<simpara>The Android monitor watches the message logs and the device, and can generate faults for the following conditions:</simpara>
<itemizedlist>
<listitem>
<simpara>A logging message matches the fault search criteria, Peach logs a fault.</simpara>
</listitem>
<listitem>
<simpara>A logging message matches the fault search criteria, Peach logs a fault and stops fuzzing.</simpara>
</listitem>
<listitem>
<simpara>A physical device becomes non-responsive.</simpara>
</listitem>
<listitem>
<simpara>A virtual device becomes non-responsive or lost.</simpara>
</listitem>
</itemizedlist>
<simpara>After detecting a fault, the monitor collects data from the device log files and crash dumps.</simpara>
<simpara>Additionally, the monitor logs exceptions, and updates fault bucket information. For bucketing,
Peach uses the text from the fault to determine the major bucket level. The minor bucket level
is not used. The risk evaluation looks for error, fatal error, or unknown.</simpara>
<simpara>The <emphasis>Android</emphasis> monitor uses the Android Debugging Bridge (adb) to communicate with a device. This
monitor can target both emulated and physical devices. The <emphasis>Android</emphasis> monitor requires
<link xl:href="http://developer.android.com/sdk/index.html">Android Platform Tools</link> and either an emulator or a
physical Android device. The configuration for a physical device follows. For a configuration using
a virtual device, see the <link linkend="Monitors_AndroidEmulator">Android Emulator Monitor</link>.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/Monitors/Android.png"/>
</imageobject>
<textobject><phrase>Android</phrase></textobject>
</mediaobject>
</informalfigure>
<note>
<simpara>Connecting to a physical device requires the device serial number. You can obtain this from a
connected device by using the following adb command: "adb&#160;devices". The result is a list of
devices that adb found. The information for each device consists of two parts: the device
number and the connection status between adb and the device. The list includes physical and
virtual devices.</simpara>
<simpara>For more information about debugging Android devices, see the following:</simpara>
<itemizedlist>
<listitem>
<simpara><link xl:href="http://developer.android.com/tools/help/adb.html">Android Debug Bridge</link>.</simpara>
</listitem>
<listitem>
<simpara><link xl:href="http://www.howtogeek.com/125769/how-to-install-and-use-abd-the-android-debug-bridge-utility/">How To Install and Use ADB, the Android Debug Bridge Utility</link></simpara>
</listitem>
</itemizedlist>
</note>
<section xml:id="_parameters_73">
<title>Parameters</title>
<simpara><emphasis>Required:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>ApplicationName</term>
<listitem>
<simpara>Name of the Android application.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>ActivityName</term>
<listitem>
<simpara>Name of the application activity, defaults to "".</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>AdbPath</term>
<listitem>
<simpara>Directory path to adb, defaults to "".</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>ClearAppData</term>
<listitem>
<simpara>Removes the application data and cache every iteration, defaults to false.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>ClearAppDataOnFault</term>
<listitem>
<simpara>Removes the application data and cache on faulting iterations, defaults to false.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>CommandTimeout</term>
<listitem>
<simpara>Sets the maximum number of seconds to wait for the adb command to complete, defaults to 10 seconds.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>ConnectTimeout</term>
<listitem>
<simpara>Sets the maximum number of seconds to wait to establish an adb connection, defaults to 5 seconds.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>DeviceMonitor</term>
<listitem>
<simpara>Identifies the Android monitor that supplies the device serial number, defaults to "". Used when monitoring a virtual device.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>DeviceSerial</term>
<listitem>
<simpara>The serial number of the device to monitor, defaults to "". Used when monitoring a physical device.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>FaultRegex</term>
<listitem>
<simpara>Specifies a regular expression; when matched from a log entry, triggers a fault. The default pattern
is <emphasis>(^E/ActivityMonitor)|(^E/AndroidRuntime)|(^F/.*)</emphasis>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>FaultWaitTime</term>
<listitem>
<simpara>Sets the time period, in milliseconds, to wait when checking for a fault, defaults to 0 ms.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>IgnoreRegex</term>
<listitem>
<simpara>Specifies a regular expression; when matched, the monitor ignores potential false positive faults, defaults to "".</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>MustStopRegex</term>
<listitem>
<simpara>Specifies a regular expression; when a match occurs, the monitor triggers a fault and stops fuzzing, defaults to "".</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>ReadyTimeout</term>
<listitem>
<simpara>Sets the maximum number of seconds to wait for the device to reach readiness&#8212;&#8203;able to respond to inputs, defaults to 600 seconds.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>RebootEveryN</term>
<listitem>
<simpara>Specifies the number of iterations between successive device reboots, defaults to 0.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>RebootOnFault</term>
<listitem>
<simpara>Reboots the device when a fault occurs, defaults to false.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>RestartEveryIteration</term>
<listitem>
<simpara>Restarts the application every iteration, defaults to false.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>StartOnCall</term>
<listitem>
<simpara>Starts the application when notified by the state machine. The string value used here must match the Call Action statement of the state model. The default string is "".</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>WaitForReadyOnCall</term>
<listitem>
<simpara>Waits for the device to be ready when notified by the state machine. The string used here must match the corresponding Call Action statement of the state model. the default string is "".</simpara>
</listitem>
</varlistentry>
</variablelist>
<tip>
<simpara>The DeviceMonitor and the DeviceSerial parameters are mutually exclusive. Use DeviceSerial to provide the serial number of a physical device. Use DeviceMonitor when using the Android Emulator, as the Emulator will provide the serial number of the virtual device.</simpara>
</tip>
</section>
<section xml:id="_examples_124">
<title>Examples</title>
<example>
<title>Basic Usage Example<?asciidoc-br?></title>
<simpara>This example runs the BadBehaviorActivity, sending random taps to generate different types of exceptions and crashes.</simpara>
<simpara>To run the Android emulator, set your AdbPath to the directory containing the adb (Android Debug Bridge) platform-tools directory and point the EmulatorPath to the adb tools directory.</simpara>
<simpara>The Avd parameter must also be the name of a valid AVD (Android Virtual Device). To create a new AVD:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Open the <emphasis>android.bat</emphasis> file located in the adb SDK tools directory.</simpara>
</listitem>
<listitem>
<simpara>From the GUI that opens, click on <emphasis>Tools</emphasis> in the menu bar, then <emphasis>Manage AVDs&#8230;&#8203;</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>From the window that opens, click <emphasis>New&#8230;&#8203;</emphasis> and create a new AVD.</simpara>
</listitem>
</orderedlist>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

	&lt;DataModel name="TheDataModel"&gt;
		&lt;Number size='32' signed="false" value="31337" /&gt;
	&lt;/DataModel&gt;

	&lt;DataModel name="X"&gt;
		&lt;Number size='32' signed="false" value="100" /&gt;
	&lt;/DataModel&gt;

	&lt;DataModel name="Y"&gt;
		&lt;Number size='32' signed="false" value="0" /&gt;
	&lt;/DataModel&gt;

	&lt;StateModel name="State" initialState="Initial" &gt;
		&lt;State name="Initial"  &gt;
			&lt;Action type="call" method="tap"&gt;
				&lt;Param&gt;
					&lt;DataModel ref="X"/&gt;
				&lt;/Param&gt;
				&lt;Param&gt;
					&lt;DataModel ref="Y"/&gt;
				&lt;/Param&gt;
			&lt;/Action&gt;
		&lt;/State&gt;
	&lt;/StateModel&gt;

	&lt;Agent name="TheAgent"&gt;
		&lt;Monitor name="Emu" class="AndroidEmulator"&gt;
			&lt;Param name="Avd" value="Nexus4" /&gt;
			&lt;Param name="EmulatorPath" value="C:\adt-bundle-windows-x86_64-20131030\sdk\tools"/&gt;
		&lt;/Monitor&gt;

		&lt;Monitor name="App" class="Android"&gt;
			&lt;Param name="ApplicationName" value="com.android.development" /&gt;
			&lt;Param name="ActivityName" value=".BadBehaviorActivity" /&gt;
			&lt;Param name="AdbPath" value="C:\adt-bundle-windows-x86_64-20131030\sdk\platform-tools"/&gt;
			&lt;Param name="DeviceMonitor" value="Emu" /&gt;
		&lt;/Monitor&gt;
	&lt;/Agent&gt;

	&lt;Test name="Default"&gt;
		&lt;StateModel ref="State"/&gt;
		&lt;Agent ref="TheAgent" /&gt;

		&lt;Publisher class="AndroidMonkey"&gt;
			&lt;Param name="DeviceMonitor" value="App"/&gt;
		&lt;/Publisher&gt;
	&lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Output for this example.</simpara>
<screen>&gt;peach -1 --debug example.xml

[*] Test 'Default' starting with random seed 3054.
Peach.Core.Agent.Agent StartMonitor: Emu AndroidEmulator
Peach.Core.Agent.Agent StartMonitor: App Android
Peach.Core.Agent.Agent SessionStarting: Emu
Peach.Enterprise.Agent.Monitors.AndroidEmulator Starting android emulator
Peach.Enterprise.Agent.Monitors.AndroidEmulator Resolved emulator instance to android device 'emulator-5554'
Peach.Enterprise.Agent.Monitors.AndroidEmulator Android emulator 'emulator-5554' successfully started
Peach.Core.Agent.Agent SessionStarting: App
Peach.Enterprise.AndroidBridge Initializing android debug bridge.
Peach.Enterprise.AndroidBridge Android debug bridge initialized.
Peach.Enterprise.Agent.Monitors.AndroidMonitor Resolved device 'emulator-5554' from monitor 'Emu'.
Peach.Enterprise.AndroidDevice Waiting for device 'emulator-5554' to become ready
Peach.Enterprise.AndroidDevice Device 'emulator-5554' is now ready
Peach.Enterprise.AndroidDevice Executing command on 'emulator-5554': am start -W -S -n com.android.development/.BadBehaviorActivity

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Call
Peach.Enterprise.Publishers.AndroidMonkeyPublisher start()
Peach.Enterprise.Publishers.AndroidMonkeyPublisher call(tap, System.Collections.Generic.List`1[Peach.Core.Dom.ActionParameter])
Peach.Core.Agent.AgentManager Message: App =&gt; DeviceSerial
Peach.Enterprise.Publishers.AndroidMonkeyPublisher Resolved device 'emulator-5554' from monitor 'App'.
Peach.Enterprise.AndroidDevice Executing command on 'emulator-5554': input tap 100 0
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Enterprise.Publishers.AndroidMonkeyPublisher stop()
Peach.Core.Agent.Agent SessionFinished: App
Peach.Enterprise.AndroidBridge Terminating android debug bridge.
Peach.Core.Agent.Agent SessionFinished: Emu
Peach.Enterprise.Agent.Monitors.AndroidEmulator Sending stop command to emulator 'emulator-5554'
Peach.Enterprise.Agent.Monitors.AndroidEmulator Waiting for emulator 'emulator-5554' to exit
Peach.Enterprise.Agent.Monitors.AndroidEmulator Emulator 'emulator-5554' exited with code: 0
Peach.Enterprise.Agent.Monitors.AndroidEmulator Emulator 'emulator-5554' exited

[*] Test 'Default' finished.</screen>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Monitors_AndroidEmulator">
<title>AndroidEmulator Monitor</title>
<simpara><emphasis role="strong">Monitor Categories</emphasis>: <emphasis role="strong">Automation</emphasis>, <emphasis role="strong">Fault detection</emphasis></simpara>
<simpara>The <emphasis>AndroidEmulator</emphasis> monitor handles setup and teardown for Android Virtual Devices (AVDs)
running within the Android Emulator. This monitor detects faults related to the emulator
operation, not fuzzing results.</simpara>
<simpara>The monitor provides the following functionality:</simpara>
<itemizedlist>
<listitem>
<simpara>Start a virtual device at the start of a fuzzing run.</simpara>
</listitem>
<listitem>
<simpara>Start a virtual device at the start of each test iteration.</simpara>
</listitem>
<listitem>
<simpara>Start a virtual device when called from the state model.</simpara>
</listitem>
<listitem>
<simpara>Start a virtual device at the beginning of an iteration that immediately follows a fault.</simpara>
</listitem>
<listitem>
<simpara>Shuts down at the end of a fuzzing session.</simpara>
</listitem>
<listitem>
<simpara>Logs timeout messages when querying the emulator for the device serial number.</simpara>
</listitem>
<listitem>
<simpara>Logs timeout messages when shutting down the emulator.</simpara>
</listitem>
<listitem>
<simpara>logs messages sent to StdErr.</simpara>
</listitem>
<listitem>
<simpara>Logs messages sent to StdOut.</simpara>
</listitem>
</itemizedlist>
<simpara>This monitor requires the following items to run:</simpara>
<itemizedlist>
<listitem>
<simpara>The Android monitor that watches the OS and application being fuzzed.</simpara>
</listitem>
<listitem>
<simpara>The <link xl:href="http://developer.android.com/tools/help/emulator.html">Android Emulator</link></simpara>
</listitem>
<listitem>
<simpara>The <link xl:href="http://developer.android.com/sdk/index.html">Android Platform Tools</link>.</simpara>
</listitem>
</itemizedlist>
<simpara>The fuzzing configuration for a virtual or emulated device follows. For a configuration using a physical device, see the <link linkend="Monitors_Android">Android Monitor</link>.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/Monitors/AndroidEmulator.png"/>
</imageobject>
<textobject><phrase>AndroidEmulator</phrase></textobject>
</mediaobject>
</informalfigure>
<section xml:id="_parameters_74">
<title>Parameters</title>
<simpara><emphasis>Required:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>Avd</term>
<listitem>
<simpara>Android virtual device.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>EmulatorPath</term>
<listitem>
<simpara>Directory containing the Android emulator.
If not provided, Peach searches the directories in the PATH variable for the installed emulator.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Headless</term>
<listitem>
<simpara>If true, runs the emulator <emphasis role="strong">without a display</emphasis>. Defaults to false.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>RestartAfterFault</term>
<listitem>
<simpara>If <literal>true</literal>, restarts the emulator when any monitor detects a fault.
If <literal>false</literal>, restarts the emulator only if the emulator exits or crashes.
This argument defaults to <literal>true</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>RestartEveryIteration</term>
<listitem>
<simpara>Restart emulator on every iteration. Defaults to false.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>StartOnCall</term>
<listitem>
<simpara>Start the emulator when notified by the state machine.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>StartTimeout</term>
<listitem>
<simpara>How many seconds to wait for emulator to start running. Defaults to 30.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>StopTimeout</term>
<listitem>
<simpara>How many seconds to wait for emulator to exit. Defaults to 30.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_125">
<title>Examples</title>
<example>
<title>Basic Usage Example</title>
<simpara>Runs the BadBehaviorActivity, sending random taps to generate different types of exceptions and crashes.</simpara>
<simpara>To run the Android emulator, set your AdbPath to the directory containing the adb
(Android Debug Bridge) platform-tools directory and point the EmulatorPath to the
adb tools directory.</simpara>
<note>
<simpara>Peach executes the monitors in the order that they are listed in the fuzzing definition. Position the Android Emulator Monitor before (above) the Android monitor in your Pit, so that, at run time, the virtual device exists when adb tries to connect to it.</simpara>
</note>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

	&lt;DataModel name="TheDataModel"&gt;
		&lt;Number size='32' signed="false" value="31337" /&gt;
	&lt;/DataModel&gt;

	&lt;DataModel name="X"&gt;
		&lt;Number size='32' signed="false" value="100" /&gt;
	&lt;/DataModel&gt;

	&lt;DataModel name="Y"&gt;
		&lt;Number size='32' signed="false" value="0" /&gt;
	&lt;/DataModel&gt;

	&lt;StateModel name="State" initialState="Initial" &gt;
		&lt;State name="Initial"  &gt;
			&lt;Action type="call" method="tap"&gt;
				&lt;Param&gt;
					&lt;DataModel ref="X"/&gt;
				&lt;/Param&gt;
				&lt;Param&gt;
					&lt;DataModel ref="Y"/&gt;
				&lt;/Param&gt;
			&lt;/Action&gt;
		&lt;/State&gt;
	&lt;/StateModel&gt;

	&lt;Agent name="TheAgent"&gt;
		&lt;Monitor name="Emu" class="AndroidEmulator"&gt;
			&lt;Param name="Avd" value="Nexus4" /&gt;
			&lt;Param name="EmulatorPath" value="C:\adt-bundle-windows-x86_64-20130717\sdk\tools"/&gt;
		&lt;/Monitor&gt;

		&lt;Monitor name="App" class="Android"&gt;
			&lt;Param name="ApplicationName" value="com.android.development" /&gt;
			&lt;Param name="ActivityName" value=".BadBehaviorActivity" /&gt;
			&lt;Param name="AdbPath" value="C:\adt-bundle-windows-x86_64-20130717\sdk\platform-tools"/&gt;
			&lt;Param name="DeviceMonitor" value="Emu" /&gt;
		&lt;/Monitor&gt;
	&lt;/Agent&gt;

	&lt;Test name="Default"&gt;
		&lt;StateModel ref="State"/&gt;
		&lt;Agent ref="TheAgent" /&gt;

		&lt;Publisher class="AndroidMonkey"&gt;
			&lt;Param name="DeviceMonitor" value="App"/&gt;
		&lt;/Publisher&gt;
	&lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Output for this example.</simpara>
<screen>&gt;peach -1 --debug example.xml

[*] Test 'Default' starting with random seed 3054.
Peach.Core.Agent.Agent StartMonitor: Emu AndroidEmulator
Peach.Core.Agent.Agent StartMonitor: App Android
Peach.Core.Agent.Agent SessionStarting: Emu
Peach.Enterprise.Agent.Monitors.AndroidEmulator Starting android emulator
Peach.Enterprise.Agent.Monitors.AndroidEmulator Resolved emulator instance to android device 'emulator-5554'
Peach.Enterprise.Agent.Monitors.AndroidEmulator Android emulator 'emulator-5554' successfully started
Peach.Core.Agent.Agent SessionStarting: App
Peach.Enterprise.AndroidBridge Initializing android debug bridge.
Peach.Enterprise.AndroidBridge Android debug bridge initialized.
Peach.Enterprise.Agent.Monitors.AndroidMonitor Resolved device 'emulator-5554' from monitor 'Emu'.
Peach.Enterprise.AndroidDevice Waiting for device 'emulator-5554' to become ready
Peach.Enterprise.AndroidDevice Device 'emulator-5554' is now ready
Peach.Enterprise.AndroidDevice Executing command on 'emulator-5554': am start -W -S -n com.android.development/.BadBehaviorActivity

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Call
Peach.Enterprise.Publishers.AndroidMonkeyPublisher start()
Peach.Enterprise.Publishers.AndroidMonkeyPublisher call(tap, System.Collections.Generic.List`1[Peach.Core.Dom.ActionParameter])
Peach.Core.Agent.AgentManager Message: App =&gt; DeviceSerial
Peach.Enterprise.Publishers.AndroidMonkeyPublisher Resolved device 'emulator-5554' from monitor 'App'.
Peach.Enterprise.AndroidDevice Executing command on 'emulator-5554': input tap 100 0
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Enterprise.Publishers.AndroidMonkeyPublisher stop()
Peach.Core.Agent.Agent SessionFinished: App
Peach.Enterprise.AndroidBridge Terminating android debug bridge.
Peach.Core.Agent.Agent SessionFinished: Emu
Peach.Enterprise.Agent.Monitors.AndroidEmulator Sending stop command to emulator 'emulator-5554'
Peach.Enterprise.Agent.Monitors.AndroidEmulator Waiting for emulator 'emulator-5554' to exit
Peach.Enterprise.Agent.Monitors.AndroidEmulator Emulator 'emulator-5554' exited with code: 0
Peach.Enterprise.Agent.Monitors.AndroidEmulator Emulator 'emulator-5554' exited

[*] Test 'Default' finished.</screen>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Monitors_ApcPower">
<title>APC Power Monitor</title>
<simpara><emphasis role="strong">Monitor Categories</emphasis>: <emphasis role="strong">Automation</emphasis></simpara>
<simpara>The <emphasis>APC Power</emphasis> monitor switches outlets on an APC power distribution unit (PDU) on and off via SNMPv1.
This monitor is useful for automatically power cycling devices during a fuzzing session.
APC&#8217;s Switched Rack Power Distribution Unit (AC7900) is known to work with this monitor.</simpara>
<simpara>Each <emphasis>APC Power</emphasis> monitor switches one or more of a PDU&#8217;s outlets, according to the configuration.
All affected outlets are given the same commands, so turning some outlets on and others off would require another monitor.
The monitor can reset the power outlets at the following points in time:</simpara>
<itemizedlist>
<listitem>
<simpara>At the start or end of a fuzzing run</simpara>
</listitem>
<listitem>
<simpara>At the start or end of each test iteration</simpara>
</listitem>
<listitem>
<simpara>After detecting a fault</simpara>
</listitem>
<listitem>
<simpara>At the start of an iteration that immediately follows a fault</simpara>
</listitem>
<listitem>
<simpara>When a specified call is received from the state model</simpara>
</listitem>
</itemizedlist>
<tip>
<simpara>The <link linkend="Monitors_IpPower9258">IpPower9258 Monitor</link> provides
 similar features, specific to the IP Power 9258 devices. The
 <link linkend="Monitors_SnmpPower">SnmpPower Monitor</link> is designed to work with
 non-APC PDUs that can be controlled via SNMPv1. For controlling power
 to a device by wiring through a relay, Peach provides a monitor for
 the <link linkend="Monitors_CanaKitRelay">CanaKit 4-Port USB Relay Controller</link>.</simpara>
</tip>
<section xml:id="_parameters_75">
<title>Parameters</title>
<simpara><emphasis>Required:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>Host</term>
<listitem>
<simpara>IP address of the switched power distribution unit.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>OutletGrouping</term>
<listitem>
<simpara>Whether outlets on the PDU are identified individually (<literal>Outlet</literal>) or in groups (<literal>OutletGroup</literal>). Default is <literal>Outlet</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Outlets</term>
<listitem>
<simpara>Comma-separated list of numeric identifiers for outlets or outlet groups to control.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>Port</term>
<listitem>
<simpara>SNMP port on the switched power distribution unit. Default is <literal>161</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>ReadCommunity</term>
<listitem>
<simpara>SNMP community string to use when reading the state of the outlets. Default is <literal>public</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>WriteCommunity</term>
<listitem>
<simpara>SNMP community string to use when modifying the state of the outlets. Default is <literal>private</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>RequestTimeout</term>
<listitem>
<simpara>Maximum duration in millseconds to block when sending an SNMP request to the PDU. Default is <literal>1000</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>SanityCheckOnStart</term>
<listitem>
<simpara>On startup, ensure switch state changes persist. Default is <literal>true</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>SanityCheckWaitTimeout</term>
<listitem>
<simpara>Maximum duration to wait for state change to take effect during startup sanity check. Default is <literal>3000</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>ResetOnCall</term>
<listitem>
<simpara>Reset power when the specified call is received from the state model.
This value is used only when the <emphasis>When</emphasis> parameter is set to <literal>OnCall</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>PowerOffOnEnd</term>
<listitem>
<simpara>Power off when the fuzzing session completes, default is <literal>false</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>PowerOnOffPause</term>
<listitem>
<simpara>Pause in milliseconds between power off/power on, default is <literal>500</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>When</term>
<listitem>
<simpara>When to reset power on the specified outlets or outlet groups. Default is <literal>OnFault</literal>.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="66.6667*"/>
<thead>
<row>
<entry align="left" valign="top">"When" Setting</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>DetectFault</simpara></entry>
<entry align="left" valign="top"><simpara>Reset power when checking for a fault.
This occurs after OnIterationEnd.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>OnStart</simpara></entry>
<entry align="left" valign="top"><simpara>Reset power when the fuzzing session starts.
This occurs once per session.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>OnEnd</simpara></entry>
<entry align="left" valign="top"><simpara>Reset power when the fuzzing session stops.
This occurs once per session.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>OnIterationStart</simpara></entry>
<entry align="left" valign="top"><simpara>Reset power at the start of each iteration.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>OnIterationEnd</simpara></entry>
<entry align="left" valign="top"><simpara>Reset power at the end of each iteration.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>OnFault</simpara></entry>
<entry align="left" valign="top"><simpara>Reset power when any monitor detects a fault.
This is the default setting.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>OnIterationStartAfterFault</simpara></entry>
<entry align="left" valign="top"><simpara>Reset power at the start of an iteration that immediately follows a fault detection.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>OnCall</simpara></entry>
<entry align="left" valign="top"><simpara>Reset power when the call specified by the <emphasis>ResetOnCall</emphasis> parameter is received from the state model.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<figure>
<title>When Choices for Performing an Action</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/Monitors/Timings_SSH.png"/>
</imageobject>
<textobject><phrase>Timings SSH</phrase></textobject>
</mediaobject>
</figure>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_126">
<title>Examples</title>
<example>
<title>Reset power on ports 1 and 2 of an APC PDU</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

  &lt;DataModel name="TheDataModel"&gt;
    &lt;Number size="32" signed="false" value="31337" /&gt;
  &lt;/DataModel&gt;

  &lt;StateModel name="State" initialState="Initial" &gt;
    &lt;State name="Initial"&gt;
      &lt;Action type="output"&gt;
        &lt;DataModel ref="TheDataModel"/&gt;
      &lt;/Action&gt;
    &lt;/State&gt;
  &lt;/StateModel&gt;

  &lt;Agent name="Local"&gt;
    &lt;Monitor class="ApcPower"&gt;
      &lt;Param name="Host" value="10.0.1.101" /&gt;
      &lt;Param name="Outlets" value="1,2" /&gt;

      &lt;!-- For APC devices that manage groups of outlets, be sure to
           set OutletGrouping. --&gt;

      &lt;!-- &lt;Param name="OutletGrouping" value="OutletGroup" /&gt; --&gt;
    &lt;/Monitor&gt;
  &lt;/Agent&gt;

  &lt;Test name="Default"&gt;
    &lt;StateModel ref="State"/&gt;
    &lt;Agent ref="Local" /&gt;
    &lt;Publisher class="ConsoleHex"/&gt;
  &lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Monitors_ButtonClicker">
<title>ButtonClicker Monitor</title>
<simpara><emphasis role="strong">Monitor Category</emphasis>: <emphasis role="strong">Automation</emphasis></simpara>
<simpara>The <emphasis>ButtonClicker</emphasis> monitor provides automation functionality by clicking buttons
in the Windows GUI. This monitor runs in the Windows environment. <emphasis>ButtonClicker</emphasis>
watches and clicks the appropriate button within the specified window. You can use
<emphasis>ButtonClicker</emphasis> to click a button in the window, such as "OK" or "Close".</simpara>
<simpara>The intent of this monitor is to initiate an action or to close a window to keep a
fuzzing session active. <emphasis>Buttonclicker</emphasis> runs from the beginning of a fuzzing session
to the end of the session.</simpara>
<simpara>The following example uses an FTP client, FileZilla, that sometimes opens a popup window
asking whether to install an update. Here, <emphasis>ButtonClicker</emphasis> monitor provides a mouse
click to the "Close" button to close the popup window. With the popup window out of
the way, fuzzing continues without delay.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/Monitors/ButtonClicker_FTP.png"/>
</imageobject>
<textobject><phrase>ButtonClicker FTP</phrase></textobject>
</mediaobject>
</informalfigure>
<note>
<simpara>Another monitor to consider for watching popup windows is
<link linkend="Monitors_PopupWatcher">PopupWatcher</link>, that can monitor several popup windows.</simpara>
</note>
<section xml:id="_parameters_76">
<title>Parameters</title>
<simpara><emphasis>Required:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>WindowText</term>
<listitem>
<simpara>Text from the window title that identifies the window to receive the button
click. The text string can be part or all of the window title.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>ButtonName</term>
<listitem>
<simpara>Text label of the button to click. The label is displayed to the user,
and is on or near the button that will receive the click.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Optional:</emphasis></simpara>
<simpara>None.</simpara>
<tip>
<simpara>If Peach has trouble clicking a button, the button might have a link to a shortcut key.</simpara>
<simpara>The shortcut key is displayed in the label using an underlined character. Windows does
this by inserting an ampersand "&amp;" immediately before the shortcut key within the button
label. Further, not all underlining shows in the initial display of the window.</simpara>
<simpara>In an application, you can manually force underlining to display in window buttons by
pressing the &lt;CTRL&gt; or &lt;ALT&gt; key. Once you find the underlining in the application,
you can adjust the value of the <literal>ButtonName</literal> parameter for <emphasis>ButtonClick</emphasis> by inserting
an ampersand (&amp;) immediately before any underlined character. Then, Peach will find the
button to click.</simpara>
<simpara>For example, in Microsoft Word, the Browsing dialog box used to open a document does
not immediately display underlining in its command buttons. You can see this by following
the sequence that opens a file:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Click <emphasis role="strong">File</emphasis> on the ribbon.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Open</emphasis> on the vertical menu.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Computer</emphasis> in the Open column.</simpara>
</listitem>
<listitem>
<simpara>Click the <emphasis role="strong">Browse</emphasis> button.<?asciidoc-br?>
The dialog opens and the "Open" button in the lower right corner is not underlined. Press the &lt;ALT&gt; or &lt;CTRL&gt; key to see the underlining as in the following illustration.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/Monitors/ButtonClicker_Shortcut.png"/>
</imageobject>
<textobject><phrase>ButtonClicker Shortcut</phrase></textobject>
</mediaobject>
</informalfigure>
</listitem>
</orderedlist>
</tip>
</section>
<section xml:id="_examples_127">
<title>Examples</title>
<formalpara>
<title>Basic Usage Example<?asciidoc-br?></title>
<para>This example uses the ButtonClicker monitor to respond to a question from a pop-up window that displays when restarting an application after a crash.</para>
</formalpara>
<informalexample>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

	&lt;DataModel name="TheDataModel"&gt;
		&lt;Number size="32" signed="false" value="31337" /&gt;
	&lt;/DataModel&gt;

	&lt;StateModel name="State" initialState="Initial" &gt;
		&lt;State name="Initial"&gt;
			&lt;Action type="output"&gt;
				&lt;DataModel ref="TheDataModel"/&gt;
			&lt;/Action&gt;
		&lt;/State&gt;
	&lt;/StateModel&gt;

	&lt;Agent name="Local"&gt;
		&lt;Monitor class="ButtonClicker"&gt;
			&lt;Param name="WindowText" value="Do you want to start in safe mode?" /&gt;
			&lt;Param name="ButtonName" value="No" /&gt;
		&lt;/Monitor&gt;
	&lt;/Agent&gt;

	&lt;Test name="Default"&gt;
		&lt;StateModel ref="State"/&gt;
		&lt;Agent ref="Local" /&gt;
		&lt;Publisher class="ConsoleHex"/&gt;
	&lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
</informalexample>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Monitors_CanaKitRelay">
<title>CanaKitRelay Monitor</title>
<simpara><emphasis role="strong">Monitor category</emphasis>: <emphasis role="strong">Automation</emphasis></simpara>
<simpara>The <emphasis>CanaKitRelay</emphasis> monitor provides automation to a number of test configurations:</simpara>
<itemizedlist>
<listitem>
<simpara>Control power to an external device that is the fuzzing target.
You can turn it on at the start of the test,
then toggle power after a fault occurs to return the device to a known, stable state.</simpara>
</listitem>
<listitem>
<simpara>Control a supporting device in a fuzzing test configuration.
Supporting devices can include recording devices,
lighting,
heating devices,
sound or motion generators.
An example is turning on an espresso machine after every 10,000th test iteration.</simpara>
</listitem>
<listitem>
<simpara>Emulate a button push by inserting the device into a circuit containing the button.
The idea is to automate the press of a button,
such as <literal>NumLock</literal>,
or the play button on a surveillance device.</simpara>
</listitem>
<listitem>
<simpara>For simulating the attachment or removal of a cable,
such as USB,
by routing the power line (VCC) through the relay.</simpara>
</listitem>
</itemizedlist>
<simpara>The CanaKit is an external product that you can add as part of your test configuration.
The kit consists of 4 relays.
A relay is an electrically operated switch that uses an electromagnet to operate a switching mechanism. Each relay in the kit is capable of controlling a 5-amp,
110V AC or a 24V DC circuit.
Communication with the kit occurs over USB.</simpara>
<simpara>For more information on the kit,
including configurations,
installation,
and the relay command set,
see <link xl:href="http://www.canakit.com/4-port-usb-relay-controller.html">CanaKit 4-Port USB Relay Controller</link>.</simpara>
<simpara>You can purchase the CanaKit from the manufacturer at the previous web site or from Amazon.com.
In each case,
the kit price is about $60.00 U.S. plus shipping costs.</simpara>
<simpara>The <emphasis>CanaKitRelay</emphasis> monitor controls one relay in a kit.
Use one monitor per relay to control multiple relays concurrently.
Within a fuzzing session,
the monitor can trigger the relay at the following times:</simpara>
<itemizedlist>
<listitem>
<simpara>At the start or end of a fuzzing run</simpara>
</listitem>
<listitem>
<simpara>At the start or end of each test iteration</simpara>
</listitem>
<listitem>
<simpara>During the detection of a fault</simpara>
</listitem>
<listitem>
<simpara>After detecting a fault</simpara>
</listitem>
<listitem>
<simpara>At the start of an iteration that immediately follows a fault</simpara>
</listitem>
<listitem>
<simpara>When a specified call is received from the state model</simpara>
</listitem>
</itemizedlist>
<simpara>The following diagram shows a sample configuration that controls power through Relay 1.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/Monitors/CanaKitRelay.png"/>
</imageobject>
<textobject><phrase>CanaKitRelay</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Each relay supplies three terminals:
Normally Open (NO),
Common (COM),
and Normally Closed (NC).
Basic configurations will connect the hot wire to Common and the other wire to either NO or NC.
For DC connections,
attach the anode (+) to the Common terminal.</simpara>
<simpara>NO provides an open circuit when the relay is off.
NC provides a closed circuit when the relay is off,
giving opposite on/off states from NO.
The following diagram shows the terminal layout and imagines that Relay 1 is On.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/Monitors/CanaKitRelay_Terminals.png"/>
</imageobject>
<textobject><phrase>CanaKitRelay Terminals</phrase></textobject>
</mediaobject>
</informalfigure>
<tip>
<simpara>The CanaKit Relay requires a driver that is available at the supplier&#8217;s website.
At the time of this writing,
the driver is unsigned,
which forces you to turn off Driver Signing Enforcement when installing the driver in 64-bit Windows 8.
For instructions on how to install unsigned drivers in this environment,
see <link xl:href="http://www.howtogeek.com/167723/how-to-disable-driver-signature-verification-on-64-bit-windows-8.1-so-that-you-can-install-unsigned-drivers/">How to Disable Driver Signature Verification on 64-Bit Windows 8.1</link>.</simpara>
</tip>
<simpara>After installing the CanaKit device driver,
connect the unit to your PC.
Windows dynamically assigns a serial port to the USB channel for the connection.
You can see the port assignment by looking at the <literal>Ports(COM and LPT)</literal> entry in the Device Manager.
The Device Manager is available from the System applet in the Control Panel.</simpara>
<note>
<simpara>For controlling power to devices using 3-prong outlets, Peach
provides the <link linkend="Monitors_IpPower9258">IpPower9258</link>,
<link linkend="Monitors_ApcPower">ApcPower</link>, and
<link linkend="Monitors_SnmpPower">SnmpPower</link> monitors.</simpara>
</note>
<section xml:id="_parameters_77">
<title>Parameters</title>
<simpara><emphasis>Required:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>SerialPort</term>
<listitem>
<simpara>Serial port for the board (such as COM2).</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>RelayNumber</term>
<listitem>
<simpara>Relay to trigger (1, 2, 3, or 4).
Each relay number corresponds to a single relay in the kit, as shown in the first diagram.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>Action</term>
<listitem>
<simpara>Perform an action on the specified relay, defaults to ToggleOff.
Valid actions include the following:</simpara>
</listitem>
</varlistentry>
</variablelist>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="66.6667*"/>
<thead>
<row>
<entry align="left" valign="top">Action</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>ToggleOff</simpara></entry>
<entry align="left" valign="top"><simpara>Sets the relay to the OFF position, then sets the relay to the ON position.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>ToggleOn</simpara></entry>
<entry align="left" valign="top"><simpara>Sets the relay to the ON position, then sets the relay to the OFF position.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>SetOn</simpara></entry>
<entry align="left" valign="top"><simpara>Sets the relay to the ON position.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>SetOff</simpara></entry>
<entry align="left" valign="top"><simpara>Sets the relay to the OFF position.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<variablelist>
<varlistentry>
<term>StartOnCall</term>
<listitem>
<simpara>Toggle power when the specified call is received from the state model.
This value is used only when the <emphasis>When</emphasis> parameter is set to <literal>OnCall</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>ToggleDelay</term>
<listitem>
<simpara>Pause in milliseconds between off/on, defaults to <literal>500</literal>.
Formerly named OnOffPause.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>When</term>
<listitem>
<simpara>Specify one of the following values to determine when a relay should be toggled:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="66.6667*"/>
<thead>
<row>
<entry align="left" valign="top">"When" Setting</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>DetectFault</simpara></entry>
<entry align="left" valign="top"><simpara>Toggle power when checking for a fault.
This occurs after OnIterationEnd.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>OnStart</simpara></entry>
<entry align="left" valign="top"><simpara>Toggle power when the fuzzing session starts.
This occurs once per session.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>OnEnd</simpara></entry>
<entry align="left" valign="top"><simpara>Toggle power when the fuzzing session stops.
This occurs once per session.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>OnIterationStart</simpara></entry>
<entry align="left" valign="top"><simpara>Toggle power at the start of each iteration.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>OnIterationEnd</simpara></entry>
<entry align="left" valign="top"><simpara>Toggle power at the end of each iteration.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>OnFault</simpara></entry>
<entry align="left" valign="top"><simpara>Toggle power when any monitor detects a fault.
This is the default setting.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>OnIterationStartAfterFault</simpara></entry>
<entry align="left" valign="top"><simpara>Toggle power at the start of an iteration that immediately follows a fault detection.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>OnCall</simpara></entry>
<entry align="left" valign="top"><simpara>Toggle power when the call specified by the <emphasis>StartOnCall</emphasis> parameter is received from the state model.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<figure>
<title>When Choices for Performing an Action</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/Monitors/Timings_SSH.png"/>
</imageobject>
<textobject><phrase>Timings SSH</phrase></textobject>
</mediaobject>
</figure>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_128">
<title>Examples</title>
<formalpara>
<title>Reset power on Relay 1<?asciidoc-br?></title>
<para>This uses the CanaKitRelay monitor to reset relay&#160;1,
which toggles the power off,
then back on.
A device attached to this relay will restart when the relay resets.
The default setting for the <emphasis>When</emphasis> parameter is <literal>OnFault</literal>,
so the relay will be toggled after a fault is detected.</para>
</formalpara>
<informalexample>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

	&lt;DataModel name="TheDataModel"&gt;
		&lt;Number size="32" signed="false" value="31337" /&gt;
	&lt;/DataModel&gt;

	&lt;StateModel name="State" initialState="Initial" &gt;
		&lt;State name="Initial"&gt;
			&lt;Action type="output"&gt;
				&lt;DataModel ref="TheDataModel"/&gt;
			&lt;/Action&gt;
		&lt;/State&gt;
	&lt;/StateModel&gt;

	&lt;Agent name="TheAgent"&gt;
		&lt;Monitor class="CanaKitRelay"&gt;
			&lt;Param name="SerialPort" value="COM5" /&gt;
			&lt;Param name="RelayNumber" value="1" /&gt;
		&lt;/Monitor&gt;
	&lt;/Agent&gt;

	&lt;Test name="Default"&gt;
		&lt;StateModel ref="State"/&gt;
		&lt;Agent ref="TheAgent" /&gt;
		&lt;Publisher class="ConsoleHex"/&gt;
	&lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
</informalexample>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Monitors_CanCapture">
<title>CAN Capture Monitor</title>
<simpara><emphasis role="strong">Monitor Category</emphasis>: <emphasis role="strong">Data Collection</emphasis></simpara>
<simpara>The <emphasis>CAN Capture</emphasis> monitor collects all frames received (but not transmitted) on the specified interface.  If a fault occure, the capture is saved in the <emphasis>PCAP</emphasis> format, loadable into Wireshark for analysis.</simpara>
<note>
<simpara>Not all information from the CAN frame is visible in Wireshark.
Basic flags and data are available, but not the full frame.  This is a
limitation of the format and not Peach Fuzzer.</simpara>
</note>
<section xml:id="_parameters_78">
<title>Parameters</title>
<simpara><emphasis>Required:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>CanDriver</term>
<listitem>
<simpara>Driver to use. Defaults to <emphasis>Vector XL</emphasis>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>CanChannel</term>
<listitem>
<simpara>Channel number</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>CanBitrate</term>
<listitem>
<simpara>Set the bitrate for CAN packet transmission (default 500,000)</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Optional:</emphasis></simpara>
<simpara>None</simpara>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Monitors_CanErrorFrame">
<title>CAN Error Frame Monitor</title>
<simpara><emphasis role="strong">Monitor Category</emphasis>: <emphasis role="strong">Fault detection</emphasis></simpara>
<simpara>The <emphasis>CAN Error Frame</emphasis> monitor is will trigger a fault when an error frame is received on the specified device/channel.  Multiple <emphasis>CAN Error Frame</emphasis> monitors can be configured to monitor different devices/channel combinations.</simpara>
<section xml:id="_parameters_79">
<title>Parameters</title>
<simpara><emphasis>Required:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>CanDriver</term>
<listitem>
<simpara>Driver to use. Defaults to <emphasis>Vector XL</emphasis>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>CanChannel</term>
<listitem>
<simpara>Channel number</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>CanBitrate</term>
<listitem>
<simpara>Set the bitrate for CAN packet reception (default 500,000)</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Optional:</emphasis></simpara>
<simpara>No optional parameters supported on this monitor.</simpara>
</section>
<section xml:id="_examples_129">
<title>Examples</title>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Monitors_CanSendFrame">
<title>CAN Send Frame Monitor</title>
<simpara><emphasis role="strong">Monitor Category</emphasis>: <emphasis role="strong">Automation</emphasis></simpara>
<simpara>The <emphasis>CAN Send Frame</emphasis> monitor is used to send CAN frames that are not fuzzed.
Frames can be sent at specific points during a test case, every N milliseconds,
or both. This can be useful to simulate messages required by a target.</simpara>
<simpara>The CAN frames being sent can share the same driver and channel as the fuzzing, or
use a different driver/channel.</simpara>
<note>
<simpara>The DLC is auto set based on the data size provided.</simpara>
</note>
<section xml:id="_parameters_80">
<title>Parameters</title>
<simpara><emphasis>Required:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>CanDriver</term>
<listitem>
<simpara>Driver to use. Defaults to <emphasis>Vector XL</emphasis>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>CanChannel</term>
<listitem>
<simpara>Channel number</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>CanBitrate</term>
<listitem>
<simpara>Set the bitrate for CAN packet transmission (default 500,000)</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Id</term>
<listitem>
<simpara>CAN Frame ID field in hex.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Data</term>
<listitem>
<simpara>CAN data to transmit in hex.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>SendEvery</term>
<listitem>
<simpara>Send frame every N milliseconds. Disable by setting to zero. Defaults to 0.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>When</term>
<listitem>
<simpara>Specify one of the following values to determine when a CAN frame should be sent (defaults to <literal>OnStart</literal>):</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="66.6667*"/>
<thead>
<row>
<entry align="left" valign="top">"When" Setting</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>DetectFault</simpara></entry>
<entry align="left" valign="top"><simpara>Send CAN frame when checking for a fault.
This occurs after OnIterationEnd.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>OnStart</simpara></entry>
<entry align="left" valign="top"><simpara>Send CAN frame when the fuzzing session starts.
This occurs once per session.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>OnEnd</simpara></entry>
<entry align="left" valign="top"><simpara>Send CAN frame when the fuzzing session stops.
This occurs once per session.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>OnIterationStart</simpara></entry>
<entry align="left" valign="top"><simpara>Send CAN frame at the start of each iteration.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>OnIterationEnd</simpara></entry>
<entry align="left" valign="top"><simpara>Send CAN frame at the end of each iteration.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>OnFault</simpara></entry>
<entry align="left" valign="top"><simpara>Send CAN frame when any monitor detects a fault.
This is the default setting.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>OnIterationStartAfterFault</simpara></entry>
<entry align="left" valign="top"><simpara>Send CAN frame at the start of an iteration that immediately follows a fault detection.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>OnCall</simpara></entry>
<entry align="left" valign="top"><simpara>Send CAN frame when the call specified by the <emphasis>StartOnCall</emphasis> parameter is received from the state model.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<figure>
<title>When Choices for Performing an Action</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/Monitors/Timings_SSH.png"/>
</imageobject>
<textobject><phrase>Timings SSH</phrase></textobject>
</mediaobject>
</figure>
</listitem>
</varlistentry>
<varlistentry>
<term>StartOnCall</term>
<listitem>
<simpara>Send frame when the specified event is received from the state model.
This value is used only when the <emphasis>When</emphasis> parameter is set to <literal>OnCall</literal>.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_130">
<title>Examples</title>
<example>
<title>Send CAN Frame Every 500 ms<?asciidoc-br?></title>
<simpara>This parameter example is from a setup that uses the CAN Send Frame monitor
to send a CAN frame every 500 ms.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach&gt;

  &lt;DataModel name="CanId" mutable="false"&gt;
    &lt;Number name="Value" size="29" signed="false"
      endian="big" mutable="false" /&gt;
  &lt;/DataModel&gt;

  &lt;DataModel name="Standard_Message_1_3"&gt;
    &lt;Number name="Signal_8_VtSig" size="8" signed="false" value="170" /&gt;
  &lt;/DataModel&gt;

  &lt;StateModel name="TheStateModel" initialState="SendCanFrames"&gt;
    &lt;State name="SendCanFrames"&gt;
      &lt;Action name="SendCanFrame_3" type="call" method="Send"&gt;
        &lt;Param name="Id"&gt;
          &lt;DataModel ref="CanId" /&gt;
		  &lt;Data&gt;
			&lt;Field name="Value" value="0x1"/&gt;
		  &lt;/Data&gt;
        &lt;/Param&gt;
        &lt;Param name="Data"&gt;
          &lt;DataModel ref="Standard_Message_1_3" /&gt;
        &lt;/Param&gt;
      &lt;/Action&gt;
    &lt;/State&gt;
  &lt;/StateModel&gt;

  &lt;Agent name="Local"&gt;
    &lt;Monitor class="CanSendFrame"&gt;
        &lt;Param name="CanDriver" value="Vector XL"/&gt;
        &lt;Param name="CanChannel" value="1"/&gt;
        &lt;Param name="CanBitrate" value="500000"/&gt;
        &lt;Param name="Id" value="0x07DC"/&gt;
        &lt;Param name="Data" value="AA BB CC DD EE FF"/&gt;
        &lt;Param name="SendEvery" value="500"/&gt;
    &lt;/Monitor&gt;
  &lt;/Agent&gt;

  &lt;Test name="Default" maxOutputSize="64"&gt;
    &lt;Agent ref="Local"/&gt;
    &lt;StateModel ref="TheStateModel" /&gt;
    &lt;Publisher class="Can"&gt;
	  &lt;Param name="Driver" value="Vector XL" /&gt;
	  &lt;Param name="Channel" value="1" /&gt;
	  &lt;Param name="Bitrate" value="500000" /&gt;
    &lt;/Publisher&gt;
  &lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Output from this example.</simpara>
<screen>&gt;peach -1 --debug example.xml

[*] Test 'Default' starting with random seed 61495.
Peach.Pro.Core.Loggers.JobLogger Writing debug.log to: c:\peach-pro\output\win_x64_debug\bin\Logs\CanSendFrame_Example.xml_20180521162530\debug.log
Peach.Core.Agent.Channels.AgentLocal StartMonitor: Monitor CanSendFrame
Peach.Pro.Core.Publishers.Can.VectorCanDriver VectorCanDriver.Initialize: Vector XL -Receive loop started
Peach.Core.Agent.Channels.AgentLocal SessionStarting
Peach.Pro.Core.Agent.Monitors.CanSendFrame Starting timer to send CAN frame every 500 ms
Peach.Pro.Core.Agent.Monitors.CanSendFrame Sending frame id '0x07DC' of 'AA BB CC DD EE FF'
Peach.Core.Engine runTest: Iteration Starting: 1,  =============================

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing control recording iteration.
Peach.Core.Dom.StateModel Run(): Changing to state "SendCanFrames".
Peach.Core.Dom.Action Run(SendCanFrame_3): Call
Peach.Pro.Core.Publishers.CanPublisher start()
Peach.Pro.Core.Publishers.CanPublisher call(Send) ActionParameter Count: 2
Peach.Pro.Core.Publishers.CanPublisher call(Send) BitwiseStream Count: 2
Peach.Pro.Core.Publishers.CanPublisher open()
Peach.Pro.Core.Publishers.CanPublisher close()
Peach.Core.Agent.AgentManager DetectedFault: checking for fault in agent Local
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Engine All test cases executed, stopping engine.
Peach.Pro.Core.Publishers.CanPublisher stop()
Peach.Core.Engine EndTest: Stopping all agents and monitors

[*] Test 'Default' finished.</screen>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Monitors_CanTiming">
<title>CAN Timing Monitor</title>
<simpara><emphasis role="strong">Monitor Category</emphasis>: <emphasis role="strong">Fault detection</emphasis></simpara>
<simpara>The <emphasis>CAN Timing</emphasis> monitor is will trigger a fault when a frame is not received within a specified time window.
Many CAN targets are designed to send one or more CAN frames every N milliseconds.
When transmition of these frames stops or is out of spec, this can indicate a failure in the target device.</simpara>
<simpara>The CAN frames being sent can share the same driver and channel as the fuzzing, or use a different driver/channel.</simpara>
<section xml:id="_parameters_81">
<title>Parameters</title>
<simpara><emphasis>Required:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>CanDriver</term>
<listitem>
<simpara>Driver to use. Defaults to <emphasis>Vector XL</emphasis>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>CanChannel</term>
<listitem>
<simpara>Channel number</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>CanBitrate</term>
<listitem>
<simpara>Set the bitrate for CAN packet reception (default 500,000)</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Id</term>
<listitem>
<simpara>CAN Frame ID field in hex to expect</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Window</term>
<listitem>
<simpara>Reception window (how often frame should be received) in milliseconds.
If frame with <literal>Id</literal> is not received in this window of time, a fault will be raised.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Optional:</emphasis></simpara>
</section>
<section xml:id="_examples_131">
<title>Examples</title>
<example>
<title>Expect frame every half second<?asciidoc-br?></title>
<simpara>This parameter example is from a setup that uses the CAN Timing Monitor
to fault if a specific CAN frame is not received every half second.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach&gt;

  &lt;DataModel name="CanId" mutable="false"&gt;
    &lt;Number name="Value" size="29" signed="false"
      endian="big" mutable="false" /&gt;
  &lt;/DataModel&gt;

  &lt;DataModel name="Standard_Message_1_3"&gt;
    &lt;Number name="Signal_8_VtSig" size="8" signed="false" value="170" /&gt;
  &lt;/DataModel&gt;

  &lt;StateModel name="TheStateModel" initialState="SendCanFrames"&gt;
    &lt;State name="SendCanFrames"&gt;
      &lt;Action name="SendCanFrame_3" type="call" method="Send"&gt;
        &lt;Param name="Id"&gt;
          &lt;DataModel ref="CanId" /&gt;
		  &lt;Data&gt;
			&lt;Field name="Value" value="0x1"/&gt;
		  &lt;/Data&gt;
        &lt;/Param&gt;
        &lt;Param name="Data"&gt;
          &lt;DataModel ref="Standard_Message_1_3" /&gt;
        &lt;/Param&gt;
      &lt;/Action&gt;
    &lt;/State&gt;
  &lt;/StateModel&gt;

  &lt;Agent name="Local"&gt;
    &lt;Monitor class="CanTiming"&gt;
        &lt;Param name="CanDriver" value="Vector XL"/&gt;
        &lt;Param name="CanChannel" value="1"/&gt;
        &lt;Param name="CanBitrate" value="500000"/&gt;
        &lt;Param name="Id" value="0x07DC"/&gt;
        &lt;Param name="Window" value="500"/&gt;
    &lt;/Monitor&gt;
  &lt;/Agent&gt;

  &lt;Test name="Default" maxOutputSize="64"&gt;
    &lt;Agent ref="Local"/&gt;
    &lt;StateModel ref="TheStateModel" /&gt;
    &lt;Publisher class="Can"&gt;
	  &lt;Param name="Driver" value="Vector XL" /&gt;
	  &lt;Param name="Channel" value="1" /&gt;
	  &lt;Param name="Bitrate" value="500000" /&gt;
    &lt;/Publisher&gt;
  &lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Output from this example.</simpara>
<screen>&gt;peach -1 --debug example.xml

[*] Test 'Default' starting with random seed 25814.
Peach.Pro.Core.Loggers.JobLogger Writing debug.log to: peach-pro\Logs\CanTiming_Example.xml_20180522150641\debug.log
Peach.Core.Agent.Channels.AgentLocal StartMonitor: Monitor CanTiming
Peach.Pro.Core.Publishers.Can.VectorCanDriver VectorCanDriver.Initialize: Vector XL -Receive loop started
Peach.Core.Agent.Channels.AgentLocal SessionStarting
Peach.Core.Engine runTest: Iteration Starting: 1,  =============================

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing control recording iteration.
Peach.Core.Dom.StateModel Run(): Changing to state "SendCanFrames".
Peach.Core.Dom.Action Run(SendCanFrame_3): Call
Peach.Pro.Core.Publishers.CanPublisher start()
Peach.Pro.Core.Publishers.CanPublisher call(Send) ActionParameter Count: 2
Peach.Pro.Core.Publishers.CanPublisher call(Send) BitwiseStream Count: 2
Peach.Pro.Core.Publishers.CanPublisher open()
Peach.Pro.Core.Publishers.CanPublisher close()
Peach.Core.Agent.AgentManager DetectedFault: checking for fault in agent Local
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Engine All test cases executed, stopping engine.
Peach.Pro.Core.Publishers.CanPublisher stop()
Peach.Core.Engine EndTest: Stopping all agents and monitors

[*] Test 'Default' finished.</screen>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Monitors_CanThreshold">
<title>CAN Threshold Monitor</title>
<simpara><emphasis role="strong">Monitor Category</emphasis>: <emphasis role="strong">Fault detection</emphasis></simpara>
<simpara>The <emphasis>CAN Threshold</emphasis> monitor triggers a fault when a CAN signal is outside a specified threshold.
The threshold is provided as a python expression that must evaluate to bool true or false.</simpara>
<simpara>This is one of several ways to monitor a CAN target during fuzzing to determin if testing has adversely affected the target.</simpara>
<simpara>The CAN frames being sent can share the same driver and channel as the fuzzing, or use a different driver/channel.</simpara>
<section xml:id="_parameters_82">
<title>Parameters</title>
<simpara><emphasis>Required:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>CanDriver</term>
<listitem>
<simpara>Driver to use. Defaults to <emphasis>Vector XL</emphasis>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>CanChannel</term>
<listitem>
<simpara>Channel number</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>CanBitrate</term>
<listitem>
<simpara>Set the bitrate for CAN packet reception (default 500,000)</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Id</term>
<listitem>
<simpara>CAN Frame ID field in hex to expect</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>SignalEndian</term>
<listitem>
<simpara>Endianness of signal (if needed). Defaults to <literal>little</literal>.  Options are <literal>little</literal> or <literal>big</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>SignalOffset</term>
<listitem>
<simpara>Bit offset to signal start</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>SignalSize</term>
<listitem>
<simpara>Length of signal field in bits</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>SignalType</term>
<listitem>
<simpara>Data type of signal.
This is used to convert signal data into a usable type in the python threshold expression.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="66.6667*"/>
<thead>
<row>
<entry align="left" valign="top">Signal Types</entry>
<entry align="left" valign="top"></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Int</simpara></entry>
<entry align="left" valign="top"><simpara>SignalSize can be any value 32 or lower</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Float</simpara></entry>
<entry align="left" valign="top"><simpara>SignalSize must be 32 or 64</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Long</simpara></entry>
<entry align="left" valign="top"><simpara>SignalSize between 33 and 64</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>String</simpara></entry>
<entry align="left" valign="top"><simpara>Interpreted as UTF-8</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Binary</simpara></entry>
<entry align="left" valign="top"><simpara>SignalSize must be factor of 8</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</listitem>
</varlistentry>
<varlistentry>
<term>Expression</term>
<listitem>
<simpara>Stateless threshold expression used to determin if the signal value is within spec.
Expression results are cached for speed, and must not be statefull.
The threshold expression is specified as a Python 2 expression.
The provided expression must evaluate to a bool true/false.
Python expressions are single line code statements.
The following is an example of a code snippet that verifies a signal value is between 10 and 20 inclusive:
<literal>signal &gt;= 10 and signal &lt;= 20</literal></simpara>
<simpara>The Python expressions have access to the following local variables:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="66.6667*"/>
<thead>
<row>
<entry align="left" valign="top">Local Variables</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>id</simpara></entry>
<entry align="left" valign="top"><simpara>CAN Frame ID as a python int</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>logger</simpara></entry>
<entry align="left" valign="top"><simpara>Logging interface output stored in debug.log in run folder and test output. logger.Debug(msg)</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>signal</simpara></entry>
<entry align="left" valign="top"><simpara>Signal value decoded based on provided type</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Optional:</emphasis></simpara>
<simpara>No optional parameters.</simpara>
</section>
<section xml:id="_examples_132">
<title>Examples</title>
<example>
<title>Expect frame every half second<?asciidoc-br?></title>
<simpara>This parameter example is from a setup that uses the CAN Threshold Monitor
to fault if a signal in the CAN frame with id 0x7DE is not between 10 and 100.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach&gt;

  &lt;DataModel name="CanId" mutable="false"&gt;
    &lt;Number name="Value" size="29" signed="false"
      endian="big" mutable="false" /&gt;
  &lt;/DataModel&gt;

  &lt;DataModel name="Standard_Message_1_3"&gt;
    &lt;Number name="Signal_8_VtSig" size="8" signed="false" value="170" /&gt;
  &lt;/DataModel&gt;

  &lt;StateModel name="TheStateModel" initialState="SendCanFrames"&gt;
    &lt;State name="SendCanFrames"&gt;
      &lt;Action name="SendCanFrame_3" type="call" method="Send"&gt;
        &lt;Param name="Id"&gt;
          &lt;DataModel ref="CanId" /&gt;
		  &lt;Data&gt;
			&lt;Field name="Value" value="0x1"/&gt;
		  &lt;/Data&gt;
        &lt;/Param&gt;
        &lt;Param name="Data"&gt;
          &lt;DataModel ref="Standard_Message_1_3" /&gt;
        &lt;/Param&gt;
      &lt;/Action&gt;
    &lt;/State&gt;
  &lt;/StateModel&gt;

  &lt;Agent name="Local"&gt;
    &lt;Monitor class="CanTiming"&gt;
        &lt;Param name="CanDriver" value="Vector XL"/&gt;
        &lt;Param name="CanChannel" value="1"/&gt;
        &lt;Param name="CanBitrate" value="500000"/&gt;
        &lt;Param name="Id" value="0x07DC"/&gt;
        &lt;Param name="Window" value="500"/&gt;
    &lt;/Monitor&gt;
  &lt;/Agent&gt;

  &lt;Test name="Default" maxOutputSize="64"&gt;
    &lt;Agent ref="Local"/&gt;
    &lt;StateModel ref="TheStateModel" /&gt;
    &lt;Publisher class="Can"&gt;
	  &lt;Param name="Driver" value="Vector XL" /&gt;
	  &lt;Param name="Channel" value="1" /&gt;
	  &lt;Param name="Bitrate" value="500000" /&gt;
    &lt;/Publisher&gt;
  &lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Output from this example.</simpara>
<screen>&gt;peach -1 --debug example.xml

[*] Test 'Default' starting with random seed 25814.
Peach.Pro.Core.Loggers.JobLogger Writing debug.log to: peach-pro\Logs\CanTiming_Example.xml_20180522150641\debug.log
Peach.Core.Agent.Channels.AgentLocal StartMonitor: Monitor CanTiming
Peach.Pro.Core.Publishers.Can.VectorCanDriver VectorCanDriver.Initialize: Vector XL -Receive loop started
Peach.Core.Agent.Channels.AgentLocal SessionStarting
Peach.Core.Engine runTest: Iteration Starting: 1,  =============================

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing control recording iteration.
Peach.Core.Dom.StateModel Run(): Changing to state "SendCanFrames".
Peach.Core.Dom.Action Run(SendCanFrame_3): Call
Peach.Pro.Core.Publishers.CanPublisher start()
Peach.Pro.Core.Publishers.CanPublisher call(Send) ActionParameter Count: 2
Peach.Pro.Core.Publishers.CanPublisher call(Send) BitwiseStream Count: 2
Peach.Pro.Core.Publishers.CanPublisher open()
Peach.Pro.Core.Publishers.CanPublisher close()
Peach.Core.Agent.AgentManager DetectedFault: checking for fault in agent Local
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Engine All test cases executed, stopping engine.
Peach.Pro.Core.Publishers.CanPublisher stop()
Peach.Core.Engine EndTest: Stopping all agents and monitors

[*] Test 'Default' finished.</screen>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Monitors_CleanupFolder">
<title>CleanupFolder Monitor</title>
<simpara><emphasis role="strong">Monitor Category</emphasis>: <emphasis role="strong">Automation</emphasis></simpara>
<simpara>The <emphasis>CleanupFolder</emphasis> monitor provides automated cleanup of files created during a
fuzzing session. This monitor purges files produced during an iteration before
the start of the following iteration. CleanupFolder acts upon a specified directory,
and does not affect any files or directories that predate the fuzzing session.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>The directory, <literal>clean2</literal>, initially contains a single file.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/Monitors/CleanupFolder_PreFuzz.png"/>
</imageobject>
<textobject><phrase>CleanupFolder PreFuzz</phrase></textobject>
</mediaobject>
</informalfigure>
</listitem>
<listitem>
<simpara>Before each iteration, the CleanupFolder monitor deletes from the specified folder
all files that were generated in the previous fuzzing iteration.</simpara>
</listitem>
<listitem>
<simpara>During each iteration, the File publisher creates a fuzzed file.</simpara>
</listitem>
<listitem>
<simpara>The following image shows the output from a file fuzzing session that uses <emphasis>CleanupFolder</emphasis> on the <literal>clean2</literal> directory. The session duration is 5 iterations.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/Monitors/CleanupFolder_Cleaned.png"/>
</imageobject>
<textobject><phrase>CleanupFolder Cleaned</phrase></textobject>
</mediaobject>
</informalfigure>
</listitem>
<listitem>
<simpara>The following image shows the <literal>clean2</literal> directory with output from a file fuzzing session that does <emphasis>not</emphasis> use <emphasis>CleanupFolder</emphasis>, but is otherwise identical to the pit used for the previous diagram. Files generated in the fuzzing session are highlighted.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/Monitors/CleanupFolder_NotCleaned.png"/>
</imageobject>
<textobject><phrase>CleanupFolder NotCleaned</phrase></textobject>
</mediaobject>
</informalfigure>
</listitem>
</orderedlist>
<note>
<simpara>The FilePerIteration publisher, that generates a new filename for each fuzzed file, produced the fuzzed output files for both of the previous images.</simpara>
</note>
<section xml:id="_parameters_83">
<title>Parameters</title>
<simpara><emphasis>Required:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>Folder</term>
<listitem>
<simpara>Folder to clean.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Optional:</emphasis></simpara>
<simpara>None.</simpara>
</section>
<section xml:id="_examples_133">
<title>Examples</title>
<example>
<title>Remove contents of a folder<?asciidoc-br?></title>
<simpara>Run this example from the folder specified using the <emphasis>folder</emphasis> parameter.</simpara>
<simpara>During each iteration, the file <literal>fuzzed.txt</literal> is created by the File publisher. At the end of each iteration, <literal>fuzzed.txt</literal> is deleted by the CleanupFolder monitor.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

	&lt;DataModel name="TheDataModel"&gt;
		&lt;Number size="32" signed="false" value="31337" /&gt;
	&lt;/DataModel&gt;

	&lt;StateModel name="State" initialState="Initial" &gt;
		&lt;State name="Initial"&gt;
			&lt;Action type="output"&gt;
				&lt;DataModel ref="TheDataModel"/&gt;
			&lt;/Action&gt;

			&lt;Action type="output" publisher="FilePub"&gt;
				&lt;DataModel ref="TheDataModel"/&gt;
			&lt;/Action&gt;
		&lt;/State&gt;
	&lt;/StateModel&gt;

	&lt;Agent name="TheAgent"&gt;
		&lt;Monitor class="CleanupFolder"&gt;
			&lt;Param name="Folder" value="C:\\cleanme"/&gt;
		&lt;/Monitor&gt;
	&lt;/Agent&gt;

	&lt;Test name="Default"&gt;
		&lt;StateModel ref="State"/&gt;
		&lt;Agent ref="TheAgent" /&gt;
		&lt;Publisher class="ConsoleHex"/&gt;
		&lt;Publisher name="FilePub" class="File"&gt;
			&lt;Param name="FileName" value="fuzzed.txt"/&gt;
		&lt;/Publisher&gt;
	&lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Output from this example.</simpara>
<screen>&gt;peach -1 --debug example.xml

[*] Test 'Default' starting with random seed 43073.
Peach.Core.Agent.Agent StartMonitor: Monitor CleanupFolder
Peach.Core.Agent.Agent SessionStarting: Monitor

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher start()
Peach.Core.Publishers.ConsolePublisher open()
Peach.Core.Publishers.ConsolePublisher output(4 bytes)
00000000   69 7A 00 00                                        iz??
Peach.Core.Publishers.ConsolePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.ConsolePublisher stop()
Peach.Core.Agent.Agent SessionFinished: Monitor

[*] Test 'Default' finished.</screen>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Monitors_CleanupRegistry">
<title>CleanupRegistry Monitor (Windows)</title>
<simpara><emphasis role="strong">Monitor Category</emphasis>: <emphasis role="strong">Automation</emphasis></simpara>
<simpara>The <emphasis>CleanupRegistry</emphasis> monitor provides automated cleanup of Windows registry
entries created during a fuzzing session. Cleanup occurs before every iteration.</simpara>
<simpara>This monitor uses a specified registry key (a parent key) as a reference point
and deletes all child keys or descendants of the parent key. All child keys at
all levels beneath the parent key are removed. Values attached to child keys are
removed as well.</simpara>
<simpara>Optionally, <emphasis>CleanupRegistry</emphasis> can include or exclude the parent key and values
attached to the parent key in its purge.</simpara>
<note>
<simpara>The Windows Registry is a hierarchical database that stores information about
the computer system, configuration, applications, current user settings, and
performance data. The contents and use of the registry has evolved since its
inception. Originally, the registry stored installation and initialization
settings for applications. On current versions of Windows, the registry contains
information for the current user, and much more, such as a list of external
serial ports that the machine has allocated.</simpara>
<simpara>One common use of the registry is to store a list of the most recently used
files used in an application. This list is typically displayed to a user to
improve the experience of selecting a file for the application to open.</simpara>
<simpara>The Windows registry consists of five hierarchies called hives, as shown in
the following illustration. Each hive consists of keys and values.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/Monitors/CleanupRegistry_Hives.png"/>
</imageobject>
<textobject><phrase>CleanupRegistry Hives</phrase></textobject>
</mediaobject>
</informalfigure>
<itemizedlist>
<listitem>
<simpara>A key is a container that can contain other keys and values. A key has a name,
a type, and optionally, a data value. The following illustration shows a selected
key. The complete name for this key is reported in the lower left corner.</simpara>
</listitem>
<listitem>
<simpara>A value is an item associated with a key that has a type, a data value, and
optionally, a name. In the following illustration, the named values defined for the
selected key are listed in the right side of the window.</simpara>
</listitem>
</itemizedlist>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/Monitors/CleanupRegistry_Values.png"/>
</imageobject>
<textobject><phrase>CleanupRegistry Values</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Each hive has one root key that is the entry point to the hive. These root keys
are the prefixes described for the <emphasis>CleanupRegistry</emphasis> <literal>Key</literal> parameter. The hives
used most often are <literal>HKCU</literal> and <literal>HKLM</literal>, but keys from other hives are accessible as well.</simpara>
<simpara>Locating a key in the registry is similar to locating a folder on disk. Start with
the root key and specify the sequence of keys you need to reach the desired key.
Separate keys with the back slash character "\", just like the folders in a path.</simpara>
<simpara>A root key, such as <literal>HKCU,</literal> has child keys; that is, the keys that it contains.
A non-root key, such as <literal>HKCU\Software</literal>, has a parent key (<literal>HKCU</literal>) and, optionally,
child keys. Note that <literal>HKCU</literal> is the parent key of <literal>Software</literal>. The key
<literal>HKCU\Software\Mozilla\FireFox</literal> also has two child keys or children (<literal>Crash Reporter</literal> and <literal>TaskBarIDs</literal>).</simpara>
<simpara>For more information, see
<link xl:href="http://en.wikipedia.org/wiki/Windows_Registry">Windows Registry</link>. Note the rich
bibliography, which can serve as a foundation for additional reading. Also, the
Microsoft Developer Network (MSDN) has several articles on the registry.</simpara>
</note>
<tip>
<simpara>In <emphasis>CleanupRegistry</emphasis>, you do not have control over individual values. You simply
identify the parent key, and specify whether you need to zap the parent key;
then let the monitor clean up around that registry key after each iteration.</simpara>
<simpara>Sometimes, applications keep lists of recently used files in the registry, typically
in the HKCU or HKLM hives. If you receive an error about not being able to create
a key in the registry, you might need to clear the children of a specified key.</simpara>
</tip>
<section xml:id="_parameters_84">
<title>Parameters</title>
<simpara><emphasis>Required:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>Key</term>
<listitem>
<simpara>Registry key to remove. The following <emphasis role="strong">key prefixes</emphasis> are used: <?asciidoc-br?>
   <emphasis role="strong">HKCU</emphasis> - Current user <?asciidoc-br?>
<emphasis role="strong">HKCC</emphasis> - Current configuration <?asciidoc-br?>
<emphasis role="strong">HKLM</emphasis> - Local machine <?asciidoc-br?>
<emphasis role="strong">HKPD</emphasis> - Performance data <?asciidoc-br?>
<emphasis role="strong">HKU</emphasis> - Users</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>ChildrenOnly</term>
<listitem>
<simpara>If true, omits the parent key from the purge, thereby deleting
all descendants (sub-keys) of the specified key.<?asciidoc-br?>
If false, the parent key and all descendants are deleted. Defaults to false.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_134">
<title>Examples</title>
<formalpara>
<title>Cleanup for office<?asciidoc-br?></title>
<para>This uses the CleanupRegistry monitor to remove a specified key from the Windows Registry at the beginning of a fuzzing session as part of the control iteration.</para>
</formalpara>
<informalexample>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

	&lt;DataModel name="TheDataModel"&gt;
		&lt;Number size="32" signed="false" value="31337" /&gt;
	&lt;/DataModel&gt;

	&lt;StateModel name="State" initialState="Initial" &gt;
		&lt;State name="Initial"&gt;
			&lt;Action type="output"&gt;
				&lt;DataModel ref="TheDataModel"/&gt;
			&lt;/Action&gt;
		&lt;/State&gt;
	&lt;/StateModel&gt;

	&lt;Agent name="TheAgent"&gt;
	&lt;Monitor class="CleanupRegistry"&gt;
		&lt;Param name="Key" value="HKLM\SOFTWARE\Office13\Recovery" /&gt;
	&lt;/Monitor&gt;
 &lt;/Agent&gt;

	&lt;Test name="Default"&gt;
		&lt;StateModel ref="State"/&gt;
		&lt;Agent ref="TheAgent" /&gt;
		&lt;Publisher class="ConsoleHex"/&gt;
	&lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Output for this example.</simpara>
<screen>&gt;peach -1 --debug example.xml

[*] Test 'Default' starting with random seed 28078.
Peach.Core.Agent.Agent StartMonitor: Monitor CleanupRegistry
Peach.Core.Agent.Agent SessionStarting: Monitor

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.OS.Windows.Agent.Monitors.CleanupRegistry Removing key: SOFTWARE\Office13\Recovery <co xml:id="CO58-1"/>
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher start()
Peach.Core.Publishers.ConsolePublisher open()
Peach.Core.Publishers.ConsolePublisher output(4 bytes)
00000000   69 7A 00 00                                        iz??
Peach.Core.Publishers.ConsolePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.ConsolePublisher stop()
Peach.Core.Agent.Agent SessionFinished: Monitor

[*] Test 'Default' finished.</screen>
<calloutlist>
<callout arearefs="CO58-1">
<para>Deleting the registry key</para>
</callout>
</calloutlist>
</informalexample>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Monitors_CrashReporter">
<title>CrashReporter Monitor (OS X)</title>
<simpara><emphasis role="strong">Monitor categories</emphasis>: <emphasis role="strong">Data collection</emphasis>, <emphasis role="strong">Fault detection</emphasis></simpara>
<simpara>The <emphasis>CrashReporter</emphasis> monitor collects and logs core dump information from crashes detected by the OS X System Crash Reporter.
Use <emphasis>CrashReporter</emphasis> when crashes can occur and you cannot use <link linkend="Monitors_CrashWrangler">CrashWrangler</link>.</simpara>
<simpara>The monitoring scope can focus on a single executable,
specified by setting the <emphasis role="strong">ProcessName</emphasis> parameter.
Or,
the monitoring scope can include all processes.
By default, all processes are monitored.</simpara>
<important>
<simpara>Before fuzzing,
make sure to disable the Apple crash report dialog window. When the fuzzing session ends, reenable the crash report dialog window.
Commands to disable and enable the crash report dialog window follow:</simpara>
<itemizedlist>
<listitem>
<simpara>Disable the crash report dialog:</simpara>
<simpara><literal>defaults write com.apple.CrashReporter DialogType none</literal></simpara>
</listitem>
<listitem>
<simpara>Enable the crash report dialog after fuzzing:</simpara>
<simpara><literal>defaults write com.apple.CrashReporter DialogType crashreport</literal></simpara>
</listitem>
</itemizedlist>
</important>
<section xml:id="_parameters_85">
<title>Parameters</title>
<simpara><emphasis>Required:</emphasis></simpara>
<simpara>None.</simpara>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>ProcessName</term>
<listitem>
<simpara>Name of the process to watch (optional, defaults to all)</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_135">
<title>Examples</title>
<example>
<title>Catch all crashes</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

  &lt;DataModel name="TheDataModel"&gt;
    &lt;Number size="32" signed="false" value="31337" /&gt;
  &lt;/DataModel&gt;

  &lt;StateModel name="State" initialState="Initial" &gt;
    &lt;State name="Initial"&gt;
      &lt;Action type="output"&gt;
        &lt;DataModel ref="TheDataModel"/&gt;
      &lt;/Action&gt;
    &lt;/State&gt;
  &lt;/StateModel&gt;

  &lt;Agent name="TheAgent"&gt;
    &lt;Monitor class="CrashReporter"/&gt;
  &lt;/Agent&gt;

  &lt;Test name="Default"&gt;
    &lt;StateModel ref="State"/&gt;
    &lt;Agent ref="TheAgent" /&gt;
    &lt;Publisher class="ConsoleHex"/&gt;
  &lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Monitors_CrashWrangler">
<title>CrashWrangler Monitor (OS X)</title>
<simpara><emphasis role="strong">Monitor Categories</emphasis>: <emphasis role="strong">Automation</emphasis>, <emphasis role="strong">Data collection</emphasis>, <emphasis role="strong">Fault detection</emphasis></simpara>
<important>
<simpara>The gdb debugger and <link linkend="Monitors_Gdb">gdb</link> monitor are the preferred tools to detect crashes and to collect core files on OS X.</simpara>
</important>
<simpara>The <emphasis>CrashWrangler</emphasis> monitor launches a process attached to the CrashWrangler debugger
and monitors the process for crashes and other faults. This monitor runs only on OS X
systems. Use this monitor when gdb is not an option, such as when anti-debugging
mechanisms are used on the test target.</simpara>
<simpara><emphasis>CrashWrangler</emphasis> monitor detects crashes, exceptions, access violations, and faults.
This monitor can generate faults for an application that exits early or that fails to exit.</simpara>
<simpara>After detecting a fault, the  <emphasis>CrashWrangler</emphasis> monitor collects a stack trace, data from
the device log files, and crash dumps. Additionally, the monitor logs exceptions, and
updates fault bucket information. For bucketing, Peach uses the text from the fault to
determine the major bucket level. The minor bucket level is not used. The risk
evaluation provides the following levels: exploitable, not exploitable, or unknown.</simpara>
<tip>
<simpara>This monitor uses Apple&#8217;s Crash Wrangler tool that can be downloaded from the
developer website. Crash Wrangler must be compiled on each machine it is used.</simpara>
<simpara>When using more than one instance of CrashWrangler in the same fuzzing session, assign unique names for the CwLockFile, CwLogFile, and CwPidFile files used with each instance of CrashWrangler. This practice will avoid contention issues involving these files.</simpara>
</tip>
<section xml:id="_parameters_86">
<title>Parameters</title>
<simpara><emphasis>Required:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>Executable</term>
<listitem>
<simpara>Command or application to launch. This parameter name is preferred over Command.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Command</term>
<listitem>
<simpara>Command to execute. Alias with Executable.</simpara>
</listitem>
</varlistentry>
</variablelist>
<note>
<simpara>The Command parameter is supported, but is being deprecated. Instead, use the Executable parameter.</simpara>
</note>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>Arguments</term>
<listitem>
<simpara>Command line arguments for the application that CrashWrangler launches, defaults to none.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>CwLockFile</term>
<listitem>
<simpara>CrashWrangler Lock file, defaults to <literal>cw.lock</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>CwLogFile</term>
<listitem>
<simpara>CrashWrangler Log file, defaults to <literal>cw.log</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>CwPidFile</term>
<listitem>
<simpara>CrashWrangler PID file, defaults to <literal>cw.pid</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>ExecHandler</term>
<listitem>
<simpara>Crash Wrangler execution handler program, defaults to <literal>exc_handler</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>ExploitableReads</term>
<listitem>
<simpara>Are read a/v&#8217;s considered exploitable? Defaults to false.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>FaultOnEarlyExit</term>
<listitem>
<simpara>Trigger a fault if the process exits prematurely, defaults to false.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>NoCpuKill</term>
<listitem>
<simpara>Disable process killing by CPU usage, Defaults to false.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>RestartAfterFault</term>
<listitem>
<simpara>If "true", restarts the target when any monitor detects a fault.
If "false", restarts the target only if the process exits or crashes.<?asciidoc-br?>
This argument defaults to true.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>RestartOnEachTest</term>
<listitem>
<simpara>Restarts the process for each iteration, defaults to false.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>StartOnCall</term>
<listitem>
<simpara>Start the executable on a state model call, defaults to none.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>UseDebugMalloc</term>
<listitem>
<simpara>Use the OS X Debug Malloc (slower), defaults to false.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>WaitForExitOnCall</term>
<listitem>
<simpara>Wait for the process to exit on a state model call and fault if a timeout occurs, defaults to none.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>WaitForExitTimeout</term>
<listitem>
<simpara>WaitForExitOnCall timeout value, expressed in milliseconds. -1 is infinite, defaults to 10000.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_136">
<title>Examples</title>
<example>
<title>Fuzzing Safari</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

	&lt;DataModel name="TheDataModel"&gt;
		&lt;Number size="32" signed="false" value="31337" /&gt;
	&lt;/DataModel&gt;

	&lt;StateModel name="State" initialState="Initial" &gt;
		&lt;State name="Initial"&gt;
			&lt;Action type="output"&gt;
				&lt;DataModel ref="TheDataModel"/&gt;
			&lt;/Action&gt;
			&lt;Action type="close"/&gt;
			&lt;Action type="call" method="ScoobySnacks" publisher="Peach.Agent"/&gt;
		&lt;/State&gt;
	&lt;/StateModel&gt;

	&lt;Agent name="Local"&gt;
		&lt;Monitor class="CrashWrangler"&gt;
			&lt;Param name="Executable" value="/Applications/Safari.app/Contents/MacOS/Safari" /&gt;
			&lt;Param name="Arguments" value="fuzzed.bin" /&gt;

			&lt;Param name="UseDebugMalloc" value="true" /&gt;
			&lt;Param name="ExploitableReads" value="true" /&gt;
			&lt;Param name="ExecHandler" value="./exc_handler" /&gt;

			&lt;Param name="StartOnCall" value="ScoobySnacks" /&gt;
		&lt;/Monitor&gt;
	&lt;/Agent&gt;

	&lt;Test name="Default"&gt;
		&lt;StateModel ref="State"/&gt;
		&lt;Agent ref="TheAgent" /&gt;

		&lt;Publisher class="File"&gt;
			&lt;Param name="FileName" value="fuzzed.bin"/&gt;
		&lt;/Publisher&gt;
	&lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Monitors_Gdb">
<title>Gdb Monitor (Linux, OS X)</title>
<simpara><emphasis role="strong">Monitor Categories</emphasis>: <emphasis role="strong">Automation</emphasis>, <emphasis role="strong">Data collection</emphasis>, <emphasis role="strong">Fault detection</emphasis></simpara>
<simpara>The <emphasis>Gdb</emphasis> monitor uses GDB to launch an executable. It then monitors the executing process for specific signals/exceptions.
<emphasis>Gdb</emphasis> is the main debugger for Linux and OS X operating systems.</simpara>
<simpara>When a configured signal/exception is handled,
<emphasis>Gdb</emphasis> collects and logs information about the crash including frame information, registers and backtrace.</simpara>
<simpara><emphasis>Gdb</emphasis> supports bucketing of crashes and basic risk ranking that is based on the exploitability of the fault. Bucketing uses categories for major and minor issues.
The exploitability evaluation is similar to the !exploitable debugging extension for .NET.</simpara>
<simpara>For GDB Server support see the <link linkend="Monitors_GdbServer">GdbServer</link> monitor.</simpara>
<note>
<simpara>The <emphasis>Gdb</emphasis> monitor requires a recent version of GDB.</simpara>
</note>
<section xml:id="_parameters_87">
<title>Parameters</title>
<simpara><emphasis>Required:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>Executable</term>
<listitem>
<simpara>Executable to launch. This should be just the executable. Command line arguments can be provided using the optional <emphasis>Arguments</emphasis> parameter.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>Arguments</term>
<listitem>
<simpara>Command line arguments for the executable.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>FaultOnEarlyExit</term>
<listitem>
<simpara>Trigger a fault if the process exits prematurely, defaults to <literal>false</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>GdbPath</term>
<listitem>
<simpara>Path to <literal>gdb</literal>, defaults to <literal>/usr/bin/gdb</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>HandleSignals</term>
<listitem>
<simpara>Signals to consider faults.
Space separated list of signals/exceptions to handle as fautls.
Defaults to: SIGSEGV SIGFPE SIGABRT SIGILL SIGPIPE SIGBUS SIGSYS SIGXCPU SIGXFSZ EXC_BAD_ACCESS EXC_BAD_INSTRUCTION EXC_ARITHMETIC</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>NoCpuKill</term>
<listitem>
<simpara>Disable process killing when the CPU usage nears zero, defaults to <literal>false</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>RestartAfterFault</term>
<listitem>
<simpara>If <literal>true</literal>, restarts the target when any monitor detects a fault.
If <literal>false</literal>, restarts the target only if the process exits or crashes.
This argument defaults to <literal>true</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>RestartOnEachTest</term>
<listitem>
<simpara>Restarts the process for each iteration, defaults to <literal>false</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Script</term>
<listitem>
<simpara>Script file used to drive GDB and perform crash analysis.
This script sets up GDB to run the target application, report back information such as child pid, and handle any signals.
This script also performs crash anlysis and bucketing.
An example script is provided in the examples section.</simpara>
<simpara>The script is a Mushtache style template with the following available parameters:</simpara>
<variablelist>
<varlistentry>
<term>executable</term>
<listitem>
<simpara>Maps to the Executable parameter</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>arguments</term>
<listitem>
<simpara>Maps to the Arguments parameter</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>exploitableScript</term>
<listitem>
<simpara>Default crash analysis and bucketing script</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>faultOnEarlyExit</term>
<listitem>
<simpara>Maps to the FaultOnEarlyExit parameter</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>gdbLog</term>
<listitem>
<simpara>Log file used to record information that will be logged with any fault</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>gdbCmd</term>
<listitem>
<simpara>This script file after being processed by Mushtache</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>gdbPath</term>
<listitem>
<simpara>Maps to the GdbPath parameter</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>gdbPid</term>
<listitem>
<simpara>Pid file generated by script at start of executable</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>gdbTempDir</term>
<listitem>
<simpara>Temporary directory to hold generated data</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>handleSignals</term>
<listitem>
<simpara>Maps to the HandleSignals parameter</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>noCpuKill</term>
<listitem>
<simpara>Maps to the NoCpuKill parameter</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>restartOnEachTest</term>
<listitem>
<simpara>Maps to the RestartOnEachTest parameter</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>restartAfterFault</term>
<listitem>
<simpara>Maps to the RestartAfterFault parameter</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>startOnCall</term>
<listitem>
<simpara>Maps to the StartOnCall parameter</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>waitForExitOnCall</term>
<listitem>
<simpara>Maps to the WaitForExitOnCall parameter</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>waitFOrExitTimeout</term>
<listitem>
<simpara>Maps to the WaitForExitTimeout parameter</simpara>
</listitem>
</varlistentry>
</variablelist>
</listitem>
</varlistentry>
<varlistentry>
<term>StartOnCall</term>
<listitem>
<simpara>Start the executable on a state model call.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>WaitForExitOnCall</term>
<listitem>
<simpara>Wait for the process to exit on a state model call and fault if a timeout is reached.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>WaitForExitTimeout</term>
<listitem>
<simpara>WaitForExitOnCall timeout value, expressed in milliseconds. <literal>-1</literal> is infinite, defaults to <literal>10000</literal>.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_gdb_installation">
<title>Gdb Installation</title>
<simpara>Installing <literal>gdb</literal> on Linux consists of using the package manager to download and install the <literal>gdb</literal> debugger and the needed support files and libraries.</simpara>
<itemizedlist>
<listitem>
<simpara>For Ubuntu systems, run the following command install <literal>gdb</literal>:</simpara>
<screen>sudo apt-get install gdb</screen>
</listitem>
<listitem>
<simpara>For CentOS and RedHat Enterprise Linux installations, run the following command to install <literal>gdb</literal>:</simpara>
<screen>sudo yum install gdb</screen>
</listitem>
<listitem>
<simpara>For SUSE Enterprise Linux installations, run the following command to install <literal>gdb</literal>:</simpara>
<screen>sudo zypper install gdb</screen>
</listitem>
</itemizedlist>
<simpara>You can also install <literal>gdb</literal> on OS X using a package manager. See the <link xl:href="http://ntraft.com/installing-gdb-on-os-x-mavericks/">Installing GDB on OS X Mavericks</link> article for more information.</simpara>
</section>
<section xml:id="_examples_137">
<title>Examples</title>
<example>
<title>Script Example</title>
<simpara>This is an example <literal>Script</literal> for driving GDB.</simpara>
<simpara>The <emphasis>Gdb</emphasis> monitor expects specific output that the included exploit analysis to generate the fault title, risk and bucket hashes.</simpara>
<simpara>The following regular expressions are used to extract information from log.  If replacing the crash analysis portion of the script make sure to output to allow the first three regexes to pass.</simpara>
<literallayout class="monospaced">"^Hash: (\w+)\.(\w+)$"  -- Major and Minor bucket
"^Exploitability Classification: (.*)$" -- Risk
"^Short description: (.*)$" -- Title
"^Other tags: (.*)$" -- If found, added to Title</literallayout>
<simpara>Script:</simpara>
<screen>define log_if_crash
 if ($_thread != 0x00)
  printf "Crash detected, running exploitable.\n"
  set logging overwrite on
  set logging redirect on
  set logging on {{gdbLog}}                 <co xml:id="CO59-1"/>
  exploitable -v                            <co xml:id="CO59-2"/>
  printf "\n--- Info Frame ---\n\n"
  info frame
  printf "\n--- Info Registers ---\n\n"
  info registers
  printf "\n--- Backtrace ---\n\n"
  thread apply all bt full
  set logging off
 end
end

handle all nostop noprint
handle {{handleSignals}} stop print

file {{executable}}
set args {{arguments}}
source {{exploitableScript}}

python
def on_start(evt):
    import tempfile, os
    h,tmp = tempfile.mkstemp()
    os.close(h)
    with open(tmp, 'w') as f:
        f.write(str(gdb.inferiors()[0].pid))
    os.renames(tmp, '{{gdbPid}}')           <co xml:id="CO59-3"/>
    gdb.events.cont.disconnect(on_start)
gdb.events.cont.connect(on_start)
end

printf "starting inferior: '{{executable}} {{arguments}}'\n"

run
log_if_crash
quit</screen>
<calloutlist>
<callout arearefs="CO59-3">
<para>Must generate <emphasis>gdbPid</emphasis> when target has been started</para>
</callout>
<callout arearefs="CO59-1">
<para>Must generate <emphasis>gdbLog</emphasis> when a fault has been handled</para>
</callout>
<callout arearefs="CO59-2">
<para>Generates output compatable with regexes</para>
</callout>
</calloutlist>
</example>
<example>
<title>Basic Usage Example</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

  &lt;DataModel name="TheDataModel"&gt;
    &lt;Number size="32" signed="false" value="31337" /&gt;
  &lt;/DataModel&gt;

  &lt;StateModel name="State" initialState="Initial" &gt;
    &lt;State name="Initial"&gt;
      &lt;Action type="call" method="ScoobySnacks" publisher="Peach.Agent"/&gt;

      &lt;Action type="accept"/&gt;
      &lt;Action type="input"&gt;
        &lt;DataModel ref="TheDataModel"/&gt;
      &lt;/Action&gt;

      &lt;Action type="output"&gt;
       &lt;DataModel ref="TheDataModel"/&gt;
     &lt;/Action&gt;
   &lt;/State&gt;
 &lt;/StateModel&gt;

 &lt;Agent name="Local"&gt;
  &lt;Monitor class="Gdb"&gt;
    &lt;Param name="Executable" value="/usr/bin/curl"/&gt;
    &lt;Param name="Arguments" value="http://localhost"/&gt;
    &lt;Param name="StartOnCall" value="ScoobySnacks"/&gt;
  &lt;/Monitor&gt;
&lt;/Agent&gt;

&lt;Test name="Default"&gt;
  &lt;StateModel ref="State"/&gt;
  &lt;Agent ref="Local" /&gt;

  &lt;Publisher class="TcpListener"&gt;
    &lt;Param name="Interface" value="127.0.0.1" /&gt;
    &lt;Param name="Port" value="80"/&gt;
  &lt;/Publisher&gt;&lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Monitors_GdbServer">
<title>GdbServer Monitor (Linux, OS X)</title>
<simpara><emphasis role="strong">Monitor Categories</emphasis>: <emphasis role="strong">Automation</emphasis>, <emphasis role="strong">Data collection</emphasis>, <emphasis role="strong">Fault detection</emphasis></simpara>
<simpara>The <emphasis>GdbServer</emphasis> monitor uses GDB to access a remote debugger that implements the gdb server protocol. This can be <literal>gdbserver</literal> or any other implementation.
This monitor also supportes the multi mode of the extended <literal>gdbserver</literal> protocol via the <emphasis>RemoteExecutable</emphasis> parameter.</simpara>
<simpara>When a configured signal/exception is handled,
<emphasis>GdbServer</emphasis> collects and logs information about the crash including frame information, registers and backtrace.</simpara>
<simpara><emphasis>GdbServer</emphasis> supports bucketing of crashes and basic risk ranking that is based on the exploitability of the fault. Bucketing uses categories for major and minor issues.
The exploitability evaluation is similar to the !exploitable debugging extension for .NET.</simpara>
<simpara>For normal GDB support see the <link linkend="Monitors_Gdb">Gdb</link> monitor.</simpara>
<note>
<simpara>The <emphasis>GdbServer</emphasis> monitor requires a recent version of GDB.</simpara>
</note>
<section xml:id="_parameters_88">
<title>Parameters</title>
<simpara><emphasis>Required:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>Target</term>
<listitem>
<simpara>GDB target command arguments.
Example: <literal>remote 192.168.1.2:6000</literal>.</simpara>
<simpara>When possible use the extended-remote version: <literal>extended-remote IP:PORT</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>LocalExecutable</term>
<listitem>
<simpara>Local copy of executable remote target is running.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>RemoteExecutable</term>
<listitem>
<simpara>Enables multi-process capabilities in the extended gdb server protocol. Provides the remote executable name to load and run. This is the remote exec file-name.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>FaultOnEarlyExit</term>
<listitem>
<simpara>Trigger a fault if the process exits prematurely, defaults to <literal>false</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>GdbPath</term>
<listitem>
<simpara>Path to <literal>gdb</literal>, defaults to <literal>/usr/bin/gdb</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>HandleSignals</term>
<listitem>
<simpara>Signals to consider faults.
Space separated list of signals/exceptions to handle as fautls.
Defaults to: SIGSEGV SIGFPE SIGABRT SIGILL SIGPIPE SIGBUS SIGSYS SIGXCPU SIGXFSZ EXC_BAD_ACCESS EXC_BAD_INSTRUCTION EXC_ARITHMETIC</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>NoCpuKill</term>
<listitem>
<simpara>Disable process killing when the CPU usage nears zero, defaults to <literal>false</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>RestartAfterFault</term>
<listitem>
<simpara>If <literal>true</literal>, restarts the debugger when any monitor detects a fault.
If <literal>false</literal>, restarts the debugger only if the process exits or crashes.
This argument defaults to <literal>true</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>RestartOnEachTest</term>
<listitem>
<simpara>Restarts the process for each iteration, defaults to <literal>false</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Script</term>
<listitem>
<simpara>Script file used to drive GDB and perform crash analysis.
This script sets up GDB to run the target application, report back information such as child pid, and handle any signals.
This script also performs crash anlysis and bucketing.
An example script is provided in the examples section.</simpara>
<simpara>The script is a Mushtache style template with the following available parameters:</simpara>
<variablelist>
<varlistentry>
<term>exploitableScript</term>
<listitem>
<simpara>Default crash analysis and bucketing script</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>faultOnEarlyExit</term>
<listitem>
<simpara>Maps to the FaultOnEarlyExit parameter</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>gdbLog</term>
<listitem>
<simpara>Log file used to record information that will be logged with any fault</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>gdbCmd</term>
<listitem>
<simpara>This script file after being processed by Mushtache</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>gdbPath</term>
<listitem>
<simpara>Maps to the GdbPath parameter</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>gdbPid</term>
<listitem>
<simpara>Pid file generated by script at start of executable</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>gdbTempDir</term>
<listitem>
<simpara>Temporary directory to hold generated data</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>handleSignals</term>
<listitem>
<simpara>Maps to the HandleSignals parameter</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>localExecutable</term>
<listitem>
<simpara>Maps to the LocalExecutableParameter</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>noCpuKill</term>
<listitem>
<simpara>Maps to the NoCpuKill parameter</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>remoteExecutable</term>
<listitem>
<simpara>Maps to the RemoteExecutable parameter</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>restartOnEachTest</term>
<listitem>
<simpara>Maps to the RestartOnEachTest parameter</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>restartAfterFault</term>
<listitem>
<simpara>Maps to the RestartAfterFault parameter</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>startOnCall</term>
<listitem>
<simpara>Maps to the StartOnCall parameter</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>target</term>
<listitem>
<simpara>Maps to the Target parameter</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>waitForExitOnCall</term>
<listitem>
<simpara>Maps to the WaitForExitOnCall parameter</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>waitFOrExitTimeout</term>
<listitem>
<simpara>Maps to the WaitForExitTimeout parameter</simpara>
</listitem>
</varlistentry>
</variablelist>
</listitem>
</varlistentry>
<varlistentry>
<term>StartOnCall</term>
<listitem>
<simpara>Start the executable on a state model call.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>WaitForExitOnCall</term>
<listitem>
<simpara>Wait for the process to exit on a state model call and fault if a timeout is reached.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>WaitForExitTimeout</term>
<listitem>
<simpara>WaitForExitOnCall timeout value, expressed in milliseconds. <literal>-1</literal> is infinite, defaults to <literal>10000</literal>.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_gdb_installation_2">
<title>Gdb Installation</title>
<simpara>Installing <literal>gdb</literal> on Linux consists of using the package manager to download and install the <literal>gdb</literal> debugger and the needed support files and libraries.</simpara>
<itemizedlist>
<listitem>
<simpara>For Ubuntu systems, run the following command install <literal>gdb</literal>:</simpara>
<screen>sudo apt-get install gdb</screen>
</listitem>
<listitem>
<simpara>For CentOS and RedHat Enterprise Linux installations, run the following command to install <literal>gdb</literal>:</simpara>
<screen>sudo yum install gdb</screen>
</listitem>
<listitem>
<simpara>For SUSE Enterprise Linux installations, run the following command to install <literal>gdb</literal>:</simpara>
<screen>sudo zypper install gdb</screen>
</listitem>
</itemizedlist>
<simpara>You can also install <literal>gdb</literal> on OS X using a package manager. See the <link xl:href="http://ntraft.com/installing-gdb-on-os-x-mavericks/">Installing GDB on OS X Mavericks</link> article for more information.</simpara>
</section>
<section xml:id="_examples_138">
<title>Examples</title>
<example>
<title>Script Example</title>
<simpara>This is an example <literal>Script</literal> for driving GDB.</simpara>
<simpara>The <emphasis>GdbServer</emphasis> monitor expects specific output that the included exploit analysis to generate the fault title, risk and bucket hashes.</simpara>
<simpara>The following regular expressions are used to extract information from log.  If replacing the crash analysis portion of the script make sure to output to allow the first three regexes to pass.</simpara>
<literallayout class="monospaced">"^Hash: (\w+)\.(\w+)$"  -- Major and Minor bucket
"^Exploitability Classification: (.*)$" -- Risk
"^Short description: (.*)$" -- Title
"^Other tags: (.*)$" -- If found, added to Title</literallayout>
<simpara>Script:</simpara>
<screen>define log_if_crash
 if ($_thread != 0x00)
  printf "Crash detected, running exploitable.\n"
  set logging overwrite on
  set logging redirect on
  set logging on {{gdbLog}}                 <co xml:id="CO60-1"/>
  exploitable -v                            <co xml:id="CO60-2"/>
  printf "\n--- Info Frame ---\n\n"
  info frame
  printf "\n--- Info Registers ---\n\n"
  info registers
  printf "\n--- Backtrace ---\n\n"
  thread apply all bt full
  set logging off
 end
end

handle all nostop noprint
handle {{handleSignals}} stop print

file {{executable}}
source {{exploitableScript}}

python

import sys

def on_start(evt):
    import tempfile, os
    h,tmp = tempfile.mkstemp()
    os.close(h)
    with open(tmp, 'w') as f:
        f.write(str(gdb.inferiors()[0].pid))
    os.renames(tmp, '{{gdbPid}}')           <co xml:id="CO60-3"/>
    gdb.events.cont.disconnect(on_start)

gdb.events.cont.connect(on_start)

print("starting inferior: '{{target}} {{remoteExecutable}}'")

try:
  if len('{{remoteExecutable}}') &gt; 1:
    print('starting in extended-remote, multi-process mode')
    gdb.execute('set remote exec-file {{remoteExecutable}}')
    gdb.execute('target {{target}}')
    gdb.execute('run')
  else:
    gdb.execute('target {{target}}')
    gdb.execute('continue')

except:
  e = sys.exc_info()[1]
  print('Exception starting target: ' + str(e))
  import tempfile, os
  h,tmp = tempfile.mkstemp()
  os.close(h)
  with open(tmp, 'w') as f:
    f.write(str(e))
  os.renames(tmp, '{{gdbConnectError}}')  <co xml:id="CO60-4"/>
  gdb.execute('quit')

end

log_if_crash
quit</screen>
<calloutlist>
<callout arearefs="CO60-3">
<para>Must generate <emphasis>gdbPid</emphasis> when target has been started</para>
</callout>
<callout arearefs="CO60-1">
<para>Must generate <emphasis>gdbLog</emphasis> when a fault has been handled</para>
</callout>
<callout arearefs="CO60-4">
<para>On remote connection error, output the error message to <emphasis>gdbConnectError</emphasis></para>
</callout>
<callout arearefs="CO60-2">
<para>Generates output compatable with regexes</para>
</callout>
</calloutlist>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Monitors_IpPower9258">
<title>IpPower9258 Monitor</title>
<simpara><emphasis role="strong">Monitor Category</emphasis>: <emphasis role="strong">Automation</emphasis></simpara>
<simpara>The <emphasis>IpPower9258</emphasis> monitor controls an IP Power 9258 Network Power Controller (IP9258).
The IP9258 consists of four three-prong outlets that support electrical loads of 6 amps at 110 or 240 VAC.
Communications between Peach and the IP9258 uses Ethernet cabling.
This monitor allows devices plugged into the IP Power 9258 switch to be powered on/off during fuzzing.</simpara>
<simpara>Each <emphasis>IpPower9258</emphasis> monitor switches an individual outlet.
Use one monitor per outlet to control multiple outlets concurrently.
The monitor can toggle power on an outlet at the following points in time:</simpara>
<itemizedlist>
<listitem>
<simpara>At the start or end of a fuzzing run</simpara>
</listitem>
<listitem>
<simpara>At the start or end of each test iteration</simpara>
</listitem>
<listitem>
<simpara>During the detection of a fault</simpara>
</listitem>
<listitem>
<simpara>After detecting a fault</simpara>
</listitem>
<listitem>
<simpara>At the start of an iteration that immediately follows a fault</simpara>
</listitem>
<listitem>
<simpara>When a specified call is received from the state model</simpara>
</listitem>
</itemizedlist>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/Monitors/IpPower9258.png"/>
</imageobject>
<textobject><phrase>IpPower9258</phrase></textobject>
</mediaobject>
</informalfigure>
<tip>
<simpara>Peach also supports power distribution units that can be
controlled using SNMPv1. For APC PDUs use the
<link linkend="Monitors_ApcPower">APC Power Monitor</link>, and for others try the
<link linkend="Monitors_SnmpPower">SNMP Power Monitor</link>. To control power to a
device by wiring through a relay, Peach provides the
<link linkend="Monitors_CanaKitRelay">CanaKit 4-Port USB Relay Monitor</link>.</simpara>
</tip>
<section xml:id="_parameters_89">
<title>Parameters</title>
<simpara><emphasis>Required:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>Host</term>
<listitem>
<simpara>Host or IP address (can include HTTP interface port e.g. :8080)</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Port</term>
<listitem>
<simpara>Port/Outlet to reset (1, 2, 3, 4)</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>User</term>
<listitem>
<simpara>Username to be used when connecting to the IP Power 9258 device.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Password</term>
<listitem>
<simpara>Password to be used when connecting to the IP Power 9258 device.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>StartOnCall</term>
<listitem>
<simpara>Toggle power when the specified call is received from the state model.
This value is used only when the <emphasis>When</emphasis> parameter is set to <literal>OnCall</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>PowerOnOffPause</term>
<listitem>
<simpara>Pause in milliseconds between power off/power on, default is <literal>500</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>PowerOffOnEnd</term>
<listitem>
<simpara>Power off when the fuzzing session completes, default is <literal>false</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>When</term>
<listitem>
<simpara>Specify one of the following values to determine when a port should be toggled:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="66.6667*"/>
<thead>
<row>
<entry align="left" valign="top">"When" Setting</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>DetectFault</simpara></entry>
<entry align="left" valign="top"><simpara>Toggle power when checking for a fault.
This occurs after OnIterationEnd.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>OnStart</simpara></entry>
<entry align="left" valign="top"><simpara>Toggle power when the fuzzing session starts.
This occurs once per session.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>OnEnd</simpara></entry>
<entry align="left" valign="top"><simpara>Toggle power when the fuzzing session stops.
This occurs once per session.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>OnIterationStart</simpara></entry>
<entry align="left" valign="top"><simpara>Toggle power at the start of each iteration.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>OnIterationEnd</simpara></entry>
<entry align="left" valign="top"><simpara>Toggle power at the end of each iteration.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>OnFault</simpara></entry>
<entry align="left" valign="top"><simpara>Toggle power when any monitor detects a fault.
This is the default setting.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>OnIterationStartAfterFault</simpara></entry>
<entry align="left" valign="top"><simpara>Toggle power at the start of an iteration that immediately follows a fault detection.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>OnCall</simpara></entry>
<entry align="left" valign="top"><simpara>Toggle power when the call specified by the <emphasis>StartOnCall</emphasis> parameter is received from the state model.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<figure>
<title>When Choices for Performing an Action</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/Monitors/Timings_SSH.png"/>
</imageobject>
<textobject><phrase>Timings SSH</phrase></textobject>
</mediaobject>
</figure>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_139">
<title>Examples</title>
<example>
<title>Reset power on port 1</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

  &lt;DataModel name="TheDataModel"&gt;
    &lt;Number size="32" signed="false" value="31337" /&gt;
  &lt;/DataModel&gt;

  &lt;StateModel name="State" initialState="Initial" &gt;
    &lt;State name="Initial"&gt;
      &lt;Action type="output"&gt;
        &lt;DataModel ref="TheDataModel"/&gt;
      &lt;/Action&gt;
    &lt;/State&gt;
  &lt;/StateModel&gt;

  &lt;Agent name="Local"&gt;
    &lt;Monitor class="IpPower9258"&gt;
      &lt;Param name="Host" value="192.168.1.1:8080" /&gt;
      &lt;Param name="Port" value="1" /&gt;
      &lt;Param name="User" value="peach" /&gt;
      &lt;Param name="Password" value="power" /&gt;
    &lt;/Monitor&gt;
  &lt;/Agent&gt;

  &lt;Test name="Default"&gt;
    &lt;StateModel ref="State"/&gt;
    &lt;Agent ref="Local" /&gt;
    &lt;Publisher class="ConsoleHex"/&gt;
  &lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Monitors_LinuxCoreFile">
<title>LinuxCoreFile Monitor (Linux)</title>
<simpara><emphasis role="strong">Monitor Categories</emphasis>: <emphasis role="strong">Data collection</emphasis>, <emphasis role="strong">Fault detection</emphasis></simpara>
<important>
<simpara>The <literal>gdb</literal> debugger and <link linkend="Monitors_Gdb">Gdb Monitor</link> are the preferred tools to detect crashes and to collect core files on Linux.</simpara>
<simpara>This monitor runs only on Linux systems.
Use this monitor when <literal>gdb</literal> is not an option,
such as when anti-debugging mechanisms are used on the test target.</simpara>
</important>
<simpara>The <emphasis>LinuxCoreFile</emphasis> monitor detects when a process crashes and collects the resulting core file.
The monitoring scope includes all processes by default, but can focus on a single executable.</simpara>
<simpara>This monitor runs for the entire fuzzing session and uses the Linux crash recording facility.
When a crash occurs,
the <emphasis>LinuxCoreFile</emphasis> monitor pulls the logging information and available core files,
and sets the bucketing information.
The major bucket is based on the name of the crashed executable,
and the minor bucket is a constant value based on the string "CORE".</simpara>
<simpara>At the end of the session,
<emphasis>LinuxCoreFile</emphasis> restores the saved state and removes the logging folder.</simpara>
<simpara>Because the <emphasis>LinuxCoreFile</emphasis> monitor registers a custom core file handler with the Linux kernel,
only one instance of the monitor is allowed to run on a host at any given time.</simpara>
<formalpara>
<title><emphasis role="strong">Setup Requirements</emphasis></title>
<para>This monitor has the following setup requirements:</para>
</formalpara>
<itemizedlist>
<listitem>
<simpara><emphasis>LinuxCoreFile</emphasis> requires root or equivalent privileges to run.
The <emphasis>LinuxCoreFile</emphasis> monitor registers a script with the kernel to catch core dumps of faulting processes.</simpara>
</listitem>
<listitem>
<simpara>Core files must be enabled.
If the maximum core file size in the system is zero, no core files are created.
You can enable core file generation using the following process:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Find the current core file hard and soft limits in use by the operating system.
The hard limit is an absolute maximum that,
once set,
cannot be increased during a session.
The soft limit is the current maximum file size that you can adjust up to the value of the hard limit.
If the hard limit or the soft limit is set to zero,
core files are disabled.</simpara>
<itemizedlist>
<listitem>
<simpara>You can display the core file hard limit using the following command:</simpara>
<screen>ulimit -Hc</screen>
</listitem>
<listitem>
<simpara>You can display the current core file soft limit using the following command:</simpara>
<screen>ulimit -Sc</screen>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Set the core file hard limit using the following command.
You can specify <literal>unlimited</literal> or a numeric value that represents the number of 512-byte blocks to allow in a core file:</simpara>
<screen>ulimit -Hc unlimited</screen>
</listitem>
<listitem>
<simpara>Set the core file soft limit using the following command.
You can specify any value less than or equal to the hard limit.</simpara>
<screen>ulimit -Sc unlimited</screen>
<simpara>The hard and soft limits can be added to <literal>/etc/sysctl.conf</literal>.
Then, whenever this file loads, appropriate core file limits are specified.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara><literal>gdb</literal> must be installed to analyze the resulting core files.
For information on installing <literal>gdb</literal>, see the <link linkend="Monitors_Gdb">Gdb Monitor</link>.</simpara>
</listitem>
</itemizedlist>
<section xml:id="_parameters_90">
<title>Parameters</title>
<simpara><emphasis>Required:</emphasis></simpara>
<simpara>None.</simpara>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>Executable</term>
<listitem>
<simpara>Target executable process,
used to filter crashes,
defaults to all processes.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>LogFolder</term>
<listitem>
<simpara>Folder with log files,
defaults to <literal>/var/peachcrash</literal>.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_140">
<title>Examples</title>
<example>
<title>Basic Usage</title>
<simpara>This example produces a fault on the first iteration to show how the LinuxCoreFile monitor works.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

  &lt;DataModel name="TheDataModel"&gt;
    &lt;String name="TheString" value="Hello World!" /&gt;
  &lt;/DataModel&gt;

  &lt;StateModel name="State" initialState="Initial" &gt;
    &lt;State name="Initial"&gt;
      &lt;Action type="output"&gt;
        &lt;DataModel ref="TheDataModel"/&gt;
      &lt;/Action&gt;
      &lt;Action type="close"/&gt;
      &lt;Action type="call" method="ScoobySnacks" publisher="Peach.Agent"/&gt;
    &lt;/State&gt;
  &lt;/StateModel&gt;

  &lt;Agent name="Local"&gt;
    &lt;Monitor class="LinuxCoreFile"&gt;
      &lt;Param name="Executable" value="CrashableServer" /&gt;
    &lt;/Monitor&gt;

    &lt;Monitor class="Process"&gt;
      &lt;Param name="Executable" value="CrashableServer" /&gt;
      &lt;Param name="Arguments" value="127.0.0.1 4244" /&gt;
    &lt;/Monitor&gt;
  &lt;/Agent&gt;

 &lt;Test name="Default"&gt;
    &lt;StateModel ref="State"/&gt;
    &lt;Agent ref="Local" /&gt;

    &lt;Publisher class="Tcp"&gt;
      &lt;Param name="Host" value="127.0.0.1" /&gt;
      &lt;Param name="Port" value="4244" /&gt;
    &lt;/Publisher&gt;
  &lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Output from this example.</simpara>
<screen>$ peach --debug --seed=1 --range=1,1 example.xml

Peach.Core.Engine runTest: context.config.range == true, start: 1, stop: 1

[*] Test 'Default' starting with random seed 1.
Peach.Core.Agent.Agent StartMonitor: Monitor LinuxCoreF
Peach.Core.Agent.Agent StartMonitor: Monitor_1 Process
Peach.Core.Agent.Agent SessionStarting: Monitor
Peach.Core.Agent.Agent SessionStarting: Monitor_1
Peach.Core.Agent.Monitors.Process _Start(): Starting process
Establishing the listener...

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Waiting for a connection...
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.TcpClientPublisher start()
Peach.Core.Publishers.TcpClientPublisher open()
Accepted connection from 127.0.0.1:35321.
Peach.Core.Publishers.TcpClientPublisher output(12 bytes)
Peach.Core.Publishers.TcpClientPublisher

00000000   48 65 6C 6C 6F 20 57 6F  72 6C 64 21               Hello World!

Received 12 bytes from client.
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Close
Peach.Core.Publishers.TcpClientPublisher close()
Peach.Core.Publishers.TcpClientPublisher Shutting down connection to 127.0.0.1:4244
Connection closed by peer.
Shutting connection down...
Connection is down.
Waiting for a connection...
Peach.Core.Publishers.TcpClientPublisher Read 0 bytes from 127.0.0.1:4244, closing client connection.
Peach.Core.Publishers.TcpClientPublisher Closing connection to 127.0.0.1:4244
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Call
Peach.Core.Agent.AgentManager Message: Action.Call =&gt; ScoobySnacks

[1,1,0:00:00.347] Performing iteration
[*] Fuzzing: TheDataModel.TheString
[*] Mutator: UnicodeBomMutator
Peach.Core.MutationStrategies.RandomStrategy Action_Starting: Fuzzing: TheDataModel.TheString
Peach.Core.MutationStrategies.RandomStrategy Action_Starting: Mutator: UnicodeBomMutator
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.TcpClientPublisher open()
Accepted connection from 127.0.0.1:48111.
Peach.Core.Publishers.TcpClientPublisher output(1354 bytes)
Peach.Core.Publishers.TcpClientPublisher

00000000   FE FF FF FE FE FF FE BB  BF FE FF FF FE FE FF FE   ????????????????
00000010   BB BF FF FE FF FE FF FE  FF FE FF FE FF FE FF FE   ????????????????
00000020   FF FE FF FE FE FF FE FF  FE FF FE BB BF FE FF FE   ????????????????
00000030   BB BF FF FE FE FF FE FF  FE BB BF FE FF FE FF FE   ????????????????
...

Received 1024 bytes from client.

In CrashMe()
Peach.Core.Dom.Action ActionType.Close
Peach.Core.Publishers.TcpClientPublisher close()
Peach.Core.Publishers.TcpClientPublisher Shutting down connection to 127.0.0.1:4244
Peach.Core.Publishers.TcpClientPublisher Unable to complete reading data from 127.0.0.1:4244.  Connection reset by peer
Peach.Core.Publishers.TcpClientPublisher Closing connection to 127.0.0.1:4244
Peach.Core.Dom.Action ActionType.Call
Peach.Core.Agent.AgentManager Message: Action.Call =&gt; ScoobySnacks
Peach.Core.Agent.AgentManager Fault detected.  Collecting monitor data.
Peach.Core.Engine runTest: detected fault on iteration 1

 -- Caught fault at iteration 1, trying to reproduce --

Peach.Core.Loggers.FileLogger Found core fault [] <co xml:id="CO61-1"/>
Peach.Core.Loggers.FileLogger Saving action: 1.Initial.Action.bin
Peach.Core.Loggers.FileLogger Saving fault: <co xml:id="CO61-2"/>
Peach.Core.Engine runTest: Attempting to reproduce fault.
Peach.Core.Engine runTest: replaying iteration 1

[1,1,0:00:02.673] Performing iteration
Peach.Core.Agent.Monitors.Process _Start(): Starting process
[*] Fuzzing: TheDataModel.TheString
[*] Mutator: UnicodeBomMutator
Peach.Core.MutationStrategies.RandomStrategy Action_Starting: Fuzzing: TheDataModel.TheString
Peach.Core.MutationStrategies.RandomStrategy Action_Starting: Mutator: UnicodeBomMutator
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.TcpClientPublisher open()
Establishing the listener...
Peach.Core.Publishers.TcpClientPublisher open: Warn, Unable to connect to remote host 127.0.0.1 on port 4244.  Trying again in 1ms...
Waiting for a connection...
Peach.Core.Publishers.TcpClientPublisher output(1354 bytes)
Peach.Core.Publishers.TcpClientPublisher

00000000   FE FF FF FE FE FF FE BB  BF FE FF FF FE FE FF FE   ????????????????
00000010   BB BF FF FE FF FE FF FE  FF FE FF FE FF FE FF FE   ????????????????
00000020   FF FE FF FE FE FF FE FF  FE FF FE BB BF FE FF FE   ????????????????
00000030   BB BF FF FE FE FF FE FF  FE BB BF FE FF FE FF FE   ????????????????
...

Accepted connection from 127.0.0.1:40387.
Received 1024 bytes from client.

In CrashMe()
Peach.Core.Dom.Action ActionType.Close
Peach.Core.Publishers.TcpClientPublisher close()
Peach.Core.Publishers.TcpClientPublisher Shutting down connection to 127.0.0.1:4244
Peach.Core.Publishers.TcpClientPublisher Unable to complete reading data from 127.0.0.1:4244.  Connection reset by peer
Peach.Core.Publishers.TcpClientPublisher Closing connection to 127.0.0.1:4244
Peach.Core.Dom.Action ActionType.Call
Peach.Core.Agent.AgentManager Message: Action.Call =&gt; ScoobySnacks
Peach.Core.Agent.AgentManager Fault detected.  Collecting monitor data.
Peach.Core.Engine runTest: detected fault on iteration 1
Peach.Core.Engine &gt;&gt; OnFault

 -- Reproduced fault at iteration 1 --

Peach.Core.Loggers.FileLogger Found core fault []
Peach.Core.Loggers.FileLogger Saving action: 1.Initial.Action.bin
Peach.Core.Loggers.FileLogger Saving fault:
Peach.Core.Engine &lt;&lt; OnFault
Peach.Core.Engine runTest: Reproduced fault, continuing fuzzing at iteration 1
Peach.Core.Publishers.TcpClientPublisher stop()
Peach.Core.Agent.Agent SessionFinished: Monitor_1
Peach.Core.Agent.Monitors.Process _Stop(): Closing process handle
Peach.Core.Agent.Agent SessionFinished: Monitor

[*] Test 'Default' finished.</screen>
<calloutlist>
<callout arearefs="CO61-1">
<para>When the program crashes, a core dump is produced and captured by the LinuxCoreFile monitor.</para>
</callout>
<callout arearefs="CO61-2">
<para>The core dump is saved in the fault record and then removed from its original location.</para>
</callout>
</calloutlist>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Monitors_MemoryMonitor">
<title>Memory Monitor</title>
<simpara><emphasis role="strong">Monitor Category</emphasis>:  <emphasis role="strong">Data collection</emphasis>, <emphasis role="strong">Fault detection</emphasis></simpara>
<simpara>The <emphasis>Memory</emphasis> monitor provides two modes of operation:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Data collection</simpara>
<simpara>When the <emphasis>MemoryLimit</emphasis> is <literal>0</literal>,
the monitor will collect memory metrics at the end of each iteration.
If a fault is triggered by another monitor,
the collected memory metrics will be stored as <literal>Usage.txt</literal> in the fault&#8217;s data bundle.</simpara>
</listitem>
<listitem>
<simpara>Fault detection</simpara>
<simpara>When the <emphasis>MemoryLimit</emphasis> is &gt; <literal>0</literal>,
the monitor will initiate a fault when the memory usage for the process being monitored exceeds the specified limit.</simpara>
</listitem>
</orderedlist>
<simpara>The reported metrics for this monitor include the following items:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Private memory size</emphasis> -
Number of bytes allocated for the process.
An approximate number of bytes a process is using.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Working set memory</emphasis> -
Total physical memory used by the process, consisting of in-memory private bytes plus memory-mapped files,
such as DLLs.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Peak working set</emphasis> -
Largest working set used by the process.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Virtual memory size</emphasis> -
Total address space occupied by the entire process,
including the working set plus paged private bytes and the standby list.</simpara>
</listitem>
</itemizedlist>
<note>
<simpara>This monitor requires that you set a memory limit and identify a process to monitor,
specifying the process by name or by process id.</simpara>
</note>
<section xml:id="_parameters_91">
<title>Parameters</title>
<simpara><emphasis>Required:</emphasis></simpara>
<simpara>Either one of <emphasis>Pid</emphasis> or <emphasis>ProcessName</emphasis> is required.
It is an error to specify both.</simpara>
<variablelist>
<varlistentry>
<term>Pid</term>
<listitem>
<simpara>Process ID to monitor.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>ProcessName</term>
<listitem>
<simpara>Name of the process to monitor.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>MemoryLimit</term>
<listitem>
<simpara>A value specified in bytes.</simpara>
<simpara>When <literal>0</literal> is specified,
enable data collection mode,
which causes memory metrics to be collected
at the end of every iteration.</simpara>
<simpara>When a value greater than <literal>0</literal> is specified,
enable fault detection mode,
which causes a fault to occur if the memory usage of the monitored process exceeds the specified limit.</simpara>
<simpara>Defaults to <literal>0</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>StopOnFault</term>
<listitem>
<simpara>Stop fuzzing if a fault is triggered, defaults to <literal>false</literal>.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_141">
<title>Examples</title>
<example>
<title>Monitor memory via PID</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach ../peach.xsd"&gt;

  &lt;DataModel name="TheDataModel"&gt;
    &lt;Number size="32" signed="false" value="31337" /&gt;
  &lt;/DataModel&gt;

  &lt;StateModel name="State" initialState="Initial" &gt;
    &lt;State name="Initial"&gt;
      &lt;Action type="output"&gt;
        &lt;DataModel ref="TheDataModel"/&gt;
      &lt;/Action&gt;
    &lt;/State&gt;
  &lt;/StateModel&gt;

  &lt;Agent name="Local"&gt;
    &lt;Monitor class="Memory"&gt;
      &lt;Param name="ProcessName" value="Notepad"/&gt;
      &lt;Param name="MemoryLimit" value="10000000" /&gt;
    &lt;/Monitor&gt;
  &lt;/Agent&gt;

  &lt;Test name="Default"&gt;
    &lt;StateModel ref="State"/&gt;
    &lt;Agent ref="Local" /&gt;
    &lt;Publisher class="ConsoleHex"/&gt;
  &lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Output from example.</simpara>
<screen>&gt;peach -1 --debug example.xml

[*] Test 'Default' starting with random seed 54974.
Peach.Core.Agent.Agent StartMonitor: Monitor Memory
Peach.Core.Agent.Agent SessionStarting: Monitor

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher start()
Peach.Core.Publishers.ConsolePublisher open()
Peach.Core.Publishers.ConsolePublisher output(4 bytes)
00000000   69 7A 00 00                                        iz??
Peach.Core.Publishers.ConsolePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.ConsolePublisher stop()
Peach.Core.Agent.Agent SessionFinished: Monitor

[*] Test 'Default' finished.</screen>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Monitors_NetworkCapture">
<title>NetworkCapture Monitor</title>
<simpara><emphasis role="strong">Monitor Categories</emphasis>: <emphasis role="strong">Data collection</emphasis>, <emphasis role="strong">Fault detection</emphasis></simpara>
<simpara>The <emphasis>NetworkCapture</emphasis> monitor performs network captures during the fuzzing iteration.
When a packet arrives,
this monitor writes the content into a file,
increments the received packet count,
and waits for the next packet to arrive.
If a filter is used,
the captured packets and associated packet count are for packets that pass the filtering criteria.</simpara>
<simpara>The captured data begins afresh for each iteration.
If a fault occurs,
the captured data is logged as a <literal>.pcap</literal> file and returned with the fault data.
The <literal>.pcap</literal> file is compatible with Wireshark and <literal>tcpdump</literal>.
A sample capture follows:</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/Monitors/NetworkCapture.png"/>
</imageobject>
<textobject><phrase>NetworkCapture</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Peach supports multiple <emphasis>NetworkCapture</emphasis> monitors in the same pit,
as well as simple and compound packet filters in a single monitor.
A compound packet filter consists of more than one packet filter joined by AND or OR.</simpara>
<note>
<simpara>A packet filter is a boolean value applied to a packet.
If the result of the operation is true,
the packet is accepted.
If the result is false,
the packet is ignored.</simpara>
<simpara>The main benefit of using filters is performance.
Applying a filter to a packet produces a smaller dataset, resulting in faster processing time for each iteration.</simpara>
<simpara>Two strategies for developing effective filters:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Develop a filter that pinpoints the packets to process.</simpara>
</listitem>
<listitem>
<simpara>Develop a filter that prunes unwanted packets using negative logic.</simpara>
</listitem>
</orderedlist>
<simpara>Generally,
using one monitor with a complex filter is better than using two monitors with simpler filters.
Using one monitor places all the packets in a single file with an order of arrival.
Using multiple monitors makes correlating arrival more difficult because each monitor has its own file to keep the processed packets.</simpara>
<simpara>For information on filter strings,
see the following:</simpara>
<itemizedlist>
<listitem>
<simpara><link xl:href="http://www.infosecwriters.com/text_resources/pdf/JStebelton_BPF.pdf">Berkely Packet Filters - The Basics</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="http://www.tcpdump.org/manpages/tcpdump.1.html">tcpdump man page</link></simpara>
</listitem>
</itemizedlist>
</note>
<section xml:id="_parameters_92">
<title>Parameters</title>
<simpara><emphasis>Required:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>Device</term>
<listitem>
<simpara>Device name or port where the packet capture takes place.</simpara>
</listitem>
</varlistentry>
</variablelist>
<note>
<simpara>The Peach command line option <literal>--showdevices</literal> causes Peach to generate a list of all available network interfaces.</simpara>
<itemizedlist>
<listitem>
<simpara>On Windows platforms, the <literal>ipconfig</literal> utility lists the network devices.</simpara>
</listitem>
<listitem>
<simpara>On Unix platforms, the <literal>ifconfig</literal> utility lists the network devices.</simpara>
</listitem>
</itemizedlist>
</note>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>Filter</term>
<listitem>
<simpara>PCAP style filter string.
If present,
the filter restricts capture to packets that match the filter string.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_142">
<title>Examples</title>
<example>
<title>Capture output to CrashableServer on port 4244</title>
<simpara>This example runs <literal>CrashableServer.exe</literal> and capture all network traffic using the NetworkCapture monitor when a fault occurs.</simpara>
<simpara>To run this example,
point to the <literal>CrashableServer</literal> location (normally the Peach directory).</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

  &lt;DataModel name="TheDataModel"&gt;
    &lt;String value="Hello World!" /&gt;
  &lt;/DataModel&gt;

  &lt;StateModel name="State" initialState="Initial" &gt;
    &lt;State name="Initial"&gt;
      &lt;Action type="output"&gt;
        &lt;DataModel ref="TheDataModel"/&gt;
      &lt;/Action&gt;
    &lt;/State&gt;
  &lt;/StateModel&gt;

  &lt;Agent name="Local"&gt;
    &lt;Monitor class="NetworkCapture"&gt;
      &lt;Param name="Device" value="Local Area Connection" /&gt;
      &lt;Param name="Filter" value="port 4244" /&gt;
    &lt;/Monitor&gt;

    &lt;Monitor class="WindowsDebugger"&gt;
      &lt;Param name="Executable" value="CrashableServer.exe" /&gt;
      &lt;Param name="Arguments" value="127.0.0.1 4244" /&gt;
    &lt;/Monitor&gt;
  &lt;/Agent&gt;

  &lt;Test name="Default"&gt;
    &lt;StateModel ref="State"/&gt;
    &lt;Agent ref="Local" /&gt;

    &lt;Publisher class="TcpClient"&gt;
      &lt;Param name="Host" value="127.0.0.1"/&gt;
      &lt;Param name="Port" value="4244"/&gt;
    &lt;/Publisher&gt;
  &lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Output from this example.</simpara>
<screen>&gt;peach -1 --debug example.xml

[*] Test 'Default' starting with random seed 10470.
Peach.Core.Agent.Agent StartMonitor: Monitor NetworkCapture
Peach.Core.Agent.Agent StartMonitor: Monitor_1 WindowsDebugger
Peach.Core.Agent.Agent SessionStarting: Monitor
Peach.Core.Agent.Agent SessionStarting: Monitor_1
Peach.Core.Agent.Monitors.WindowsDebuggerHybrid SessionStarting
Establishing the listener...

[R1,-,-] Performing iteration
Waiting for a connection...
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.TcpClientPublisher start()
Peach.Core.Publishers.TcpClientPublisher open()
Accepted connection from 127.0.0.1:51784.
Peach.Core.Publishers.TcpClientPublisher output(12 bytes)
Peach.Core.Publishers.TcpClientPublisher

00000000   48 65 6C 6C 6F 20 57 6F  72 6C 64 21               Hello World!

Received 12 bytes from client.
Peach.Core.Publishers.TcpClientPublisher close()
Peach.Core.Publishers.TcpClientPublisher Shutting down connection to 127.0.0.1:4244
Connection closed by peer.
Shutting connection down...
Connection is down.
Waiting for a connection...
Peach.Core.Publishers.TcpClientPublisher Read 0 bytes from 127.0.0.1:4244, closing client connection.
Peach.Core.Publishers.TcpClientPublisher Closing connection to 127.0.0.1:4244
Peach.Core.Agent.Monitors.WindowsDebuggerHybrid DetectedFault()
Peach.Core.Agent.Monitors.WindowsDebuggerHybrid DetectedFault() - No fault detected
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.TcpClientPublisher stop()
Peach.Core.Agent.Agent SessionFinished: Monitor_1
Peach.Core.Agent.Monitors.WindowsDebuggerHybrid SessionFinished
Peach.Core.Agent.Monitors.WindowsDebuggerHybrid _StopDebugger
Peach.Core.Agent.Monitors.WindowsDebuggerHybrid _FinishDebugger
Peach.Core.Agent.Monitors.WindowsDebuggerHybrid _StopDebugger
Peach.Core.Agent.Agent SessionFinished: Monitor
Peach.Core.Agent.Monitors.WindowsDebuggerHybrid _StopDebugger
Peach.Core.Agent.Monitors.WindowsDebuggerHybrid _FinishDebugger
Peach.Core.Agent.Monitors.WindowsDebuggerHybrid _StopDebugger

[*] Test 'Default' finished.</screen>
<simpara>Running this example for a few iterations will produce a crash.
When Peach is logging the fault,
a <literal>.pcap</literal> file is created inside the fault record.</simpara>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Monitors_PageHeap">
<title>PageHeap Monitor (Windows)</title>
<simpara><emphasis role="strong">Monitor Category</emphasis>: <emphasis role="strong">Automation</emphasis></simpara>
<simpara>The <emphasis>PageHeap</emphasis> monitor enables heap allocation monitoring for an executable through the Windows debugger. Peach sets and clears the parameters used for monitoring heap allocation at the beginning and end of the fuzzing session.</simpara>
<note>
<simpara>The <emphasis>PageHeap</emphasis> monitor requires heightened or administrative permissions to run.</simpara>
</note>
<section xml:id="_parameters_93">
<title>Parameters</title>
<simpara><emphasis>Required:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>Executable</term>
<listitem>
<simpara>Executable name (no path)</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>WinDbgPath</term>
<listitem>
<simpara>Path to the Windows Debugger installation.
If not provided, Peach attempts to locate the directory.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_143">
<title>Examples</title>
<example>
<title>Enable for Notepad</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

  &lt;DataModel name="TheDataModel"&gt;
    &lt;String length="32" value="31337" /&gt;
  &lt;/DataModel&gt;

  &lt;StateModel name="State" initialState="Initial" &gt;
    &lt;State name="Initial"&gt;
      &lt;Action type="output"&gt;
        &lt;DataModel ref="TheDataModel"/&gt;
      &lt;/Action&gt;
      &lt;Action type="close"/&gt;
      &lt;Action type="call" method="launchProgram" publisher="Peach.Agent"/&gt;
    &lt;/State&gt;
  &lt;/StateModel&gt;

  &lt;Agent name="Local"&gt;
    &lt;Monitor class="WindowsDebugger"&gt;
        &lt;Param name="Executable" value="notepad.exe"/&gt;
        &lt;Param name="Arguments" value="fuzzed.txt"/&gt;
        &lt;Param name="StartOnCall" value="launchProgram"/&gt;
    &lt;/Monitor&gt;

    &lt;Monitor class="PageHeap"&gt;
      &lt;Param name="Executable" value="notepad.exe" /&gt;
    &lt;/Monitor&gt;
  &lt;/Agent&gt;

  &lt;Test name="Default"&gt;
    &lt;StateModel ref="State"/&gt;
    &lt;Agent ref="Local" /&gt;
    &lt;Publisher class="File"&gt;
      &lt;Param name="FileName" value="fuzzed.txt"/&gt;
    &lt;/Publisher&gt;
  &lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Output from this example.</simpara>
<screen>&gt;peach -1 --debug example.xml

[*] Test 'Default' starting with random seed 5090.
Peach.Core.Agent.Agent StartMonitor: Monitor WindowsDebugger
Peach.Core.Agent.Agent StartMonitor: Monitor_1 PageHeap
Peach.Core.Agent.Agent SessionStarting: Monitor
Peach.Core.Agent.Monitors.WindowsDebuggerHybrid SessionStarting
Peach.Core.Agent.Agent SessionStarting: Monitor_1

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.FilePublisher start()
Peach.Core.Publishers.FilePublisher open()
Peach.Core.Publishers.FilePublisher output(32 bytes)
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Close
Peach.Core.Publishers.FilePublisher close()
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Call
Peach.Core.Agent.AgentManager Message: Action.Call =&gt; launchProgram
Peach.Core.Agent.Monitors.WindowsDebuggerHybrid _StopDebugger
Peach.Core.Agent.Monitors.WindowsDebuggerHybrid Cpu is idle, stopping process.
Peach.Core.Agent.Monitors.WindowsDebuggerHybrid _StopDebugger
Peach.Core.Agent.Monitors.WindowsDebuggerHybrid DetectedFault()
Peach.Core.Agent.Monitors.WindowsDebuggerHybrid DetectedFault() - No fault detected
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.FilePublisher stop()
Peach.Core.Agent.Agent SessionFinished: Monitor_1
Peach.Core.Agent.Agent SessionFinished: Monitor
Peach.Core.Agent.Monitors.WindowsDebuggerHybrid SessionFinished
Peach.Core.Agent.Monitors.WindowsDebuggerHybrid _StopDebugger
Peach.Core.Agent.Monitors.WindowsDebuggerHybrid _FinishDebugger
Peach.Core.Agent.Monitors.WindowsDebuggerHybrid _StopDebugger
Peach.Core.Agent.Monitors.WindowsDebuggerHybrid _StopDebugger
Peach.Core.Agent.Monitors.WindowsDebuggerHybrid _FinishDebugger
Peach.Core.Agent.Monitors.WindowsDebuggerHybrid _StopDebugger

[*] Test 'Default' finished.</screen>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Monitors_Ping">
<title>Ping Monitor</title>
<simpara><emphasis role="strong">Monitor Category</emphasis>: <emphasis role="strong">Fault detection</emphasis></simpara>
<simpara>The <emphasis>Ping</emphasis> monitor verifies whether a device is functioning by sending a packet to a target location,
and waiting for a response from the device.
<emphasis>Ping</emphasis> continues to monitor until either a <emphasis>Timeout</emphasis> occurs or a response from the target device reaches the <emphasis>Ping</emphasis> monitor.
Ping runs at the end of each iteration.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/Monitors/Ping.png"/>
</imageobject>
<textobject><phrase>Ping</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>In the first scenario (left),
Ping successfully interacts with the test target.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>At the end of each iteration, the Ping monitor sends a message to the test target.</simpara>
</listitem>
<listitem>
<simpara>In this case, the target receives the message and sends a response.</simpara>
</listitem>
<listitem>
<simpara>The monitor waits a specified time period for a response.
In this case,
the response within the time period,
and gives the "OK" response.
The Ping Monitor resets for the sequence to repeat at the end of the next iteration.</simpara>
</listitem>
</orderedlist>
<simpara>In the second scenario (right),
the test target is non-responsive.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>At the end of the iteration, the Ping monitor sends a message to the test target.</simpara>
</listitem>
<listitem>
<simpara>(2B) In this case, the target is non-responsive or no longer exists. No response is sent.</simpara>
</listitem>
<listitem>
<simpara>(3B) The monitor waits a specified time period for a response.
In this case, a timeout occurs.
The Ping monitor issues a fault and collects data around the fault.
Ping resets for the next iteration.</simpara>
</listitem>
</orderedlist>
<simpara><emphasis>Ping</emphasis> can validate that a target is still up or is waiting to restart.
This is useful when fuzzing embedded devices that crash surreptitiously.</simpara>
<simpara>Additionally,
by using the <emphasis>FaultOnSuccess</emphasis> parameter,
<emphasis>Ping</emphasis> can help you to verify whether or not a new device at a specific address becomes available,
or that a non-functioning device starts to function.
For example,
if you are fuzzing a device that programmatically turns other computers on,
you can use <emphasis>Ping</emphasis> with <emphasis>FaultOnSuccess</emphasis> set to <literal>true</literal> to determine whether the computers are off (an uninteresting result) or on (an interesting result).</simpara>
<note>
<simpara>When running under Unix, the following restrictions apply:</simpara>
<itemizedlist>
<listitem>
<simpara>Root privileges are required</simpara>
</listitem>
<listitem>
<simpara><emphasis>Data</emphasis> parameter is limited to 72 bytes</simpara>
</listitem>
</itemizedlist>
</note>
<section xml:id="_parameters_94">
<title>Parameters</title>
<simpara><emphasis>Required:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>Host</term>
<listitem>
<simpara>Host name or IP address to ping.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>Data</term>
<listitem>
<simpara>Data to send in the ping packet payload.
If this value is left blank,
the OS will use default data to send.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>FaultOnSuccess</term>
<listitem>
<simpara>Fault if ping is successful, defaults to <literal>false</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Timeout</term>
<listitem>
<simpara>Timeout value expressed in milliseconds, defaults to <literal>1000</literal>.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_144">
<title>Examples</title>
<example>
<title>Ping Host</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

  &lt;DataModel name="TheDataModel"&gt;
    &lt;Number size="32" signed="false" value="31337" /&gt;
  &lt;/DataModel&gt;

  &lt;StateModel name="State" initialState="Initial" &gt;
    &lt;State name="Initial"&gt;
      &lt;Action type="output"&gt;
        &lt;DataModel ref="TheDataModel"/&gt;
      &lt;/Action&gt;
    &lt;/State&gt;
  &lt;/StateModel&gt;

  &lt;Agent name="Local"&gt;
    &lt;Monitor class="Ping"&gt;
      &lt;Param name="Host" value="www.peachfuzzer.com" /&gt;
      &lt;Param name="Timeout" value="10000"/&gt;
    &lt;/Monitor&gt;
  &lt;/Agent&gt;

  &lt;Test name="Default"&gt;
    &lt;StateModel ref="State"/&gt;

    &lt;Agent ref="Local" /&gt;

    &lt;Publisher class="TcpClient"&gt;
      &lt;Param name="Host" value="www.peachfuzzer.com"/&gt;
      &lt;Param name="Port" value="80"/&gt;
    &lt;/Publisher&gt;
  &lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Output from this example.</simpara>
<screen>&gt;peach -1 --debug example.xml

[*] Test 'Default' starting with random seed 26777.
Peach.Core.Agent.Agent StartMonitor: Monitor Ping
Peach.Core.Agent.Agent SessionStarting: Monitor

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.TcpClientPublisher start()
Peach.Core.Publishers.TcpClientPublisher open()
Peach.Core.Publishers.TcpClientPublisher output(4 bytes)
Peach.Core.Publishers.TcpClientPublisher

00000000   69 7A 00 00                                        iz

Peach.Core.Publishers.TcpClientPublisher close()
Peach.Core.Publishers.TcpClientPublisher Shutting down connection to 198.185.159.135:80
Peach.Core.Publishers.TcpClientPublisher Read 0 bytes from 198.185.159.135:80, closing client connection.
Peach.Core.Publishers.TcpClientPublisher Closing connection to 198.185.159.135:80
Peach.Core.Agent.Monitors.PingMonitor DetectedFault(): www.peachfuzzer.com replied after 10000ms
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.TcpClientPublisher stop()
Peach.Core.Agent.Agent SessionFinished: Monitor

[*] Test 'Default' finished.</screen>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Monitors_PopupWatcher">
<title>PopupWatcher Monitor (Windows)</title>
<simpara><emphasis role="strong">Monitor Categories</emphasis>: <emphasis role="strong">Automation</emphasis>, <emphasis role="strong">Fault detection</emphasis></simpara>
<simpara>The <emphasis>PopupWatcher</emphasis> monitor closes pop-up windows based on a window title.
<emphasis>PopupWatcher</emphasis> monitors the test target for a list of windows.
When a window opens whose name is in the list,
<emphasis>PopupWatcher</emphasis> closes the pop-up window,
and if specified in the configuration,
initiates a fault.</simpara>
<simpara>This monitor starts at the beginning of the session and runs to the session end.</simpara>
<note>
<simpara>Some applications re-use a pop-up window for many purposes.
The window has one title,
but the main area of the window can display several different messages depending on the context of the application.
If you&#8217;re interested in monitoring a pop-up window based on content rather than the window title,
consider using the <link linkend="Monitors_ButtonClicker">ButtonClicker Monitor</link>.</simpara>
</note>
<section xml:id="_parameters_95">
<title>Parameters</title>
<simpara><emphasis>Required:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>WindowNames</term>
<listitem>
<simpara>One or more Window names separated by commas.</simpara>
</listitem>
</varlistentry>
</variablelist>
<tip>
<simpara>The comma-delimited list should not contain any white-space characters.</simpara>
</tip>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>Fault</term>
<listitem>
<simpara>Trigger a fault when a pop-up window is found, default <literal>false</literal>.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_145">
<title>Examples</title>
<example>
<title>Close Notepad</title>
<simpara>For this example, you must first launch <literal>notepad.exe</literal>, then start Peach.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

  &lt;DataModel name="TheDataModel"&gt;
    &lt;Number size="32" signed="false" value="31337" /&gt;
  &lt;/DataModel&gt;

  &lt;StateModel name="State" initialState="Initial" &gt;
    &lt;State name="Initial"&gt;
      &lt;Action type="output"&gt;
        &lt;DataModel ref="TheDataModel"/&gt;
      &lt;/Action&gt;
    &lt;/State&gt;
  &lt;/StateModel&gt;

  &lt;Agent name="Local"&gt;
    &lt;Monitor class="PopupWatcher"&gt;
      &lt;Param name="WindowNames" value="Notepad" /&gt;
    &lt;/Monitor&gt;
  &lt;/Agent&gt;

  &lt;Test name="Default"&gt;
    &lt;StateModel ref="State"/&gt;S
    &lt;Agent ref="Local" /&gt;
    &lt;Publisher class="ConsoleHex"/&gt;
  &lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Output for this example.</simpara>
<screen>&gt;peach -1 --debug example.xml

[*] Test 'Default' starting with random seed 18897.
Peach.Core.Agent.Agent StartMonitor: Monitor PopupWatcher
Peach.Core.Agent.Agent SessionStarting: Monitor

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher start()
Peach.Core.Publishers.ConsolePublisher open()
Peach.Core.Publishers.ConsolePublisher output(4 bytes)
00000000   69 7A 00 00                                        iz??
Peach.Core.Publishers.ConsolePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.ConsolePublisher stop()
Peach.Core.Agent.Agent SessionFinished: Monitor

[*] Test 'Default' finished.</screen>
</example>
<example>
<title>Fault on Assert</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

  &lt;DataModel name="TheDataModel"&gt;
    &lt;Number size="32" signed="false" value="31337" /&gt;
  &lt;/DataModel&gt;

  &lt;StateModel name="State" initialState="Initial" &gt;
    &lt;State name="Initial"&gt;
      &lt;Action type="output"&gt;
        &lt;DataModel ref="TheDataModel"/&gt;
      &lt;/Action&gt;
    &lt;/State&gt;
  &lt;/StateModel&gt;

  &lt;Agent name="Local"&gt;
  &lt;Monitor class="PopupWatcher"&gt;
    &lt;Param name="WindowNames" value="Assert" /&gt;
    &lt;Param name="Fault" value="True" /&gt;
  &lt;/Monitor&gt;
 &lt;/Agent&gt;

  &lt;Test name="Default"&gt;
    &lt;StateModel ref="State"/&gt;
    &lt;Agent ref="Local" /&gt;
    &lt;Publisher class="ConsoleHex"/&gt;
  &lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Output for this example.</simpara>
<screen>&gt;peach -1 --debug example.xml

[*] Test 'Default' starting with random seed 55395.
Peach.Core.Agent.Agent StartMonitor: Monitor PopupWatcher
Peach.Core.Agent.Agent SessionStarting: Monitor

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher start()
Peach.Core.Publishers.ConsolePublisher open()
Peach.Core.Publishers.ConsolePublisher output(4 bytes)
00000000   69 7A 00 00                                        iz??
Peach.Core.Publishers.ConsolePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.ConsolePublisher stop()
Peach.Core.Agent.Agent SessionFinished: Monitor

[*] Test 'Default' finished.</screen>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Monitors_Process">
<title>Process Monitor</title>
<simpara><emphasis role="strong">Monitor Categories</emphasis>: <emphasis role="strong">Automation</emphasis>, <emphasis role="strong">Fault detection</emphasis></simpara>
<simpara>The <emphasis>Process</emphasis> monitor controls a process during a fuzzing run.
This monitor provides automation by controlling when the process starts,
restarts and ends,
and whether the process should be killed.
This monitor also provides fault detection for early exit and failure to exit.
Finally,
the <emphasis>Process</emphasis> monitor provides data collection by copying messages from standard out and standard error.</simpara>
<simpara>The <emphasis>Process</emphasis> monitor provides the following functionality:</simpara>
<itemizedlist>
<listitem>
<simpara>Start a process at the session start.</simpara>
</listitem>
<listitem>
<simpara>Start or restart a process on every iteration.</simpara>
</listitem>
<listitem>
<simpara>Start a process in response to a call from the state model.</simpara>
</listitem>
<listitem>
<simpara>Wait for a process to exit in response to a call from the state model.</simpara>
</listitem>
<listitem>
<simpara>Restart a process when it exits.</simpara>
</listitem>
<listitem>
<simpara>Terminates a process if the CPU usage is low.</simpara>
</listitem>
<listitem>
<simpara>Logs a fault if a process exits early.</simpara>
</listitem>
<listitem>
<simpara>Logs a fault if a process fails to exit.</simpara>
</listitem>
</itemizedlist>
<simpara>The <emphasis>Process</emphasis> monitor initiates a fault when a process being monitored experiences the following conditions:</simpara>
<itemizedlist>
<listitem>
<simpara>Early exit</simpara>
</listitem>
<listitem>
<simpara>Timeout while waiting for exit</simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://github.com/google/sanitizers/wiki/AddressSanitizer">Address Sanitizer</link> detection</simpara>
</listitem>
</itemizedlist>
<section xml:id="_parameters_96">
<title>Parameters</title>
<simpara><emphasis>Required:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>Executable</term>
<listitem>
<simpara>Executable to launch</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>Arguments</term>
<listitem>
<simpara>Command line arguments</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>FaultOnEarlyExit</term>
<listitem>
<simpara>Trigger fault if process exits, defaults to <literal>false</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>NoCpuKill</term>
<listitem>
<simpara>Disable process killing when the CPU usage nears zero, defaults to <literal>false</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>RestartOnEachTest</term>
<listitem>
<simpara>Restart process on every iteration.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>RestartAfterFault</term>
<listitem>
<simpara>If <literal>true</literal>, restarts the target when any monitor detects a fault.
If <literal>false</literal>, restarts the target only if the process exits or crashes.
This argument defaults to <literal>true</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>StartOnCall</term>
<listitem>
<simpara>Start process when the specified call is received from the state model.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>WaitForExitOnCall</term>
<listitem>
<simpara>Wait for process to exit when the specified call is received from the state model.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>WaitForExitTimeout</term>
<listitem>
<simpara>Wait timeout value, expressed in milliseconds.
Triggers a fault when the timeout period expires.
Defaults to <literal>10000</literal>.
Use <literal>-1</literal> for infinite, no timeout.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_146">
<title>Examples</title>
<example>
<title>Start Process</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

  &lt;DataModel name="TheDataModel"&gt;
    &lt;String length="32" value="31337"/&gt;
  &lt;/DataModel&gt;

  &lt;StateModel name="State" initialState="Initial" &gt;
    &lt;State name="Initial"&gt;
      &lt;Action type="output"&gt;
        &lt;DataModel ref="TheDataModel"/&gt;
      &lt;/Action&gt;

      &lt;Action type="close"/&gt;
    &lt;/State&gt;
  &lt;/StateModel&gt;

  &lt;Agent name="Local"&gt;
  &lt;Monitor class="Process"&gt;
    &lt;Param name="Executable" value="notepad.exe" /&gt;
    &lt;Param name="Arguments" value="fuzzed.txt" /&gt;
  &lt;/Monitor&gt;
  &lt;/Agent&gt;

  &lt;Test name="Default"&gt;
    &lt;StateModel ref="State"/&gt;
    &lt;Agent ref="Local" /&gt;

    &lt;Publisher class="File"&gt;
      &lt;Param name="FileName" value="fuzzed.txt"/&gt;
    &lt;/Publisher&gt;
  &lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Output for this example.</simpara>
<screen>&gt;peach -1 --debug example.xml

[*] Test 'Default' starting with random seed 20172.
Peach.Core.Agent.Agent StartMonitor: Monitor Process
Peach.Core.Agent.Agent SessionStarting: Monitor
Peach.Core.Agent.Monitors.Process _Start(): Starting process

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.FilePublisher start()
Peach.Core.Publishers.FilePublisher open()
Peach.Core.Publishers.FilePublisher output(32 bytes)
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Close
Peach.Core.Publishers.FilePublisher close()
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Call
Peach.Core.Agent.AgentManager Message: Action.Call =&gt; launchProgram
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.FilePublisher stop()
Peach.Core.Agent.Agent SessionFinished: Monitor
Peach.Core.Agent.Monitors.Process _Stop(): Killing process

[*] Test 'Default' finished.</screen>
<simpara>When running this example, notepad opens when the session starts and closes when the session finishes.</simpara>
</example>
<example>
<title>Restart Process on Each Test</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

  &lt;DataModel name="TheDataModel"&gt;
    &lt;String length="32" value="31337" /&gt;
  &lt;/DataModel&gt;

  &lt;StateModel name="State" initialState="Initial" &gt;
    &lt;State name="Initial"&gt;
      &lt;Action type="output"&gt;
        &lt;DataModel ref="TheDataModel"/&gt;
      &lt;/Action&gt;
      &lt;Action type="close"/&gt;
    &lt;/State&gt;
  &lt;/StateModel&gt;

  &lt;Agent name="Local"&gt;
	&lt;Monitor class="Process"&gt;
		&lt;Param name="Executable" value="notepad.exe" /&gt;
		&lt;Param name="Arguments" value="fuzzed.txt" /&gt;
		&lt;Param name="RestartOnEachTest" value="true" /&gt;
	&lt;/Monitor&gt;
  &lt;/Agent&gt;

  &lt;Test name="Default"&gt;
    &lt;StateModel ref="State"/&gt;
    &lt;Agent ref="Local" /&gt;

    &lt;Publisher class="File"&gt;
      &lt;Param name="FileName" value="fuzzed.txt"/&gt;
    &lt;/Publisher&gt;
  &lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Output for this example.</simpara>
<screen>&gt;peach -1 --debug example.xml

[*] Test 'Default' starting with random seed 40308.
Peach.Core.Agent.Agent StartMonitor: Monitor Process
Peach.Core.Agent.Agent SessionStarting: Monitor

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Agent.Monitors.Process _Start(): Starting process
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.FilePublisher start()
Peach.Core.Publishers.FilePublisher open()
Peach.Core.Publishers.FilePublisher output(32 bytes)
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Close
Peach.Core.Publishers.FilePublisher close()
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Call
Peach.Core.Agent.AgentManager Message: Action.Call =&gt; launchProgram
Peach.Core.Agent.Monitors.Process _Stop(): Killing process
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.FilePublisher stop()
Peach.Core.Agent.Agent SessionFinished: Monitor

[*] Test 'Default' finished.</screen>
<simpara>When running this example, notepad repeatedly opens and closes.</simpara>
</example>
<example>
<title>Start Process From State Model</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

  &lt;DataModel name="TheDataModel"&gt;
    &lt;String length="32" value="31337" /&gt;
  &lt;/DataModel&gt;

&lt;StateModel name="State" initialState="Initial" &gt;
  &lt;State name="Initial"&gt;
    &lt;Action type="call" method="ScoobySnacks" publisher="Peach.Agent" /&gt;
  &lt;/State&gt;
&lt;/StateModel&gt;

&lt;Agent name="Local"&gt;
  &lt;Monitor class="Process"&gt;
    &lt;Param name="Executable" value="notepad.exe" /&gt;
    &lt;Param name="Arguments" value="fuzzed.txt" /&gt;
    &lt;Param name="StartOnCall" value="ScoobySnacks" /&gt;
  &lt;/Monitor&gt;
&lt;/Agent&gt;

  &lt;Test name="Default"&gt;
    &lt;StateModel ref="State"/&gt;
    &lt;Agent ref="Local" /&gt;

    &lt;Publisher class="File"&gt;
      &lt;Param name="FileName" value="fuzzed.txt"/&gt;
    &lt;/Publisher&gt;
  &lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Output for this example.</simpara>
<screen>&gt;peach -1 --debug example.xml

[*] Test 'Default' starting with random seed 63117.
Peach.Core.Agent.Agent StartMonitor: Monitor Process
Peach.Core.Agent.Agent SessionStarting: Monitor

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Call
Peach.Core.Publishers.FilePublisher start()
Peach.Core.Agent.AgentManager Message: Action.Call =&gt; ScoobySnacks
Peach.Core.Agent.Monitors.Process _Start(): Starting process
Peach.Core.Agent.Monitors.Process Cpu is idle, stopping process.
Peach.Core.Agent.Monitors.Process _Stop(): Killing process
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.FilePublisher stop()
Peach.Core.Agent.Agent SessionFinished: Monitor

[*] Test 'Default' finished.</screen>
<simpara>When running this example, notepad repeatedly opens and closes.</simpara>
</example>
<example>
<title>Wait for process to exit in state model</title>
<simpara>For this example to complete, you must close notepad when it opens.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

  &lt;DataModel name="TheDataModel"&gt;
    &lt;String length="32" value="31337" /&gt;
  &lt;/DataModel&gt;

  &lt;StateModel name="State" initialState="Initial"&gt;
    &lt;State name="Initial"&gt;
      &lt;!-- This action will block until process exits --&gt;
      &lt;Action type="call" method="ScoobySnacks" publisher="Peach.Agent" /&gt;
    &lt;/State&gt;
  &lt;/StateModel&gt;

  &lt;Agent name="Local"&gt;
    &lt;Monitor class="Process"&gt;
      &lt;Param name="Executable" value="notepad.exe" /&gt;
      &lt;Param name="Arguments" value="fuzzed.txt" /&gt;
      &lt;Param name="WaitForExitOnCall" value="ScoobySnacks" /&gt;
    &lt;/Monitor&gt;
  &lt;/Agent&gt;

  &lt;Test name="Default"&gt;
    &lt;StateModel ref="State"/&gt;
    &lt;Agent ref="Local" /&gt;

    &lt;Publisher class="File"&gt;
      &lt;Param name="FileName" value="fuzzed.txt"/&gt;
    &lt;/Publisher&gt;
  &lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Output from this example</simpara>
<screen>&gt;peach -1 --debug example.xml

[*] Test 'Default' starting with random seed 6946.
Peach.Core.Agent.Agent StartMonitor: Monitor Process
Peach.Core.Agent.Agent SessionStarting: Monitor
Peach.Core.Agent.Monitors.Process _Start(): Starting process

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Call
Peach.Core.Publishers.FilePublisher start()
Peach.Core.Agent.AgentManager Message: Action.Call =&gt; ScoobySnacks
Peach.Core.Agent.Monitors.Process WaitForExit(10000)
Peach.Core.Agent.Monitors.Process _Stop(): Closing process handle
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.FilePublisher stop()
Peach.Core.Agent.Agent SessionFinished: Monitor

[*] Test 'Default' finished.</screen>
<simpara>Since notepad doesn&#8217;t close automatically, remember to close notepad after each iteration.</simpara>
<simpara>Use <literal>WaitForExitOnCall</literal> when you want to halt fuzzing until the process closes.</simpara>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Monitors_ProcessKiller">
<title>ProcessKiller Monitor</title>
<simpara><emphasis role="strong">Monitor Category</emphasis>: <emphasis role="strong">Automation</emphasis></simpara>
<simpara>The <emphasis>ProcessKiller</emphasis> monitor kills (terminates) specified processes after each iteration.</simpara>
<section xml:id="_parameters_97">
<title>Parameters</title>
<simpara><emphasis>Required:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>ProcessNames</term>
<listitem>
<simpara>Comma separated list of the processes to kill.</simpara>
</listitem>
</varlistentry>
</variablelist>
<note>
<simpara>The process name is usually the executable filename without the extension (<literal>.exe</literal>).
For example, <literal>notepad.exe</literal> will be <literal>Notepad</literal> or <literal>notepad</literal>.
For Windows operating systems,
the process name can be found by using the <literal>tasklist.exe</literal> command.</simpara>
<simpara>The comma-delimited list should not contain any white-space characters.</simpara>
</note>
<simpara><emphasis>Optional:</emphasis></simpara>
<simpara>None.</simpara>
</section>
<section xml:id="_examples_147">
<title>Examples</title>
<example>
<title>Terminate two processes</title>
<simpara>Before running this example, open <literal>notepad.exe</literal>.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

  &lt;DataModel name="TheDataModel"&gt;
    &lt;Number size="32" signed="false" value="31337" /&gt;
  &lt;/DataModel&gt;

  &lt;StateModel name="State" initialState="Initial" &gt;
    &lt;State name="Initial"&gt;
      &lt;Action type="output"&gt;
        &lt;DataModel ref="TheDataModel"/&gt;
      &lt;/Action&gt;
    &lt;/State&gt;
  &lt;/StateModel&gt;

  &lt;Agent name="Local"&gt;
    &lt;Monitor class="ProcessKiller"&gt;
      &lt;Param name="ProcessNames" value="Notepad" /&gt;
    &lt;/Monitor&gt;
  &lt;/Agent&gt;

  &lt;Test name="Default"&gt;
    &lt;StateModel ref="State"/&gt;
    &lt;Agent ref="Local" /&gt;
    &lt;Publisher class="ConsoleHex"/&gt;
  &lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Output for this example.</simpara>
<screen>&gt;peach -1 --debug example.xml

[*] Test 'Default' starting with random seed 41446.
Peach.Core.Agent.Agent StartMonitor: Monitor ProcessKiller
Peach.Core.Agent.Agent SessionStarting: Monitor

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher start()
Peach.Core.Publishers.ConsolePublisher open()
Peach.Core.Publishers.ConsolePublisher output(4 bytes)
00000000   69 7A 00 00                                        iz??
Peach.Core.Publishers.ConsolePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.ConsolePublisher stop()
Peach.Core.Agent.Agent SessionFinished: Monitor

[*] Test 'Default' finished.</screen>
<simpara>In this example, peach kills the <literal>notepad</literal> process whenever it runs.</simpara>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Monitors_RunCommand">
<title>Run Command</title>
<simpara><emphasis role="strong">Monitor Categories</emphasis>: <emphasis role="strong">Automation</emphasis>, <emphasis role="strong">Data collection</emphasis>, <emphasis role="strong">Fault detection</emphasis></simpara>
<simpara>The <emphasis>RunCommand</emphasis> monitor can be used to launch a command at various points in time during a fuzzing session:</simpara>
<itemizedlist>
<listitem>
<simpara>At the start or end of a fuzzing run</simpara>
</listitem>
<listitem>
<simpara>At the start or end of each test iteration</simpara>
</listitem>
<listitem>
<simpara>After detecting a fault</simpara>
</listitem>
<listitem>
<simpara>At the start of an iteration that immediately follows a fault</simpara>
</listitem>
<listitem>
<simpara>When a specified call is received from the state model</simpara>
</listitem>
</itemizedlist>
<simpara>If a fault occurs,
the monitor captures and logs the console output from <literal>stdout</literal> and <literal>stderr</literal>.
Additionally,
this monitor can initiate a fault under the following conditions (in-order of evaluation):</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>An <link xl:href="https://github.com/google/sanitizers/wiki/AddressSanitizer">Address Sanitizer</link> message appears in <literal>stderr</literal>.</simpara>
</listitem>
<listitem>
<simpara>The specified regular expression matches messages in <literal>stdout</literal> or <literal>stderr</literal>.</simpara>
</listitem>
<listitem>
<simpara>The command takes longer to finish than the specified timeout duration.</simpara>
</listitem>
<listitem>
<simpara>The command exits with a specified exit code.</simpara>
</listitem>
<listitem>
<simpara>The command exits with a nonzero exit code.</simpara>
</listitem>
</orderedlist>
<section xml:id="_parameters_98">
<title>Parameters</title>
<simpara><emphasis>Required:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>Command</term>
<listitem>
<simpara>The command or application to launch.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>Arguments</term>
<listitem>
<simpara>Command line arguments</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>FaultOnNonZeroExit</term>
<listitem>
<simpara>When this value is set to <literal>true</literal>,
generate a fault if the exit code is non-zero.
The default value is <literal>false</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>FaultOnExitCode</term>
<listitem>
<simpara>When this value is set to <literal>true</literal>,
generate a fault if the exit code matches the specified <emphasis>FaultExitCode</emphasis> parameter.
The default value is <literal>false</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>FaultExitCode</term>
<listitem>
<simpara>When <emphasis>FaultOnExitCode</emphasis> is set to <literal>true</literal>, generate a fault if the specified exit code occurs.
The default value is <literal>1</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>StartOnCall</term>
<listitem>
<simpara>Launch the command when the monitor receives the specified call from the state machine.
This value is used only when the <emphasis>When</emphasis> parameter is set to <literal>OnCall</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>FaultOnRegex</term>
<listitem>
<simpara>If this value is specified,
generate a fault if the specified regular expression matches the command output.
The default value is unspecified.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Timeout</term>
<listitem>
<simpara>Maximum time period, in milliseconds, for the process to run.
Generate a fault if the command runs longer than the specified value.
This feature is disabled by specifying <literal>-1</literal> for the time period.
The default value is <literal>-1</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>WorkingDirectory</term>
<listitem>
<simpara>Set the current working directory for the command launched by this monitor.
The default value is the Peach current working directory.
The current working directory for the command is valid until the command changes the directory or ends.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>When</term>
<listitem>
<simpara>Specify one of the following values to determine when to launch the command:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="66.6667*"/>
<thead>
<row>
<entry align="left" valign="top">"When" Setting</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>OnStart</simpara></entry>
<entry align="left" valign="top"><simpara>Run command when the fuzzing session starts.
This occurs once per session.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>OnEnd</simpara></entry>
<entry align="left" valign="top"><simpara>Run command when the fuzzing session stops.
This occurs once per session.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>OnIterationStart</simpara></entry>
<entry align="left" valign="top"><simpara>Run command at the start of each iteration.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>OnIterationEnd</simpara></entry>
<entry align="left" valign="top"><simpara>Run command at the end of each iteration.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>OnFault</simpara></entry>
<entry align="left" valign="top"><simpara>Run command when any monitor detects a fault.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>OnIterationStartAfterFault</simpara></entry>
<entry align="left" valign="top"><simpara>Run command at the start of an iteration that immediately follows a fault detection.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>OnCall</simpara></entry>
<entry align="left" valign="top"><simpara>Run command when the call specified by the <emphasis>StartOnCall</emphasis> parameter is received from the state model.
This is the default setting.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<figure>
<title>When Choices</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/Monitors/Timings_All.png"/>
</imageobject>
<textobject><phrase>Timings All</phrase></textobject>
</mediaobject>
</figure>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_148">
<title>Examples</title>
<example>
<title>Using <emphasis>RunCommand</emphasis> for Fault Detection</title>
<simpara>This example detects a fault by checking for any lines that begin with <literal>ERROR_</literal>.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

	&lt;DataModel name="TheDataModel"&gt;
		&lt;String value="Hello World!" /&gt;
	&lt;/DataModel&gt;

	&lt;StateModel name="TheStateModel" initialState="InitialState"&gt;
		&lt;State name="InitialState"&gt;
			&lt;Action type="output"&gt;
				&lt;DataModel ref="TheDataModel" /&gt;
			&lt;/Action&gt;
		&lt;/State&gt;
	&lt;/StateModel&gt;

	&lt;Agent name="TheAgent"&gt;
		&lt;Monitor class="RunCommand"&gt;
			&lt;Param name="Command" value="python"/&gt;
			&lt;Param name="Arguments" value="check_for_fault.py" /&gt;
			&lt;Param name="WorkingDirectory" value="C:\MyScripts" /&gt;
			&lt;Param name="FaultOnRegex" value="^ERROR_" /&gt;
			&lt;Param name="When" value="OnIterationEnd" /&gt;
		&lt;/Monitor&gt;
	&lt;/Agent&gt;

	&lt;Test name="Default"&gt;
		&lt;Agent ref="TheAgent"/&gt;
		&lt;StateModel ref="TheStateModel" /&gt;
		&lt;Publisher class="ConsoleHex"/&gt;
	&lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
</example>
<example>
<title>Using <emphasis>RunCommand</emphasis> for Data Collection</title>
<simpara>This example captures <literal>stderr</literal> and <literal>stdout</literal> for data collection when another monitor detects a fault.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

	&lt;DataModel name="TheDataModel"&gt;
		&lt;String value="Hello World!" /&gt;
	&lt;/DataModel&gt;

	&lt;StateModel name="TheStateModel" initialState="InitialState"&gt;
		&lt;State name="InitialState"&gt;
			&lt;Action type="output"&gt;
				&lt;DataModel ref="TheDataModel" /&gt;
			&lt;/Action&gt;
		&lt;/State&gt;
	&lt;/StateModel&gt;

	&lt;Agent name="TheAgent"&gt;
		&lt;Monitor class="RunCommand"&gt;
			&lt;Param name="Command" value="python"/&gt;
			&lt;Param name="Arguments" value="collect_log.py" /&gt;
			&lt;Param name="WorkingDirectory" value="C:\MyScripts" /&gt;
			&lt;Param name="When" value="OnFault" /&gt;
		&lt;/Monitor&gt;
	&lt;/Agent&gt;

	&lt;Test name="Default"&gt;
		&lt;Agent ref="TheAgent"/&gt;
		&lt;StateModel ref="TheStateModel" /&gt;
		&lt;Publisher class="ConsoleHex"/&gt;
	&lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
</example>
<example>
<title>Using <emphasis>RunCommand</emphasis> for Automation</title>
<simpara>This example runs the <literal>clear_state.py</literal> python script on the next iteration start after a fault is detected.
This can be used to get the target back into a working state so that fuzzing can continue.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

	&lt;DataModel name="TheDataModel"&gt;
		&lt;String value="Hello World!" /&gt;
	&lt;/DataModel&gt;

	&lt;StateModel name="TheStateModel" initialState="InitialState"&gt;
		&lt;State name="InitialState"&gt;
			&lt;Action type="output"&gt;
				&lt;DataModel ref="TheDataModel" /&gt;
			&lt;/Action&gt;
		&lt;/State&gt;
	&lt;/StateModel&gt;

	&lt;Agent name="TheAgent"&gt;
		&lt;Monitor class="RunCommand"&gt;
			&lt;Param name="Command" value="python"/&gt;
			&lt;Param name="Arguments" value="clear_state.py" /&gt;
			&lt;Param name="WorkingDirectory" value="C:\MyScripts" /&gt;
			&lt;Param name="When" value="OnIterationStartAfterFault" /&gt;
		&lt;/Monitor&gt;
	&lt;/Agent&gt;

	&lt;Test name="Default"&gt;
		&lt;Agent ref="TheAgent"/&gt;
		&lt;StateModel ref="TheStateModel" /&gt;
		&lt;Publisher class="ConsoleHex"/&gt;
	&lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Monitors_SaveFile">
<title>SaveFile Monitor</title>
<simpara><emphasis role="strong">Monitor Categories</emphasis>: <emphasis role="strong">Data collection</emphasis></simpara>
<simpara>The <emphasis>SaveFile</emphasis> monitor saves a specified file as part of the logged data when a fault occurs.
A copy of the file is placed in the log folder.</simpara>
<section xml:id="_parameters_99">
<title>Parameters</title>
<simpara><emphasis>Required:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>Filename</term>
<listitem>
<simpara>File to save when a fault is detected by another monitor.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Optional:</emphasis></simpara>
<simpara>None.</simpara>
</section>
<section xml:id="_examples_149">
<title>Examples</title>
<formalpara>
<title>Collect logs when a fault occurs</title>
<para>In this example,
the <link linkend="Monitors_Process">Process Monitor</link> is used to launch <literal>nginx</literal> as the target.
When a fault is detected by this monitor,
the <emphasis>SaveFile</emphasis> monitor is configured to collect logs from <literal>nginx</literal>.
These logs will be available as part of the data collected for the fault.</para>
</formalpara>
<informalexample>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

  &lt;DataModel name="TheDataModel"&gt;
    &lt;Number size="32" signed="false" value="31337" /&gt;
  &lt;/DataModel&gt;

  &lt;StateModel name="State" initialState="Initial" &gt;
    &lt;State name="Initial"&gt;
      &lt;Action type="output"&gt;
        &lt;DataModel ref="TheDataModel"/&gt;
      &lt;/Action&gt;
    &lt;/State&gt;
  &lt;/StateModel&gt;

  &lt;Agent name="Local"&gt;
    &lt;Monitor class="Process"&gt;
      &lt;Param name="Executable" value="/usr/sbin/nginx" /&gt;
      &lt;Param name="FaultOnEarlyExit" value="true" /&gt;
    &lt;/Monitor&gt;
    &lt;Monitor name="Save access.log" class="SaveFile"&gt;
      &lt;Param name="Filename" value="/var/log/nginx/access.log" /&gt;
    &lt;/Monitor&gt;
    &lt;Monitor name="Save error.log" class="SaveFile"&gt;
      &lt;Param name="Filename" value="/var/log/nginx/error.log" /&gt;
    &lt;/Monitor&gt;
  &lt;/Agent&gt;

  &lt;Test name="Default"&gt;
    &lt;StateModel ref="State"/&gt;
    &lt;Agent ref="Local" /&gt;
    &lt;Publisher class="ConsoleHex"/&gt;
  &lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
</informalexample>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Monitors_Serial">
<title>Serial Port Monitor</title>
<simpara><emphasis role="strong">Monitor Categories</emphasis>: <emphasis role="strong">Automation</emphasis>, <emphasis role="strong">Data collection</emphasis>, <emphasis role="strong">Fault detection</emphasis></simpara>
<simpara>The <emphasis>Serial Port</emphasis> monitor can be used to perform
data collection,
fault detection,
or automation,
based on specified parameters.</simpara>
<simpara>The default usage of the <emphasis>Serial Port</emphasis> monitor is data collection.
The data received via the serial port is logged when a fault occurs.</simpara>
<simpara>To perform fault detection,
specify a regular expression using the <emphasis>FaultRegex</emphasis> parameter.
When the regular expression matches,
Peach generates a fault.</simpara>
<simpara>For automation tasks, use the <emphasis>WaitForRegex</emphasis> and <emphasis>WaitWhen</emphasis> parameters.
These automation parameters cause Peach to wait for matching input before continuing.
The <emphasis>Serial Port</emphasis> monitor can wait at various points in time during a fuzzing session:</simpara>
<itemizedlist>
<listitem>
<simpara>At the start or end of a fuzzing run</simpara>
</listitem>
<listitem>
<simpara>At the start or end of each test iteration</simpara>
</listitem>
<listitem>
<simpara>After detecting a fault</simpara>
</listitem>
<listitem>
<simpara>At the start of an iteration that immediately follows a fault</simpara>
</listitem>
<listitem>
<simpara>When a specified call is received from the state model</simpara>
</listitem>
</itemizedlist>
<simpara>Additionally,
Peach supports multiple <emphasis>Serial Port</emphasis> monitors in a pit,
allowing for more complex configurations.
This can be used to monitor multiple serial ports.
Multiple monitors may also be configured to use the same port, allowing for fault detection,
automation,
and/or data collection to occur on a single port.</simpara>
<section xml:id="_parameters_100">
<title>Parameters</title>
<simpara><emphasis>Required:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>Port</term>
<listitem>
<simpara>The port to use (for example, <literal>COM1</literal> or <literal>/dev/ttyS0</literal>)</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>BaudRate</term>
<listitem>
<simpara>The baud rate (only standard values are allowed).
Defaults to <literal>115200</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>DataBits</term>
<listitem>
<simpara>The data bits value.
Defaults to <literal>8</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Parity</term>
<listitem>
<simpara>Specifies the parity bit.
Defaults to <literal>None</literal>.
Available options for this parameter are:</simpara>
<informaltable tabstyle="horizontal" frame="none" colsep="0" rowsep="0">
<tgroup cols="2">
<colspec colwidth="15*"/>
<colspec colwidth="85*"/>
<tbody valign="top">
<row>
<entry>
<simpara>Even</simpara>
<simpara>Mark</simpara>
<simpara>None</simpara>
<simpara>Odd</simpara>
<simpara>Space</simpara>
</entry>
<entry>
</entry>
</row>
</tbody>
</tgroup>
</informaltable>
</listitem>
</varlistentry>
<varlistentry>
<term>StopBits</term>
<listitem>
<simpara>Specifies the number of stop bits used.
Defaults to <literal>One</literal>.
Available options for this parameter are:</simpara>
<informaltable tabstyle="horizontal" frame="none" colsep="0" rowsep="0">
<tgroup cols="2">
<colspec colwidth="15*"/>
<colspec colwidth="85*"/>
<tbody valign="top">
<row>
<entry>
<simpara>One</simpara>
<simpara>OnePointFive</simpara>
<simpara>Two</simpara>
</entry>
<entry>
</entry>
</row>
</tbody>
</tgroup>
</informaltable>
</listitem>
</varlistentry>
<varlistentry>
<term>Handshake</term>
<listitem>
<simpara>Specifies the control protocol used in establishing a serial port communication.
Defaults to <literal>None</literal>.
Available options for this parameter are:</simpara>
<informaltable tabstyle="horizontal" frame="none" colsep="0" rowsep="0">
<tgroup cols="2">
<colspec colwidth="15*"/>
<colspec colwidth="85*"/>
<tbody valign="top">
<row>
<entry>
<simpara>None</simpara>
<simpara>RequestToSend</simpara>
<simpara>RequestToSendXOnXOff</simpara>
<simpara>XOnXOff</simpara>
</entry>
<entry>
</entry>
</row>
</tbody>
</tgroup>
</informaltable>
</listitem>
</varlistentry>
<varlistentry>
<term>DtrEnable</term>
<listitem>
<simpara>Enables the Data Terminal Ready (DTR) signal during serial communication.
Defaults to <literal>false</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>RtsEnable</term>
<listitem>
<simpara>Enables the Request To Transmit (RTS) signal during serial communication.
Defaults to <literal>false</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>MaxBufferSize</term>
<listitem>
<simpara>Maximum amount of serial data to store in bytes.
Defaults to <literal>1048576</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>FaultRegex</term>
<listitem>
<simpara>Generate a fault when the specified regular expression matches received data.
This causes the <emphasis>Serial Port</emphasis> monitor to be used for fault detection.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>WaitRegex</term>
<listitem>
<simpara>Wait until the specified regular expression matches received data.
This causes the <emphasis>Serial Port</emphasis> monitor to be used for automation.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>WaitOnCall</term>
<listitem>
<simpara>Begin waiting for the regular expression specified in the <emphasis>WaitRegex</emphasis> parameter after the monitor receives the specified call from the state machine.
This value is used only when the <emphasis>WaitWhen</emphasis> parameter is set to <literal>OnCall</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>WaitWhen</term>
<listitem>
<simpara>Specify one of the following values to determine when to begin waiting for the regular expression specified in the <emphasis>WaitRegex</emphasis> parameter to match received data:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="66.6667*"/>
<thead>
<row>
<entry align="left" valign="top">"WaitWhen" Setting</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>OnStart</simpara></entry>
<entry align="left" valign="top"><simpara>Waits when the fuzzing session starts.
This occurs once per session.
This is the default setting.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>OnEnd</simpara></entry>
<entry align="left" valign="top"><simpara>Waits when the fuzzing session stops.
This occurs once per session.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>OnIterationStart</simpara></entry>
<entry align="left" valign="top"><simpara>Waits at the start of each iteration.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>OnIterationEnd</simpara></entry>
<entry align="left" valign="top"><simpara>Waits at the end of each iteration.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>OnFault</simpara></entry>
<entry align="left" valign="top"><simpara>Waits when any monitor detects a fault.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>OnIterationStartAfterFault</simpara></entry>
<entry align="left" valign="top"><simpara>Waits at the start of the iteration that immediately follows a fault detection.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>OnCall</simpara></entry>
<entry align="left" valign="top"><simpara>Waits upon receipt of the call specified by the <emphasis>WaitOnCall</emphasis> parameter from the state model.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<figure>
<title>WaitWhen Choices</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/Monitors/Timings_All.png"/>
</imageobject>
<textobject><phrase>Timings All</phrase></textobject>
</mediaobject>
</figure>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_150">
<title>Examples</title>
<example>
<title>Data Collection example</title>
<simpara>This example shows the <emphasis>Serial Port</emphasis> monitor configured to log data received from <literal>COM1</literal>.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

  &lt;DataModel name="TheDataModel"&gt;
    &lt;Number size="32" signed="false" value="31337" /&gt;
  &lt;/DataModel&gt;

  &lt;StateModel name="State" initialState="Initial" &gt;
    &lt;State name="Initial"&gt;
      &lt;Action type="output"&gt;
        &lt;DataModel ref="TheDataModel"/&gt;
      &lt;/Action&gt;
    &lt;/State&gt;
  &lt;/StateModel&gt;

  &lt;Agent name="Local"&gt;
    &lt;Monitor class="SerialPort"&gt;
      &lt;Param name="Port" value="COM1" /&gt;
    &lt;/Monitor&gt;
  &lt;/Agent&gt;

  &lt;Test name="Default"&gt;
    &lt;StateModel ref="State"/&gt;
    &lt;Agent ref="Local" /&gt;
    &lt;Publisher class="ConsoleHex"/&gt;
  &lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
</example>
<example>
<title>Collect Serial Data on Fault</title>
<simpara>This example shows the <emphasis>Serial Port</emphasis> monitor configured to log received data and to generate a fault when the text <literal>ERROR</literal> is received.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

  &lt;DataModel name="TheDataModel"&gt;
    &lt;Number size="32" signed="false" value="31337" /&gt;
  &lt;/DataModel&gt;

  &lt;StateModel name="State" initialState="Initial" &gt;
    &lt;State name="Initial"&gt;
      &lt;Action type="output"&gt;
        &lt;DataModel ref="TheDataModel"/&gt;
      &lt;/Action&gt;
    &lt;/State&gt;
  &lt;/StateModel&gt;

  &lt;Agent name="Local"&gt;
    &lt;Monitor class="SerialPort"&gt;
      &lt;Param name="Port" value="COM1" /&gt;
      &lt;Param name="FaultRegex" value="ERROR" /&gt;
    &lt;/Monitor&gt;
  &lt;/Agent&gt;

  &lt;Test name="Default"&gt;
    &lt;StateModel ref="State"/&gt;
    &lt;Agent ref="Local" /&gt;
    &lt;Publisher class="ConsoleHex"/&gt;
  &lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
</example>
<example>
<title>Combined Automation and Fault Detection example</title>
<simpara>This example might be used when fuzzing a network device such as a router.
One <emphasis>Serial Port</emphasis> monitor is configured to wait until the router has booted before starting the fuzzing session.
Another <emphasis>Serial Port</emphasis> monitor is configured to detect faults and also to wait for the router to finish rebooting after a fault is detected.
The <link linkend="Monitors_IpPower9258">IpPower9258 Monitor</link> is configured to reboot the router after a fault is detected.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

  &lt;DataModel name="TheDataModel"&gt;
    &lt;Number size="32" signed="false" value="31337" /&gt;
  &lt;/DataModel&gt;

  &lt;StateModel name="State" initialState="Initial" &gt;
    &lt;State name="Initial"&gt;
      &lt;Action type="output"&gt;
          &lt;DataModel ref="TheDataModel"/&gt;
      &lt;/Action&gt;
    &lt;/State&gt;
  &lt;/StateModel&gt;

  &lt;Agent name="Local"&gt;
    &lt;!-- Waits at the start of fuzzing for message --&gt;
    &lt;Monitor class="SerialPort"&gt;
      &lt;Param name="Port" value="COM1" /&gt;
      &lt;Param name="WaitForRegex" value="Boot up completed" /&gt;
    &lt;/Monitor&gt;

    &lt;!-- Fault when "ERROR" is found, and also wait for boot message after fault. --&gt;
    &lt;Monitor class="SerialPort"&gt;
      &lt;Param name="Port" value="COM1" /&gt;
      &lt;Param name="FaultRegex" value="ERROR" /&gt;
      &lt;Param name="WaitRegex" value="Boot up completed" /&gt;
      &lt;Param name="WaitWhen" value="OnIterationAfterFault" /&gt;
    &lt;/Monitor&gt;

    &lt;!-- Restart device on fault --&gt;
    &lt;Monitor class="IpPower9258"&gt;
      &lt;Param name="Host" value="10.1.1.1" /&gt;
      &lt;Param name="Port" value="1" /&gt;
      &lt;Param name="User" value="guest" /&gt;
      &lt;Param name="Password" value="guest123" /&gt;
      &lt;Param name="When" value="OnFault" /&gt;
    &lt;/Monitor&gt;
  &lt;/Agent&gt;

  &lt;Test name="Default"&gt;
    &lt;StateModel ref="State"/&gt;
    &lt;Agent ref="Local" /&gt;
    &lt;Publisher class="ConsoleHex"/&gt;
  &lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
</example>
<example>
<title>Multiple Serial Port monitors for different ports</title>
<simpara>This example connects Peach to the console port and also the debug port of a target device.
The monitor on the console port is set up for fault detection, data collection, and automation.
The monitor on the debug port is set up for data collection.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

  &lt;DataModel name="TheDataModel"&gt;
    &lt;Number size="32" signed="false" value="31337" /&gt;
  &lt;/DataModel&gt;

  &lt;StateModel name="State" initialState="Initial" &gt;
    &lt;State name="Initial"&gt;
      &lt;Action type="output"&gt;
        &lt;DataModel ref="TheDataModel"/&gt;
      &lt;/Action&gt;
    &lt;/State&gt;
  &lt;/StateModel&gt;

  &lt;Agent name="Local"&gt;
    &lt;!-- Console Port --&gt;
    &lt;Monitor class="SerialPort"&gt;
      &lt;Param name="Port" value="COM1" /&gt;
      &lt;Param name="FaultRegex" value="ERROR" /&gt;
      &lt;Param name="WaitRegex" value="Boot up completed" /&gt;
      &lt;Param name="WaitWhen" value="OnIterationAfterFault" /&gt;
    &lt;/Monitor&gt;

    &lt;!-- Debug port --&gt;
    &lt;Monitor class="SerialPort"&gt;
      &lt;Param name="Port" value="COM2" /&gt;
    &lt;/Monitor&gt;
  &lt;/Agent&gt;

  &lt;Test name="Default"&gt;
    &lt;StateModel ref="State"/&gt;
    &lt;Agent ref="Local" /&gt;
    &lt;Publisher class="ConsoleHex"/&gt;
  &lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Monitors_SnmpPower">
<title>SNMP Power Monitor</title>
<simpara><emphasis role="strong">Monitor Categories</emphasis>: <emphasis role="strong">Automation</emphasis></simpara>
<simpara>The <emphasis>SNMP Power</emphasis> monitor switches outlets on a power distribution unit (PDU) on and off via SNMPv1.
This monitor is useful for automatically power cycling devices during a fuzzing session.</simpara>
<simpara>Each <emphasis>SNMP Power</emphasis> monitor switches one or more of a PDU&#8217;s outlets, according to the configuration.
All affected outlets are given the same commands, so turning some outlets on and others off would require another monitor.
The monitor can reset the power outlets at the following points in time:</simpara>
<itemizedlist>
<listitem>
<simpara>At the start or end of a fuzzing run</simpara>
</listitem>
<listitem>
<simpara>At the start or end of each test iteration</simpara>
</listitem>
<listitem>
<simpara>After detecting a fault</simpara>
</listitem>
<listitem>
<simpara>At the start of an iteration that immediately follows a fault</simpara>
</listitem>
<listitem>
<simpara>When a specified call is received from the state model</simpara>
</listitem>
</itemizedlist>
<tip>
<simpara>The <link linkend="Monitors_IpPower9258">IpPower9258 Monitor</link> and
<link linkend="Monitors_ApcPower">ApcPower Monitor</link> provide similar features, for
IP Power 9258 and APC devices, respectively. For controlling power to
a device by wiring through a relay, Peach provides a monitor for the
<link linkend="Monitors_CanaKitRelay">CanaKit 4-Port USB Relay Controller</link>.</simpara>
</tip>
<section xml:id="_parameters_101">
<title>Parameters</title>
<simpara><emphasis>Required:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>Host</term>
<listitem>
<simpara>IP address of the switched power distribution unit.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>OIDs</term>
<listitem>
<simpara>Comma-separated list of OIDs for controlling the power outlets.
To determine the OIDs, start by installing the SNMP MIB provided by the device manufacturer.
Use a utility like <literal>snmptranslate</literal> to lookup numeric OID associate with the OID name of an outlet.
For example, <literal>snmptranslate -On PowerNet-MIB::sPDUOutletCtl.1</literal> indicates <literal>.1.3.6.1.4.1.318.1.1.4.4.2.1.3.1</literal> is the OID to use for outlet 1 on an APC Switched Power Distribution Unit (AC7900).</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>OnCode</term>
<listitem>
<simpara>On indicator code used by outlet OIDs. Default is <literal>1</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>OffCode</term>
<listitem>
<simpara>Off indicator code used by outlet OIDs. Default is <literal>2</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Port</term>
<listitem>
<simpara>SNMP port on the switched power distribution unit. Default is <literal>161</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>ReadCommunity</term>
<listitem>
<simpara>SNMP community string to use when reading the state of the outlets. Default is <literal>public</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>WriteCommunity</term>
<listitem>
<simpara>SNMP community string to use when modifying the state of the outlets. Default is <literal>private</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>RequestTimeout</term>
<listitem>
<simpara>Maximum duration in millseconds to block when sending an SNMP request to the PDU. Default is <literal>1000</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>SanityCheckOnStart</term>
<listitem>
<simpara>On startup, ensure switch state changes persist. Default is <literal>true</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>SanityCheckWaitTimeout</term>
<listitem>
<simpara>Maximum duration to wait for state change to take effect during startup sanity check. Default is <literal>3000</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>ResetOnCall</term>
<listitem>
<simpara>Reset power when the specified call is received from the state model.
This value is used only when the <emphasis>When</emphasis> parameter is set to <literal>OnCall</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>PowerOffOnEnd</term>
<listitem>
<simpara>Power off when the fuzzing session completes, default is <literal>false</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>PowerOnOffPause</term>
<listitem>
<simpara>Pause in milliseconds between power off/power on, default is <literal>500</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>When</term>
<listitem>
<simpara>When to reset power on the specified outlets. Default is <literal>OnFault</literal>.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="66.6667*"/>
<thead>
<row>
<entry align="left" valign="top">"When" Setting</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>DetectFault</simpara></entry>
<entry align="left" valign="top"><simpara>Reset power when checking for a fault.
This occurs after OnIterationEnd.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>OnStart</simpara></entry>
<entry align="left" valign="top"><simpara>Reset power when the fuzzing session starts.
This occurs once per session.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>OnEnd</simpara></entry>
<entry align="left" valign="top"><simpara>Reset power when the fuzzing session stops.
This occurs once per session.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>OnIterationStart</simpara></entry>
<entry align="left" valign="top"><simpara>Reset power at the start of each iteration.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>OnIterationEnd</simpara></entry>
<entry align="left" valign="top"><simpara>Reset power at the end of each iteration.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>OnFault</simpara></entry>
<entry align="left" valign="top"><simpara>Reset power when any monitor detects a fault.
This is the default setting.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>OnIterationStartAfterFault</simpara></entry>
<entry align="left" valign="top"><simpara>Reset power at the start of an iteration that immediately follows a fault detection.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>OnCall</simpara></entry>
<entry align="left" valign="top"><simpara>Reset power when the call specified by the <emphasis>ResetOnCall</emphasis> parameter is received from the state model.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<figure>
<title>When Choices for Performing an Action</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/Monitors/Timings_SSH.png"/>
</imageobject>
<textobject><phrase>Timings SSH</phrase></textobject>
</mediaobject>
</figure>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_151">
<title>Examples</title>
<example>
<title>Reset power on ports 1 and 2 of a PDU</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

  &lt;DataModel name="TheDataModel"&gt;
    &lt;Number size="32" signed="false" value="31337" /&gt;
  &lt;/DataModel&gt;

  &lt;StateModel name="State" initialState="Initial" &gt;
    &lt;State name="Initial"&gt;
      &lt;Action type="output"&gt;
        &lt;DataModel ref="TheDataModel"/&gt;
      &lt;/Action&gt;
    &lt;/State&gt;
  &lt;/StateModel&gt;

  &lt;Agent name="Local"&gt;
    &lt;Monitor class="SnmpPower"&gt;
      &lt;Param name="Host" value="10.0.1.101" /&gt;
      &lt;Param name="OIDs" value=".1.3.6.1.4.1.318.1.1.4.4.2.1.3.1,.1.3.6.1.4.1.318.1.1.4.4.2.1.3.2" /&gt;
    &lt;/Monitor&gt;
  &lt;/Agent&gt;

  &lt;Test name="Default"&gt;
    &lt;StateModel ref="State"/&gt;
    &lt;Agent ref="Local" /&gt;
    &lt;Publisher class="ConsoleHex"/&gt;
  &lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Monitors_Socket">
<title>Socket Monitor</title>
<simpara><emphasis role="strong">Monitor Category</emphasis>: <emphasis role="strong">Data collection</emphasis>, <emphasis role="strong">Fault detection</emphasis></simpara>
<simpara>The <emphasis>Socket</emphasis> monitor waits for an incoming TCP or UDP connection at the end of a test iteration.
This monitor accepts a point-to-point connection to a single host or a multicast connection where the host broadcasts to one or more clients.
Multicast connections are not supported when using the TCP protocol.</simpara>
<simpara>The monitor can be configured to be used for data collection or fault detection depending on the <emphasis>FaultOnSuccess</emphasis> parameter value and whether or not data is received within the specified timeout.
The following table provides the available options:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="33.3333*"/>
<colspec colname="col_3" colwidth="33.3334*"/>
<thead>
<row>
<entry align="left" valign="top">FaultOnSuccess</entry>
<entry align="left" valign="top">Data Received</entry>
<entry align="left" valign="top">Behavior</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>true</literal></simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>Data collection</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>true</literal></simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
<entry align="left" valign="top"><simpara>Fault detection</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>false</literal></simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>Fault detection</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>false</literal></simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
<entry align="left" valign="top"><simpara>Data collection</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<section xml:id="_parameters_102">
<title>Parameters</title>
<simpara><emphasis>Required:</emphasis></simpara>
<simpara>None.</simpara>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>Host</term>
<listitem>
<simpara>IP address of the remote host to receive data from.
Defaults to <literal>""</literal>,
which means accept data from any host.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Interface</term>
<listitem>
<simpara>IP address of the interface to listen on.
Defaults to <literal>0.0.0.0</literal>,
which means listen to all interfaces on the host.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Port</term>
<listitem>
<simpara>Port to listen on.
Defaults to <literal>8080</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Protocol</term>
<listitem>
<simpara>Protocol type to listen for.
Defaults to <literal>tcp</literal>.
Available options for this parameter are <literal>tcp</literal> and <literal>udp</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Timeout</term>
<listitem>
<simpara>Length of time in milliseconds to wait for an incoming connection.
Defaults to <literal>1000</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>FaultOnSuccess</term>
<listitem>
<simpara>Generate a fault if no data is received.
Defaults to <literal>false</literal>.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_152">
<title>Examples</title>
<example>
<title>Fault Detection example</title>
<simpara>This example generates a fault if data from a tcp connection on port <literal>53</literal> is received at the end of a test iteration.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

  &lt;DataModel name="TheDataModel"&gt;
    &lt;Number size="32" signed="false" value="31337" /&gt;
  &lt;/DataModel&gt;

  &lt;StateModel name="State" initialState="Initial" &gt;
    &lt;State name="Initial"&gt;
      &lt;Action type="output"&gt;
        &lt;DataModel ref="TheDataModel"/&gt;
      &lt;/Action&gt;
    &lt;/State&gt;
  &lt;/StateModel&gt;

  &lt;Agent name="Local"&gt;
    &lt;Monitor class="Socket"&gt;
      &lt;Param name="Port" value="53" /&gt;
    &lt;/Monitor&gt;
  &lt;/Agent&gt;

  &lt;Test name="Default"&gt;
    &lt;StateModel ref="State"/&gt;
    &lt;Agent ref="Local" /&gt;
    &lt;Publisher class="ConsoleHex"/&gt;
  &lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Monitors_SshCommand">
<title>SshCommand Monitor</title>
<simpara><emphasis role="strong">Monitor Categories</emphasis>: <emphasis role="strong">Automation</emphasis>, <emphasis role="strong">Data collection</emphasis>, <emphasis role="strong">Fault detection</emphasis></simpara>
<simpara>The <emphasis>SshCommand</emphasis> monitor connects to a remote host over SSH (Secure Shell),
runs a command,
and waits for the command to complete.
The output from the process is logged when a fault is detected.
This monitor can operate as a fault detector,
data collector,
and automation module depending on configuration.</simpara>
<simpara><emphasis>SshCommand</emphasis> supports password, keyboard, and private key authentication methods.</simpara>
<simpara>To increase the speed of operation,
the monitor holds open the SSH connection to the remote machine across test iterations.
This removes the cost of authenticating every time the command is executed.
If multiple <emphasis>SshCommand</emphasis> monitors are configured against the same remote host,
multiple SSH connections are created and held open.</simpara>
<simpara><emphasis role="strong">Fault Detection</emphasis></simpara>
<simpara>This monitor can perform fault detection depending on the configuration of the <emphasis>FaultOnMatch</emphasis> and <emphasis>CheckValue</emphasis> parameters.
The following table describes the behavior of these parameters:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="33.3333*"/>
<colspec colname="col_3" colwidth="33.3334*"/>
<thead>
<row>
<entry align="left" valign="top">FaultOnMatch</entry>
<entry align="left" valign="top">CheckValue match</entry>
<entry align="left" valign="top">Behavior</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>true</literal></simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>Fault detection</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>true</literal></simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
<entry align="left" valign="top"><simpara>Data collection</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>false</literal></simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>Data collection</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>false</literal></simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
<entry align="left" valign="top"><simpara>Fault detection</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>This monitor will also automatically detect <link xl:href="https://github.com/google/sanitizers/wiki/AddressSanitizer">AddressSanitizer</link> crash information and generate a fault if found.</simpara>
<simpara><emphasis role="strong">Data Collection</emphasis></simpara>
<simpara>The monitor always collects the output from the executed command and reports it for logging when a fault is detected.</simpara>
<simpara><emphasis role="strong">Automation</emphasis></simpara>
<simpara>The <emphasis>SshCommand</emphasis> monitor can run the specified command at various points in time during a fuzzing session:</simpara>
<itemizedlist>
<listitem>
<simpara>At the start or end of a fuzzing run</simpara>
</listitem>
<listitem>
<simpara>At the start or end of each test iteration</simpara>
</listitem>
<listitem>
<simpara>While detecting a fault</simpara>
</listitem>
<listitem>
<simpara>After detecting a fault</simpara>
</listitem>
<listitem>
<simpara>At the start of an iteration that immediately follows a fault</simpara>
</listitem>
<listitem>
<simpara>When a specified call is received from the state model</simpara>
</listitem>
</itemizedlist>
<section xml:id="_parameters_103">
<title>Parameters</title>
<simpara><emphasis>Required:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>Host</term>
<listitem>
<simpara>Remote hostname or IP address for the SSH connection.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Username</term>
<listitem>
<simpara>Username for authentication with the remote host.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Command</term>
<listitem>
<simpara>The command to execute on the remote host.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>Password</term>
<listitem>
<simpara>Password for authentication with the remote host.
Defaults to <literal>""</literal>.
Either the <emphasis>Password</emphasis> or the <emphasis>KeyPath</emphasis> parameter must be set.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>KeyPath</term>
<listitem>
<simpara>A local path to the private part of an SSH key-pair to be used for authentication with the remote host.
Defaults to <literal>""</literal>.
Either the <emphasis>Password</emphasis> or the <emphasis>KeyPath</emphasis> parameter must be set.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>CheckValue</term>
<listitem>
<simpara>A regular expression to match the command output.
Defaults to <literal>""</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>FaultOnMatch</term>
<listitem>
<simpara>Trigger a fault if <emphasis>FaultOnMatch</emphasis> is <literal>true</literal> and the <emphasis>CheckValue</emphasis> regular expression matches,
or <emphasis>FaultOnMatch</emphasis> is <literal>false</literal> and the <emphasis>CheckValue</emphasis> regular expression does not match.
Defaults to <literal>false</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>StartOnCall</term>
<listitem>
<simpara>Run the specified command after the monitor receives the specified call from the state machine.
This value is used only when the <emphasis>When</emphasis> parameter is set to <literal>OnCall</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>When</term>
<listitem>
<simpara>Specify one of the following values to determine when to run the specified command:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="66.6667*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis>When</emphasis> Value</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>DetectFault</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Run the command to perform fault detection.
Requires a regular expression to be specified in the <emphasis>CheckValue</emphasis> parameter.
This is the default setting.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>OnStart</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Run the command when fuzzing session starts.
This occurs once per session.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>OnEnd</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Run the command when fuzzing session stops.
This occurs once per session.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>OnIterationStart</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Run the command at the start of each iteration.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>OnIterationEnd</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Run the command at the end of each iteration.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>OnFault</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Run the command when any monitor detects a fault.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>OnIterationStartAfterFault</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Run the command at the start of an iteration that immediately follows a fault detection.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>OnCall</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Run the command upon receipt of the call specified by the <emphasis>WaitOnCall</emphasis> parameter from the state model.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<figure>
<title>When Choices</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/Monitors/Timings_SSH.png"/>
</imageobject>
<textobject><phrase>Timings SSH</phrase></textobject>
</mediaobject>
</figure>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_153">
<title>Examples</title>
<example>
<title>Checking for core dump files</title>
<simpara>This example connects to the target machine using SSH during the fault detection phase of a test iteration.
A fault occurs if any core files exist.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

  &lt;DataModel name="TheDataModel"&gt;
    &lt;Number size="32" signed="false" value="31337" /&gt;
  &lt;/DataModel&gt;

  &lt;StateModel name="State" initialState="Initial" &gt;
    &lt;State name="Initial"&gt;
      &lt;Action type="output"&gt;
        &lt;DataModel ref="TheDataModel"/&gt;
      &lt;/Action&gt;
    &lt;/State&gt;
  &lt;/StateModel&gt;

  &lt;Agent name="Local"&gt;
    &lt;Monitor class="Ssh"&gt;
      &lt;Param name="Host" value="my.target.com" /&gt;
      &lt;Param name="Username" value="tester" /&gt;
      &lt;Param name="Password" value="Password!" /&gt;
      &lt;Param name="Command" value="ls /var/cores/*.core" /&gt;
      &lt;Param name="CheckValue" value="target.*?.core" /&gt;
      &lt;Param name="FaultOnMatch" value="true" /&gt;
    &lt;/Monitor&gt;
  &lt;/Agent&gt;

  &lt;Test name="Default"&gt;
    &lt;StateModel ref="State"/&gt;
    &lt;Agent ref="Local" /&gt;
    &lt;Publisher class="ConsoleHex"/&gt;
  &lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Monitors_SshDownloader">
<title>SshDownloader Monitor</title>
<simpara><emphasis role="strong">Monitor Categories</emphasis>: <emphasis role="strong">Data collection</emphasis></simpara>
<simpara>The <emphasis>SshDownloader</emphasis> monitor downloads a file or folder from a remote host over SSH SFTP (Secure Shell File Transfer Protocol) after any other monitor detects a fault.</simpara>
<simpara><emphasis>SshDownloader</emphasis> supports password, keyboard, and private key authentication methods.</simpara>
<simpara><emphasis>SshDownloader</emphasis> can be configured to delete files from the source after they have been downloaded.</simpara>
<section xml:id="_parameters_104">
<title>Parameters</title>
<simpara><emphasis>Required:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>Host</term>
<listitem>
<simpara>Remote hostname or IP address for the SSH connection.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Username</term>
<listitem>
<simpara>Username for authentication with the remote host.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>Password</term>
<listitem>
<simpara>Password for authentication with the remote host.
Defaults to <literal>""</literal>.
Either the <emphasis>Password</emphasis> or the <emphasis>KeyPath</emphasis> parameter must be set.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>KeyPath</term>
<listitem>
<simpara>A local path to the private part of an SSH key-pair to be used for authentication with the remote host.
Defaults to <literal>""</literal>.
Either the <emphasis>Password</emphasis> or the <emphasis>KeyPath</emphasis> parameter must be set.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>File</term>
<listitem>
<simpara>Path of the remote file to download.
Defaults to <literal>""</literal>.
Either the <emphasis>File</emphasis> or the <emphasis>Folder</emphasis> parameter must be set.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Folder</term>
<listitem>
<simpara>Path of the remote folder to download.
Defaults to <literal>""</literal>.
Either the <emphasis>File</emphasis> or the <emphasis>Folder</emphasis> parameter must be set.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Remove</term>
<listitem>
<simpara>When this value is set to <literal>true</literal>,
remove the remote file after the download completes.
Defaults to <literal>true</literal>.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_154">
<title>Examples</title>
<example>
<title>Download a log file</title>
<simpara>This example downloads a log file when a fault is detected by any other monitor.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

  &lt;DataModel name="TheDataModel"&gt;
    &lt;Number size="32" signed="false" value="31337" /&gt;
  &lt;/DataModel&gt;

  &lt;StateModel name="State" initialState="Initial" &gt;
    &lt;State name="Initial"&gt;
      &lt;Action type="output"&gt;
        &lt;DataModel ref="TheDataModel"/&gt;
      &lt;/Action&gt;
    &lt;/State&gt;
  &lt;/StateModel&gt;

  &lt;Agent name="Local"&gt;
    &lt;Monitor class="SshDownloader"&gt;
      &lt;Param name="Host" value="my.target.com" /&gt;
      &lt;Param name="Username" value="tester" /&gt;
      &lt;Param name="Password" value="Password!" /&gt;
      &lt;Param name="File" value="/var/log/syslog" /&gt;
      &lt;Param name="Remove" value="false" /&gt;
    &lt;/Monitor&gt;
  &lt;/Agent&gt;

  &lt;Test name="Default"&gt;
    &lt;StateModel ref="State"/&gt;
    &lt;Agent ref="Local" /&gt;
    &lt;Publisher class="ConsoleHex"/&gt;
  &lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Monitors_Syslog">
<title>Syslog Monitor</title>
<simpara><emphasis role="strong">Monitor Categories</emphasis>: <emphasis role="strong">Automation</emphasis>, <emphasis role="strong">Data collection</emphasis>, <emphasis role="strong">Fault detection</emphasis></simpara>
<simpara>The <emphasis>Syslog</emphasis> monitor listens on a specified port for incoming syslog messages.
This monitor is capable of performing automation, data collection, and fault detection.</simpara>
<simpara>The default usage of the <emphasis>Syslog</emphasis> monitor is data collection.
The syslog messages received are logged when a fault occurs.</simpara>
<simpara>To perform fault detection,
specify a regular expression using the <emphasis>FaultRegex</emphasis> parameter.
When the regular expression matches an incoming syslog message,
Peach generates a fault.</simpara>
<simpara>For automation tasks, use the <emphasis>WaitForRegex</emphasis> and <emphasis>WaitWhen</emphasis> parameters.
These automation parameters cause Peach to wait for matching input before continuing.
The <emphasis>Syslog</emphasis> monitor can wait at various points in time during a fuzzing session:</simpara>
<itemizedlist>
<listitem>
<simpara>At the start or end of a fuzzing run</simpara>
</listitem>
<listitem>
<simpara>At the start or end of each test iteration</simpara>
</listitem>
<listitem>
<simpara>After detecting a fault</simpara>
</listitem>
<listitem>
<simpara>At the start of an iteration that immediately follows a fault</simpara>
</listitem>
<listitem>
<simpara>When a specified call is received from the state model</simpara>
</listitem>
</itemizedlist>
<section xml:id="_parameters_105">
<title>Parameters</title>
<simpara><emphasis>Required:</emphasis></simpara>
<simpara>None.</simpara>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>Port</term>
<listitem>
<simpara>Port number to listen on.
The default value is <literal>514</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Interface</term>
<listitem>
<simpara>IP address of the interface to listen on.
The default value is <literal>0.0.0.0</literal>, which listens on all interfaces.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>FaultRegex</term>
<listitem>
<simpara>Generate a fault when the specified regular expression matches received data.
This causes the <emphasis>Syslog</emphasis> monitor to be used for fault detection.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>WaitRegex</term>
<listitem>
<simpara>Wait until the specified regular expression matches received data.
This causes the <emphasis>Syslog</emphasis> monitor to be used for automation.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>WaitOnCall</term>
<listitem>
<simpara>Begin waiting for the regular expression specified in the <emphasis>WaitRegex</emphasis> parameter after the monitor receives the specified call from the state machine.
This value is used only when the <emphasis>WaitWhen</emphasis> parameter is set to <literal>OnCall</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>WaitWhen</term>
<listitem>
<simpara>Specify one of the following values to determine when to begin waiting for the regular expression specified in the <emphasis>WaitRegex</emphasis> parameter to match received data:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="66.6667*"/>
<thead>
<row>
<entry align="left" valign="top">"WaitWhen" Setting</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>OnStart</simpara></entry>
<entry align="left" valign="top"><simpara>Waits when the fuzzing session starts.
This occurs once per session.
This is the default setting.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>OnEnd</simpara></entry>
<entry align="left" valign="top"><simpara>Waits when the fuzzing session stops.
This occurs once per session.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>OnIterationStart</simpara></entry>
<entry align="left" valign="top"><simpara>Waits at the start of each iteration.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>OnIterationEnd</simpara></entry>
<entry align="left" valign="top"><simpara>Waits at the end of each iteration.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>OnFault</simpara></entry>
<entry align="left" valign="top"><simpara>Waits when any monitor detects a fault.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>OnIterationStartAfterFault</simpara></entry>
<entry align="left" valign="top"><simpara>Waits at the start of the iteration that immediately follows a fault detection.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>OnCall</simpara></entry>
<entry align="left" valign="top"><simpara>Waits upon receipt of the call specified by the <emphasis>WaitOnCall</emphasis> parameter from the state model.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<figure>
<title>WaitWhen Choices</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/Monitors/Timings_All.png"/>
</imageobject>
<textobject><phrase>Timings All</phrase></textobject>
</mediaobject>
</figure>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_155">
<title>Examples</title>
<example>
<title>Data Collection example</title>
<simpara>This example shows the <emphasis>Syslog</emphasis> monitor listening on the default port for incoming messages.
When a fault occurs,
all messages are saved.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

  &lt;DataModel name="TheDataModel"&gt;
    &lt;Number size="32" signed="false" value="31337" /&gt;
  &lt;/DataModel&gt;

  &lt;StateModel name="State" initialState="Initial" &gt;
    &lt;State name="Initial"&gt;
      &lt;Action type="output"&gt;
        &lt;DataModel ref="TheDataModel"/&gt;
      &lt;/Action&gt;
    &lt;/State&gt;
  &lt;/StateModel&gt;

  &lt;Agent name="Local"&gt;
    &lt;Monitor class="Syslog"/&gt;
  &lt;/Agent&gt;

  &lt;Test name="Default"&gt;
    &lt;StateModel ref="State"/&gt;
    &lt;Agent ref="Local" /&gt;
    &lt;Publisher class="ConsoleHex"/&gt;
  &lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
</example>
<example>
<title>Fault Detection example</title>
<simpara>This example shows the <emphasis>Syslog</emphasis> monitor listening on the default port for incoming messages.
<emphasis>Syslog</emphasis> compares the <emphasis>FaultRegex</emphasis> regular expression with each incoming message;
when a match occurs,
the monitor generates a fault and saves the syslog data.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

  &lt;DataModel name="TheDataModel"&gt;
    &lt;Number size="32" signed="false" value="31337" /&gt;
  &lt;/DataModel&gt;

  &lt;StateModel name="State" initialState="Initial" &gt;
    &lt;State name="Initial"&gt;
      &lt;Action type="output"&gt;
        &lt;DataModel ref="TheDataModel"/&gt;
      &lt;/Action&gt;
    &lt;/State&gt;
  &lt;/StateModel&gt;

  &lt;Agent name="Local"&gt;
    &lt;Monitor class="Syslog"&gt;
      &lt;Param name="FaultRegex" value="ERROR" /&gt;
    &lt;/Monitor&gt;
  &lt;/Agent&gt;

  &lt;Test name="Default"&gt;
    &lt;StateModel ref="State"/&gt;
    &lt;Agent ref="Local" /&gt;
    &lt;Publisher class="ConsoleHex"/&gt;
  &lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
</example>
<example>
<title>Combined Automation and Fault Detection example</title>
<simpara>This example might be used when fuzzing a network device such as a router.
One <emphasis>Syslog</emphasis> monitor is configured to wait until the router has booted before starting the fuzzing session.
Another <emphasis>Syslog</emphasis> monitor is configured to detect faults and also to wait for the router to finish rebooting after a fault is detected.
The <link linkend="Monitors_IpPower9258">IpPower9258 Monitor</link> is configured to reboot the router after a fault is detected.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

  &lt;DataModel name="TheDataModel"&gt;
    &lt;Number size="32" signed="false" value="31337" /&gt;
  &lt;/DataModel&gt;

  &lt;StateModel name="State" initialState="Initial" &gt;
    &lt;State name="Initial"&gt;
      &lt;Action type="output"&gt;
          &lt;DataModel ref="TheDataModel"/&gt;
      &lt;/Action&gt;
    &lt;/State&gt;
  &lt;/StateModel&gt;

  &lt;Agent name="Local"&gt;
    &lt;!-- Waits at the start of fuzzing for message --&gt;
    &lt;Monitor class="Syslog"&gt;
      &lt;Param name="WaitForRegex" value="Boot up completed" /&gt;
    &lt;/Monitor&gt;

    &lt;!-- Fault when "ERROR" is found, and also wait for boot message after fault. --&gt;
    &lt;Monitor class="Syslog"&gt;
      &lt;Param name="FaultRegex" value="ERROR" /&gt;
      &lt;Param name="WaitRegex" value="Boot up completed" /&gt;
      &lt;Param name="WaitWhen" value="OnIterationAfterFault" /&gt;
    &lt;/Monitor&gt;

    &lt;!-- Restart device on fault --&gt;
    &lt;Monitor class="IpPower9258"&gt;
      &lt;Param name="Host" value="10.1.1.1" /&gt;
      &lt;Param name="Port" value="1" /&gt;
      &lt;Param name="User" value="guest" /&gt;
      &lt;Param name="Password" value="guest123" /&gt;
      &lt;Param name="When" value="OnFault" /&gt;
    &lt;/Monitor&gt;
  &lt;/Agent&gt;

  &lt;Test name="Default"&gt;
    &lt;StateModel ref="State"/&gt;
    &lt;Agent ref="Local" /&gt;
    &lt;Publisher class="ConsoleHex"/&gt;
  &lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Monitors_TcpPort">
<title>TcpPort Monitor</title>
<simpara><emphasis role="strong">Monitor Categories</emphasis>: <emphasis role="strong">Automation</emphasis>, <emphasis role="strong">Data collection</emphasis>, <emphasis role="strong">Fault detection</emphasis></simpara>
<simpara>The <emphasis>TcpPort</emphasis> monitor detects state changes on TCP ports.
A state change is a transition in port status from <emphasis>Open</emphasis> to <emphasis>Closed</emphasis> or from <emphasis>Closed</emphasis> to <emphasis>Open</emphasis>.
The <emphasis>TcpPort</emphasis> monitor can be configured in the following ways:</simpara>
<itemizedlist>
<listitem>
<simpara>as an automation task (wait until a specified state occurs)</simpara>
</listitem>
<listitem>
<simpara>fault detection (fault on a specific state)</simpara>
</listitem>
<listitem>
<simpara>data collection (report the current state)</simpara>
</listitem>
</itemizedlist>
<simpara>For automation tasks,
the <emphasis>When</emphasis> parameter can be configured to detect the state of a TCP port
at various points in time during a fuzzing session:</simpara>
<itemizedlist>
<listitem>
<simpara>At the start or end of a fuzzing run</simpara>
</listitem>
<listitem>
<simpara>At the start or end of each test iteration</simpara>
</listitem>
<listitem>
<simpara>After detecting a fault</simpara>
</listitem>
<listitem>
<simpara>At the start of an iteration that immediately follows a fault</simpara>
</listitem>
<listitem>
<simpara>When a specified call is received from the state model</simpara>
</listitem>
</itemizedlist>
<section xml:id="_parameters_106">
<title>Parameters</title>
<simpara><emphasis>Required:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>Host</term>
<listitem>
<simpara>Hostname or IP address of the remote host</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Port</term>
<listitem>
<simpara>Port number to monitor</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>Action</term>
<listitem>
<simpara>Action to take (Automation, Data, Fault).
Defaults to <literal>Automation</literal>.</simpara>
<informaltable tabstyle="horizontal" frame="none" colsep="0" rowsep="0">
<tgroup cols="2">
<colspec colwidth="15*"/>
<colspec colwidth="85*"/>
<tbody valign="top">
<row>
<entry>
<simpara>Automation</simpara>
</entry>
<entry>
<simpara>Wait for the port to reach a specified state.
The <emphasis>When</emphasis> parameter determines when the monitor should detect the state of the specified port.</simpara>
</entry>
</row>
<row>
<entry>
<simpara>Data</simpara>
</entry>
<entry>
<simpara>Report the state of the port immediately following a fault that is detected by any other monitor.</simpara>
</entry>
</row>
<row>
<entry>
<simpara>Fault</simpara>
</entry>
<entry>
<simpara>Generate a fault if the port is in a specified state at the end of an iteration.</simpara>
</entry>
</row>
</tbody>
</tgroup>
</informaltable>
</listitem>
</varlistentry>
</variablelist>
<variablelist>
<varlistentry>
<term>State</term>
<listitem>
<simpara>Port state to monitor.
The default value is <literal>Open</literal>.</simpara>
<informaltable tabstyle="horizontal" frame="none" colsep="0" rowsep="0">
<tgroup cols="2">
<colspec colwidth="15*"/>
<colspec colwidth="85*"/>
<tbody valign="top">
<row>
<entry>
<simpara>Open</simpara>
</entry>
<entry>
<simpara>The port is available for use.</simpara>
</entry>
</row>
<row>
<entry>
<simpara>Closed</simpara>
</entry>
<entry>
<simpara>The port is not available.</simpara>
</entry>
</row>
</tbody>
</tgroup>
</informaltable>
</listitem>
</varlistentry>
</variablelist>
<variablelist>
<varlistentry>
<term>Timeout</term>
<listitem>
<simpara>The amount of time in milliseconds to wait for the specified TCP state to occur.
Specify <literal>-1</literal> to indicate an infinte timeout.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>WaitOnCall</term>
<listitem>
<simpara>Detect port state upon recept of the specified call from the state model.
This value is used only when the <emphasis>When</emphasis> parameter is set to <literal>OnCall</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>When</term>
<listitem>
<simpara>Specify one of the following values to control when port state detection should occur during a fuzzing session:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="66.6667*"/>
<thead>
<row>
<entry align="left" valign="top">"When" Setting</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>OnStart</simpara></entry>
<entry align="left" valign="top"><simpara>Detect port state when the fuzzing session starts.
This occurs once per session.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>OnEnd</simpara></entry>
<entry align="left" valign="top"><simpara>Detect port state when the fuzzing session stops.
This occurs once per session.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>OnIterationStart</simpara></entry>
<entry align="left" valign="top"><simpara>Detect port state at the start of each iteration.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>OnIterationEnd</simpara></entry>
<entry align="left" valign="top"><simpara>Detect port state at the end of each iteration.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>OnFault</simpara></entry>
<entry align="left" valign="top"><simpara>Detect port state when any monitor detects a fault.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>OnIterationStartAfterFault</simpara></entry>
<entry align="left" valign="top"><simpara>Detect port state at the start of the iteration that immediately follows a fault detection.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>OnCall</simpara></entry>
<entry align="left" valign="top"><simpara>Detect port state upon receipt of the call specified by the <emphasis>WaitOnCall</emphasis> parameter from the state model.
This is the default setting.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<figure>
<title>When Choices</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/Monitors/Timings_All.png"/>
</imageobject>
<textobject><phrase>Timings All</phrase></textobject>
</mediaobject>
</figure>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_156">
<title>Examples</title>
<example>
<title>Automation example: Open</title>
<simpara>This example causes Peach to wait until the remote port is in an open state after the <literal>WaitForPort</literal> call is received from the state model.
No timeout interval is provided, so Peach will wait forever.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

  &lt;DataModel name="TheDataModel"&gt;
    &lt;Number size="32" signed="false" value="31337" /&gt;
  &lt;/DataModel&gt;

  &lt;StateModel name="State" initialState="Initial" &gt;
    &lt;State name="Initial"&gt;
      &lt;Action type="output"&gt;
        &lt;DataModel ref="TheDataModel"/&gt;
      &lt;/Action&gt;

      &lt;Action type="call" method="WaitForPort" publisher="Peach.Agent" /&gt;
    &lt;/State&gt;
  &lt;/StateModel&gt;

  &lt;Agent name="Local"&gt;
    &lt;Monitor class="TcpPort"&gt;
      &lt;Param name="Host" value="192.168.133.4" /&gt;
      &lt;Param name="Port" value="502" /&gt;
      &lt;Param name="WaitOnCall" value="WaitForPort" /&gt;
    &lt;/Monitor&gt;
  &lt;/Agent&gt;

  &lt;Test name="Default"&gt;
    &lt;StateModel ref="State"/&gt;
    &lt;Agent ref="Local" /&gt;
    &lt;Publisher class="ConsoleHex"/&gt;
  &lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
</example>
<example>
<title>Automation example: Closed</title>
<simpara>This example causes Peach to wait until the remote port in in a closed state after the <literal>WaitForPort</literal> call is received from the state model.
No timeout interval is provided, so Peach will wait forever.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

  &lt;DataModel name="TheDataModel"&gt;
    &lt;Number size="32" signed="false" value="31337" /&gt;
  &lt;/DataModel&gt;

  &lt;StateModel name="State" initialState="Initial" &gt;
    &lt;State name="Initial"&gt;
      &lt;Action type="output"&gt;
        &lt;DataModel ref="TheDataModel"/&gt;
      &lt;/Action&gt;

      &lt;Action type="call" method="WaitForPort" publisher="Peach.Agent" /&gt;
    &lt;/State&gt;
  &lt;/StateModel&gt;

  &lt;Agent name="Local"&gt;
    &lt;Monitor class="TcpPort"&gt;
      &lt;Param name="Host" value="192.168.133.4" /&gt;
      &lt;Param name="Port" value="502" /&gt;
      &lt;Param name="State" value="Closed" /&gt;
      &lt;Param name="WaitOnCall" value="WaitForPort" /&gt;
    &lt;/Monitor&gt;
  &lt;/Agent&gt;

  &lt;Test name="Default"&gt;
    &lt;StateModel ref="State"/&gt;
    &lt;Agent ref="Local" /&gt;
    &lt;Publisher class="ConsoleHex"/&gt;
  &lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
</example>
<example>
<title>Fault Detection example</title>
<simpara>This example inspects the state of the remote port at the end of an iteration.
A fault is generated if the port is closed at the end of an iteration.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

  &lt;DataModel name="TheDataModel"&gt;
    &lt;Number size="32" signed="false" value="31337" /&gt;
  &lt;/DataModel&gt;

  &lt;StateModel name="State" initialState="Initial" &gt;
    &lt;State name="Initial"&gt;
      &lt;Action type="output"&gt;
        &lt;DataModel ref="TheDataModel"/&gt;
      &lt;/Action&gt;
    &lt;/State&gt;
  &lt;/StateModel&gt;

  &lt;Agent name="Local"&gt;
    &lt;Monitor class="TcpPort"&gt;
      &lt;Param name="Host" value="192.168.133.4" /&gt;
      &lt;Param name="Port" value="502" /&gt;
      &lt;Param name="Action" value="Fault" /&gt;
      &lt;Param name="State" value="Closed" /&gt;
    &lt;/Monitor&gt;
  &lt;/Agent&gt;

  &lt;Test name="Default"&gt;
    &lt;StateModel ref="State"/&gt;
    &lt;Agent ref="Local" /&gt;
    &lt;Publisher class="ConsoleHex"/&gt;
  &lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
</example>
<example>
<title>Data Collection example</title>
<simpara>This example causes the TcpPort monitor to report the state of a port after a fault is detected by any other monitor.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

  &lt;DataModel name="TheDataModel"&gt;
    &lt;Number size="32" signed="false" value="31337" /&gt;
  &lt;/DataModel&gt;

  &lt;StateModel name="State" initialState="Initial" &gt;
    &lt;State name="Initial"&gt;
      &lt;Action type="output"&gt;
        &lt;DataModel ref="TheDataModel"/&gt;
      &lt;/Action&gt;
    &lt;/State&gt;
  &lt;/StateModel&gt;

  &lt;Agent name="Local"&gt;
    &lt;!-- Fault detection --&gt;
    &lt;Monitor class="Gdb"&gt;
      &lt;Param name="Executable" value="/usr/bin/curl"/&gt;
      &lt;Param name="Arguments" value="http://localhost"/&gt;
      &lt;Param name="StartOnCall" value="ScoobySnacks"/&gt;
    &lt;/Monitor&gt;

    &lt;!-- Data collection --&gt;
    &lt;Monitor class="TcpPort"&gt;
      &lt;Param name="Host" value="192.168.133.4" /&gt;
      &lt;Param name="Port" value="502" /&gt;
      &lt;Param name="Action" value="Data" /&gt;
  	&lt;/Monitor&gt;
  &lt;/Agent&gt;

  &lt;Test name="Default"&gt;
    &lt;StateModel ref="State"/&gt;
    &lt;Agent ref="Local" /&gt;
    &lt;Publisher class="ConsoleHex"/&gt;
  &lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Monitors_Vmware">
<title>Vmware Monitor</title>
<simpara><emphasis role="strong">Monitor Categories</emphasis>: <emphasis role="strong">Automation</emphasis></simpara>
<simpara>The <emphasis>Vmware</emphasis> monitor can control a VMware virtual machine (VM).
This monitor works with a snapshot of the VM that provides a consistent VM environment throughout a fuzzing session.
The <emphasis>Vmware</emphasis> monitor can start a VM snapshot and,
optionally,
reset the VM to a snapshot configuration each iteration.</simpara>
<simpara>The following illustration shows the VMWare Snapshot Manager,
which is used for managing snapshots for a particular VM.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/Common/Monitors/Vmware_SnapshotManager.png" scale="60"/>
</imageobject>
<textobject><phrase>Vmware SnapshotManager</phrase></textobject>
</mediaobject>
</informalfigure>
<section xml:id="_parameters_107">
<title>Parameters</title>
<simpara><emphasis>Required:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>Vmx</term>
<listitem>
<simpara>Path to the virtual machine.</simpara>
<tip>
<simpara>When using with vSphere/ESXi,
prefix the VM image name with the storage location in brackets.
For example, <literal>[ha-datacenter/datastore1] guest/guest.vmx</literal>.</simpara>
</tip>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>SnapshotName</term>
<listitem>
<simpara>VM snapshot name.</simpara>
<simpara>Either <emphasis>SnapshotName</emphasis> or <emphasis>SnapshotIndex</emphasis> must be specified,
but it is an error to specify both.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>SnapshotIndex</term>
<listitem>
<simpara>VM snapshot index specification.</simpara>
<simpara>Either <emphasis>SnapshotName</emphasis> or <emphasis>SnapshotIndex</emphasis> must be specified,
but it is an error to specify both.</simpara>
<simpara>The index specification is a list of zero-based index values delimited by a period (<literal>.</literal>).
The specification resolves which leaf in a tree of snapshots should be used.</simpara>
<simpara>For example,
in the following tree of snapshots,
the snapshot named <literal>Snapshot 1.2.1</literal> would be used when <literal>0.1.0</literal> is specifed.</simpara>
<itemizedlist>
<listitem>
<simpara>Snapshot 1</simpara>
<itemizedlist>
<listitem>
<simpara>Snapshot 1.1</simpara>
</listitem>
<listitem>
<simpara>Snapshot 1.2</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Snapshot 1.2.1</emphasis></simpara>
</listitem>
<listitem>
<simpara>Snapshot 1.2.2</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Snapshot 2</simpara>
<itemizedlist>
<listitem>
<simpara>Snapshot 2.1</simpara>
</listitem>
<listitem>
<simpara>Snapshot 2.2</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term>Host</term>
<listitem>
<simpara>Hostname or IP address the VMware host.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>HostPort</term>
<listitem>
<simpara>TCP/IP port of the VMware host.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Login</term>
<listitem>
<simpara>Username for authentication with the VMware host.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Password</term>
<listitem>
<simpara>Password for authentication with the VMware host.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>HostType</term>
<listitem>
<simpara>Type of remote host, defaults to <literal>Default</literal></simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="66.6667*"/>
<thead>
<row>
<entry align="left" valign="top">VM Product</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><emphasis role="strong">VIServer</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara>vCenter Server, ESX/ESXi hosts, VMWare Server 2.0</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><emphasis role="strong">Workstation</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara>VMWare Workstation</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><emphasis role="strong">WorkstationShared</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara>VMWare Workstation (Shared Mode)</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><emphasis role="strong">Player</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara>VMWare Player</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><emphasis role="strong">Server</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara>VMWare Server 1.0.x</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><emphasis role="strong">Default</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara>Default</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</listitem>
</varlistentry>
<varlistentry>
<term>ResetEveryIteration</term>
<listitem>
<simpara>If <literal>true</literal> is specified,
reset the VM on every iteration.
Defaults to <literal>false</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>ResetOnFaultBeforeCollection</term>
<listitem>
<simpara>If <literal>true</literal> is specified,
reset the VM after a fault is detected by any other monitor.
Defaults to <literal>false</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>StopOnFaultBeforeCollection</term>
<listitem>
<simpara>If <literal>true</literal> is specified,
stop the VM after a fault is detected by any other monitor.
Defaults to <literal>false</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>WaitForToolsInGuest</term>
<listitem>
<simpara>If <literal>true</literal> is specified,
wait for VMware tools to start within the guest whenever a VM is restarted.
Defaults to <literal>true</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>WaitTimeout</term>
<listitem>
<simpara>The number of seconds to wait for VMware tools to start within a guest.
Defaults to <literal>600</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Headless</term>
<listitem>
<simpara>Run a VM without a GUI.
Using this parameter can improve performance but may cause issues if the target interacts with the desktop.
Defaults to <literal>true</literal>.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_157">
<title>Examples</title>
<example>
<title>Start Virtual Machine</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;Agent name="Local"&gt;
	&lt;Monitor class="Vmware"&gt;
		&lt;Param name="Vmx" value="D:\VirtualMachines\OfficeWebTest\OfficeWebTest.vmx" /&gt;
		&lt;Param name="HostType" value="Workstation" /&gt;
		&lt;Param name="SnapshotName" value="Fuzzing" /&gt;
	&lt;/Monitor&gt;
&lt;/Agent&gt;</programlisting>
</example>
<example>
<title>Start Virtual Machine hosted on ESXi</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;Agent name="Local"&gt;
	&lt;Monitor class="Vmware"&gt;
		&lt;Param name="Vmx" value="[ha-datacenter/datastore1] guest/guest.vmx" /&gt;
		&lt;Param name="SnapshotName" value="Fuzzing" /&gt;
	&lt;/Monitor&gt;
&lt;/Agent&gt;</programlisting>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Monitors_WindowsDebugger">
<title>WindowsDebugger Monitor (Windows)</title>
<simpara><emphasis role="strong">Monitor Categories</emphasis>: <emphasis role="strong">Automation</emphasis>, <emphasis role="strong">Data collection</emphasis>, <emphasis role="strong">Fault detection</emphasis></simpara>
<simpara>The <emphasis>WindowsDebugger</emphasis> monitor controls a windows debugger instance.</simpara>
<simpara>This monitor launches an executable file, a process, or a service with the debugger
attached; or, this monitor can attach the debugger to a running executable,
process, or service.</simpara>
<simpara>The <emphasis>WindowsDebugger</emphasis> performs automation, fault detection, and data collection.</simpara>
<itemizedlist>
<listitem>
<simpara>Automation manages when the fuzzing target (process, service, etc) starts and restarts. This can occur
at the start of a fuzzing session, at the start of each iteration, after detecting a fault,
or upon receiving a call from the state model.</simpara>
</listitem>
<listitem>
<simpara>Fault detection watches and reports crashes and faults&#8212;&#8203;when the target exits prematurely,
and when the target fails to exit.</simpara>
</listitem>
<listitem>
<simpara>Data collection retrieves stack traces, logs, and other information provided by the debugger.
Note that this monitor provides bucket information&#8212;&#8203;major and minor hash values&#8212;&#8203;as part of
data collected on faults. For more information on bucketing provided by this monitor, see <link xl:href="http://msecdbg.codeplex.com/">!exploitable</link>.</simpara>
</listitem>
</itemizedlist>
<section xml:id="_parameters_108">
<title>Parameters</title>
<simpara><emphasis>Exactly one of the three required parameters is needed for each instance of this monitor.
The other two required parameters are not used.</emphasis></simpara>
<variablelist>
<varlistentry>
<term>Executable</term>
<listitem>
<simpara>Executable to launch via the debugger. If the executable has command-line arguments,  specify these in the "Arguments" parameter.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>ProcessName</term>
<listitem>
<simpara>Name of the process that the debugger attaches.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Service</term>
<listitem>
<simpara>Name of the Windows process or service to  attach to the debugger. If the service
crashes or is stopped, this monitor will restart the service.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>Arguments</term>
<listitem>
<simpara>Command-line arguments for the executable file specified with the "Executable" parameter.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>SymbolsPath</term>
<listitem>
<simpara>Path to the debugging symbol files. The default value is Microsoft public
symbols server,SRV*http://msdl.microsoft.com/download/symbols.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>WinDbgPath</term>
<listitem>
<simpara>Path to the Windows Debugger installation. If undeclared, Peach attempts to locate a local installation of the debugger.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>StartOnCall</term>
<listitem>
<simpara>Defers launching the target until the state model issues a call to the monitor
to begin. Upon receiving the call, the debugger attaches to the process, or starts the process
or executable.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>IgnoreFirstChanceGuardPage</term>
<listitem>
<simpara>Ignores faults from the first chance guard page. These faults
are sometimes false positives or anti-debugging faults, defaults to false.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>IgnoreSecondChanceGuardPage</term>
<listitem>
<simpara>Ignores faults from the second chance guard page. These faults
are sometimes false positives or anti-debugging faults, defaults to false.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>IgnoreFirstChanceReadAv</term>
<listitem>
<simpara>Ignores faults from the first chance read access violations. These faults
are sometimes false positives, defaults to false.  Whem monitoring a Java process,
it is recommended to set this parameter to true.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>NoCpuKill</term>
<listitem>
<simpara>Allows or disallows the CPU to idle. If true, the CPU can idle without terminating
the target. If false, Peach polls and then terminates the target if it is caught idling. The
default value is false.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>CpuPollInterval</term>
<listitem>
<simpara>Specifies the time interval, expressed in milliseconds (ms), that the monitor
waits between successive polls of the target. This argument is used when NoCpuKill is false.
The default value is 200 ms.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>FaultOnEarlyExit</term>
<listitem>
<simpara>Triggers a fault if the target exits prematurely, defaults to false.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>RestartAfterFault</term>
<listitem>
<simpara>If "true", restarts the target when any monitor detects a fault.
If "false", restarts the target only if the process exits or crashes.<?asciidoc-br?>
This argument defaults to true.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>RestartOnEachTest</term>
<listitem>
<simpara>Restarts the process for each iteration, defaults to false.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>ServiceStartTimeout</term>
<listitem>
<simpara>When debugging a windows service, this specifies how long the
monitor should wait for the service to start. The default value is 60 seconds.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>WaitForExitOnCall</term>
<listitem>
<simpara>Exits the target upon receiving a call from the state model. If the
call fails to occur within an acceptable  waiting period, issue a fault and then exit. The
WaitForExitTimeout parameter specifies the waiting period.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>WaitForExitTimeout</term>
<listitem>
<simpara>Specifies the WaitForExitOnCall timeout value, expressed in milliseconds,
defaults to 10000 ms (10 sec). The value -1 specifies an infinite waiting period.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_158">
<title>Examples</title>
<example>
<title>Command Line Configuration</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;Agent name="Local"&gt;
	&lt;Monitor class="WindowsDebugger"&gt;
		&lt;Param name="Executable" value="CrashableServer.exe" /&gt;
		&lt;Param name="Arguments" value="127.0.0.1 4244" /&gt;
		&lt;!--&lt;Param name="WinDbgPath" value="C:\Program Files (x86)\Debugging Tools for Windows (x86)" /&gt;--&gt;
	&lt;/Monitor&gt;
&lt;/Agent&gt;</programlisting>
</example>
<example>
<title>Service Configuration</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;Param name="Service" value="WinDefend" /&gt;</programlisting>
</example>
<example>
<title>Process Configuration</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;Param name="ProcessName" value="CrashableServer.exe" /&gt;</programlisting>
</example>
<example>
<title>StartOnCall Configuration</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;StateModel name="TheState" initialState="initial"&gt;
    &lt;State name="initial"&gt;
        &lt;Action type="call" method="launchProgram" publisher="Peach.Agent"/&gt;
    &lt;/State&gt;
&lt;/StateModel&gt;


&lt;Agent name="Local"&gt;
    &lt;Monitor class="WindowsDebugger"&gt;
        &lt;Param name="Executable" value="CrashableServer.exe"/&gt;
        &lt;Param name="Arguments" value="127.0.0.1 4244"/&gt;
        &lt;Param name="StartOnCall" value="launchProgram"/&gt;
    &lt;/Monitor&gt;
&lt;/Agent&gt;</programlisting>
</example>
<example>
<title>Exit Configurations</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;Agent name="Local"&gt;
    &lt;Monitor class="WindowsDebugger"&gt;
        &lt;Param name="Executable" value="CrashableServer.exe"/&gt;
        &lt;Param name="Arguments" value="127.0.0.1 4244"/&gt;
        &lt;Param name="NoCpuKill" value="true"/&gt;
        &lt;Param name="FaultOnEarlyExit" value="false"/&gt;
        &lt;Param name="WaitForExitTimeout" value="250"/&gt;
    &lt;/Monitor&gt;
&lt;/Agent&gt;</programlisting>
</example>
<example>
<title>WaitForExitOnCall Configuration</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;StateModel name="TheState" initialState="initial"&gt;
    &lt;State name="initial"&gt;
        &lt;Action type="call" method="exitProgram" publisher="Peach.Agent"/&gt;
    &lt;/State&gt;
&lt;/StateModel&gt;


&lt;Agent name="Local"&gt;
    &lt;Monitor class="WindowsDebugger"&gt;
        &lt;Param name="Executable" value="CrashableServer.exe"/&gt;
        &lt;Param name="Arguments" value="127.0.0.1 4244"/&gt;
        &lt;Param name="WaitForExitOnCall" value="exitProgram"/&gt;
    &lt;/Monitor&gt;
&lt;/Agent&gt;</programlisting>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Monitors_WindowsKernelDebugger">
<title>WindowsKernelDebugger Monitor (Windows)</title>
<simpara><emphasis role="strong">Monitor Categories</emphasis>: <emphasis role="strong">Data collection</emphasis>, <emphasis role="strong">Fault detection</emphasis></simpara>
<simpara>The <emphasis>WindowsKernelDebugger</emphasis> monitor controls debugging of a remote windows kernel
debugging instance. At least two machines are involved:</simpara>
<itemizedlist>
<listitem>
<simpara>The target machine that receives fuzzing data.</simpara>
</listitem>
<listitem>
<simpara>The host machine that controls the debugging session. Peach resides on this machine</simpara>
</listitem>
</itemizedlist>
<simpara>The <emphasis>WindowsKernelDebugger</emphasis> performs fault detection, and data collection.</simpara>
<itemizedlist>
<listitem>
<simpara>Fault detection watches and reports crashes and faults&#8212;&#8203;when the target exits prematurely,
and when the target fails to exit.</simpara>
</listitem>
<listitem>
<simpara>Data collection retrieves stack traces, logs, and other information provided by the debugger.
Note that this monitor provides bucket information&#8212;&#8203;major and minor hash values&#8212;&#8203;as part of
data collected on faults. For more information on bucketing provided by this monitor, see <link xl:href="http://msecdbg.codeplex.com/">!exploitable</link>.</simpara>
</listitem>
</itemizedlist>
<simpara>The workflow for this configuration follows:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>On the host machine, start Peach with the WindowsKernelDebugger Monitor.<?asciidoc-br?>
This action starts the fuzzing and loads a copy of Windbg in kernel mode. The
host machine enters a waiting state because the target machine will initiate and
secure the connection for the debugging session.</simpara>
</listitem>
<listitem>
<simpara>On the target machine, open Windbg, and choose "Connect to Remote Session" from the File menu.</simpara>
<itemizedlist>
<listitem>
<simpara>For the "Connection String", specify the "transport:port" and the server for the debugging session, as in this example: <literal>net:port=5000,key=1.2.3.4</literal>.<?asciidoc-br?></simpara>
</listitem>
<listitem>
<simpara>Click OK.</simpara>
</listitem>
</itemizedlist>
</listitem>
</orderedlist>
<simpara>The debug session starts on the target machine. The target machine initiates contact
with the host to establish the connection. Once the connection is secure, the host
machine (with Peach) drives the activities.</simpara>
<important>
<simpara>Instrumenting this configuration requires additional monitors external to the target. The monitors need to be able to restart the target after a crash, and to have the host resume fuzzing.</simpara>
</important>
<section xml:id="_parameters_109">
<title>Parameters</title>
<variablelist>
<varlistentry>
<term>KernelConnectionString</term>
<listitem>
<simpara>Connection string for attaching the debugger to a kernel-mode process
(e.g. a driver). The connection string <literal>net:port=5000,key=1.2.3.4</literal> indicates this is the debug server and uses the tcp transport on port 5000. The Windows debugger offers a choice of transports; and, the port is arbitrary. For more information on using other values, see MSDN articles on live kernel mode, debugging, remote debugging, and kernel connection strings.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>SymbolsPath</term>
<listitem>
<simpara>Path to the debugging symbol files. The default value is Microsoft public
symbols server <literal>SRV*http://msdl.microsoft.com/download/symbols</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>WinDbgPath</term>
<listitem>
<simpara>Path to the windbg installation. If undeclared, Peach attempts to locate a local installation of the debugger.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>ConnectTimeout</term>
<listitem>
<simpara>Duration, in milliseconds, to wait to receive a kernel connection. The default value is 3000 ms.</simpara>
<simpara><?asciidoc-pagebreak?></simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
</section>
<section xml:id="Monitors_WindowsService">
<title>WindowsService Monitor (Windows)</title>
<simpara><emphasis role="strong">Monitor Categories</emphasis>: <emphasis role="strong">Automation</emphasis>, <emphasis role="strong">Fault detection</emphasis></simpara>
<simpara>The <emphasis>WindowsService</emphasis> monitor controls a windows service. When the monitor runs, it checks
the state of the service. If the service exits prematurely, <emphasis>WindowsService</emphasis> generates a fault.
If a fault is detected by from <emphasis>windowsService</emphasis> or from another monitor, the monitor collects status of
the service and continues.</simpara>
<simpara>If the service is not running, this monitor attempts to restore the service to a running state, whether starting, restarting, or resuming from a paused state.</simpara>
<section xml:id="_parameters_110">
<title>Parameters</title>
<simpara><emphasis>Required:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>Service</term>
<listitem>
<simpara>Name that identifies the service to the system, such as the display name of the service.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>FaultOnEarlyExit</term>
<listitem>
<simpara>Fault if the service exits early, defaults to false.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>MachineName</term>
<listitem>
<simpara>Name of the computer on which the service resides, defaults to local machine.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Restart</term>
<listitem>
<simpara>Specifies whether to start the service on each iteration, defaults to false.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>StartTimeout</term>
<listitem>
<simpara>Specifies the duration, in minutes, to wait for the service to start, defaults to 1 minute.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_159">
<title>Examples</title>
<example>
<title>Start IIS</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;Agent name="Local"&gt;
	&lt;Monitor class="WindowsService"&gt;
		&lt;Param name="Service" value="World Wide Web Publishing Service" /&gt;
	&lt;/Monitor&gt;
&lt;/Agent&gt;</programlisting>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
</section>
<section xml:id="Publisher">
<title>Publishers</title>
<simpara>Publishers are the I/O interfaces Peach uses to send and receive data.</simpara>
<simpara>Publishers support both stream and call based operations.</simpara>
<simpara>When the fuzzer is running, all <link linkend="Action">Actions</link> (except <link linkend="Action_changeState">changeState</link> and <link linkend="Action_slurp">slurp</link>) use a publisher to perform the action.</simpara>
<simpara>Different publishers support a different set of Action types.  For example, the <link linkend="Publishers_File">File</link> publisher supports input for reading from a file, output for writing to a file, but does not support <link linkend="Action_accept">accept</link> or <link linkend="Action_call">call</link>. This differs from the <link linkend="Publishers_Com">COM</link> publisher which supports <link linkend="Action_call">call</link>, but not <link linkend="Action_input">input</link>, <link linkend="Action_output">output</link>, or <link linkend="Action_accept">accept</link>.</simpara>
<simpara>All fuzzing definitions must use at least one Publisher and (optionally) can use multiple Publishers.  When using multiple Publishers, each Action must specify which Publisher it is referencing by including the Publisher&#8217;s <literal>name</literal> attribute in the Action&#8217;s <literal>publisher</literal> attribute. If the <literal>publisher</literal> attribute is missing, Peach
performs the Action using the first Publisher defined in the Test.</simpara>
<section xml:id="_network_publishers">
<title>Network Publishers</title>
<simpara>When fuzzing network protocols, publishers typically uses the protocol that encompasses (operates one layer below) the target protocol. For example, when fuzzing the HTTP protocol, use the <link linkend="Publishers_Tcp">TCP</link> publisher.  When fuzzing TCP, use either the <link linkend="Publishers_RawV4">RawV4</link> or <link linkend="Publishers_RawV6">RawV6</link> publisher. When fuzzing IPv4 and IPv6, use the <link linkend="Publishers_RawEther">RawEther</link> publisher.</simpara>
</section>
<section xml:id="_publishers">
<title>Publishers</title>
<itemizedlist>
<listitem>
<simpara><link linkend="Publishers_AndroidMonkey">AndroidMonkey</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="Publishers_CAN">CAN</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="Publishers_Com">Com</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="Publishers_Console">Console</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="Publishers_ConsoleHex">ConsoleHex</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="Publishers_File">File</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="Publishers_FilePerIteration">FilePerIteration</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="Publishers_Http">Http</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="Publishers_I2C">I2C</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="Publishers_RawEther">RawEther</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="Publishers_RawIPv4">RawIPv4</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="Publishers_RawV4">RawV4</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="Publishers_RawV6">RawV6</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="Publishers_Remote">Remote</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="Publishers_Rest">Rest</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="Publishers_SerialPort">SerialPort</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="Publishers_Ssl">SslClient</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="Publishers_SslListener">SslListener</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="Publishers_Tcp">TcpClient</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="Publishers_TcpListener">TcpListener</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="Publishers_Udp">Udp</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="Publishers_Usb">Usb</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="Publishers_WebApi">WebApi</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="Publishers_WebService">WebService</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="Publishers_WebSocket">WebSocket</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="Publishers_Zip">Zip</link></simpara>
</listitem>
</itemizedlist>
<note>
<simpara>A full list of publishers and parameter information for any
specific version can be found in the output of <literal>peach --showenv</literal></simpara>
</note>
</section>
<section xml:id="_syntax_91">
<title>Syntax</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;Test name="Default"&gt;
  &lt;!-- ... --&gt;
	&lt;Publisher class="ConsoleHex"&gt;
	  &lt;Param name="BytesPerLine" value="32"/&gt;
	&lt;/Publisher&gt;
  &lt;!-- ... --&gt;
&lt;/Test&gt;</programlisting>
</section>
<section xml:id="_examples_160">
<title>Examples</title>
<example>
<title>Multiple Publishers</title>
<simpara>Many of the licensed Pits use a single publisher; and, some Pits use multiple publishers. Peach imposes no limit on the number of publishers to use in a Pit.</simpara>
<simpara>For example, you might use multiple publishers to communicate with a network service that listens on multiple ports:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
			 xsi:schemaLocation="http://peachfuzzer.com/2012/Peach /peach/peach.xsd"&gt;

	&lt;DataModel name="Hello"&gt;
		&lt;Blob value="Hello Server"/&gt;
	&lt;/DataModel&gt;

	&lt;DataModel name="Goodbye"&gt;
		&lt;Blob value="Goodbye Server"/&gt;
	&lt;/DataModel&gt;

	&lt;StateModel name="TheState" initialState="Initial"&gt;
		&lt;State name="Initial"&gt;
			&lt;Action type="output" publisher="FirstPort"&gt;
				&lt;DataModel ref="Hello"/&gt;
			&lt;/Action&gt;
			&lt;Action type="output" publisher="SecondPort"&gt;
				&lt;DataModel  ref="Goodbye"/&gt;
			&lt;/Action&gt;
		&lt;/State&gt;
	&lt;/StateModel&gt;
	&lt;Agent name="TheAgent" /&gt;
	&lt;Test name="Default"&gt;
		&lt;Agent ref="TheAgent"/&gt;
		&lt;StateModel ref="TheState"/&gt;
		&lt;Publisher class="Tcp" name="FirstPort"&gt;
			&lt;Param name="Host" value="localhost"/&gt;
			&lt;Param name="Port" value="12345"/&gt;
		&lt;/Publisher&gt;
		&lt;Publisher class="Tcp" name="SecondPort"&gt;
			&lt;Param name="Host" value="localhost"/&gt;
			&lt;Param name="Port" value="54321"/&gt;
		&lt;/Publisher&gt;
	&lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<screen>$ peach -1 --debug TwoPublisher.xml

[*] Test 'Default' starting with random seed 9324.
Peach.Core.MutationStrategies.RandomStrategy Iteration: Switch iteration, setting controlIteration and controlRecordingIteration.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Updating action to original data model
Peach.Core.Dom.Action Updating action to original data model
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.TcpClientPublisher start()
Peach.Core.Publishers.TcpClientPublisher open()
Peach.Core.Publishers.TcpClientPublisher output(12 bytes)
Peach.Core.Publishers.TcpClientPublisher

00000000   48 65 6C 6C 6F 20 53 65  72 76 65 72               Hello Server

Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.TcpClientPublisher start()
Peach.Core.Publishers.TcpClientPublisher open()
Peach.Core.Publishers.TcpClientPublisher output(14 bytes)
Peach.Core.Publishers.TcpClientPublisher

00000000   47 6F 6F 64 62 79 65 20  53 65 72 76 65 72         Goodbye Server

Peach.Core.Publishers.TcpClientPublisher close()
Peach.Core.Publishers.TcpClientPublisher Shutting down connection to 127.0.0.1:12345
Peach.Core.Publishers.TcpClientPublisher Read 0 bytes from 127.0.0.1:12345, closing client connection.
Peach.Core.Publishers.TcpClientPublisher Closing connection to 127.0.0.1:12345
Peach.Core.Publishers.TcpClientPublisher close()
Peach.Core.Publishers.TcpClientPublisher Shutting down connection to 127.0.0.1:54321
Peach.Core.Publishers.TcpClientPublisher Read 0 bytes from 127.0.0.1:54321, closing client connection.
Peach.Core.Publishers.TcpClientPublisher Closing connection to 127.0.0.1:54321
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.TcpClientPublisher stop()
Peach.Core.Publishers.TcpClientPublisher stop()

[*] Test 'Default' finished.</screen>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
<section xml:id="Publishers_AndroidMonkey">
<title>AndroidMonkey Publisher</title>
<simpara>The <emphasis>AndroidMonkey</emphasis> publisher is used to communicate with both Android emulators and physicals devices.</simpara>
<simpara><emphasis>AndroidMonkey</emphasis> allows you to fuzz text inputs, screen touches and key presses. By using additional Android monitors, you can target specific Android applications for fuzzing and monitoring.</simpara>
<section xml:id="_syntax_92">
<title>Syntax</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;Publisher class="AndroidMonkey"&gt;
    &lt;Param name="DeviceMonitor" value="App"/&gt;
&lt;/Publisher&gt;</programlisting>
</section>
<section xml:id="_parameters_111">
<title>Parameters</title>
<simpara><emphasis>Required:</emphasis></simpara>
<simpara>One of the following parameters is required.</simpara>
<variablelist>
<varlistentry>
<term>DeviceSerial</term>
<listitem>
<simpara>The serial of the device to fuzz.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>DeviceMonitor</term>
<listitem>
<simpara>Android monitor to get device serial from.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>AdbPath</term>
<listitem>
<simpara>Directory containing adb.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>ConnectTimeout</term>
<listitem>
<simpara>Max seconds to wait for adb connection. Defaults to 5.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>CommandTimeout</term>
<listitem>
<simpara>Max seconds to wait for adb command to complete. Defaults to 10.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_actions">
<title>Actions</title>
<variablelist>
<varlistentry>
<term><link linkend="Action_start">start</link></term>
<listitem>
<simpara>Implicit Action to start the Publisher.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_stop">stop</link></term>
<listitem>
<simpara>Implicit Action to stop the Publisher.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_call">call</link></term>
<listitem>
<simpara>This publisher supports several methods that result in different user interactions occurring. <?asciidoc-br?></simpara>
<variablelist>
<varlistentry>
<term>tap </term>
<listitem>
<simpara>Specify on an X,Y coordinate on the screen. Requires two parameters providing a numerical value for X and Y.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>keyevent</term>
<listitem>
<simpara>Send a key press to the target device. Requires a single string parameter. The parameter corresponds to the keyevent byte code used to for android key mapping. The entire list of android keyevent codes can be found <link xl:href="http://developer.android.com/reference/android/view/KeyEvent.html">here</link>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>text</term>
<listitem>
<simpara>Enter in text into a text field. Requires a single parameter with the text to enter.</simpara>
</listitem>
</varlistentry>
</variablelist>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_161">
<title>Examples</title>
<example>
<title>Basic Usage Example</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

  &lt;DataModel name="TheDataModel"&gt;
    &lt;Number size='32' signed="false" value="31337" /&gt;
  &lt;/DataModel&gt;

  &lt;DataModel name="X"&gt;
    &lt;Number size='32' signed="false" value="230" /&gt;
  &lt;/DataModel&gt;

  &lt;DataModel name="Y"&gt;
    &lt;Number size='32' signed="false" value="150" /&gt;
  &lt;/DataModel&gt;

  &lt;StateModel name="State" initialState="Initial" &gt;
    &lt;State name="Initial"  &gt;
      &lt;Action type="call" method="OpenApplication" publisher="Peach.Agent"/&gt;

      &lt;Action type="call" method="tap"&gt;
        &lt;Param&gt;
          &lt;DataModel ref="X"/&gt;
        &lt;/Param&gt;
        &lt;Param&gt;
          &lt;DataModel ref="Y"/&gt;
        &lt;/Param&gt;
      &lt;/Action&gt;
    &lt;/State&gt;
  &lt;/StateModel&gt;

  &lt;Agent name="TheAgent"&gt;
    &lt;Monitor name="Emu" class="AndroidEmulator"&gt;
      &lt;Param name="Avd" value="unused" /&gt;
      &lt;Param name="EmulatorPath" value="C:\adt-bundle-windows-x86_64-20131030\sdk\tools"/&gt;
    &lt;/Monitor&gt;

    &lt;Monitor name="App" class="Android"&gt;
      &lt;Param name="ApplicationName" value="com.android.development" /&gt;
      &lt;Param name="ActivityName" value=".BadBehaviorActivity" /&gt;
      &lt;Param name="AdbPath" value="C:\adt-bundle-windows-x86_64-20131030\sdk\platform-tools"/&gt;
      &lt;Param name="StartOnCall" value="OpenApplication"/&gt;
      &lt;Param name="DeviceMonitor" value="Emu" /&gt;
    &lt;/Monitor&gt;
  &lt;/Agent&gt;

  &lt;Test name="Default"&gt;
    &lt;StateModel ref="State"/&gt;
    &lt;Agent ref="TheAgent" /&gt;

    &lt;Publisher class="AndroidMonkey"&gt;
      &lt;Param name="DeviceMonitor" value="App"/&gt;
    &lt;/Publisher&gt;
  &lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Publishers_CAN">
<title>CAN Publisher</title>
<simpara>Use the <emphasis>CAN</emphasis> Publisher to read and write bytes directly to and from a CAN bus.</simpara>
<simpara><emphasis>CAN</emphasis> is designed to interface with the TotalPhase Komodo CAN SOLO or DUO (USB) Host Adapter.</simpara>
<section xml:id="_syntax_93">
<title>Syntax</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;Publisher class="CAN"&gt;
  &lt;Param name="ID" value="5"/&gt;
&lt;/Publisher&gt;</programlisting>
</section>
<section xml:id="_parameters_112">
<title>Parameters</title>
<simpara><emphasis>Required:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>ID</term>
<listitem>
<simpara>The CAN identifier used for for transmission and reception</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>RTR</term>
<listitem>
<simpara>Is the frame requesting the transmission of a specific identifier.  This parameter only effects output and does not effect input.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>ExtendedFrame</term>
<listitem>
<simpara>Should extended frame format be used.  This parameter only effects output and does not effect input.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>SerialNumber</term>
<listitem>
<simpara>Serial number of Komodo CAN Interface to use.  If omitted the first available interface will be used.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Bitrate</term>
<listitem>
<simpara>Controls the bitrate used for transmission and reception of CAN frames. Defaults to 125000 bps.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Timeout</term>
<listitem>
<simpara>How long to wait in milliseconds for incoming data to arrive. Defaults to 3000 ms.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>SendTimeout</term>
<listitem>
<simpara>How long to wait in milliseconds for outgoing data to send. Defaults to 3000 ms.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_actions_2">
<title>Actions</title>
<variablelist>
<varlistentry>
<term><link linkend="Action_start">start</link></term>
<listitem>
<simpara>Open and initialize the Komodo device.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_stop">stop</link></term>
<listitem>
<simpara>Close and clean up the Komodo device.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_open">open</link></term>
<listitem>
<simpara>Enable the CAN port on the Komodo device.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_close">close</link></term>
<listitem>
<simpara>Disable the CAN port on the Komodo device.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_output">output</link></term>
<listitem>
<simpara>Data sent via output is written to the CAN bus.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_input">input</link></term>
<listitem>
<simpara>Data received via input is read from the CAN bus.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_162">
<title>Examples</title>
<example>
<title>Read ADC from TotalPhase CAN Activity Board Pro</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;Peach&gt;
  &lt;StateModel name='SM' initialState='Initial'&gt;
    &lt;State name='Initial'&gt;
      &lt;!-- Send query to ADC --&gt;
      &lt;Action type='output'&gt;
        &lt;DataModel name='DM' /&gt;
      &lt;/Action&gt;

      &lt;!-- Read response --&gt;
      &lt;Action type='input'&gt;
        &lt;DataModel name='DM'&gt;
          &lt;Blob length='3' /&gt;
        &lt;/DataModel&gt;
      &lt;/Action&gt;
    &lt;/State&gt;
  &lt;/StateModel&gt;

  &lt;Test name='Default'&gt;
    &lt;StateModel ref='SM' /&gt;
    &lt;Publisher class='CAN'&gt;
      &lt;Param name='ID' value='66' /&gt;
      &lt;Param name='RTR' value='true' /&gt;
    &lt;/Publisher&gt;
  &lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
</example>
<example>
<title>Write LCD on TotalPhase CAN Activity Board Pro</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;Peach&gt;
  &lt;DataModel name='DM'&gt;
    &lt;Number name='index' size='8' /&gt;
    &lt;String name='value' length='4' /&gt;
  &lt;/DataModel&gt;

  &lt;StateModel name='SM' initialState='Initial'&gt;
    &lt;State name='Initial'&gt;
      &lt;Action type='output'&gt;
        &lt;DataModel ref='DM' /&gt;
        &lt;Data&gt;
          &lt;Field name='index' value='0' /&gt;
          &lt;Field name='value' value='abcd' /&gt;
        &lt;/Data&gt;
      &lt;/Action&gt;
      &lt;Action type='output'&gt;
        &lt;DataModel ref='DM' /&gt;
        &lt;Data&gt;
          &lt;Field name='index' value='1' /&gt;
          &lt;Field name='value' value='efgh' /&gt;
        &lt;/Data&gt;
      &lt;/Action&gt;
    &lt;/State&gt;
  &lt;/StateModel&gt;

  &lt;Test name='Default'&gt;
    &lt;StateModel ref='SM' /&gt;
    &lt;Publisher class='CAN'&gt;
      &lt;Param name='ID' value='322' /&gt;
    &lt;/Publisher&gt;
  &lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Publishers_Com">
<title>Com Publisher</title>
<simpara>The <emphasis>Com</emphasis> Publisher allows calling methods and properties on COM objects. Properties and Methods correlate directly to those in the corresponding COM definition.</simpara>
<simpara>The <link linkend="Action_setProperty">setProperty</link> and <link linkend="Action_getProperty">getProperty</link> Actions can only accept Strings or Numbers because binary arrays are incompatible with COM Properties.</simpara>
<note>
<simpara><emphasis>Com</emphasis> Publisher only runs on Windows.</simpara>
</note>
<simpara>To use <emphasis>Com</emphasis>, Peach.Core.ComContainer.exe must be running in a separate command prompt (so it can host the COM object) while the Peach is running.</simpara>
<simpara>You can configure a debugger monitor to launch and monitor this process. See the <link linkend="Monitors_WindowsDebugger">WindowsDebugger</link> monitor for more information about configuring a debugger monitor.</simpara>
<section xml:id="_syntax_94">
<title>Syntax</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;Publisher class="COM"&gt;
	&lt;Param name="clsid" value="{d20ea4e1-3957-11d2-a40b-0c5020524153}" /&gt;
&lt;/Publisher&gt;</programlisting>
</section>
<section xml:id="_parameters_113">
<title>Parameters</title>
<simpara><emphasis>Required:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>clsid</term>
<listitem>
<simpara>COM CLSID</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Optional:</emphasis></simpara>
<simpara>There are no optional parameters for this publisher.</simpara>
</section>
<section xml:id="_actions_3">
<title>Actions</title>
<variablelist>
<varlistentry>
<term><link linkend="Action_start">start</link></term>
<listitem>
<simpara>Implicit Action to start the Publisher.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_stop">stop</link></term>
<listitem>
<simpara>Implicit Action to stop the Publisher.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_call">call</link></term>
<listitem>
<simpara>Call a method</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_getProperty">getProperty</link></term>
<listitem>
<simpara>Get a property value</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_setProperty">setProperty</link></term>
<listitem>
<simpara>Set a property value</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_163">
<title>Examples</title>
<example>
<title>Calling a method</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

	&lt;DataModel name="CoolThingsModel"&gt;
		&lt;String name="Username" value="username=user"/&gt;
		&lt;String name="Comma" value=","/&gt;
		&lt;String name="Password" value="password=admin"/&gt;
	&lt;/DataModel&gt;

	&lt;StateModel name="TheStateModel"&gt;
		&lt;State name="initial"&gt;
			&lt;Action type="call" method="DoCoolThings"&gt;
				&lt;Param name="AuthString"&gt;
					&lt;DataModel ref="CoolThingsModel"/&gt;
				&lt;/Param&gt;
			&lt;/Action&gt;
		&lt;/State&gt;
	&lt;/StateModel&gt;

	&lt;Test name="Default"&gt;
		&lt;StateModel ref=="TheStateModel" /&gt;
		&lt;Publisher class="COM"&gt;
			&lt;Param name="clsid" value="{d20ea4e1-3957-11d2-a40b-0c5020524153}" /&gt;
		&lt;/Publisher&gt;
	&lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
</example>
<example>
<title>Setting/Getting Properties</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://peachfuzzer.com/2012/Peach /peach/peach.xsd"&gt;

	&lt;DataModel name="TheDataModel"&gt;
		&lt;String name="Value" /&gt;
	&lt;/DataModel&gt;

	&lt;StateModel name="TheState" initialState="Initial"&gt;
		&lt;State name="Initial"&gt;

			&lt;Action type="call" method="Players[1].OpenUrl"&gt;
				&lt;Param name="P1"&gt;
					&lt;DataModel ref="TheDataModel" /&gt;
					&lt;Data&gt;
						&lt;Field name="Value" value="C:\labs\com\boymgirl.mov"/&gt;
					&lt;/Data&gt;
				&lt;/Param&gt;
			&lt;/Action&gt;

			&lt;Action type="setProperty" property="Players[1].QTControl.Movie.Height"&gt;
				&lt;DataModel ref="TheDataModel" /&gt;
				&lt;Data&gt;
					&lt;Field name="Value" value="200"/&gt;
				&lt;/Data&gt;
			&lt;/Action&gt;

			&lt;Action type="setProperty" property="Players[1].QTControl.Movie.Width"&gt;
				&lt;DataModel ref="TheDataModel" /&gt;
				&lt;Data&gt;
					&lt;Field name="Value" value="500"/&gt;
				&lt;/Data&gt;
			&lt;/Action&gt;

			&lt;Action type="call" method="Players[1].QTControl.Movie.Play" /&gt;
		&lt;/State&gt;
	&lt;/StateModel&gt;

	&lt;Test name="Default"&gt;
		&lt;StateModel ref="TheState"/&gt;
		&lt;Publisher class="Com"&gt;
			&lt;Param name="clsid" value="QuickTimePlayerLib.QuickTimePlayerApp"/&gt;
		&lt;/Publisher&gt;
	&lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Publishers_Console">
<title>Console Publisher</title>
<simpara>The <emphasis>Console</emphasis> publisher outputs data to standard out.</simpara>
<section xml:id="_syntax_95">
<title>Syntax</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;Publisher class="Console" /&gt;</programlisting>
</section>
<section xml:id="_parameters_114">
<title>Parameters</title>
<simpara>There are no parameters for this publisher.</simpara>
</section>
<section xml:id="_actions_4">
<title>Actions</title>
<variablelist>
<varlistentry>
<term><link linkend="Action_open">open</link></term>
<listitem>
<simpara>Initialize stream to standard out.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_close">close</link></term>
<listitem>
<simpara>Close stream to standard out.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_output">output</link></term>
<listitem>
<simpara>Data sent via output is written to the console.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_164">
<title>Examples</title>
<example>
<title>Display data to console</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

  &lt;DataModel name="Data"&gt;
    &lt;String name="Start" value="Start"/&gt;
    &lt;Blob name="Data" valueType="hex" value="BEEFEA7E41"/&gt;
    &lt;String name="Stop" value="Stop"/&gt;
  &lt;/DataModel&gt;

  &lt;StateModel name="TheState" initialState="initial"&gt;
    &lt;State name="initial"&gt;
      &lt;Action type="output"&gt;
        &lt;DataModel ref="Data" /&gt;
      &lt;/Action&gt;
    &lt;/State&gt;
  &lt;/StateModel&gt;

  &lt;Test name="Default"&gt;
    &lt;StateModel ref="TheState"/&gt;
    &lt;Publisher class="Console" /&gt;
  &lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Publishers_ConsoleHex">
<title>ConsoleHex Publisher</title>
<simpara>The <emphasis>ConsoleHex</emphasis> publisher outputs data to standard out.  The data is displayed in hex format.</simpara>
<section xml:id="_syntax_96">
<title>Syntax</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;Publisher class="ConsoleHex"/&gt;</programlisting>
</section>
<section xml:id="_parameters_115">
<title>Parameters</title>
<simpara><emphasis>Required:</emphasis></simpara>
<simpara>There are no required parameters for this publisher.</simpara>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>BytesPerLine</term>
<listitem>
<simpara>Number of bytes per row of text (optional, defaults to 16)</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_actions_5">
<title>Actions</title>
<variablelist>
<varlistentry>
<term><link linkend="Action_open">open</link></term>
<listitem>
<simpara>Initialize stream to standard out.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_close">close</link></term>
<listitem>
<simpara>Close stream to standard out.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_output">output</link></term>
<listitem>
<simpara>Data sent via output is written to the console.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_165">
<title>Examples</title>
<example>
<title>Display data to console</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

  &lt;DataModel name="Data"&gt;
    &lt;String name="Start" value="Start"/&gt;
    &lt;Blob name="Data" valueType="hex" value="BEEFEA7E41"/&gt;
    &lt;String name="Stop" value="Stop"/&gt;
  &lt;/DataModel&gt;

  &lt;StateModel name="TheState" initialState="initial"&gt;
    &lt;State name="initial"&gt;
      &lt;Action type="output"&gt;
        &lt;DataModel ref="Data" /&gt;
      &lt;/Action&gt;
    &lt;/State&gt;
  &lt;/StateModel&gt;

  &lt;Test name="Default"&gt;
    &lt;StateModel ref="TheState"/&gt;
    &lt;Publisher class="ConsoleHex"/&gt;
  &lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
</example>
<example>
<title>Display data with custom bytes per line</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

  &lt;DataModel name="Data"&gt;
    &lt;String name="Start" value="Start"/&gt;
    &lt;Blob name="Data" valueType="hex" value="BEEFEA7E41"/&gt;
    &lt;String name="Stop" value="Stop"/&gt;
  &lt;/DataModel&gt;

  &lt;StateModel name="TheState" initialState="initial"&gt;
    &lt;State name="initial"&gt;
      &lt;Action type="output"&gt;
        &lt;DataModel ref="Data" /&gt;
      &lt;/Action&gt;
    &lt;/State&gt;
  &lt;/StateModel&gt;

  &lt;Test name="Default"&gt;
    &lt;StateModel ref="TheState"/&gt;
    &lt;Publisher class="ConsoleHex"&gt;
      &lt;Param name="BytesPerLine" value="8" /&gt;
    &lt;/Publisher&gt;
  &lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Publishers_File">
<title>File Publisher</title>
<simpara>The <emphasis>File</emphasis> publisher opens a file for reading or writing.</simpara>
<section xml:id="_syntax_97">
<title>Syntax</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;Publisher class="File"&gt;
    &lt;Param name="FileName" value="fuzzed.bin" /&gt;
&lt;/Publisher&gt;</programlisting>
</section>
<section xml:id="_parameters_116">
<title>Parameters</title>
<simpara><emphasis>Required:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>FileName</term>
<listitem>
<simpara>Name of file to open</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>Overwrite</term>
<listitem>
<simpara>Overwrite existing files, defaults to true.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Append</term>
<listitem>
<simpara>Append data to existing file, defaults to false.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_actions_6">
<title>Actions</title>
<variablelist>
<varlistentry>
<term><link linkend="Action_open">open</link></term>
<listitem>
<simpara>Open file for reading/writing.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_close">close</link></term>
<listitem>
<simpara>Close file stream.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_output">output</link></term>
<listitem>
<simpara>Data to be written to file</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_input">input</link></term>
<listitem>
<simpara>Read data from file.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_166">
<title>Examples</title>
<example>
<title>Write to file</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach ../peach.xsd"&gt;

  &lt;DataModel name="TheDataModel"&gt;
    &lt;Number name="Magic" size="8" value="47" token="true"/&gt;
    &lt;Number name="Length" size="8"&gt;
      &lt;Relation type="size" of="Data"/&gt;
    &lt;/Number&gt;
    &lt;Blob name="Data"/&gt;
  &lt;/DataModel&gt;

  &lt;StateModel name="TheState" initialState="initial"&gt;
    &lt;State name="initial"&gt;
      &lt;Action type="output"&gt;
        &lt;DataModel ref="TheDataModel" /&gt;
        &lt;Data fileName="file.bin" /&gt;
      &lt;/Action&gt;
    &lt;/State&gt;
  &lt;/StateModel&gt;

  &lt;Test name="Default"&gt;
    &lt;StateModel ref="TheState"/&gt;
    &lt;Publisher class="File"&gt;
      &lt;Param name="FileName" value="fuzzed.bin" /&gt;
    &lt;/Publisher&gt;
  &lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
</example>
<example>
<title>Read from file</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach ../peach.xsd"&gt;

  &lt;DataModel name="TheDataModel"&gt;
    &lt;Number name="Magic" size="8" value="47" token="true"/&gt;
    &lt;Number name="Length" size="8"&gt;
      &lt;Relation type="size" of="Data"/&gt;
    &lt;/Number&gt;
    &lt;Blob name="Data"/&gt;
  &lt;/DataModel&gt;

  &lt;StateModel name="TheState" initialState="initial"&gt;
    &lt;State name="initial"&gt;
      &lt;Action type="input"&gt;
        &lt;DataModel ref="TheDataModel" /&gt;
      &lt;/Action&gt;
    &lt;/State&gt;
  &lt;/StateModel&gt;

  &lt;Test name="Default"&gt;
    &lt;StateModel ref="TheState"/&gt;
    &lt;Publisher class="File"&gt;
      &lt;Param name="FileName" value="file.bin" /&gt;
      &lt;Param name="Overwrite" value="False"/&gt;
    &lt;/Publisher&gt;
  &lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Publishers_FilePerIteration">
<title>FilePerIteration Publisher</title>
<simpara>The <emphasis>FilePerIteration</emphasis> publisher creates an output file for each fuzzer iteration.</simpara>
<simpara>Use <emphasis>FilePerIteration</emphasis> when pre-generating fuzzing cases.</simpara>
<simpara>When generating the fuzzed files, Peach appends the iteration number to the fuzzed files name.  For a file name format of "fuzzed_{0}.bin" the {0} will be replaced with the current iteration number which produces the following filenames: fuzzed_1.bin, fuzzed_2.bin, fuzzed_3.bin, fuzzed_4.bin, etc.</simpara>
<section xml:id="_syntax_98">
<title>Syntax</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;Publisher class="FilePerIteration"&gt;
    &lt;Param name="FileName" value="fuzzed_{0}.bin" /&gt;
&lt;/Publisher&gt;</programlisting>
</section>
<section xml:id="_parameters_117">
<title>Parameters</title>
<simpara><emphasis>Required:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>FileName</term>
<listitem>
<simpara>Name of file to create.  Filename must contain "{0}" which will be substituted with the iteration count.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Optional:</emphasis></simpara>
<simpara>There are no optional parameters for this publisher.</simpara>
</section>
<section xml:id="_actions_7">
<title>Actions</title>
<variablelist>
<varlistentry>
<term><link linkend="Action_open">open</link></term>
<listitem>
<simpara>Open file for reading/writing</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_close">close</link></term>
<listitem>
<simpara>Close file stream</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_output">output</link></term>
<listitem>
<simpara>Data to be written to file</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_input">input</link></term>
<listitem>
<simpara>Read data from file</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_167">
<title>Examples</title>
<example>
<title>Basic Usage Example</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

  &lt;DataModel name="TheDataModel"&gt;
    &lt;Number name="Magic" size="8" value="47" token="true"/&gt;
    &lt;Number name="Length" size="8"&gt;
      &lt;Relation type="size" of="Data"/&gt;
    &lt;/Number&gt;
    &lt;Blob name="Data"/&gt;
  &lt;/DataModel&gt;

  &lt;StateModel name="TheState" initialState="initial"&gt;
    &lt;State name="initial"&gt;
      &lt;Action type="output"&gt;
        &lt;DataModel ref="TheDataModel" /&gt;
        &lt;Data fileName="file.bin"/&gt;
      &lt;/Action&gt;
    &lt;/State&gt;
  &lt;/StateModel&gt;

  &lt;Test name="Default"&gt;
    &lt;StateModel ref="TheState"/&gt;
    &lt;Publisher class="FilePerIteration"&gt;
      &lt;Param name="FileName" value="fuzzed_{0}.bin" /&gt;
    &lt;/Publisher&gt;
  &lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Publishers_Http">
<title>Http Publisher (Depricated)</title>
<simpara>This publisher is depricated, please see <link linkend="Publishers_WebApi">WebApi publisher</link>.</simpara>
<simpara><emphasis>Http</emphasis> publisher sends data over HTTP via a valid HTTP method type.</simpara>
<simpara><emphasis>Http</emphasis> supports the following features:</simpara>
<itemizedlist>
<listitem>
<simpara>Authentication via Basic, Digest, or Windows integrated</simpara>
</listitem>
<listitem>
<simpara>Definable method type</simpara>
</listitem>
<listitem>
<simpara>Fuzzing and dynamic setting of headers (both key and value)</simpara>
</listitem>
<listitem>
<simpara>Fuzzing and dynamic setting of query strings</simpara>
</listitem>
<listitem>
<simpara>Optional cookie support</simpara>
</listitem>
<listitem>
<simpara>SSL</simpara>
</listitem>
</itemizedlist>
<simpara>See also the <link linkend="Publishers_WebApi">WebApi</link> publisher.</simpara>
<section xml:id="_syntax_99">
<title>Syntax</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;Publisher class="Http"&gt;
    &lt;Param name="Method" value="POST" /&gt;
    &lt;Param name="Url" value="http://foo/user/create" /&gt;
&lt;/Publisher&gt;</programlisting>
</section>
<section xml:id="_parameters_118">
<title>Parameters</title>
<simpara><emphasis>Required:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>Method</term>
<listitem>
<simpara>HTTP Method type (like GET and POST)</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Url</term>
<listitem>
<simpara>URL of target</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>BaseUrl</term>
<listitem>
<simpara>Base URL is used by some authentication types</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Username</term>
<listitem>
<simpara>Username for authentication</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Domain</term>
<listitem>
<simpara>Domain for authentication</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Cookies</term>
<listitem>
<simpara>Enable cookie support. Defaults to true.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>CookiesAcrossIterations</term>
<listitem>
<simpara>Track cookies across iterations. Defaults to false.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>FailureStatusCodes</term>
<listitem>
<simpara>Comma separated list of status codes that are failures causing current test case to stop.
Defaults to: <literal>400,401,402,403,404,405,406,407,408,409,410,411,412,413,414,415,416,417,500,501,502,503,504,505</literal></simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>FaultOnStatusCodes</term>
<listitem>
<simpara>Comma separated list of status codes that are faults. Defaults to none.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Timeout</term>
<listitem>
<simpara>How long to wait in milliseconds for data/connection. Defaults to 3,000.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>IgnoreCertErrors</term>
<listitem>
<simpara>Allow HTTPS regardless of cert status. Defaults to false.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Proxy</term>
<listitem>
<simpara>To use HTTP proxy, set the URL. Default is none. Example: <literal><link xl:href="http://192.168.1.1:8080">http://192.168.1.1:8080</link></literal>.<?asciidoc-br?>
<?asciidoc-br?>
The publisher will not use the default system proxy.
If a proxy is required it must be explicitly set via the publisher parameter.<?asciidoc-br?>
<?asciidoc-br?>
Please note that the host <literal>localhost</literal> and IP 127.0.0.1 will bypass the provided proxy. This is a behavior hardcoded into the underlying http networking code. For a discussion of options to deal with this limitation see the following article: <link xl:href="http://docs.telerik.com/fiddler/Configure-Fiddler/Tasks/MonitorLocalTraffic">Fiddler - Monitoring Local Traffic</link>.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_actions_8">
<title>Actions</title>
<variablelist>
<varlistentry>
<term><link linkend="Action_call">call</link></term>
<listitem>
<simpara>Special method names used to fuzz the query string or a specific header. <?asciidoc-br?></simpara>
<variablelist>
<varlistentry>
<term>Query</term>
<listitem>
<simpara>Specify as the method name for a call action, the first parameter is the query string</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Header</term>
<listitem>
<simpara>Specify as the method name for a call action, the first parameter is the header name, the second is the value</simpara>
</listitem>
</varlistentry>
</variablelist>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_start">start</link></term>
<listitem>
<simpara>Implicit Action to start the Publisher.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_stop">stop</link></term>
<listitem>
<simpara>Implicit Action to stop the Publisher.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_open">open</link></term>
<listitem>
<simpara>Open and initialize the socket.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_close">close</link></term>
<listitem>
<simpara>Close and clean up the socket.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_output">output</link></term>
<listitem>
<simpara>Data sent via output is written to the open socket.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_input">input</link></term>
<listitem>
<simpara>Data received via input is read from the open socket.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_scripting">
<title>Scripting</title>
<simpara>The Http publisher exposes a public Headers dictionary that can be used to add/remove headers from Python scripting code.  See the <link linkend="Publishers_WebApi">WebApi</link> publisher examples.</simpara>
</section>
<section xml:id="_examples_168">
<title>Examples</title>
<example>
<title>HTTP POST Request</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

  &lt;DataModel name="PostBody"&gt;
    &lt;String name="Username" value="username=user"/&gt;
    &lt;String name="Comma" value=","/&gt;
    &lt;String name="Password" value="password=admin"/&gt;
  &lt;/DataModel&gt;

  &lt;StateModel name="TheState" initialState="initial"&gt;
    &lt;State name="initial"&gt;
      &lt;Action type="output"&gt;
        &lt;DataModel ref="PostBody" /&gt;
      &lt;/Action&gt;
    &lt;/State&gt;
  &lt;/StateModel&gt;

  &lt;Test name="Default"&gt;
    &lt;StateModel ref="TheState"/&gt;
    &lt;Publisher class="Http"&gt;
      &lt;Param name="Method" value="POST" /&gt;
      &lt;Param name="Url" value="http://foo/user/create" /&gt;
    &lt;/Publisher&gt;
  &lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
</example>
<example>
<title>HTTP GET Request</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

  &lt;DataModel name="TheDataModel"&gt;
     &lt;Blob/&gt;
  &lt;/DataModel&gt;

  &lt;StateModel name="TheState" initialState="initial"&gt;
    &lt;State name="initial"&gt;
      &lt;Action type="input" &gt;
          &lt;DataModel ref="TheDataModel" /&gt;
      &lt;/Action&gt;
    &lt;/State&gt;
  &lt;/StateModel&gt;

  &lt;Test name="Default"&gt;
    &lt;StateModel ref="TheState"/&gt;
    &lt;Publisher class="Http"&gt;
      &lt;Param name="Method" value="GET" /&gt;
      &lt;Param name="Url" value="http://foo/user/create" /&gt;
    &lt;/Publisher&gt;
  &lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
</example>
<example>
<title>Fuzzing HTTP GET Request Query String</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

 &lt;DataModel name="QueryModel"&gt;
   &lt;String value="key"/&gt;
   &lt;String value="=" token="true" /&gt;
   &lt;String value="value"/&gt;
  &lt;/DataModel&gt;

  &lt;DataModel name="GetInputModel"&gt;
    &lt;Blob/&gt;
  &lt;/DataModel&gt;

  &lt;StateModel name="TheState" initialState="initial"&gt;
    &lt;State name="initial"&gt;
      &lt;Action type="call" method="Query"&gt;
        &lt;Param&gt;
          &lt;DataModel ref="QueryModel" /&gt;
        &lt;/Param&gt;
      &lt;/Action&gt;

      &lt;Action type="input"&gt;
        &lt;DataModel ref="GetInputModel"/&gt;
      &lt;/Action&gt;
    &lt;/State&gt;
  &lt;/StateModel&gt;

  &lt;Test name="Default"&gt;
    &lt;StateModel ref="TheState"/&gt;
    &lt;Publisher class="Http"&gt;
      &lt;Param name="Method" value="GET" /&gt;
      &lt;Param name="Url" value="http://foo/user/create" /&gt;
    &lt;/Publisher&gt;
  &lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
</example>
<example>
<title>Fuzzing Cookie Value in Header</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

  &lt;DataModel name="HeaderKey"&gt;
   &lt;String value="Cookie" /&gt;
  &lt;/DataModel&gt;

  &lt;DataModel name="HeaderValue"&gt;
     &lt;String value="user=newuesr" /&gt;
  &lt;/DataModel&gt;

  &lt;DataModel name="GetInputModel"&gt;
    &lt;Blob/&gt;
  &lt;/DataModel&gt;

  &lt;StateModel name="TheState" initialState="initial"&gt;
    &lt;State name="initial"&gt;
      &lt;Action type="call" method="Header"&gt;
        &lt;Param&gt;
          &lt;DataModel ref="HeaderKey" /&gt;
        &lt;/Param&gt;
        &lt;Param&gt;
          &lt;DataModel ref="HeaderValue" /&gt;
        &lt;/Param&gt;
      &lt;/Action&gt;

      &lt;Action type="input"&gt;
        &lt;DataModel ref="GetInputModel"/&gt;
      &lt;/Action&gt;
    &lt;/State&gt;
  &lt;/StateModel&gt;

  &lt;Test name="Default"&gt;
    &lt;StateModel ref="TheState"/&gt;
    &lt;Publisher class="Http"&gt;
      &lt;Param name="Method" value="GET" /&gt;
      &lt;Param name="Url" value="http://foo/user/create" /&gt;
    &lt;/Publisher&gt;
  &lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Publishers_I2C">
<title>I2C Publisher</title>
<simpara>Use the <emphasis>I2C</emphasis> Publisher to read and write bytes directly to and from an I2C bus.</simpara>
<simpara><emphasis>I2C</emphasis> is designed to interface with the Total Phase Aardvark I2C/SPI (USB) Host Adapter.</simpara>
<section xml:id="_syntax_100">
<title>Syntax</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;Publisher class="I2C"&gt;
	&lt;Param name="Address" value="18"/&gt;
	&lt;Param name="SleepTime" value="5"/&gt;
	&lt;Param name="Bitrate" value="400"/&gt;
&lt;/Publisher&gt;</programlisting>
</section>
<section xml:id="_parameters_119">
<title>Parameters</title>
<simpara><emphasis>Required:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>Address</term>
<listitem>
<simpara>Address to write/read on target device.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>Bitrate</term>
<listitem>
<simpara>Bitrate supported by target device. Defaults to 100.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Port</term>
<listitem>
<simpara>USB port connected to Aardvark device. Defaults to 0.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>SleepTime</term>
<listitem>
<simpara>Time to sleep between actions. Defaults to 100.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_actions_9">
<title>Actions</title>
<variablelist>
<varlistentry>
<term><link linkend="Action_start">start</link></term>
<listitem>
<simpara>Implicit Action to start the Publisher.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_stop">stop</link></term>
<listitem>
<simpara>Implicit Action to stop the Publisher.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_open">open</link></term>
<listitem>
<simpara>Open and initialize the aardvark handle.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_close">close</link></term>
<listitem>
<simpara>Close and clean up the aardvark handle.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_output">output</link></term>
<listitem>
<simpara>Data sent via output is written to the I2C bus.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_input">input</link></term>
<listitem>
<simpara>Data received via input is read from the I2C bus.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_169">
<title>Examples</title>
<example>
<title>Basic Usage</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://peachfuzzer.com/2012/Peach /peach/peach.xsd"&gt;

	&lt;DataModel name="I2CModel"&gt;
		&lt;Blob name="CtlCode" length="1" /&gt;
		&lt;Number name="Length" size="8"&gt;
			&lt;Relation type="size" of="Data" /&gt;
		&lt;/Number&gt;
		&lt;Blob name="Data" /&gt;
	&lt;/DataModel&gt;

	&lt;StateModel name="TheState" initialState="Initial"&gt;
		&lt;State name="Initial"&gt;
			&lt;Action type="open" /&gt;
			&lt;Action type="output"&gt;
				&lt;DataModel ref="I2C_Data_Reset"/&gt;
				&lt;Data&gt;
					&lt;Field name="CtlCode" value="1" /&gt;
					&lt;Field name="Data" value="0x30313233"/&gt;
				&lt;/Data&gt;
			&lt;/Action&gt;
		&lt;/State&gt;
	&lt;/StateModel&gt;

	&lt;Test name="Default"&gt;
		&lt;StateModel ref="TheState"/&gt;

		&lt;Publisher class="I2C"&gt;
			&lt;Param name="Address" value="18"/&gt;
			&lt;Param name="SleepTime" value="5"/&gt;
			&lt;Param name="Bitrate" value="400"/&gt;
		&lt;/Publisher&gt;

		&lt;Strategy class="Random" /&gt;
	&lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Publishers_RawEther">
<title>RawEther Publisher</title>
<simpara>The <emphasis>RawEther</emphasis> publisher allows sending raw Ethernet packets.</simpara>
<note>
<simpara>This publisher requires administrative privileges.</simpara>
</note>
<section xml:id="_syntax_101">
<title>Syntax</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;Publisher class="RawEther"&gt;
	&lt;Param name="Interface" value="eth0" /&gt;
&lt;/Publisher&gt;</programlisting>
</section>
<section xml:id="_parameters_120">
<title>Parameters</title>
<simpara><emphasis>Required:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>Interface</term>
<listitem>
<simpara>Name of interface to bind to</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>Timeout</term>
<listitem>
<simpara>Amount of time, in milliseconds, to wait for data or for a connection. The default value is 3,000.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>MinMTU</term>
<listitem>
<simpara>Minimum packet size to transmit. The smallest value is 1280, which is the default value.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>MaxMTU</term>
<listitem>
<simpara>maximum packet size to transmit. The largest value is 131070, which is the default value.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Filter</term>
<listitem>
<simpara>Filters the received frames using a libpcap-style filter string. For more information
about libpcap style filters, see <link xl:href="http://www.tcpdump.org/manpages/pcap-filter.7.html">this page</link>.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_actions_10">
<title>Actions</title>
<variablelist>
<varlistentry>
<term><link linkend="Action_start">start</link></term>
<listitem>
<simpara>Implicit Action to start the Publisher.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_stop">stop</link></term>
<listitem>
<simpara>Implicit Action to stop the Publisher.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_open">open</link></term>
<listitem>
<simpara>Open and initialize the socket.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_close">close</link></term>
<listitem>
<simpara>Close and clean up the socket.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_output">output</link></term>
<listitem>
<simpara>Writes data through output to the open socket.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_input">input</link></term>
<listitem>
<simpara>Reads data through input from the open socket.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_170">
<title>Examples</title>
<example>
<title>Sending data</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

  &lt;Defaults&gt;
    &lt;Number endian="big"/&gt;
  &lt;/Defaults&gt;

  &lt;DataModel name="TheDataModel"&gt;
    &lt;Blob name="Dest" valueType="hex" mutable="false" length="6" value="FFFFFFFFFFFF"/&gt;
    &lt;Blob name="Src" valueType="hex" mutable="false" length="6" value="FFFFFFFFFFFF"/&gt;
    &lt;Number name="TypeOrLen" size="16" token="true"  valueType="hex" value="0806"/&gt;
    &lt;Block name="Payload"&gt;
      &lt;String name="name" value="Hello, scoobysnacks."/&gt;
    &lt;/Block&gt;
  &lt;/DataModel&gt;

  &lt;DataModel name="propertySize"&gt;
    &lt;Number size="32" value="1500"/&gt;
  &lt;/DataModel&gt;

  &lt;StateModel name="TheState" initialState="initial"&gt;
    &lt;State name="initial"&gt;
      &lt;Action type="setProperty" property="MaxMTU"&gt;
        &lt;DataModel ref="propertySize"/&gt;
      &lt;/Action&gt;

      &lt;Action type="setProperty" property="MinMTU"&gt;
        &lt;DataModel ref="propertySize"/&gt;
      &lt;/Action&gt;

      &lt;Action type="output"&gt;
        &lt;DataModel ref="TheDataModel"/&gt;
      &lt;/Action&gt;
    &lt;/State&gt;
  &lt;/StateModel&gt;

  &lt;Test name="Default"&gt;
    &lt;StateModel ref="TheState"/&gt;
  &lt;Publisher class="RawEther"&gt;
    &lt;Param name="Interface" value="eth0" /&gt;
    &lt;Param name="Filter" value="ether proto 0x0806" /&gt;
  &lt;/Publisher&gt;
  &lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Publishers_RawIPv4">
<title>RawIPv4 Publisher</title>
<simpara>The <emphasis>RawIPv4</emphasis> publisher sends raw IPv4 packets with IP headers.</simpara>
<simpara>Input received from <emphasis>RawIPv4</emphasis> includes the IPv4 header.</simpara>
<simpara>The <emphasis>RawIPv4</emphasis> maximum and minimum MTU size can be fuzzed by using the <emphasis>setProperty</emphasis> action.</simpara>
<note>
<simpara>This publisher runs best on Linux and requires root privileges.</simpara>
</note>
<section xml:id="_syntax_102">
<title>Syntax</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;Publisher class="RawV4"&gt;
    &lt;Param name="Host" value="127.0.0.1" /&gt;
    &lt;Param name="Protocol" value="17" /&gt;
&lt;/Publisher&gt;</programlisting>
</section>
<section xml:id="_parameters_121">
<title>Parameters</title>
<simpara><emphasis>Required:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>Host</term>
<listitem>
<simpara>Hostname or IP address of remote host</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Protocol</term>
<listitem>
<simpara>IP protocol to use (e.g. TCP)</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>Interface</term>
<listitem>
<simpara>IP of interface to bind to</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Timeout</term>
<listitem>
<simpara>How long to wait in milliseconds for data/connection. Defaults to 3,000.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>MaxMTU</term>
<listitem>
<simpara>Maximum allowable MTU property value. Defaults to 131,070.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>MinMTU</term>
<listitem>
<simpara>Minimum allowable MTU property value. Defaults to 1,280.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_actions_11">
<title>Actions</title>
<variablelist>
<varlistentry>
<term><link linkend="Action_start">start</link></term>
<listitem>
<simpara>Implicit Action to start the Publisher.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_stop">stop</link></term>
<listitem>
<simpara>Implicit Action to stop the Publisher.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_open">open</link></term>
<listitem>
<simpara>Open and initialize the socket.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_close">close</link></term>
<listitem>
<simpara>Close and clean up the socket.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_output">output</link></term>
<listitem>
<simpara>Data sent via output is written to the open socket.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_input">input</link></term>
<listitem>
<simpara>Data received via input is read from the open socket.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_getProperty">getProperty</link></term>
<listitem>
<simpara>Get a property value.<?asciidoc-br?>
This publisher supports two properties:	+
[horizontal]</simpara>
<variablelist>
<varlistentry>
<term>MTU</term>
<listitem>
<simpara>The current MTU value</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>LastRecvAddr</term>
<listitem>
<simpara>The last receive address</simpara>
</listitem>
</varlistentry>
</variablelist>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_setProperty">setProperty</link></term>
<listitem>
<simpara>Set a property value. This can be used to fuzz properties exposed by the publisher.	+
This publisher supports one property:<?asciidoc-br?>
[horizontal]</simpara>
<variablelist>
<varlistentry>
<term>MTU</term>
<listitem>
<simpara>Set the current MTU value. The value is ignored if it is not within the set range.</simpara>
</listitem>
</varlistentry>
</variablelist>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_171">
<title>Examples</title>
<example>
<title>Sending data</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

  &lt;DataModel name="propertySize"&gt;
    &lt;Number size="32" value="1500"/&gt;
  &lt;/DataModel&gt;

  &lt;DataModel name="Data"&gt;
    &lt;String name="Start" value="Start"/&gt;
    &lt;Blob name="Data" valueType="hex" value="BEEFEA7E41"/&gt;
    &lt;String name="Stop" value="Stop"/&gt;
  &lt;/DataModel&gt;

  &lt;DataModel name="UDPPacket"&gt;
    &lt;Block name="Header"&gt;
      &lt;Number name="SrcPort"  size="16" endian="big" value="31337"/&gt;
      &lt;Number name="DestPort" size="16" endian="big" value="31337"/&gt;
      &lt;Number name="Length"   size="16" endian="big"&gt;
        &lt;Relation type="size" of="UDPPacket"/&gt;
      &lt;/Number&gt;
      &lt;Number name="Checksum" size="16" endian="big"&gt;
        &lt;Fixup class="UDPChecksumFixup"&gt;
          &lt;Param name="ref" value="UDPPacket"/&gt;
          &lt;Param name="src" value="127.0.0.1"/&gt;
          &lt;Param name="dst" value="127.0.0.1"/&gt;
        &lt;/Fixup&gt;
      &lt;/Number&gt;
    &lt;/Block&gt;
    &lt;Block name="UdpPayload" ref="Data"/&gt;
  &lt;/DataModel&gt;

  &lt;DataModel name="Packet"&gt;
    &lt;Block name="Header"&gt;
      &lt;Flags size="16" endian="big"&gt;
        &lt;Flag name="Version" position="0" size="4" valueType="hex" value="04" token="true"/&gt;
        &lt;Flag name="HeaderLength" position="4" size="4" valueType="hex"&gt;
          &lt;Relation type="size" of="Header" expressionGet="size * 4" expressionSet="size / 4"/&gt;
        &lt;/Flag&gt;
        &lt;Flag name="DSCP" position="8" size="6" valueType="hex" value="00"/&gt;
        &lt;Flag name="ECN" position="14" size="2" valueType="hex" value="00"/&gt;
      &lt;/Flags&gt;
      &lt;Number name="TotalLength" size="16" endian="big" valueType="hex"&gt;
        &lt;Relation type="size" of="Packet"/&gt;
      &lt;/Number&gt;
      &lt;Number name="Identification" size="16" endian="big" value="0"/&gt;
      &lt;Flags name="Flags" size="16" endian="big"&gt;
        &lt;Flag name="Reserved" position="0" size="1" valueType="hex" value="00"/&gt;
        &lt;Flag name="DF" position="1" size="1" valueType="hex" value="01"/&gt;
        &lt;Flag name="MF" position="2" size="1" valueType="hex" value="00"/&gt;
        &lt;Flag name="FragmentOffset" position="3" size="13" valueType="hex" value="00 00"/&gt;
      &lt;/Flags&gt;
      &lt;Number name="TTL" size="8" endian="big" valueType="hex" value="40"/&gt;
      &lt;Number name="Protocol" size="8" endian="big" valueType="hex" value="11"/&gt;
      &lt;Number name="Checksum" size="16" endian="big"&gt;
        &lt;Fixup class="checksums.IcmpChecksumFixup"&gt;
          &lt;Param name="ref" value="Header"/&gt;
        &lt;/Fixup&gt;
      &lt;/Number&gt;
      &lt;Block name="SrcBlock" length="4"&gt;
        &lt;String name="SrcIP" value="127.0.0.1" mutable="false"&gt;
          &lt;Transformer class="Ipv4StringToOctet" /&gt;
        &lt;/String&gt;
      &lt;/Block&gt;
      &lt;Block name="DstBlock" length="4"&gt;
        &lt;String name="DestIP" value="127.0.0.1" mutable="false"&gt;
          &lt;Transformer class="Ipv4StringToOctet" /&gt;
        &lt;/String&gt;
      &lt;/Block&gt;
    &lt;/Block&gt;
    &lt;Block name="Payload" ref="UDPPacket"/&gt;
  &lt;/DataModel&gt;

  &lt;StateModel name="TheState" initialState="initial"&gt;
    &lt;State name="initial"&gt;
    	&lt;Action type="setProperty" property="MaxMTU"&gt;
        &lt;DataModel ref="propertySize"/&gt;
      &lt;/Action&gt;

      &lt;Action type="output"&gt;
        &lt;DataModel ref="Packet" /&gt;
      &lt;/Action&gt;
    &lt;/State&gt;
  &lt;/StateModel&gt;

  &lt;Test name="Default"&gt;
    &lt;StateModel ref="TheState"/&gt;
    &lt;Publisher class="RawV4"&gt;
      &lt;Param name="Host" value="127.0.0.1" /&gt;
     &lt;Param name="Protocol" value="17" /&gt;
    &lt;/Publisher&gt;
  &lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Publishers_RawV4">
<title>RawV4 Publisher</title>
<simpara>The <emphasis>RawV4</emphasis> publisher sends raw IPv4 packets without the IP headers.</simpara>
<simpara>Input received from <emphasis>RawV4</emphasis> includes the IPv4 header in the received data.</simpara>
<simpara>The <emphasis>RawV4</emphasis> maximum and minimum MTU size can be fuzzed by using the <emphasis>setProperty</emphasis> action.</simpara>
<note>
<simpara>This publisher runs best on Linux and requires root privileges.</simpara>
</note>
<simpara><emphasis>Supported Protocol Values:</emphasis></simpara>
<informaltable tabstyle="horizontal" frame="none" colsep="0" rowsep="0">
<tgroup cols="2">
<colspec colwidth="15*"/>
<colspec colwidth="85*"/>
<tbody valign="top">
<row>
<entry>
<simpara>1</simpara>
</entry>
<entry>
<simpara>ICMP</simpara>
</entry>
</row>
<row>
<entry>
<simpara>2</simpara>
</entry>
<entry>
<simpara>IGMP</simpara>
</entry>
</row>
<row>
<entry>
<simpara>6</simpara>
</entry>
<entry>
<simpara>TCP</simpara>
</entry>
</row>
<row>
<entry>
<simpara>17</simpara>
</entry>
<entry>
<simpara>UDP</simpara>
</entry>
</row>
<row>
<entry>
<simpara>41</simpara>
</entry>
<entry>
<simpara>ENCAP</simpara>
</entry>
</row>
<row>
<entry>
<simpara>89</simpara>
</entry>
<entry>
<simpara>OSPF</simpara>
</entry>
</row>
<row>
<entry>
<simpara>132</simpara>
</entry>
<entry>
<simpara>SCTP</simpara>
</entry>
</row>
</tbody>
</tgroup>
</informaltable>
<section xml:id="_syntax_103">
<title>Syntax</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;Publisher class="RawV4"&gt;
    &lt;Param name="Host" value="127.0.0.1" /&gt;
    &lt;Param name="Protocol" value="17" /&gt;
&lt;/Publisher&gt;</programlisting>
</section>
<section xml:id="_parameters_122">
<title>Parameters</title>
<simpara><emphasis>Required:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>Host</term>
<listitem>
<simpara>Hostname or IP address of remote host</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Protocol</term>
<listitem>
<simpara>IP protocol to use (e.g. TCP)</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>Interface</term>
<listitem>
<simpara>IP of interface to bind to. Defaults to auto select.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Timeout</term>
<listitem>
<simpara>How long to wait in milliseconds for data/connection. Defaults to 3,000.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>MaxMTU</term>
<listitem>
<simpara>Maximum allowable MTU property value. Only needed when fuzzing MTU. Defaults to 131,070.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>MinMTU</term>
<listitem>
<simpara>Minimum allowable MTU property value. Only needed when fuzzing MTU. Defaults to 1,280.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_actions_12">
<title>Actions</title>
<variablelist>
<varlistentry>
<term><link linkend="Action_start">start</link></term>
<listitem>
<simpara>Implicit Action to start the Publisher.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_stop">stop</link></term>
<listitem>
<simpara>Implicit Action to stop the Publisher.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_open">open</link></term>
<listitem>
<simpara>Open and initialize the socket.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_close">close</link></term>
<listitem>
<simpara>Close and clean up the socket.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_output">output</link></term>
<listitem>
<simpara>Data sent via output is written to the open socket.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_input">input</link></term>
<listitem>
<simpara>Data received via input is read from the open socket.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_getProperty">getProperty</link></term>
<listitem>
<simpara>Get a property value. This publisher supports two properties: <?asciidoc-br?></simpara>
<variablelist>
<varlistentry>
<term><emphasis role="strong">MTU</emphasis></term>
<listitem>
<simpara>The current MTU value</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><emphasis role="strong">LastRecvAddr</emphasis></term>
<listitem>
<simpara>The last receive address</simpara>
</listitem>
</varlistentry>
</variablelist>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_setProperty">setProperty</link></term>
<listitem>
<simpara>Set a property value. This can be used to fuzz properties exposed by the publisher. This publisher supports one property: 	+</simpara>
<variablelist>
<varlistentry>
<term><emphasis role="strong">MTU</emphasis></term>
<listitem>
<simpara>Set the current MTU value. The value is ignored if it is not within the set range.</simpara>
</listitem>
</varlistentry>
</variablelist>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_172">
<title>Examples</title>
<example>
<title>Sending data</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

  &lt;DataModel name="propertySize"&gt;
    &lt;Number size="32" value="1500"/&gt;
  &lt;/DataModel&gt;

  &lt;DataModel name="Data"&gt;
    &lt;String name="Start" value="Start"/&gt;
    &lt;Blob name="Data" valueType="hex" value="BEEFEA7E41"/&gt;
    &lt;String name="Stop" value="Stop"/&gt;
  &lt;/DataModel&gt;

  &lt;DataModel name="Packet"&gt;
    &lt;Block name="Header"&gt;
      &lt;Number name="SrcPort"  size="16" endian="big" value="31337"/&gt;
      &lt;Number name="DestPort" size="16" endian="big" value="31337"/&gt;
      &lt;Number name="Length"   size="16" endian="big"&gt;
        &lt;Relation type="size" of="Packet"/&gt;
      &lt;/Number&gt;
      &lt;Number name="Checksum" size="16" endian="big"&gt;
        &lt;Fixup class="UDPChecksumFixup"&gt;
          &lt;Param name="ref" value="Packet"/&gt;
          &lt;Param name="src" value="127.0.0.1"/&gt;
          &lt;Param name="dst" value="127.0.0.1"/&gt;
        &lt;/Fixup&gt;
      &lt;/Number&gt;
    &lt;/Block&gt;
    &lt;Block name="UdpPayload" ref="Data"/&gt;
  &lt;/DataModel&gt;

  &lt;StateModel name="TheState" initialState="initial"&gt;
    &lt;State name="initial"&gt;
    	&lt;Action type="setProperty" property="MaxMTU"&gt;
        &lt;DataModel ref="propertySize"/&gt;
      &lt;/Action&gt;

      &lt;Action type="output"&gt;
        &lt;DataModel ref="Packet" /&gt;
      &lt;/Action&gt;
    &lt;/State&gt;
  &lt;/StateModel&gt;

  &lt;Test name="Default"&gt;
    &lt;StateModel ref="TheState"/&gt;
    &lt;Publisher class="RawV4"&gt;
      &lt;Param name="Host" value="127.0.0.1" /&gt;
      &lt;Param name="Protocol" value="17" /&gt;
    &lt;/Publisher&gt;
  &lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Publishers_RawV6">
<title>RawV6 Publisher</title>
<simpara>The <emphasis>RawV6</emphasis> publisher sends raw IPv6 packets without the IP headers.</simpara>
<simpara>Input received from <emphasis>RawV6</emphasis> includes the IPv6 header in the received data.</simpara>
<simpara>The <emphasis>RawV6</emphasis> MTU size can be fuzzed by using the <emphasis>setProperty</emphasis> action.</simpara>
<note>
<simpara>This publisher runs best on Linux and requires root privileges.</simpara>
</note>
<section xml:id="_syntax_104">
<title>Syntax</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;Publisher class="RawV6"&gt;
  	&lt;Param name="Host" value="::1" /&gt;
	&lt;Param name="Protocol" value="17" /&gt;
&lt;/Publisher&gt;</programlisting>
</section>
<section xml:id="_parameters_123">
<title>Parameters</title>
<simpara><emphasis>Required:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>Host</term>
<listitem>
<simpara>Hostname or IP address of remote host</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Protocol</term>
<listitem>
<simpara>IP protocol to use (value must be between 0 and 255).</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>Interface</term>
<listitem>
<simpara>IP of interface to bind to. Uses all interfaces by default.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Timeout</term>
<listitem>
<simpara>How long to wait in milliseconds for data/connection. Defaults to 3,000.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>MaxMTU</term>
<listitem>
<simpara>Maximum allowable MTU property value. Defaults to 131,070.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>MinMTU</term>
<listitem>
<simpara>Minimum allowable MTU property value. Defaults to 1,280.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_actions_13">
<title>Actions</title>
<variablelist>
<varlistentry>
<term><link linkend="Action_start">start</link></term>
<listitem>
<simpara>Implicit Action to start the Publisher.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_stop">stop</link></term>
<listitem>
<simpara>Implicit Action to stop the Publisher.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_open">open</link></term>
<listitem>
<simpara>Open and initialize the socket.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_close">close</link></term>
<listitem>
<simpara>Close and clean up the socket.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_output">output</link></term>
<listitem>
<simpara>Data sent via output is written to the open socket.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_input">input</link></term>
<listitem>
<simpara>Data received via input is read from the open socket.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_getProperty">getProperty</link></term>
<listitem>
<simpara>Get a property value. This publisher supports two properties: <?asciidoc-br?></simpara>
<variablelist>
<varlistentry>
<term><emphasis role="strong">MTU</emphasis></term>
<listitem>
<simpara>The current MTU value <?asciidoc-br?></simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><emphasis role="strong">LastRecvAddr</emphasis></term>
<listitem>
<simpara>The last receive address</simpara>
</listitem>
</varlistentry>
</variablelist>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_setProperty">setProperty</link></term>
<listitem>
<simpara>Set a property value. This can be used to fuzz properties exposed by the publisher. This publisher supports one property: <?asciidoc-br?></simpara>
<variablelist>
<varlistentry>
<term><emphasis role="strong">MTU</emphasis></term>
<listitem>
<simpara>Set the current MTU value. The value is ignored if it is not within the set range.</simpara>
</listitem>
</varlistentry>
</variablelist>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_173">
<title>Examples</title>
<example>
<title>Sending data</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

  &lt;DataModel name="propertySize"&gt;
    &lt;Number size="32" value="1500"/&gt;
  &lt;/DataModel&gt;

  &lt;DataModel name="Data"&gt;
    &lt;String name="Start" value="Start"/&gt;
    &lt;Blob name="Data" valueType="hex" value="BEEFEA7E41"/&gt;
    &lt;String name="Stop" value="Stop"/&gt;
  &lt;/DataModel&gt;

  &lt;DataModel name="UDPPacket"&gt;
    &lt;Block name="Header"&gt;
      &lt;Number name="SrcPort"  size="16" endian="big" value="31337"/&gt;
      &lt;Number name="DestPort" size="16" endian="big" value="31337"/&gt;
      &lt;Number name="Length"   size="16" endian="big"&gt;
        &lt;Relation type="size" of="UDPPacket"/&gt;
      &lt;/Number&gt;
      &lt;Number name="Checksum" size="16" endian="big"&gt;
        &lt;Fixup class="UDPChecksumFixup"&gt;
          &lt;Param name="ref" value="UDPPacket"/&gt;
          &lt;Param name="src" value="::1"/&gt;
          &lt;Param name="dst" value="::1"/&gt;
        &lt;/Fixup&gt;
      &lt;/Number&gt;
    &lt;/Block&gt;
    &lt;Block name="UdpPayload" ref="Data"/&gt;
  &lt;/DataModel&gt;

  &lt;DataModel name="Packet"&gt;
    &lt;Flags size="32" endian="big"&gt;
      &lt;Flag name="Version" position="0" size="4" valueType="hex" value="06"/&gt;
      &lt;Flag name="DSCP" position="4" size="6" valueType="hex" value="00"/&gt;
      &lt;Flag name="ECN" position="10" size="2" valueType="hex" value="00"/&gt;
      &lt;Flag name="FlowLabel" position="12" size="20" valueType="hex" value="000000"/&gt;
    &lt;/Flags&gt;
    &lt;Number name="PayloadLength" size="16" endian="big"&gt;
      &lt;Relation type="size" of="IPv6Payload" /&gt;
    &lt;/Number&gt;
    &lt;Number name="NextHeader" size="8" value="17"/&gt;
    &lt;Number name="HopLimit" size="8" endian="big" valueType="hex" value="40"/&gt;
    &lt;Block name="SrcBlock" length="16"&gt;
      &lt;Blob name="SrcIP" value="::1"&gt;
        &lt;Transformer class="Ipv6StringToOctet"/&gt;
      &lt;/Blob&gt;
    &lt;/Block&gt;
    &lt;Block name="DstBlock" length="16"&gt;
      &lt;Blob name="DestIP" value="::1"&gt;
        &lt;Transformer class="Ipv6StringToOctet"/&gt;
      &lt;/Blob&gt;
    &lt;/Block&gt;
    &lt;Block name="IPv6Payload" ref ="UDPPacket"/&gt;
  &lt;/DataModel&gt;

  &lt;StateModel name="TheState" initialState="initial"&gt;
    &lt;State name="initial"&gt;
    	&lt;Action type="setProperty" property="MaxMTU"&gt;
        &lt;DataModel ref="propertySize"/&gt;
      &lt;/Action&gt;

      &lt;Action type="output"&gt;
        &lt;DataModel ref="Packet" /&gt;
      &lt;/Action&gt;
    &lt;/State&gt;
  &lt;/StateModel&gt;

  &lt;Test name="Default"&gt;
    &lt;StateModel ref="TheState"/&gt;
    &lt;Publisher class="RawV6"&gt;
  		&lt;Param name="Host" value="::1" /&gt;
		&lt;Param name="Protocol" value="17" /&gt;
    &lt;/Publisher&gt;
  &lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Publishers_Remote">
<title>Remote Publisher</title>
<simpara><emphasis>Remote</emphasis> publisher runs another publisher from a Peach remote <link linkend="Agent">Agent</link> process.</simpara>
<simpara><emphasis>Remote</emphasis> resides on a separate (virtual or actual) machine from the remote <link linkend="Agent">Agent</link>. The remote <link linkend="Agent">Agent</link> must have started before <emphasis>Remote</emphasis> is initiated. Peach will connect to the agent and provide the information required to start the remote publisher.</simpara>
<section xml:id="_syntax_105">
<title>Syntax</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;Publisher class="Remote"&gt;
	&lt;Param name="Agent" value="RemoteAgent" /&gt;
	&lt;Param name="Class" value="RawEther"/&gt;

	&lt;!-- Parameters for RawEther --&gt;
	&lt;Param name="Interface" value="eth0" /&gt;
&lt;/Publisher&gt;</programlisting>
</section>
<section xml:id="_parameters_124">
<title>Parameters</title>
<simpara><emphasis>Required:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>Agent</term>
<listitem>
<simpara>Name of Agent to run the Publisher from</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Class</term>
<listitem>
<simpara>Name of Publisher to run</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Remoted Parameters</term>
<listitem>
<simpara>Parameters for Publisher being remoted</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Optional:</emphasis></simpara>
<simpara>There are no optional parameters for this publisher.</simpara>
</section>
<section xml:id="_actions_14">
<title>Actions</title>
<simpara>Any actions supported by remoted publisher.</simpara>
</section>
<section xml:id="_examples_174">
<title>Examples</title>
<example>
<title>Remoting TCP Publisher</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach ../peach.xsd"&gt;

  &lt;Defaults&gt;
    &lt;Number endian="big"/&gt;
  &lt;/Defaults&gt;

  &lt;DataModel name="TheDataModel"&gt;
    &lt;Blob name="Dest" valueType="hex" mutable="false" length="6" value="FFFFFFFFFFFF"/&gt;
    &lt;Blob name="Src" valueType="hex" mutable="false" length="6" value="FFFFFFFFFFFF"/&gt;
    &lt;Number name="TypeOrLen" size="16" token="true"  valueType="hex" value="0806"/&gt;
    &lt;Block name="Payload"&gt;
      &lt;String name="name" value="Hello, scoobysnacks."/&gt;
    &lt;/Block&gt;
  &lt;/DataModel&gt;

  &lt;DataModel name="propertySize"&gt;
    &lt;Number size="32" value="1500"/&gt;
  &lt;/DataModel&gt;

  &lt;Agent name="RemoteAgent" location="tcp://192.168.1.1:9001" /&gt;

  &lt;StateModel name="TheState" initialState="initial"&gt;
    &lt;State name="initial"&gt;
      &lt;Action type="output"&gt;
        &lt;DataModel ref="TheDataModel"/&gt;
      &lt;/Action&gt;
    &lt;/State&gt;
  &lt;/StateModel&gt;

  &lt;Test name="Default"&gt;
    &lt;Agent ref="RemoteAgent" /&gt;

    &lt;StateModel ref="TheState"/&gt;

   &lt;Publisher class="Remote"&gt;
    &lt;Param name="Agent" value="RemoteAgent" /&gt;
    &lt;Param name="Class" value="RawEther"/&gt;

    &lt;!-- Parameters for RawEther --&gt;
    &lt;Param name="Interface" value="eth0" /&gt;
  &lt;/Publisher&gt;
  &lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>Starting Peach Agent Process on Remote Machine</simpara>
<screen>peach.exe -a tcp</screen>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Publishers_Rest">
<title>Rest Publisher (Depricated)</title>
<simpara>This publisher is depricated, please see <link linkend="Publishers_WebApi">WebApi publisher</link>.</simpara>
<simpara>The <emphasis>Rest</emphasis> Publisher  is an I/O adapter that communicates using the Representational State Transfer (Rest) architecture. This publisher communicates using HTTP as the underlying transport.</simpara>
<simpara>This publisher supports sending body data as:</simpara>
<itemizedlist>
<listitem>
<simpara>JSON when models contain Json elements (JsonString, JsonObject, etc.) or the deprecated Json element.</simpara>
</listitem>
<listitem>
<simpara>XML when models contain XmlElement</simpara>
</listitem>
<listitem>
<simpara>As raw binary data when a custom content type is provided</simpara>
</listitem>
</itemizedlist>
<simpara>Similar to the <link linkend="Publishers_Http">Http</link> publisher, the <emphasis>Rest</emphasis> publisher supports setting headers by using a special action type <emphasis>call</emphasis> syntax.
See the examples section for an example of setting a custom header field.</simpara>
<simpara>Several analyzers are useful when building Pits for RESTful APIs:</simpara>
<variablelist>
<varlistentry>
<term><link linkend="Analyzers_Json">Json</link></term>
<listitem>
<simpara>Converts JSON documents or strings into Peach data models.
Can be used both inside of DataModels with the String element or also via the command line.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Analyzers_Postman">Postman</link></term>
<listitem>
<simpara>Converts Postman Catalogs to Peach Pits.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Analyzers_Swagger">Swagger</link></term>
<listitem>
<simpara>Converts Swagger JSON to Peach Pits</simpara>
</listitem>
</varlistentry>
</variablelist>
<tip>
<simpara>SSL/TLS is supported, just use <literal>https</literal> as the protocol in the URL.</simpara>
</tip>
<tip>
<simpara>By default the publisher will attempt to detect the body content type and set the correct ContentType header.</simpara>
</tip>
<section xml:id="_syntax_106">
<title>Syntax</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;!-- AUtomatically detect content type --&gt;
&lt;Publisher class="Rest"/&gt;

&lt;!-- Custom content type header --&gt;
&lt;Publisher class="Rest"&gt;
    &lt;Param name="ContentType" value="application/octet-stream" /&gt;
&lt;/Publisher&gt;</programlisting>
</section>
<section xml:id="_parameters_125">
<title>Parameters</title>
<simpara><emphasis>Required:</emphasis></simpara>
<simpara>There are no required parameters.</simpara>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>ContentType</term>
<listitem>
<simpara>Value for content-type header.  Set this to allow sending of binary data.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>BaseUrl</term>
<listitem>
<simpara>Base URL is used by some authentication types. Only used as part of authentication.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Username</term>
<listitem>
<simpara>Username for authentication</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Password</term>
<listitem>
<simpara>Optional password associated with the Username in authentication</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Domain</term>
<listitem>
<simpara>Domain for authentication</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Cookies</term>
<listitem>
<simpara>Enable cookie support. The default value is true.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>CookiesAcrossIterations</term>
<listitem>
<simpara>Track cookies across iterations. The default value is false.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>FailureStatusCodes</term>
<listitem>
<simpara>Comma separated list of status codes that are failures causing current test case to stop.
Defaults to: <literal>400,401,402,403,404,405,406,407,408,409,410,411,412,413,414,415,416,417,500,501,502,503,504,505</literal></simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>FaultOnStatusCodes</term>
<listitem>
<simpara>Comma separated list of status codes that are faults. Defaults to none.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Timeout</term>
<listitem>
<simpara>How long to wait in milliseconds for data/connection. the default value is 3,000.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>IgnoreCertErrors</term>
<listitem>
<simpara>Allow HTTPS regardless of cert status. The default value is true.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Proxy</term>
<listitem>
<simpara>To use HTTP proxy, set the URL. Default is none. Example: <literal><link xl:href="http://192.168.1.1:8080">http://192.168.1.1:8080</link></literal>.<?asciidoc-br?>
<?asciidoc-br?>
Please note that the host <literal>localhost</literal> and IP 127.0.0.1 will bypass the provided proxy. This is a behavior hardcoded into the underlying http networking code. For a discussion of options to deal with this limitation see the following article: <link xl:href="http://docs.telerik.com/fiddler/Configure-Fiddler/Tasks/MonitorLocalTraffic">Fiddler - Monitoring Local Traffic</link>.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_actions_15">
<title>Actions</title>
<variablelist>
<varlistentry>
<term><link linkend="Action_call">call</link></term>
<listitem>
<simpara>Call actions are used to perform Rest calls.</simpara>
<simpara>The method attribute contains both the HTTP method (GET, POST, etc.) and the URL.
The URL portion of the method attribute can contain parameter substitution tokens.
These tokens are replaced with the parameters provided.
One additional parameter can be provided that is used for the body of the request.</simpara>
<itemizedlist>
<listitem>
<simpara>The format of the method attribute is: <literal>METHOD URL</literal></simpara>
</listitem>
<listitem>
<simpara>This example places a call that expects to receive a single parameter: <literal>GET /product/{0}</literal></simpara>
</listitem>
<listitem>
<simpara>This example places a call that expects to receive two parameters: <literal>GET /invoices?start_date={0}&amp;end_date={1}</literal></simpara>
<simpara>A final Param can be added to provide the body content if needed.</simpara>
<simpara>This action also supports the <link linkend="Action_call">Result</link> element to capture the response paylaod.</simpara>
<tip>
<simpara>The order of the parameters is important. In order they are matched to the substitutions of {0}, then {1}, etc.  The final Param (optional) is used for the body payload.</simpara>
</tip>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_call">call</link></term>
<listitem>
<simpara>Call actions are used to set HTTP headers.</simpara>
<simpara>To set a header using a call action you must:</simpara>
<itemizedlist>
<listitem>
<simpara>Set the method to "Header"</simpara>
</listitem>
<listitem>
<simpara>Have two parameters named <literal>Name</literal> and <literal>Value</literal></simpara>
</listitem>
<listitem>
<simpara>The <literal>Name</literal> parameter is the header key name</simpara>
</listitem>
<listitem>
<simpara>The <literal>Value</literal> parameter is the value for the header</simpara>
<simpara>By default they are fuzzed. This can be disabled using the <literal>mutable</literal> attribute on the data model and data elements or using the <literal>Include/Exclude</literal> elements in the <literal>Test</literal> portion of the xml.</simpara>
<simpara>An example of settings headers both via Python and also the <literal>call</literal> action are provided in the Example section.</simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_scripting_2">
<title>Scripting</title>
<simpara>The Rest publisher exposes a public Headers dictionary that can be used to add/remove headers from Python scripting code.  See example <emphasis>Setting Custom Authentication Header via Python</emphasis> below.</simpara>
</section>
<section xml:id="_example_4">
<title>Example</title>
<example>
<title>Calling Rest Services with Result</title>
<simpara>The following example provides three fragments using the GET and POST methods.
For the GET request, the Result element is used to capture any returned data.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

&lt;DataModel name="PostData"&gt;
    &lt;JsonObject&gt;
        &lt;JsonString propertyName="Name" value="Widget" /&gt;
        &lt;JsonDouble propertyName="Price" value="1.99" /&gt;
        &lt;JsonInteger propertyName="Quantify" value="1" /&gt;
    &lt;/JsonObject&gt;
&lt;/DataModel&gt;

&lt;DataModel name="RestString"&gt;
	&lt;String name="value" value=""&gt;
		&lt;Hint name="Peach.TypeTransform" value="false" /&gt;
	&lt;/String&gt;
&lt;/DataModel&gt;

&lt;DataModel name="RestResult"&gt;
	&lt;Choice name="ResultOrEmpty"&gt;
		&lt;String name="Result"&gt;
			&lt;Analyzer class="Json" /&gt;
		&lt;/String&gt;
		&lt;Block name="Empty" /&gt;
	&lt;/Choice&gt;
&lt;/DataModel&gt;

&lt;StateModel name="Default" initialState="FirstState"&gt;
    &lt;State name="FirstState"&gt;
        &lt;Action type="call" method="GET http://www.example.com/product/{0}"&gt;
            &lt;!-- {0} --&gt;
            &lt;Param name="Id"&gt;
                &lt;DataModel ref="RestString" /&gt;
				&lt;Data&gt;
					&lt;Field name="value" value="1"/&gt;
				&lt;/Data&gt;
            &lt;/Param&gt;

            &lt;!-- Capture Response (optional) --&gt;
            &lt;Result&gt;
                &lt;DataModel ref="RestResult" /&gt;
            &lt;/Result&gt;
        &lt;/Action&gt;

        &lt;Action type="call" method="GET http://www.example.com/invoices?start_date={0}&amp;amp;end_data={1}"&gt;
            &lt;!-- {0} --&gt;
            &lt;Param name="StartDate"&gt;
                &lt;DataModel ref="RestString" /&gt;
				&lt;Data&gt;
					&lt;Field name="value" value="11-21-2011"/&gt;
				&lt;/Data&gt;
            &lt;/Param&gt;

            &lt;!-- {1} --&gt;
            &lt;Param name="EndDate"&gt;
                &lt;DataModel ref="RestString" /&gt;
				&lt;Data&gt;
					&lt;Field name="value" value="11-21-2015"/&gt;
				&lt;/Data&gt;
            &lt;/Param&gt;

            &lt;!-- Capture Response (optional) --&gt;
            &lt;Result&gt;
                &lt;DataModel ref="RestResult" /&gt;
            &lt;/Result&gt;
        &lt;/Action&gt;

        &lt;Action type="call" method="POST http://www.example.com/product/{0}"&gt;
            &lt;!-- {0} --&gt;
            &lt;Param name="Id"&gt;
                &lt;DataModel ref="RestString" /&gt;
				&lt;Data&gt;
					&lt;Field name="value" value="100"/&gt;
				&lt;/Data&gt;
            &lt;/Param&gt;

            &lt;!-- POST Body --&gt;
            &lt;Param name="PostData"&gt;
                &lt;DataModel ref="PostData" /&gt;
            &lt;/Param&gt;
        &lt;/Action&gt;
    &lt;/State&gt;
&lt;/StateModel&gt;

&lt;Test name="Default"&gt;
    &lt;StateModel ref="Default" /&gt;
    &lt;Publisher class="Rest" /&gt;
&lt;/Test&gt;

&lt;/Peach&gt;</programlisting>
</example>
<example>
<title>Posting XML</title>
<simpara>The following example provides three fragments using the GET and POST methods.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

&lt;DataModel name="RestString"&gt;
	&lt;String name="value" value=""&gt;
		&lt;Hint name="Peach.TypeTransform" value="false" /&gt;
	&lt;/String&gt;
&lt;/DataModel&gt;

&lt;DataModel name="PostData"&gt;
    &lt;XmlElement elementName="Product"&gt;
        &lt;XmlAttribute attributeName="Name"&gt;
            &lt;String value="Widget" /&gt;
        &lt;/XmlAttribute&gt;
        &lt;XmlAttribute attributeName="Price"&gt;
            &lt;String value="1.99" /&gt;
        &lt;/XmlAttribute&gt;
        &lt;XmlAttribute attributeName="Quantity"&gt;
            &lt;String value="1" /&gt;
        &lt;/XmlAttribute&gt;
    &lt;/XmlElement&gt;
&lt;/DataModel&gt;

&lt;StateModel name="Default" initialState="FirstState"&gt;
    &lt;State name="FirstState"&gt;

        &lt;Action type="call" method="POST http://www.example.com/product/{0}"&gt;
            &lt;!-- {0} --&gt;
            &lt;Param name="Id"&gt;
                &lt;DataModel ref="RestString" /&gt;
                &lt;Data&gt;
                    &lt;Field name="value" value="1" /&gt;
                &lt;/Data&gt;
            &lt;/Param&gt;

            &lt;!-- POST Body --&gt;
            &lt;Param name="PostData"&gt;
                &lt;DataModel ref="PostData" /&gt;
            &lt;/Param&gt;
        &lt;/Action&gt;

    &lt;/State&gt;
&lt;/StateModel&gt;

&lt;Test name="Default"&gt;
    &lt;StateModel ref="Default" /&gt;
    &lt;Publisher class="Rest" /&gt;
&lt;/Test&gt;

&lt;/Peach&gt;</programlisting>
</example>
<example>
<title>Posting Binary</title>
<simpara>The following example provides three fragments using the GET and POST methods.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

&lt;DataModel name="RestString"&gt;
	&lt;String name="value" value=""&gt;
		&lt;Hint name="Peach.TypeTransform" value="false" /&gt;
	&lt;/String&gt;
&lt;/DataModel&gt;

&lt;DataModel name="PostData"&gt;
    &lt;Blob /&gt;
&lt;/DataModel&gt;

&lt;StateModel name="Default" initialState="FirstState"&gt;
    &lt;State name="FirstState"&gt;

        &lt;Action type="call" method="POST http://www.example.com/product/{0}/image"&gt;
            &lt;!-- {0} --&gt;
            &lt;Param name="Id"&gt;
                &lt;DataModel ref="RestString" /&gt;
                &lt;Data&gt;
                    &lt;Field name="value" value="1" /&gt;
                &lt;/Data&gt;
            &lt;/Param&gt;

            &lt;!-- POST Body --&gt;
            &lt;Param name="PostData"&gt;
                &lt;DataModel ref="PostData" /&gt;
                &lt;Data fileName="image.png" /&gt;
            &lt;/Param&gt;
        &lt;/Action&gt;

    &lt;/State&gt;
&lt;/StateModel&gt;

&lt;Test name="Default"&gt;

    &lt;StateModel ref="Default"/&gt;
    &lt;Publisher class="Rest"&gt;
        &lt;Param name="ContentType" value="application/octet-stream" /&gt;
    &lt;/Publisher&gt;

&lt;/Test&gt;

&lt;/Peach&gt;</programlisting>
</example>
<example>
<title>Setting Custom Header via Pit</title>
<simpara>The following example shows how to set a custom header via the Pit XML.
The custom header is named "X-CustomeHeader" with a value of "Hello World".</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

&lt;DataModel name="RestString"&gt;
	&lt;String name="value" value=""&gt;
		&lt;Hint name="Peach.TypeTransform" value="false" /&gt;
	&lt;/String&gt;
&lt;/DataModel&gt;

&lt;DataModel name="RestResult"&gt;
	&lt;Choice name="ResultOrEmpty"&gt;
		&lt;String name="Result"&gt;
			&lt;Analyzer class="Json" /&gt;
		&lt;/String&gt;
		&lt;Block name="Empty" /&gt;
	&lt;/Choice&gt;
&lt;/DataModel&gt;

&lt;StateModel name="Default" initialState="FirstState"&gt;
    &lt;State name="FirstState"&gt;

		&lt;!-- Add X-CustomHeader header --&gt;
		&lt;Action type="call" method="Header"&gt;
            &lt;Param name="Name"&gt;
                &lt;DataModel ref="RestString" /&gt;
				&lt;Data&gt;
					&lt;Field name="value" value="X-CustomHeader"/&gt;
				&lt;/Data&gt;
            &lt;/Param&gt;
            &lt;Param name="Value"&gt;
                &lt;DataModel ref="RestString" /&gt;
				&lt;Data&gt;
					&lt;Field name="value" value="Hello World!"/&gt;
				&lt;/Data&gt;
            &lt;/Param&gt;
		&lt;/Action&gt;

        &lt;Action type="call" method="GET http://www.example.com/product/{0}"&gt;
            &lt;!-- {0} --&gt;
            &lt;Param name="Id"&gt;
                &lt;DataModel ref="RestString" /&gt;
				&lt;Data&gt;
					&lt;Field name="value" value="1"/&gt;
				&lt;/Data&gt;
            &lt;/Param&gt;

            &lt;!-- Capture Response (optional) --&gt;
            &lt;Result&gt;
                &lt;DataModel ref="RestResult" /&gt;
            &lt;/Result&gt;
        &lt;/Action&gt;

    &lt;/State&gt;
&lt;/StateModel&gt;

&lt;Test name="Default"&gt;
    &lt;StateModel ref="Default" /&gt;
    &lt;Publisher class="Rest" /&gt;
&lt;/Test&gt;

&lt;/Peach&gt;</programlisting>
</example>
<example>
<title>Setting Custom Authentication Header via Python</title>
<simpara>The following example shows how to add custom authentication via a python script.
In this example we will configure a pit for fuzzing an Amazon AWS S3 service endpoint.
This is only and example and should not actually be used to fuzz AWS.</simpara>
<programlisting language="python" linenumbering="unnumbered">import base64
import hmac
from hashlib import sha1
from email.Utils import formatdate

AWS_ACCESS_KEY_ID = "44CF9590006BF252F707"
AWS_SECRET_KEY = "OtxrzxIsfpFjA7SwPzILwy8Bw21TLhquhboDYROV"

def AwsAuthGen(context, action):

    # Get the Publisher (RestPublisher)
    if action.publisher:
        publisher = context.test.publishers[action.publisher]
    else:
        publisher = context.test.publishers[0]

    XAmzDate = formatdate()

    h = hmac.new(AWS_SECRET_KEY, "PUT\n\napplication/json\n\nx-amz-date:%s\n/?policy" % XAmzDate, sha1)
    authToken = base64.encodestring(h.digest()).strip()

    publisher.Headers.Add("x-amz-date", XAmzDate)
    publisher.Headers.Add("Authorization", "AWS %s:%s" % (AWS_ACCESS_KEY_ID, authToken))

# end</programlisting>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

  &lt;Import import="aws_s3_example"/&gt;

  &lt;!--
{
"Version":"2008-10-17",
"Id":"aaaa-bbbb-cccc-dddd",
"Statement" : [
    {
        "Effect":"Allow",
        "Sid":"1",
        "Principal" : {
            "AWS":["111122223333","444455556666"]
        },
        "Action":["s3:*"],
        "Resource":"arn:aws:s3:::bucket/*"
    }
 ]
}
  --&gt;
  &lt;!-- Generated using the JSON analyzer --&gt;
  &lt;DataModel name="Policy"&gt;
    &lt;JsonObject&gt;
      &lt;JsonString propertyName="Version" name="Version" value="2008-10-17" /&gt;
      &lt;JsonString propertyName="Id" name="Id" value="aaaa-bbbb-cccc-dddd" /&gt;
      &lt;JsonArray propertyName="Statement" name="Statement"&gt;
        &lt;JsonObject propertyName="Statement" name="Statement"&gt;
          &lt;JsonString propertyName="Effect" name="Effect" value="Allow" /&gt;
          &lt;JsonString propertyName="Sid" name="Sid" value="1" /&gt;
          &lt;JsonObject propertyName="Principal" name="Principal"&gt;
            &lt;JsonArray propertyName="AWS" name="AWS"&gt;
              &lt;JsonString propertyName="AWS" name="AWS" value="111122223333" /&gt;
              &lt;JsonString value="444455556666" /&gt;
            &lt;/JsonArray&gt;
          &lt;/JsonObject&gt;
          &lt;JsonArray propertyName="Action" name="Action"&gt;
            &lt;JsonString propertyName="Action" name="Action" value="s3:*" /&gt;
          &lt;/JsonArray&gt;
          &lt;JsonString propertyName="Resource" name="Resource" value="arn:aws:s3:::bucket/*" /&gt;
        &lt;/JsonObject&gt;
      &lt;/JsonArray&gt;
    &lt;/JsonObject&gt;
  &lt;/DataModel&gt;

  &lt;StateModel name="TheStateModel" initialState="Initial"&gt;
    &lt;State name="Initial"&gt;

      &lt;Action type="call" method="PUT http://XXXXX.s3.amazonaws.com/?policy"
              onStart="aws_s3_example.AwsAuthGen(context, action)"&gt;

        &lt;Param name="Body"&gt;
          &lt;DataModel ref="Policy" /&gt;
        &lt;/Param&gt;
      &lt;/Action&gt;

    &lt;/State&gt;
  &lt;/StateModel&gt;

  &lt;Test name="Default" maxOutputSize="20000000"&gt;
    &lt;StateModel ref="TheStateModel"/&gt;
    &lt;Publisher class="Rest"&gt;
      &lt;Param name="FaultOnStatusCodes" value="500,501,502,503,504,505" /&gt;
    &lt;/Publisher&gt;
  &lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Publishers_SerialPort">
<title>SerialPort Publisher</title>
<simpara>The <emphasis>SerialPort</emphasis> publisher allows Peach to communicate with a device using a serial port and serial transmissions.</simpara>
<section xml:id="_syntax_107">
<title>Syntax</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;Publisher class="SerialPort"&gt;
    &lt;Param name="PortName" value="/dev/ttyUSB0"/&gt;
    &lt;Param name="Baudrate" value="115200"/&gt;
    &lt;Param name="DataBits" value="8"/&gt;
    &lt;Param name="Parity" value="None"/&gt;
    &lt;Param name="StopBits" value="One"/&gt;
&lt;/Publisher&gt;</programlisting>
</section>
<section xml:id="_parameters_126">
<title>Parameters</title>
<simpara><emphasis>Required:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>PortName</term>
<listitem>
<simpara>Serial port device name</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Baudrate</term>
<listitem>
<simpara>Serial baud rate. The transmission rate that accounts for data bits and more: start bit, stop bits, parity bits, and commands.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Parity</term>
<listitem>
<simpara>The parity-checking protocol.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>DataBits</term>
<listitem>
<simpara>Standard length of data bits per byte.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>StopBits</term>
<listitem>
<simpara>The standard number of stop bits per byte.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>Handshake</term>
<listitem>
<simpara>The handshaking protocol for serial port data transmission. The default value is none.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Timeout</term>
<listitem>
<simpara>Maximum waiting period, specified in milliseconds, between transmissions. The default value is 3,000.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_actions_16">
<title>Actions</title>
<variablelist>
<varlistentry>
<term><link linkend="Action_open">open</link></term>
<listitem>
<simpara>Open the device</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_input">input</link></term>
<listitem>
<simpara>Receive data</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_output">output</link></term>
<listitem>
<simpara>Send data</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_175">
<title>Examples</title>
<example>
<title>Sending and receiving data</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://peachfuzzer.com/2012/Peach /peach/peach.xsd"&gt;

  &lt;DataModel name="DataModel"&gt;
    &lt;Blob name="Hello" value="Hello Serial Device!\n"/&gt;
  &lt;/DataModel&gt;

  &lt;StateModel name="TheState" initialState="Initial"&gt;
    &lt;State name="Initial"&gt;
      &lt;Action type="open"/&gt;
      &lt;Action type="output"&gt;
        &lt;DataModel ref="DataModel"/&gt;
      &lt;/Action&gt;
      &lt;Action type="input"&gt;
        &lt;DataModel ref="DataModel"/&gt;
      &lt;/Action&gt;
    &lt;/State&gt;
  &lt;/StateModel&gt;

  &lt;Test name="Default"&gt;
    &lt;StateModel ref="TheState"/&gt;
    &lt;Publisher class="SerialPort"&gt;
      &lt;Param name="PortName" value="/dev/ttyUSB0"/&gt;
      &lt;Param name="Baudrate" value="115200"/&gt;
      &lt;Param name="DataBits" value="8"/&gt;
      &lt;Param name="Parity" value="None"/&gt;
      &lt;Param name="StopBits" value="One"/&gt;
    &lt;/Publisher&gt;  &lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Publishers_Ssl">
<title>Ssl Publisher</title>
<simpara>The <emphasis>Ssl</emphasis> Publisher enables a pit to communicate via an SSL over TCP socket.</simpara>
<simpara><emphasis>Ssl</emphasis> is used to fuzz protocols built inside an SSL encrypted channel (such as HTTPS).</simpara>
<simpara>Since it is easy to confuse <emphasis>Ssl</emphasis> and <emphasis>SslListner</emphasis>, here&#8217;s the difference:</simpara>
<itemizedlist>
<listitem>
<simpara>The <emphasis>Ssl</emphasis> Publisher connects out</simpara>
</listitem>
<listitem>
<simpara>The <emphasis>SslListner</emphasis> Publisher accepts (inward) connections</simpara>
</listitem>
</itemizedlist>
<section xml:id="_syntax_108">
<title>Syntax</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;Publisher class="Ssl"&gt;
	&lt;Param name="Host" value="192.168.48.128" /&gt;
	&lt;Param name="Port" value="433" /&gt;
&lt;/Publisher&gt;

&lt;Publisher class="Ssl"&gt;
	&lt;Param name="Host" value="192.168.48.128" /&gt;
	&lt;Param name="Port" value="433" /&gt;
	&lt;Param name="Alpn" value="h2;spdy/3.1;http/1.1" /&gt;
&lt;/Publisher&gt;</programlisting>
</section>
<section xml:id="_parameters_127">
<title>Parameters</title>
<simpara><emphasis>Required:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>Host</term>
<listitem>
<simpara>Hostname to connect to.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Port</term>
<listitem>
<simpara>Port to connect to.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>ClientCert</term>
<listitem>
<simpara>Provide client certificate for server verification.
Path to client certificate in PEM format</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>ClientKey</term>
<listitem>
<simpara>Provide client key for server verification.
Path to client private key in PEM format</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Alpn</term>
<listitem>
<simpara>Enable ALPN TLS extension (RFC 7301).
Example value: <literal>h2;spdy/3.1;http/1.1</literal></simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>VerifyServer</term>
<listitem>
<simpara>Verify the server certificate. Defaults to false.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>ConnectTimeout</term>
<listitem>
<simpara>Max milliseconds to wait for connection (default 10000).</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Timeout</term>
<listitem>
<simpara>How many milliseconds to wait for data (default 3000).</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_actions_17">
<title>Actions</title>
<variablelist>
<varlistentry>
<term><link linkend="Action_start">start</link></term>
<listitem>
<simpara>Implicit Action to start the Publisher.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_stop">stop</link></term>
<listitem>
<simpara>Implicit Action to stop the Publisher.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_open">open</link></term>
<listitem>
<simpara>Open and initialize the SSL connection.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_close">close</link></term>
<listitem>
<simpara>Close and clean up the SSL connection.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_output">output</link></term>
<listitem>
<simpara>Data sent via output is written to the SSL stream.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_input">input</link></term>
<listitem>
<simpara>Data received via input is read from the SSL input buffer.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_176">
<title>Examples</title>
<formalpara>
<title>Sending and receiving data</title>
<para>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://peachfuzzer.com/2012/Peach /peach/peach.xsd"&gt;

	&lt;DataModel name="OutModel"&gt;
		&lt;Block name="Headers"&gt;
			&lt;String value="POST /testsslpage.html HTTP/1.0\r\n" /&gt;
			&lt;String value="User-Agent: TestAgent/1.0\r\n"/&gt;
			&lt;String value="Content-Length:   " /&gt;
			&lt;String name="ContentLen"&gt;
				&lt;Relation of="Data" type="size"/&gt;
			&lt;/String&gt;
			&lt;String value="\r\n\r\n"/&gt;
			&lt;String name="Data"/&gt;
		&lt;/Block&gt;
	&lt;/DataModel&gt;

	&lt;DataModel name="InModel"&gt;
		&lt;String value="{" token="true" /&gt;
		&lt;String /&gt;
		&lt;String value="}" token="true" /&gt;
	&lt;/DataModel&gt;

	&lt;StateModel name="State" initialState="First"&gt;
		&lt;State name="First"&gt;
			&lt;Action type="output"&gt;
				&lt;DataModel ref="OutModel"&gt;
			&lt;/Action&gt;
			&lt;Action type="input"&gt;
				&lt;DataModel ref="InModel"&gt;
			&lt;/Action&gt;
		&lt;/State&gt;
	&lt;/StateModel&gt;

	&lt;Test name="Default"&gt;
		&lt;StateModel ref="State"/&gt;

		&lt;Publisher class="Ssl"&gt;
			&lt;Param name="Host" value="localhost"/&gt;
			&lt;Param name="Port" value="31337"/&gt;
			&lt;Param name="Timeout" value="3000"/&gt;
		&lt;/Publisher&gt;
	&lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
</para>
</formalpara>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Publishers_SslListener">
<title>SslListener Publisher</title>
<simpara>The <emphasis>SslListner</emphasis> Publisher enables a pit to accept SSL connections over a TCP socket.</simpara>
<simpara><emphasis>SslListner</emphasis> is used to fuzz protocol built inside an SSL encrypted channel, such as HTTPS.</simpara>
<simpara>Since it is easy to confuse <emphasis>Ssl</emphasis> and <emphasis>SslListner</emphasis>, here&#8217;s the difference:</simpara>
<itemizedlist>
<listitem>
<simpara>The <emphasis>Ssl</emphasis> Publisher connects out(ward)</simpara>
</listitem>
<listitem>
<simpara>The <emphasis>SslListner</emphasis> Publisher accepts (inward) connections</simpara>
</listitem>
</itemizedlist>
<simpara>The SslListener is similar to the TcpListener because both accept connections over a TCP port and block until a connection has been established.</simpara>
<section xml:id="_syntax_109">
<title>Syntax</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;Publisher class="SslListener"&gt;
	&lt;Param name="Interface" value="0.0.0.0"/&gt;
	&lt;Param name="Port" value="31337"/&gt;
	&lt;Param name="Timeout" value="3000"/&gt;
	&lt;Param name="AcceptTimeout" value="3000"/&gt;
	&lt;Param name="ServerCertPath" value="cert.pfx" /&gt;
&lt;/Publisher&gt;</programlisting>
</section>
<section xml:id="_parameters_128">
<title>Parameters</title>
<simpara><emphasis>Required:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>Interface</term>
<listitem>
<simpara>IP of interface to bind to. Use <literal>0.0.0.0</literal> for all interfaces.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Port</term>
<listitem>
<simpara>Local port to listen on.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>ServerCertPath</term>
<listitem>
<simpara>Path to server certificate file.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>AcceptTimeout</term>
<listitem>
<simpara>How many milliseconds to wait for a connection. Defaults to 3000.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>CheckCertRevocation</term>
<listitem>
<simpara>Check revocation of certificate. Defaults to false.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>ClientCertRequired</term>
<listitem>
<simpara>Require client to authenticate via certificate. Defaults to false.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>ServerCertPass</term>
<listitem>
<simpara>Password for cert file. Defaults to none.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Timeout</term>
<listitem>
<simpara>How many milliseconds to wait for data. Defaults to 3000.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_actions_18">
<title>Actions</title>
<variablelist>
<varlistentry>
<term><link linkend="Action_start">start</link></term>
<listitem>
<simpara>Implicit Action to start the Publisher.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_stop">stop</link></term>
<listitem>
<simpara>Implicit Action to stop the Publisher.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_open">open</link></term>
<listitem>
<simpara>Open and initialize the SSL connection.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_close">close</link></term>
<listitem>
<simpara>Close and clean up the SSL connection.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_accept">accept</link></term>
<listitem>
<simpara>Block until an incoming SSL connection has been received.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_output">output</link></term>
<listitem>
<simpara>Data sent via output is written to the SSL stream.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_input">input</link></term>
<listitem>
<simpara>Data received via input is read from the SSL input buffer.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_177">
<title>Examples</title>
<example>
<title>Sending and receiving data</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://peachfuzzer.com/2012/Peach /peach/peach.xsd"&gt;

	&lt;DataModel name="OutModel"&gt;
		&lt;Block name="Headers"&gt;
			&lt;String value="{" /&gt;
			&lt;String value="key1" /&gt;
			&lt;String value="," /&gt;
			&lt;String value="value1" /&gt;
			&lt;String value="}" /&gt;
		&lt;/Block&gt;
	&lt;/DataModel&gt;

	&lt;DataModel name="InModel"&gt;
		&lt;String value="GET /testsslpage.html HTTP/1.0\r\n" /&gt;
	&lt;/DataModel&gt;

	&lt;StateModel name="State" initialState="First"&gt;
		&lt;State name="First"&gt;
			&lt;Action type="accept" /&gt;
			&lt;Action type="input"&gt;
				&lt;DataModel ref="InModel"&gt;
			&lt;/Action&gt;
			&lt;Action type="output"&gt;
				&lt;DataModel ref="OutModel"&gt;
			&lt;/Action&gt;
		&lt;/State&gt;
	&lt;/StateModel&gt;

	&lt;Test name="Default"&gt;
		&lt;StateModel ref="State"/&gt;

		&lt;Publisher class="SslListener"&gt;
			&lt;Param name="Interface" value="0.0.0.0"/&gt;
			&lt;Param name="Port" value="31337"/&gt;
			&lt;Param name="Timeout" value="3000"/&gt;
			&lt;Param name="AcceptTimeout" value="3000"/&gt;
			&lt;Param name="ServerCertPath" value="cert.pfx" /&gt;
		&lt;/Publisher&gt;
	&lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Publishers_Tcp">
<title>Tcp Client Publisher</title>
<simpara>The <emphasis>Tcp</emphasis> Client publisher connects to a remote TCP service.</simpara>
<simpara>Since it is easy to confuse <emphasis>Tcp</emphasis> Client and <emphasis>TcpListener</emphasis>, here&#8217;s the difference:</simpara>
<itemizedlist>
<listitem>
<simpara>The <emphasis>Tcp</emphasis> Client Publisher connects out(ward)</simpara>
</listitem>
<listitem>
<simpara>The <emphasis>TcpListener</emphasis> Publisher listens to (inward) connections</simpara>
</listitem>
</itemizedlist>
<section xml:id="_syntax_110">
<title>Syntax</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;Publisher class="Tcp"&gt;
	&lt;Param name="Host" value="127.0.0.1" /&gt;
	&lt;Param name="Port" value="8080" /&gt;
&lt;/Publisher&gt;</programlisting>
</section>
<section xml:id="_parameters_129">
<title>Parameters</title>
<simpara><emphasis>Required:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>Host</term>
<listitem>
<simpara>Hostname or IP address of remote host</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Port</term>
<listitem>
<simpara>Destination port number</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>RetryMode</term>
<listitem>
<simpara>Connection retry method, defaults to <literal>FirstAndAfterFault</literal>.</simpara>
<simpara><emphasis>Options:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>Never</term>
<listitem>
<simpara>Never attempt a reconnection</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>FirstAndAfterFault</term>
<listitem>
<simpara>Only reattempt a connection when the remote host may be have restarted by Peach. This will be on first iteration and after a fault was detected.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Always</term>
<listitem>
<simpara>Always attempt a reconnection</simpara>
</listitem>
</varlistentry>
</variablelist>
</listitem>
</varlistentry>
<varlistentry>
<term>FaultOnConnectionFailure</term>
<listitem>
<simpara>Log a fault when unable to connect to remote host. Defaults to true.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Lifetime</term>
<listitem>
<simpara>Lifetime of connection.  Defaults to <literal>Iteration</literal>.</simpara>
<simpara><emphasis>Options:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>Iteration</term>
<listitem>
<simpara>Connection lasts lifetime of a testcase/iteration.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Session</term>
<listitem>
<simpara>Connection lasts lifetime of testing session. Reconnects if connection is closed, but otherwise the connection will be left open.</simpara>
</listitem>
</varlistentry>
</variablelist>
</listitem>
</varlistentry>
<varlistentry>
<term>Timeout</term>
<listitem>
<simpara>How long to wait in milliseconds for data. Defaults to 3,000.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>ConnectTimeout</term>
<listitem>
<simpara>How long to wait in milliseconds for a new connection. Defaults to 10,000.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_actions_19">
<title>Actions</title>
<variablelist>
<varlistentry>
<term><link linkend="Action_output">output</link></term>
<listitem>
<simpara>Send data to remote host</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_input">input</link></term>
<listitem>
<simpara>Receive data from remote host</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_178">
<title>Examples</title>
<example>
<title>Sending and receiving data</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
			 xsi:schemaLocation="http://peachfuzzer.com/2012/Peach /peach/peach.xsd"&gt;

	&lt;DataModel name="TheDataModel"&gt;
		&lt;String name="value" length="4" /&gt;
	&lt;/DataModel&gt;

	&lt;StateModel name="TheState" initialState="Initial"&gt;
		&lt;State name="Initial"&gt;
			&lt;Action type="output"&gt;
				&lt;DataModel ref="TheDataModel"/&gt;
				&lt;Data&gt;
					&lt;Field name="value" value="mike" /&gt;
				&lt;/Data&gt;
			&lt;/Action&gt;

			&lt;!-- receive 4 bytes --&gt;
			&lt;Action type="input"&gt;
				&lt;DataModel ref="TheDataModel"/&gt;
			&lt;/Action&gt;
		&lt;/State&gt;
	&lt;/StateModel&gt;

	&lt;Agent name="TheAgent"/&gt;

	&lt;Test name="Default"&gt;
		&lt;Agent ref="TheAgent"/&gt;
		&lt;StateModel ref="TheState"/&gt;
		&lt;Publisher class="Tcp"&gt;
			&lt;Param name="Host" value="127.0.0.1" /&gt;
			&lt;Param name="Port" value="8080" /&gt;
		&lt;/Publisher&gt;
	&lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Publishers_TcpListener">
<title>TcpListener Publisher</title>
<simpara>The <emphasis>TcpListener</emphasis> publisher is able to listen for incoming connections on a TCP port.</simpara>
<simpara>Since it is easy to confuse <emphasis>Tcp</emphasis> Client and <emphasis>TcpListener</emphasis>, here&#8217;s the difference:</simpara>
<itemizedlist>
<listitem>
<simpara>The <emphasis>Tcp</emphasis> Client Publisher connects out(ward)</simpara>
</listitem>
<listitem>
<simpara>The <emphasis>TcpListener</emphasis> Publisher listens to (inward) connections</simpara>
</listitem>
</itemizedlist>
<section xml:id="_syntax_111">
<title>Syntax</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;Publisher class="TcpListener"&gt;
    &lt;Param name="Interface" value="127.0.0.1" /&gt;
    &lt;Param name="Port" value="8080" /&gt;
&lt;/Publisher&gt;</programlisting>
</section>
<section xml:id="_parameters_130">
<title>Parameters</title>
<simpara><emphasis>Required:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>Interface</term>
<listitem>
<simpara>IP of interface to bind to</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Port</term>
<listitem>
<simpara>Destination port number</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>Timeout</term>
<listitem>
<simpara>How long to wait in milliseconds for data once a connection has been established. Defaults to 3,000.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>AcceptTimeout</term>
<listitem>
<simpara>How long to wait in milliseconds for a new connection. Defaults to 3,000.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_actions_20">
<title>Actions</title>
<variablelist>
<varlistentry>
<term><link linkend="Action_accept">accept</link></term>
<listitem>
<simpara>Wait for incoming connection</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_output">output</link></term>
<listitem>
<simpara>Send data to remote host</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_input">input</link></term>
<listitem>
<simpara>Receive data from remote host</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_179">
<title>Examples</title>
<example>
<title>Sending and receiving data</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

  &lt;DataModel name="TheDataModel"&gt;
    &lt;String name="value" length="4" /&gt;
  &lt;/DataModel&gt;

  &lt;StateModel name="TheState" initialState="Initial"&gt;
    &lt;State name="Initial"&gt;
      &lt;Action type="accept" /&gt;
      &lt;Action type="output"&gt;
        &lt;DataModel ref="TheDataModel"/&gt;
        &lt;Data&gt;
          &lt;Field name="value" value="mike" /&gt;
        &lt;/Data&gt;
      &lt;/Action&gt;

      &lt;!-- receive 4 bytes --&gt;
      &lt;Action type="input"&gt;
        &lt;DataModel ref="TheDataModel"/&gt;
      &lt;/Action&gt;
    &lt;/State&gt;
  &lt;/StateModel&gt;

  &lt;Agent name="TheAgent"/&gt;

  &lt;Test name="Default"&gt;
    &lt;Agent ref="TheAgent"/&gt;
    &lt;StateModel ref="TheState"/&gt;
    &lt;Publisher class="TcpListener"&gt;
      &lt;Param name="Interface" value="127.0.0.1" /&gt;
      &lt;Param name="Port" value="8080" /&gt;
    &lt;/Publisher&gt;
  &lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Publishers_Udp">
<title>Udp Publisher</title>
<simpara>The <emphasis>Udp</emphasis> publisher sends and receives UDP packets.</simpara>
<simpara>The underlying stack correctly pads out the UDP packet on output and strips the UDP padding on input.
Because of the padding and stripping, a slight difference occurs between the lengths of an incoming packet
and the corresponding outgoing packet. This has no effect on the actual data sent; the integrity of the
actual data remains intact.</simpara>
<simpara>Each <emphasis>Udp</emphasis> output action results in a single packet being sent. Each <emphasis>Udp</emphasis> input action receives a single packet.</simpara>
<section xml:id="_syntax_112">
<title>Syntax</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;Publisher class="Udp"&gt;
	&lt;Param name="Host" value="127.0.0.1" /&gt;
	&lt;Param name="Port" value="8000" /&gt;
&lt;/Publisher&gt;</programlisting>
</section>
<section xml:id="_parameters_131">
<title>Parameters</title>
<simpara><emphasis>Required:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>Host</term>
<listitem>
<simpara>Host or IP address or remote host</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>Port</term>
<listitem>
<simpara>Destination port number, only optional when first packet is sent by target.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>SrcPort</term>
<listitem>
<simpara>Source port</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Interface</term>
<listitem>
<simpara>IP of interface to bind to</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Timeout</term>
<listitem>
<simpara>How long to wait in milliseconds for data/connection. Defaults to 3,000.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>MaxMTU</term>
<listitem>
<simpara>Maximum allowable MTU property value. Defaults to 131,070.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>MinMTU</term>
<listitem>
<simpara>Minimum allowable MTU property value. Defaults to 1,280.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_actions_21">
<title>Actions</title>
<variablelist>
<varlistentry>
<term><link linkend="Action_output">output</link></term>
<listitem>
<simpara>Send a single UDP packet to remote host.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_input">input</link></term>
<listitem>
<simpara>Receive a single UDP packet from remote host.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_getProperty">getProperty</link></term>
<listitem>
<simpara>Get a property value.</simpara>
<simpara>This publisher supports two properties:</simpara>
<informaltable tabstyle="horizontal" frame="none" colsep="0" rowsep="0">
<tgroup cols="2">
<colspec colwidth="15*"/>
<colspec colwidth="85*"/>
<tbody valign="top">
<row>
<entry>
<simpara>LastRecvAddr</simpara>
</entry>
<entry>
<simpara>The last receive address</simpara>
</entry>
</row>
<row>
<entry>
<simpara>Port</simpara>
</entry>
<entry>
<simpara>Get the <literal>Port</literal> parameter.</simpara>
</entry>
</row>
<row>
<entry>
<simpara>MTU</simpara>
</entry>
<entry>
<simpara>Get the <literal>MTU</literal> of the interface</simpara>
</entry>
</row>
<row>
<entry>
<simpara>SrcPort</simpara>
</entry>
<entry>
<simpara>Get the <literal>SrcPort</literal> parameter.</simpara>
</entry>
</row>
</tbody>
</tgroup>
</informaltable>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_setProperty">setProperty</link></term>
<listitem>
<simpara>Set a property value.</simpara>
<simpara>This publisher supports two properties:</simpara>
<informaltable tabstyle="horizontal" frame="none" colsep="0" rowsep="0">
<tgroup cols="2">
<colspec colwidth="15*"/>
<colspec colwidth="85*"/>
<tbody valign="top">
<row>
<entry>
<simpara>Port</simpara>
</entry>
<entry>
<simpara>Change the <literal>Port</literal> parameter.</simpara>
</entry>
</row>
<row>
<entry>
<simpara>MTU</simpara>
</entry>
<entry>
<simpara>Change the <literal>MTU</literal> parameter.</simpara>
</entry>
</row>
<row>
<entry>
<simpara>SrcPort</simpara>
</entry>
<entry>
<simpara>Change the <literal>SrcPort</literal> parameter.</simpara>
</entry>
</row>
</tbody>
</tgroup>
</informaltable>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_180">
<title>Examples</title>
<example>
<title>Connect Example</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
			 xsi:schemaLocation="http://peachfuzzer.com/2012/Peach /peach/peach.xsd"&gt;

	&lt;DataModel name="TheDataModel"&gt;
		&lt;String name="value" length="4" /&gt;
	&lt;/DataModel&gt;

	&lt;StateModel name="TheState" initialState="Initial"&gt;
		&lt;State name="Initial"&gt;
			&lt;Action type="output"&gt;
				&lt;DataModel ref="TheDataModel"/&gt;
				&lt;Data&gt;
					&lt;Field name="value" value="mike" /&gt;
				&lt;/Data&gt;
			&lt;/Action&gt;

			&lt;!-- receive 4 bytes --&gt;
			&lt;Action type="input"&gt;
				&lt;DataModel ref="TheDataModel"/&gt;
			&lt;/Action&gt;
		&lt;/State&gt;
	&lt;/StateModel&gt;

	&lt;Agent name="TheAgent"/&gt;

	&lt;Test name="Default"&gt;
		&lt;Agent ref="TheAgent"/&gt;
		&lt;StateModel ref="TheState"/&gt;
		&lt;Publisher class="Udp"&gt;
			&lt;Param name="Host" value="127.0.0.1" /&gt;
			&lt;Param name="Port" value="8000" /&gt;
		&lt;/Publisher&gt;

	&lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
</example>
<example>
<title>Listener</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
			 xsi:schemaLocation="http://peachfuzzer.com/2012/Peach /peach/peach.xsd"&gt;

	&lt;DataModel name="TheDataModel"&gt;
		&lt;String name="value" length="4" /&gt;
	&lt;/DataModel&gt;

	&lt;StateModel name="TheState" initialState="Initial"&gt;
		&lt;State name="Initial"&gt;
			&lt;Action type="open"/&gt;
			&lt;Action type="output"&gt;
				&lt;DataModel ref="TheDataModel"/&gt;
				&lt;Data&gt;
					&lt;Field name="value" value="mike" /&gt;
				&lt;/Data&gt;
			&lt;/Action&gt;

			&lt;!-- receive 4 bytes --&gt;
			&lt;Action type="input"&gt;
				&lt;DataModel ref="TheDataModel"/&gt;
			&lt;/Action&gt;
			&lt;Action type="close"/&gt;
		&lt;/State&gt;
	&lt;/StateModel&gt;

	&lt;Agent name="TheAgent"/&gt;

	&lt;Test name="Default"&gt;
		&lt;Agent ref="TheAgent"/&gt;
		&lt;StateModel ref="TheState"/&gt;
		&lt;Publisher class="Udp"&gt;
			&lt;Param name="Host" value="127.0.0.1" /&gt;
			&lt;Param name="Interface" value="127.0.0.1" /&gt;
			&lt;Param name="SrcPort" value="8000" /&gt;
			&lt;Param name="Port" value="8001" /&gt;
		&lt;/Publisher&gt;

	&lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
</example>
<example>
<title>Multicast</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
			 xsi:schemaLocation="http://peachfuzzer.com/2012/Peach /peach/peach.xsd"&gt;

	&lt;DataModel name="TheDataModel"&gt;
		&lt;String name="value" length="4" /&gt;
	&lt;/DataModel&gt;

	&lt;StateModel name="TheState" initialState="Initial"&gt;
		&lt;State name="Initial"&gt;
			&lt;Action type="open"/&gt;
			&lt;Action type="output"&gt;
				&lt;DataModel ref="TheDataModel"/&gt;
				&lt;Data&gt;
					&lt;Field name="value" value="mike" /&gt;
				&lt;/Data&gt;
			&lt;/Action&gt;

			&lt;!-- receive 4 bytes --&gt;
			&lt;Action type="input"&gt;
				&lt;DataModel ref="TheDataModel"/&gt;
			&lt;/Action&gt;
			&lt;Action type="close"/&gt;
		&lt;/State&gt;
	&lt;/StateModel&gt;

	&lt;Agent name="TheAgent"/&gt;

	&lt;Test name="Default"&gt;
		&lt;Agent ref="TheAgent"/&gt;
		&lt;StateModel ref="TheState"/&gt;
    &lt;Publisher class="Udp" name="ListenPublisher"&gt;
      &lt;Param name="Host" value="224.0.0.1"/&gt;
      &lt;Param name="Port" value="8000"/&gt;
      &lt;Param name="SrcPort" value="8001"/&gt;
      &lt;Param name="Interface" value="127.0.0.1"/&gt;
    &lt;/Publisher&gt;
	&lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Publishers_Usb">
<title>USB Publisher</title>
<simpara>The <emphasis>Usb</emphasis> publisher is used to test devices via the USB hardware interface.
This publisher is used to test devices connected to a host via USB.
It cannot be used to test USB drivers.</simpara>
<simpara>The Usb publisher is a wrapper around libusb.
As such it can be useful at times to refer to the libusb documentation regarding questions about publisher parameters specific to USB or to diagnose error messages.</simpara>
<simpara>It is recommended that users have a basic understanding of how USB works prior to using the <emphasis>Usb</emphasis> publisher.</simpara>
<simpara>A number of tools exist that can assist in identifying USB devices and capturing traffic.
One tool that is highly recommended is <link xl:href="https://wiki.wireshark.org">Wireshark</link>. Wireshark has the ability to capture USB traffic on Windows and Linux. More information about capture USB with Wireshark can be found <link xl:href="https://wiki.wireshark.org/CaptureSetup/USB">here</link>.</simpara>
<section xml:id="_syntax_113">
<title>Syntax</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;Publisher class="Usb"&gt;
    &lt;Param name="VendorId" value="4817" /&gt;
    &lt;Param name="ProductId" value="5340" /&gt;

    &lt;Param name="Configuration" value="1"/&gt;
    &lt;Param name="Interface" value="0"/&gt;
    &lt;Param name="ReadEndpoint" value="Ep02" /&gt;
    &lt;Param name="WriteEndpoint" value="Ep02" /&gt;
&lt;/Publisher&gt;</programlisting>
</section>
<section xml:id="_parameters_132">
<title>Parameters</title>
<simpara><emphasis>Required:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>VendorId</term>
<listitem>
<simpara>USB vendor IDs (VID) are 16-bit numbers used in comingation with USB vendor IDs to identify USB devices to a  host.
Each vendor ID is assigned by the USB Implementers Forum to a specific company.
The VID is embedded in the product and communicated to the computer when the device is plugged in.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>ProductId</term>
<listitem>
<simpara>USB product IDs (PID) are 16-bit numbers used in combination with USB vendor IDs to identify USB devices to a host. Each vendor assigns a PID to individual products. The PID is then embedded in the product and communicated to the computer when the device is plugged in.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>Configuration</term>
<listitem>
<simpara>USB configuration to set for device. Defaults to 1. Use -2 to skip and -1 to set unconfigured state.</simpara>
<simpara>If the device is already configured with the selected configuration, a lightweight device reset will occur: a SET_CONFIGURATION is issued causing most USB-related device state to be reset.</simpara>
<simpara>The configuration cannot be set if other applications or drivers have claimed interfaces.
In this case a value of -2 can be used to skip setting the configuration.</simpara>
<simpara>A configuration value of -1 will put the device into unconfigured state.
The USB specifications state that a configuration value of 0 does this, however buddy devices exist which actually have a configuration 0.</simpara>
<simpara>A USB device configuration descriptor specified hwo the device is powered, the number of interfaces it has, etc.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Interface</term>
<listitem>
<simpara>USB device interface descriptor to claim for use. Defaults to 0.</simpara>
<simpara>The interface groups endpoints for a single feature of the device.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>ReadEndpoint</term>
<listitem>
<simpara>USB endpoint to read from. Defaults to <emphasis>Ep01</emphasis>. Options are: Ep01 through Ep15.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>ReadEndpointType</term>
<listitem>
<simpara>USB endpoint read type. Defaults to <emphasis>Bulk</emphasis>. Options are: Bulk, Control, Interrupt, Isochronous</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>WriteEndpoint</term>
<listitem>
<simpara>USB endpoint to write to. Defaults to <emphasis>Ep01</emphasis>. Options are: Ep01 through Ep15.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>WriteEndpointType</term>
<listitem>
<simpara>USB endpoint write type. Defaults to <emphasis>Bulk</emphasis>. Options are: Bulk, Control, Interrupt, Isochronous</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Timeout</term>
<listitem>
<simpara>How long to wait in milliseconds for reading and writing. Defaults to 3,000.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_actions_22">
<title>Actions</title>
<variablelist>
<varlistentry>
<term><link linkend="Action_start">start</link></term>
<listitem>
<simpara>Open USB device, set configuration, claim interface and open endpoints.</simpara>
<simpara>Performed once at the start of fuzzing.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_stop">stop</link></term>
<listitem>
<simpara>Free all USB resources. Performed once at the end of fuzzing.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_output">output</link></term>
<listitem>
<simpara>Transmit data via the USB writer endpoint.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_input">input</link></term>
<listitem>
<simpara>Receive data via the USB reader endpoint.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_181">
<title>Examples</title>
<example>
<title>USB Fuzzing Example</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://peachfuzzer.com/2012/Peach /peach-pro/output/win_x64_debug/bin/peach.xsd"&gt;

	&lt;Import import="time"/&gt;

	&lt;Defaults&gt;
		&lt;Number endian="big" signed="false"/&gt;
	&lt;/Defaults&gt;

	&lt;DataModel name="TheDataModel"&gt;
		&lt;Number name="MessageType" size="32" endian="little" value="1" /&gt;
		&lt;Number name="MessageLength" size="32" endian="little"&gt;
			&lt;Relation type="size" of="TheDataModel"/&gt;
		&lt;/Number&gt;
		&lt;Number name="DataOffset" size="32" endian="little"&gt;
			&lt;Relation type="offset" of="Frame"/&gt;
		&lt;/Number&gt;
		&lt;Number name="DataLength" size="32" endian="little"&gt;
			&lt;Relation type="size" of="Frame"/&gt;
		&lt;/Number&gt;
		&lt;Number name="OOBDataOffset" size="32" endian="little" value="0" /&gt;
		&lt;Number name="OOBDataLength" size="32" endian="little" value="0" /&gt;
		&lt;Number name="NumOOBDataElements" size="32" endian="little" value="0" /&gt;
		&lt;Number name="PerPacketInfoOffset" size="32" endian="little" value="0" /&gt;
		&lt;Number name="PerPacketInfoLength" size="32" endian="little" value="0" /&gt;
		&lt;Number name="VcHandle" size="32" endian="little" value="0" /&gt;
		&lt;Number name="Reserved" size="32" endian="little" value="0" /&gt;

		&lt;Blob name="Frame" value="AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"/&gt;
	&lt;/DataModel&gt;

	&lt;StateModel name="State" initialState="State1" &gt;
		&lt;State name="State1"&gt;
			&lt;Action type="output" onStart="time.sleep(1)"&gt;
				&lt;DataModel ref="TheDataModel"/&gt;
			&lt;/Action&gt;
		&lt;/State&gt;
	&lt;/StateModel&gt;

	&lt;Test name="Default"&gt;
		&lt;StateModel ref="State"/&gt;

		&lt;Publisher class="Usb"&gt;
			&lt;Param name="VendorId" value="4817" /&gt;
			&lt;Param name="ProductId" value="5340" /&gt;
			&lt;Param name="Configuration" value="1"/&gt;
			&lt;Param name="Interface" value="0"/&gt;
			&lt;Param name="ReadEndpoint" value="Ep02" /&gt;
			&lt;Param name="WriteEndpoint" value="Ep02" /&gt;
		&lt;/Publisher&gt;
	&lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Publishers_WebApi">
<title>WebApi Publisher</title>
<simpara>The <emphasis>WebApi</emphasis> Publisher  is an I/O adapter that communicates with various web API/HTTP end points.  This publisher is used with the <link linkend="Action_web">web</link> action type.</simpara>
<simpara>This is the recommended method to perform web requests using Peach.  The <literal>Rest</literal> and <literal>Http</literal> publishers are depricated.</simpara>
<simpara>This publisher, in combination with the <link linkend="Action_web">web</link> action gives full control over:</simpara>
<itemizedlist>
<listitem>
<simpara>Path</simpara>
</listitem>
<listitem>
<simpara>Query string</simpara>
</listitem>
<listitem>
<simpara>Form data</simpara>
</listitem>
<listitem>
<simpara>Body</simpara>
<itemizedlist>
<listitem>
<simpara>Json</simpara>
</listitem>
<listitem>
<simpara>XML</simpara>
</listitem>
<listitem>
<simpara>Binary</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
<simpara>Several analyzers are useful when building Pits for for use with this publisher:</simpara>
<variablelist>
<varlistentry>
<term><link linkend="Analyzers_Json">Json</link></term>
<listitem>
<simpara>Converts JSON documents or strings into Peach data models.
Can be used both inside of DataModels with the String element or also via the command line.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Analyzers_Postman">Postman</link></term>
<listitem>
<simpara>Converts Postman Catalogs to Peach Pits.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Analyzers_Swagger">Swagger</link></term>
<listitem>
<simpara>Converts Swagger JSON to Peach Pits</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Analyzers_WebRecordProxy">WebRecordProxy</link></term>
<listitem>
<simpara>Recording proxy captures web requests and generates full pit.
This makes creating the base pit easy, simply use as your HTTP proxy.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Analyzers_Xml">Xml</link></term>
<listitem>
<simpara>Converts XML documents or string into Peach data models.
Can be used both inside of DataModels with the String element or also via the command line.</simpara>
</listitem>
</varlistentry>
</variablelist>
<tip>
<simpara>SSL/TLS is supported, just use <literal>https</literal> as the protocol in the URL.</simpara>
</tip>
<section xml:id="_syntax_114">
<title>Syntax</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;Publisher class="WebApi"/&gt;</programlisting>
</section>
<section xml:id="_parameters_133">
<title>Parameters</title>
<simpara><emphasis>Required:</emphasis></simpara>
<simpara>There are no required parameters.</simpara>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>BaseUrl</term>
<listitem>
<simpara>The base URL to use for authentication.<?asciidoc-br?>
Example: <literal><link xl:href="http://myservice.domainname.example">http://myservice.domainname.example</link></literal>.<?asciidoc-br?>
This parameter is required if the <literal>Username</literal> and <literal>Password</literal> parameters are specified.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Username</term>
<listitem>
<simpara>Username for authentication</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Password</term>
<listitem>
<simpara>Password for for authentication</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Domain</term>
<listitem>
<simpara>Domain for authentication</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>FailureStatusCodes</term>
<listitem>
<simpara>Comma separated list of status codes that are failures causing current test case to stop.
Defaults to: <literal>400,401,402,403,404,405,406,407,408,409,410,411,412,413,414,415,416,417,500,501,502,503,504,505</literal></simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>FaultOnStatusCodes</term>
<listitem>
<simpara>Comma separated list of status codes that are faults. Defaults to none.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Timeout</term>
<listitem>
<simpara>How long to wait in milliseconds for data/connection. the default value is 3,000.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>IgnoreCertErrors</term>
<listitem>
<simpara>Allow HTTPS regardless of cert status. The default value is true.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Proxy</term>
<listitem>
<simpara>To use HTTP proxy, set the URL. Default is none. Example: <literal><link xl:href="http://192.168.1.1:8080">http://192.168.1.1:8080</link></literal>.<?asciidoc-br?>
<?asciidoc-br?>
The publisher will not use the default system proxy.
If a proxy is required it must be explicitly set via the publisher parameter.<?asciidoc-br?>
<?asciidoc-br?>
Please note that the host <literal>localhost</literal> and IP 127.0.0.1 will bypass the provided proxy. This is a behavior hardcoded into the underlying http networking code. For a discussion of options to deal with this limitation see the following article: <link xl:href="http://docs.telerik.com/fiddler/Configure-Fiddler/Tasks/MonitorLocalTraffic">Fiddler - Monitoring Local Traffic</link>.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_actions_23">
<title>Actions</title>
<variablelist>
<varlistentry>
<term><link linkend="Action_web">web</link></term>
<listitem>
<simpara>Web actions are used to perform WebApi calls.</simpara>
<simpara>This action provides full control over the HTTP request.
The <emphasis>method</emphasis> attribute contains the HTTP method (GET, POST, etc.).
The <emphasis>url</emphasis> attribute contains the URL with optional parameter substitution tokens.
These tokens are replaced with the parameters provided by the <emphasis>Path</emphasis> elements.</simpara>
<itemizedlist>
<listitem>
<simpara>This example places a call that expects to receive a single parameter: <literal><link xl:href="http://localhost/product/{id}">http://localhost/product/{id}</link></literal></simpara>
</listitem>
<listitem>
<simpara>Query parameters are set using <emphasis>Query</emphasis> elements.</simpara>
<simpara>This action also supports the <link linkend="web_Response">Response</link> element to capture the response status code, headers and body.</simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_example_5">
<title>Example</title>
<example>
<title>Calling WebApi Services with Result</title>
<simpara>The following example provides three fragments using the GET and POST methods.
For the GET request, the Result element is used to capture any returned data.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

&lt;DataModel name="PostData"&gt;
    &lt;JsonObject&gt;
        &lt;JsonString propertyName="Name" value="Widget" /&gt;
        &lt;JsonDouble propertyName="Price" value="1.99" /&gt;
        &lt;JsonInteger propertyName="Quantify" value="1" /&gt;
    &lt;/JsonObject&gt;
&lt;/DataModel&gt;

&lt;DataModel name="WebApiResult"&gt;
	&lt;Choice name="ResultOrEmpty"&gt;
		&lt;String name="Result"&gt;
			&lt;Analyzer class="Json" /&gt;
		&lt;/String&gt;
		&lt;Block name="Empty" /&gt;
	&lt;/Choice&gt;
&lt;/DataModel&gt;

&lt;StateModel name="Default" initialState="FirstState"&gt;
    &lt;State name="FirstState"&gt;
        &lt;Action type="web" method="GET" url="http://www.example.com/product/{id}"&gt;
            &lt;Path name="Id" key="id" value="1"/&gt;

            &lt;Response /&gt;
                &lt;DataModel ref="WebApiResult" /&gt;
            &lt;/Response&gt;
        &lt;/Action&gt;

        &lt;Action type="web" method="GET" url="http://www.example.com/invoices"&gt;
            &lt;Query name="StartDate" key="start_date" value="11-21-2011" /&gt;
            &lt;Query name="EndDate" key="end_date" value="11-21-2015" /&gt;

            &lt;Response&gt;
                &lt;DataModel ref="WebApiResult" /&gt;
            &lt;/Response&gt;
        &lt;/Action&gt;

        &lt;Action type="call" method="POST" url="http://www.example.com/product/{id}"&gt;
            &lt;Path name="Id" key="id" value="100" /&gt;
            &lt;Body name="PostData"&gt;
                &lt;DataModel ref="PostData" /&gt;
            &lt;/Body&gt;
        &lt;/Action&gt;
    &lt;/State&gt;
&lt;/StateModel&gt;

&lt;Test name="Default"&gt;
    &lt;StateModel ref="Default" /&gt;
    &lt;Publisher class="WebApi" /&gt;
&lt;/Test&gt;

&lt;/Peach&gt;</programlisting>
</example>
<example>
<title>Posting XML</title>
<simpara>The following example provides three fragments using the GET and POST methods.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

&lt;DataModel name="PostData"&gt;
    &lt;XmlElement elementName="Product"&gt;
        &lt;XmlAttribute attributeName="Name"&gt;
            &lt;String value="Widget" /&gt;
        &lt;/XmlAttribute&gt;
        &lt;XmlAttribute attributeName="Price"&gt;
            &lt;String value="1.99" /&gt;
        &lt;/XmlAttribute&gt;
        &lt;XmlAttribute attributeName="Quantity"&gt;
            &lt;String value="1" /&gt;
        &lt;/XmlAttribute&gt;
    &lt;/XmlElement&gt;
&lt;/DataModel&gt;

&lt;StateModel name="Default" initialState="FirstState"&gt;
    &lt;State name="FirstState"&gt;

        &lt;Action type="web" method="POST" url="http://www.example.com/product/{id}"&gt;
            &lt;Path name="Id" key="id" value="1"/&gt;

            &lt;Body name="PostData"&gt;
                &lt;DataModel ref="PostData" /&gt;
            &lt;/Body&gt;
        &lt;/Action&gt;

    &lt;/State&gt;
&lt;/StateModel&gt;

&lt;Test name="Default"&gt;
    &lt;StateModel ref="Default" /&gt;
    &lt;Publisher class="WebApi" /&gt;
&lt;/Test&gt;

&lt;/Peach&gt;</programlisting>
</example>
<example>
<title>Posting Binary</title>
<simpara>The following example provides three fragments using the GET and POST methods.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

&lt;DataModel name="PostData"&gt;
    &lt;Blob /&gt;
&lt;/DataModel&gt;

&lt;StateModel name="Default" initialState="FirstState"&gt;
    &lt;State name="FirstState"&gt;

        &lt;Action type="web" method="POST" url="http://www.example.com/product/{id}/image"&gt;
            &lt;Path name="Id" key="id" value="1"/&gt;
            &lt;Body name="PostData"&gt;
                &lt;DataModel ref="PostData" /&gt;
                &lt;Data fileName="image.png" /&gt;
            &lt;/Body&gt;
        &lt;/Action&gt;

    &lt;/State&gt;
&lt;/StateModel&gt;

&lt;Test name="Default"&gt;

    &lt;StateModel ref="Default"/&gt;
    &lt;Publisher class="WebApi"/&gt;

&lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
</example>
<example>
<title>Setting Custom Header via Pit</title>
<simpara>The following example shows how to set a custom header via the Pit XML.
The custom header is named "X-CustomeHeader" with a value of "Hello World".</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

&lt;StateModel name="Default" initialState="FirstState"&gt;
    &lt;State name="FirstState"&gt;

        &lt;Action type="web" method="GET" url="http://www.example.com/product/{id}"&gt;
            &lt;Path name="Id" key="id" value="1"/&gt;
            &lt;Header name="x-custom" key="X-CustomHeader" value="Hello World!" /&gt;
            &lt;Response/&gt;
        &lt;/Action&gt;

    &lt;/State&gt;
&lt;/StateModel&gt;

&lt;Test name="Default"&gt;
    &lt;StateModel ref="Default" /&gt;
    &lt;Publisher class="WebApi" /&gt;
&lt;/Test&gt;

&lt;/Peach&gt;</programlisting>
</example>
<example>
<title>Setting Custom Authentication Header via Python</title>
<simpara>The following example shows how to add custom authentication via a python script.
In this example we will configure a pit for fuzzing an Amazon AWS S3 service endpoint.
This is only an example and should not actually be used to fuzz AWS.</simpara>
<programlisting language="python" linenumbering="unnumbered">import base64
import hmac
from hashlib import sha1
from email.Utils import formatdate

AWS_ACCESS_KEY_ID = "44CF9590006BF252F707"
AWS_SECRET_KEY = "OtxrzxIsfpFjA7SwPzILwy8Bw21TLhquhboDYROV"

def AwsAuthGen(context, action):

    # Get the Publisher (WebApiPublisher)
    if action.publisher:
        publisher = context.test.publishers[action.publisher]
    else:
        publisher = context.test.publishers[0]

    XAmzDate = formatdate()

    h = hmac.new(AWS_SECRET_KEY, "PUT\n\napplication/json\n\nx-amz-date:%s\n/?policy" % XAmzDate, sha1)
    authToken = base64.encodestring(h.digest()).strip()

    publisher.Headers.Add("x-amz-date", XAmzDate)
    publisher.Headers.Add("Authorization", "AWS %s:%s" % (AWS_ACCESS_KEY_ID, authToken))

# end</programlisting>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

  &lt;Import import="aws_s3_example"/&gt;

  &lt;!--
{
"Version":"2008-10-17",
"Id":"aaaa-bbbb-cccc-dddd",
"Statement" : [
    {
        "Effect":"Allow",
        "Sid":"1",
        "Principal" : {
            "AWS":["111122223333","444455556666"]
        },
        "Action":["s3:*"],
        "Resource":"arn:aws:s3:::bucket/*"
    }
 ]
}
  --&gt;
  &lt;!-- Generated using the JSON analyzer --&gt;
  &lt;DataModel name="Policy"&gt;
    &lt;JsonObject&gt;
      &lt;JsonString propertyName="Version" name="Version" value="2008-10-17" /&gt;
      &lt;JsonString propertyName="Id" name="Id" value="aaaa-bbbb-cccc-dddd" /&gt;
      &lt;JsonArray propertyName="Statement" name="Statement"&gt;
        &lt;JsonObject propertyName="Statement" name="Statement"&gt;
          &lt;JsonString propertyName="Effect" name="Effect" value="Allow" /&gt;
          &lt;JsonString propertyName="Sid" name="Sid" value="1" /&gt;
          &lt;JsonObject propertyName="Principal" name="Principal"&gt;
            &lt;JsonArray propertyName="AWS" name="AWS"&gt;
              &lt;JsonString propertyName="AWS" name="AWS" value="111122223333" /&gt;
              &lt;JsonString value="444455556666" /&gt;
            &lt;/JsonArray&gt;
          &lt;/JsonObject&gt;
          &lt;JsonArray propertyName="Action" name="Action"&gt;
            &lt;JsonString propertyName="Action" name="Action" value="s3:*" /&gt;
          &lt;/JsonArray&gt;
          &lt;JsonString propertyName="Resource" name="Resource" value="arn:aws:s3:::bucket/*" /&gt;
        &lt;/JsonObject&gt;
      &lt;/JsonArray&gt;
    &lt;/JsonObject&gt;
  &lt;/DataModel&gt;

  &lt;StateModel name="TheStateModel" initialState="Initial"&gt;
    &lt;State name="Initial"&gt;

      &lt;Action type="web" method="PUT" url="http://XXXXX.s3.amazonaws.com/?policy"
              onStart="aws_s3_example.AwsAuthGen(context, action)"&gt;

        &lt;Body name="Body"&gt;
          &lt;DataModel ref="Policy" /&gt;
        &lt;/Body&gt;
      &lt;/Action&gt;

    &lt;/State&gt;
  &lt;/StateModel&gt;

  &lt;Test name="Default" maxOutputSize="20000000"&gt;
    &lt;StateModel ref="TheStateModel"/&gt;
    &lt;Publisher class="WebApi"&gt;
      &lt;Param name="FaultOnStatusCodes" value="500,501,502,503,504,505" /&gt;
    &lt;/Publisher&gt;
  &lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Publishers_WebService">
<title>WebService Publisher</title>
<simpara>The <emphasis>WebService</emphasis> publisher is able to call SOAP and WCF based web services.</simpara>
<simpara><emphasis>WebService</emphasis> attempts to locate a service definition, or you can provide one.</simpara>
<section xml:id="_syntax_115">
<title>Syntax</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;Publisher class="WebService"&gt;
    &lt;Param name="Url" value="http://localhost:7789/TestService/Service.asmx" /&gt;
    &lt;Param name="Service" value="Service" /&gt;
&lt;/Publisher&gt;</programlisting>
</section>
<section xml:id="_parameters_134">
<title>Parameters</title>
<simpara><emphasis>Required:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>Url</term>
<listitem>
<simpara>WebService URL</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Service</term>
<listitem>
<simpara>Service Name</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>Wsdl</term>
<listitem>
<simpara>Path or URL to WSDL for web service</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>ErrorOnStatusCode</term>
<listitem>
<simpara>Error when status code isn&#8217;t 200, defaults to true.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Timeout</term>
<listitem>
<simpara>How long to wait in milliseconds for data/connection, defaults to 3,000.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Throttle</term>
<listitem>
<simpara>Time in milliseconds to wait between connections, defaults to 0.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_actions_24">
<title>Actions</title>
<variablelist>
<varlistentry>
<term><link linkend="Action_call">call</link></term>
<listitem>
<simpara>Method attribute is method on web service to call.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_182">
<title>Examples</title>
<example>
<title>Example calling web service</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://peachfuzzer.com/2012/Peach /peach/peach.xsd"&gt;

  &lt;DataModel name="ArbitraryData"&gt;
    &lt;String name="value" /&gt;
  &lt;/DataModel&gt;

  &lt;StateModel name="TheState" initialState="Initial"&gt;
    &lt;State name="Initial"&gt;

      &lt;Action type="call" method="Login"&gt;
        &lt;Param name="name"&gt;
          &lt;DataModel ref="ArbitraryData"/&gt;
          &lt;Data&gt;
            &lt;Field name="value" value="mike" /&gt;
          &lt;/Data&gt;
        &lt;/Param&gt;
        &lt;Param name="passwd"&gt;
          &lt;DataModel ref="ArbitraryData"/&gt;
          &lt;Data&gt;
            &lt;Field name="value" value="Password!" /&gt;
          &lt;/Data&gt;
        &lt;/Param&gt;
      &lt;/Action&gt;

    &lt;/State&gt;
  &lt;/StateModel&gt;

  &lt;Agent name="TheAgent"/&gt;

  &lt;Test name="Default"&gt;
    &lt;Agent ref="TheAgent"/&gt;
    &lt;StateModel ref="TheState"/&gt;
    &lt;Publisher class="WebService"&gt;
      &lt;Param name="Url" value="http://localhost:7789/TestService/Service.asmx" /&gt;
      &lt;Param name="Service" value="Service" /&gt;
    &lt;/Publisher&gt;
  &lt;/Test&gt;

&lt;/Peach&gt;</programlisting>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Publishers_WebSocket">
<title>WebSocket Publisher</title>
<simpara>The <emphasis>WebSocket</emphasis> publisher allows rapid delivery of fuzzing data to browsers using a web socket.</simpara>
<simpara>The web socket publisher works through a simple JSON based protocol. The browser evokes a JavaScript handler to accept data from the fuzzer and display it. The iterations wait for the data to be fully loaded prior to completing an iteration.</simpara>
<simpara>Peach provides a fuzzer template with a placeholder to drop the encoded data. The client code loads the template into an iframe.</simpara>
<section xml:id="_syntax_116">
<title>Syntax</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;Publisher class="WebSocket"&gt;
    &lt;Param name="Port" value="8080"/&gt;
    &lt;Param name="Template" value="peach_ws_template.html"/&gt;
    &lt;Param name="Publish" value="base64"/&gt;
&lt;/Publisher&gt;</programlisting>
</section>
<section xml:id="_parameters_135">
<title>Parameters</title>
<simpara><emphasis>Required:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>Template</term>
<listitem>
<simpara>Data template for publishing. The template contains the HTML that is loaded into an iframe element in the browser each iteration. It must contain the <emphasis>DataToken</emphasis> placeholder which will be replaced with the data based on the <emphasis>Publish</emphasis> parameter.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>Port</term>
<listitem>
<simpara>Port to listen for connections on. Defaults to <literal>8080</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Publish</term>
<listitem>
<simpara>How to publish data, base64 or URL. Defaults to <literal>base64</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>DataToken</term>
<listitem>
<simpara>Token to replace with data in template. Defaults to <literal>##DATA##</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Timeout</term>
<listitem>
<simpara>Time in milliseconds to wait for client response. Defaults to <literal>60000</literal>.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_actions_25">
<title>Actions</title>
<variablelist>
<varlistentry>
<term><link linkend="Action_output">output</link></term>
<listitem>
<simpara>Generate and send <emphasis>Template</emphasis></simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_183">
<title>Examples</title>
<example>
<title>Basic Usage Example</title>
<simpara>A working example of the WebSocket publisher comes with the Peach Fuzzer Professional binary distribution in the <emphasis>samples</emphasis> folder. The full example is a combination of four files and is too long to list in this document. The list of files is below.</simpara>
<variablelist>
<varlistentry>
<term>websocket.xml</term>
<listitem>
<simpara>Pit file</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>peach_ws_client.html</term>
<listitem>
<simpara>HTML file that is loaded into browser</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>peach_ws_template.html</term>
<listitem>
<simpara>Template for HTML generated and sent to target</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>peach_ws_client.js</term>
<listitem>
<simpara>JavaScript code used by <emphasis>peach_ws_client.html</emphasis></simpara>
</listitem>
</varlistentry>
</variablelist>
<formalpara>
<title>websocket.xml</title>
<para>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach /peach/peach.xsd"&gt;

  &lt;DataModel name="TheDataModel"&gt;
    &lt;Blob/&gt;
  &lt;/DataModel&gt;

  &lt;StateModel name="TheState" initialState="Initial"&gt;
    &lt;State name="Initial"&gt;
      &lt;Action type="output"&gt;
        &lt;DataModel ref="TheDataModel"/&gt;
        &lt;Data fileName="samples_png" /&gt;
      &lt;/Action&gt;
    &lt;/State&gt;
  &lt;/StateModel&gt;

  &lt;Agent name="TheAgent"&gt;
    &lt;Monitor class="WindowsDebugger"&gt;
      &lt;Param name="Executable" value="C:\Program Files (x86)\Mozilla Firefox\firefox.exe" /&gt;
      &lt;Param name="Arguments" value="peach_ws_client.html" /&gt;
    &lt;/Monitor&gt;
  &lt;/Agent&gt;

  &lt;Test name="Default"&gt;
    &lt;Agent ref="TheAgent"/&gt;
    &lt;StateModel ref="TheState"/&gt;

    &lt;Publisher class="WebSocket"&gt;
      &lt;Param name="Port" value="8080"/&gt;
      &lt;Param name="Template" value="peach_ws_template.html"/&gt;
      &lt;Param name="Publish" value="base64"/&gt;
    &lt;/Publisher&gt;
  &lt;/Test&gt;

&lt;/Peach&gt;</programlisting>
</para>
</formalpara>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Publishers_Zip">
<title>Zip Publisher</title>
<simpara>The <emphasis>Zip</emphasis> publisher opens a zip file for writing.
The Zip publisher enumerates all Stream data elements in the DataModel and creates a zip entry for each stream.</simpara>
<section xml:id="_syntax_117">
<title>Syntax</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;Publisher class="Zip"&gt;
    &lt;Param name="FileName" value="output.zip" /&gt;
&lt;/Publisher&gt;</programlisting>
</section>
<section xml:id="_parameters_136">
<title>Parameters</title>
<simpara><emphasis>Required:</emphasis></simpara>
<variablelist>
<varlistentry>
<term>FileName</term>
<listitem>
<simpara>Name of file to open</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_actions_26">
<title>Actions</title>
<variablelist>
<varlistentry>
<term><link linkend="Action_open">open</link></term>
<listitem>
<simpara>Open file for reading/writing.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_close">close</link></term>
<listitem>
<simpara>Close file stream.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="Action_output">output</link></term>
<listitem>
<simpara>Data to be written to file</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_184">
<title>Examples</title>
<example>
<title>Write two text files (file1.txt and file2.txt) to a zip file</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach ../peach.xsd"&gt;

  &lt;DataModel name="TheDataModel"&gt;
    &lt;Stream streamName='file1.txt'&gt;
      &lt;String value='Hello'/&gt;
    &lt;/Stream&gt;
    &lt;Stream streamName='file2.txt'&gt;
      &lt;String value='World'/&gt;
    &lt;/Stream&gt;
  &lt;/DataModel&gt;

  &lt;StateModel name="TheState" initialState="initial"&gt;
    &lt;State name="initial"&gt;
      &lt;Action type="output"&gt;
        &lt;DataModel ref="TheDataModel" /&gt;
      &lt;/Action&gt;
    &lt;/State&gt;
  &lt;/StateModel&gt;

  &lt;Test name="Default"&gt;
    &lt;StateModel ref="TheState"/&gt;
    &lt;Publisher class="Zip"&gt;
      &lt;Param name="FileName" value="fuzzed.zip" /&gt;
    &lt;/Publisher&gt;
  &lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
<simpara>View of fuzzed.zip in 7Zip</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/DevGuide/Publishers/Zip.png"/>
</imageobject>
<textobject><phrase>Zip</phrase></textobject>
</mediaobject>
</informalfigure>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
</section>
<section xml:id="Mutators">
<title>Mutators</title>
<simpara>Mutators perform the actual data changes to models that produce fuzzed output. The fuzzing strategy decides
how and when to apply mutators. During a fuzzing session, Peach weights mutators based on the number of
variations of data that each mutator generates. Peach selects mutators that generate more variations
more frequently than mutators that generate fewer variations of fuzzed data.</simpara>
<simpara>A typical mutator performs a single type of change. For example, the <emphasis>BlobBitFlipperMutator</emphasis> performs bit flipping on <emphasis>Blob</emphasis> elements. Most mutators have no or very little state or complex logic.</simpara>
<simpara>Mutators that are associated with state have a prefix for identification, either State or Action.</simpara>
<simpara>Custom mutators are relatively easy to write.</simpara>
<simpara>To focus on using a specific set of mutators in a fuzzing session, specify the mutators to use or those not to use during a fuzzing run in the <link linkend="Test"><emphasis>Test</emphasis></link> element of the Pit. Most often, Peach considers all mutations and uses all mutations appropriate for the DataModel.</simpara>
<simpara>The following sections provide descriptions of each mutator, as well as hints and configuration options.</simpara>
<simpara><?asciidoc-pagebreak?></simpara>
<section xml:id="Mutators_ArrayNumericalEdgeCasesMutator">
<title>ArrayEdgeCase</title>
<simpara>This mutator produces test cases in which the size of an array expands or contracts to have item counts near certain numerical edge cases. An algorithm helps in producing a distribution with focal points at numerical edge cases:</simpara>
<itemizedlist>
<listitem>
<simpara>Where an array index transitions from 0 to 8 bits, from 8 to 16 bits, 16 to 32 bits, and from 32 to 64 bits.</simpara>
</listitem>
<listitem>
<simpara>Where numeric values are interpreted differently for signed and unsigned integer types.</simpara>
</listitem>
</itemizedlist>
<simpara>This mutator focuses on integer issues that lead to memory corruption.</simpara>
<note>
<simpara>Currently this mutator limits the number of items in an array to 65K.</simpara>
</note>
<section xml:id="_supported_elements">
<title>Supported Elements</title>
<simpara>This mutator supports any array element. Array elements are those that have the <emphasis>occurs</emphasis>, <emphasis>minOccurs</emphasis>, or <emphasis>maxOccurs</emphasis> attribute.</simpara>
<itemizedlist>
<listitem>
<simpara><link linkend="occurs">occurs</link> attribute</simpara>
</listitem>
<listitem>
<simpara><link linkend="minOccurs">minOccurs</link> attribute</simpara>
</listitem>
<listitem>
<simpara><link linkend="maxOccurs">maxOccurs</link> attribute</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="_hints">
<title>Hints</title>
<simpara>This mutator does not support hints.</simpara>
<note>
<simpara>A previous version of this mutator supported a hint. An update to the underlying algorithm removed the need for a hint.</simpara>
</note>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Mutators_ArrayRandomizeOrderMutator">
<title>ArrayRandomizeOrder</title>
<simpara>This mutator randomizes the order of items in an array.</simpara>
<simpara><emphasis>Operation with deterministic strategies</emphasis></simpara>
<simpara>With deterministic strategies, the number of test cases this mutator generates is the lessor of 100, or the factorial of the number of array items.</simpara>
<simpara>You can repeat this mutator with a different seed value to produce different randomized array orders.</simpara>
<simpara><emphasis>Operation with non-deterministic strategies</emphasis></simpara>
<simpara>With non-deterministic strategies, each call to this mutator produces a randomized order of the elements.
The weighting of this mutator is based the lessor of 100, or the factorial of the number of array items.</simpara>
<section xml:id="_supported_elements_2">
<title>Supported Elements</title>
<simpara>This mutator supports any array element. Array elements are those that have the <emphasis>occurs</emphasis>, <emphasis>minOccurs</emphasis>, or <emphasis>maxOccurs</emphasis> attribute.</simpara>
<itemizedlist>
<listitem>
<simpara><link linkend="occurs">occurs</link> attribute</simpara>
</listitem>
<listitem>
<simpara><link linkend="minOccurs">minOccurs</link> attribute</simpara>
</listitem>
<listitem>
<simpara><link linkend="maxOccurs">maxOccurs</link> attribute</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="_hints_2">
<title>Hints</title>
<simpara>This mutator does not support hints.</simpara>
<note>
<simpara>A previous version of this mutator supported a hint. An update to the underlying algorithm removed the need for a hint.</simpara>
</note>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Mutators_ArrayReverseOrderMutator">
<title>ArrayReverseOrder</title>
<simpara>This mutator reverses the order of items in an array.</simpara>
<section xml:id="_supported_elements_3">
<title>Supported Elements</title>
<simpara>This mutator supports any array element. Array elements are those that have the <emphasis>occurs</emphasis>, <emphasis>minOccurs</emphasis>, or <emphasis>maxOccurs</emphasis> attribute.</simpara>
<itemizedlist>
<listitem>
<simpara><link linkend="occurs">occurs</link> attribute</simpara>
</listitem>
<listitem>
<simpara><link linkend="minOccurs">minOccurs</link> attribute</simpara>
</listitem>
<listitem>
<simpara><link linkend="maxOccurs">maxOccurs</link> attribute</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="_hints_3">
<title>Hints</title>
<simpara>This mutator does not support hints.</simpara>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Mutators_ArrayVarianceMutator">
<title>ArrayVarianceMutator</title>
<simpara>This mutator produces test cases in which the array expands or contracts to produce sizes that are in a distribution with the center of the distribution the current count of the array. For example, if an array contains 100 elements, this mutator produces test cases in which the array has grown to larger sizes and smaller sizes with the sizes clustered around 100.</simpara>
<note>
<simpara>Currently this mutator limits the number of items in an array to 65K.</simpara>
</note>
<section xml:id="_supported_elements_4">
<title>Supported Elements</title>
<simpara>This mutator supports any array element. Array elements are those that have the <emphasis>occurs</emphasis>, <emphasis>minOccurs</emphasis>, or <emphasis>maxOccurs</emphasis> attributes set.</simpara>
<itemizedlist>
<listitem>
<simpara><link linkend="occurs">occurs</link> attribute</simpara>
</listitem>
<listitem>
<simpara><link linkend="minOccurs">minOccurs</link> attribute</simpara>
</listitem>
<listitem>
<simpara><link linkend="maxOccurs">maxOccurs</link> attribute</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="_hints_4">
<title>Hints</title>
<simpara>This mutator does not support hints.</simpara>
<note>
<simpara>A previous version of this mutator supported a hint. An update to the underlying algorithm removed the need for a hint.</simpara>
</note>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Mutators_BlobChangeFromNull">
<title>BlobChangeFromNull</title>
<simpara>This mutator produces test cases in which a random number of contiguous null bytes in a <link linkend="Blob">Blob</link> are changed. The location where the change occurs is randomly-determined as is the number of bytes altered in the mutation. The number of contiguous bytes that receive new and different values range from 1 to 100.</simpara>
<section xml:id="_supported_elements_5">
<title>Supported Elements</title>
<itemizedlist>
<listitem>
<simpara><link linkend="Blob">Blob</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="_hints_5">
<title>Hints</title>
<variablelist>
<varlistentry>
<term>BlobChangeFromNull-N</term>
<listitem>
<simpara>Standard deviation of the number of bytes to change.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>BlobMutator-N</term>
<listitem>
<simpara>Standard deviation of the number of bytes to change. The value of this Hint affects other Blob mutators.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Mutators_BlobChangeRandom">
<title>BlobChangeRandom</title>
<simpara>This mutator produces test cases in which a random number of contiguous bytes in a <link linkend="Blob">Blob</link> are changed. The location where the change occurs is randomly-determined as is the number of bytes altered in the mutation. The number of contiguous bytes that receive new and different values range from 1 to 100.</simpara>
<section xml:id="_supported_elements_6">
<title>Supported Elements</title>
<itemizedlist>
<listitem>
<simpara><link linkend="Blob">Blob</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="_hints_6">
<title>Hints</title>
<variablelist>
<varlistentry>
<term>BlobChangeRandom-N</term>
<listitem>
<simpara>Standard deviation of the number of bytes to change.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>BlobMutator-N</term>
<listitem>
<simpara>Standard deviation of the number of bytes to change. The value of this Hint affects other Blob mutators.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Mutators_BlobChangeSpecial">
<title>BlobChangeSpecial</title>
<simpara>This mutator produces test cases in which a random number of contiguous bytes in a <link linkend="Blob">Blob</link> are individually changed using a small set of replacement values. The location where the change occurs is randomly-determined as is the number of bytes altered in the mutation. The number of bytes that receive new values range from 1 to 100.</simpara>
<simpara>Each altered value randomly receives one of the following replacement values: 0x00, 0x01, 0xFE, or 0xFF.</simpara>
<section xml:id="_supported_elements_7">
<title>Supported Elements</title>
<itemizedlist>
<listitem>
<simpara><link linkend="Blob">Blob</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="_hints_7">
<title>Hints</title>
<variablelist>
<varlistentry>
<term>BlobChangeSpecial-N</term>
<listitem>
<simpara>Standard deviation of the number of bytes to change.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>BlobMutator-N</term>
<listitem>
<simpara>Standard deviation of the number of bytes to change. The value of this Hint affects other Blob mutators.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Mutators_BlobChangeToNull">
<title>BlobChangeToNull</title>
<simpara>This mutator produces test cases in which a random number of contiguous bytes in a <link linkend="Blob">Blob</link> are changed to null. The location where the change occurs is randomly-determined as is the number of bytes altered in the mutation. The number of bytes that receive the null value range from 1 to 100.</simpara>
<section xml:id="_supported_elements_8">
<title>Supported Elements</title>
<itemizedlist>
<listitem>
<simpara><link linkend="Blob">Blob</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="_hints_8">
<title>Hints</title>
<variablelist>
<varlistentry>
<term>BlobChangeToNull-N</term>
<listitem>
<simpara>Standard deviation of the number of bytes to change.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>BlobMutator-N</term>
<listitem>
<simpara>Standard deviation of the number of bytes to change. The value of this Hint affects other Blob mutators.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Mutators_BlobExpandAllRandom">
<title>BlobExpandAllRandom</title>
<simpara>This mutator produces test cases in which a random number of contiguous bytes are inserted in a <link linkend="Blob">Blob</link>. The location where the insertion starts is randomly determined, as is the number of inserted bytes. The number of inserted bytes range from 1 to 255.
The value of each inserted byte is a different randomly-selected value.</simpara>
<section xml:id="_supported_elements_9">
<title>Supported Elements</title>
<itemizedlist>
<listitem>
<simpara><link linkend="Blob">Blob</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="_hints_9">
<title>Hints</title>
<variablelist>
<varlistentry>
<term>BlobExpandAllRandom-N</term>
<listitem>
<simpara>Standard deviation of the number of bytes to change.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>BlobMutator-N</term>
<listitem>
<simpara>Standard deviation of the number of bytes to change. The value of this Hint affects other Blob mutators.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Mutators_BlobExpandSingleIncrementing">
<title>BlobExpandSingleIncrementing</title>
<simpara>This mutator produces test cases in which a random number of contiguous bytes are inserted in a <link linkend="Blob">Blob</link>. The location where the insertion starts is randomly-determined as is the number of inserted bytes. The number of inserted bytes range from 1 to 255.</simpara>
<simpara>The value of the first inserted byte is randomly selected and ranges from 0x00 to 0xff. The value of the second inserted byte increments by 1. The value of the third byte increments again. When the value 0xff occurs, value of the subsequent byte rolls over to 0x00. Thereafter the values continue to increment until all of the inserted bytes have values.</simpara>
<section xml:id="_supported_elements_10">
<title>Supported Elements</title>
<itemizedlist>
<listitem>
<simpara><link linkend="Blob">Blob</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="_hints_10">
<title>Hints</title>
<variablelist>
<varlistentry>
<term>BlobExpandAllRandom-N</term>
<listitem>
<simpara>Standard deviation of the number of bytes to change.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>BlobMutator-N</term>
<listitem>
<simpara>Standard deviation of number of the bytes to change. The value of this Hint affects other Blob mutators.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Mutators_BlobExpandSingleRandom">
<title>BlobExpandSingleRandom</title>
<simpara>This mutator produces test cases in which a random number of contiguous bytes having the same value are inserted in a <link linkend="Blob">Blob</link>. The location where the insertion starts is randomly-determined as is the number of inserted bytes. The number of inserted bytes range from 1 to 255.</simpara>
<simpara>The value used for the inserted bytes is randomly selected from the range of 0x00 to 0xff.</simpara>
<section xml:id="_supported_elements_11">
<title>Supported Elements</title>
<itemizedlist>
<listitem>
<simpara><link linkend="Blob">Blob</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="_hints_11">
<title>Hints</title>
<variablelist>
<varlistentry>
<term>BlobExpandSingleRandom-N</term>
<listitem>
<simpara>Standard deviation of the number of bytes to change.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>BlobMutator-N</term>
<listitem>
<simpara>Standard deviation of the number of bytes to change. The value of this Hint affects other Blob mutators.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Mutators_BlobExpandZero">
<title>BlobExpandZero</title>
<simpara>This mutator produces test cases in which a random number of contiguous null bytes are inserted in a <link linkend="Blob">Blob</link>. The location where the insertion starts is randomly-determined as is the number of inserted bytes. The number of inserted bytes range from 1 to 255.</simpara>
<section xml:id="_supported_elements_12">
<title>Supported Elements</title>
<itemizedlist>
<listitem>
<simpara><link linkend="Blob">Blob</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="_hints_12">
<title>Hints</title>
<variablelist>
<varlistentry>
<term>BlobExpandZero-N</term>
<listitem>
<simpara>Standard deviation of the number of bytes to change.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>BlobMutator-N</term>
<listitem>
<simpara>Standard deviation of the number of bytes to change. The value of this Hint affects other Blob mutators.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Mutators_BlobReduce">
<title>BlobReduce</title>
<simpara>This mutator produces test cases in which a random number of contiguous bytes are removed from a <link linkend="Blob">Blob</link>. The location where the deletion starts is randomly-determined as is the number of bytes to delete. The number of deleted bytes range from 1 to 255.</simpara>
<section xml:id="_supported_elements_13">
<title>Supported Elements</title>
<itemizedlist>
<listitem>
<simpara><link linkend="Blob">Blob</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="_hints_13">
<title>Hints</title>
<variablelist>
<varlistentry>
<term>BlobReduce-N</term>
<listitem>
<simpara>Standard deviation of the number of bytes to change.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>BlobMutator-N</term>
<listitem>
<simpara>Standard deviation of the number of bytes to change. The value of this Hint affects other Blob mutators.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Mutators_ChoiceSwitch">
<title>ChoiceSwitch</title>
<simpara>This mutator produces test cases for <link linkend="Choice">Choice</link> elements by changing the selected choice.</simpara>
<section xml:id="_supported_elements_14">
<title>Supported Elements</title>
<itemizedlist>
<listitem>
<simpara><link linkend="Choice">Choice</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="_hints_14">
<title>Hints</title>
<simpara>This mutator does not support hints.</simpara>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Mutators_DataElementBitFlipper">
<title>DataElementBitFlipper</title>
<simpara>This mutator produces test cases by changing the values of individual bits (bit flipping) within data produced by the model. The number of changed bits is a Gaussian distribution with a range of 1 to 6.</simpara>
<simpara>If Transformers are used in the model, this mutator affects both the pre- and post- transformed data.</simpara>
<section xml:id="_supported_elements_15">
<title>Supported Elements</title>
<simpara>This mutator can attach to the following data elements:</simpara>
<itemizedlist>
<listitem>
<simpara>Container elements that have a transformer attached. Container elements typically have one or more child elements. Containers include Data Models, Blocks, Choices and arrays.</simpara>
</listitem>
<listitem>
<simpara>Data elements that are not containers.</simpara>
</listitem>
</itemizedlist>
<simpara>The lone exception: a data element that does not perform a type transformation on itself is unsupported. A type transformation occurs when an element packs or encodes its data in another format. A type transformation can occur with elements whose parent elements have types such as XmlElement or XmlAttribute. A couple of type transformation examples follow:</simpara>
<itemizedlist>
<listitem>
<simpara>A Number element that packs its value into a binary format</simpara>
</listitem>
<listitem>
<simpara>A String element that encodes the characters into a representation such as ASCII or UTF-8</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="_hints_15">
<title>Hints</title>
<simpara>This mutator does not support hints.</simpara>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Mutators_DataElementDuplicate">
<title>DataElementDuplicate</title>
<simpara>This mutator produces test cases for all data elements by duplicating them in the model. The number of duplicated elements range from 1 to 50 and form a distribution. The distribution is configurable.</simpara>
<section xml:id="_supported_elements_16">
<title>Supported Elements</title>
<simpara>All data elements are supported.</simpara>
</section>
<section xml:id="_hints_16">
<title>Hints</title>
<variablelist>
<varlistentry>
<term>DataElementDuplicate-N</term>
<listitem>
<simpara>Standard deviation of the number of duplications.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Mutators_DataElementRemove">
<title>DataElementRemove</title>
<simpara>This mutator produces a single test case by removing all data elements from the model.</simpara>
<section xml:id="_supported_elements_17">
<title>Supported Elements</title>
<simpara>All data elements are supported.</simpara>
</section>
<section xml:id="_hints_17">
<title>Hints</title>
<simpara>This mutator does not support hints.</simpara>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Mutators_DataElementSwapNear">
<title>DataElementSwapNear</title>
<simpara>This mutator produces a single test case for all data elements by swapping the element with its neighbor.</simpara>
<section xml:id="_supported_elements_18">
<title>Supported Elements</title>
<simpara>All data elements are supported.</simpara>
<note>
<simpara>This mutator binds to any container data element (DataModel, Block, Choice, Flags, or array) that contains 2 or more child elements.</simpara>
</note>
</section>
<section xml:id="_hints_18">
<title>Hints</title>
<simpara>This mutator does not support hints.</simpara>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Mutators_DoubleRandom">
<title>DoubleRandom</title>
<simpara>This mutator produces test cases for Double and String elements. String elements are only supported when the default data they contain is a number. The test cases produced are random floating point numbers in the numerical space of the element. For a 32-bit floating point number, the values range from -3.402823E+38 to 3.4028234E+38. For String elements, the range of values is identical to that of a 64-bit floating point number, from -1.79769313486232E+308 to 1.7976931348623157E+308.</simpara>
<simpara>For weighting purposes and for deterministic strategies where an estimate of the number of generated test cases is needed, this mutator reports that it generates 5,000 test cases. In actuality, the number of test cases can exceed 5000.</simpara>
<section xml:id="_supported_elements_19">
<title>Supported Elements</title>
<itemizedlist>
<listitem>
<simpara><link linkend="String">String</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="Double">Double</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="_hints_19">
<title>Hints</title>
<simpara>This mutator does not support hints.</simpara>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Mutators_DoubleVariance">
<title>DoubleVariance</title>
<simpara>This mutator produces test cases for Double and String elements. String elements are only supported when the default data they contain is a number. The test cases are produced using a Gaussian distribution with the current default value as the center of the distribution.</simpara>
<section xml:id="_supported_elements_20">
<title>Supported Elements</title>
<itemizedlist>
<listitem>
<simpara><link linkend="String">String</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="Double">Double</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="_hints_20">
<title>Hints</title>
<simpara>This mutator does not support hints.</simpara>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Mutators_ExtraValues">
<title>ExtraValues</title>
<simpara>This mutator allows the user to supply additional values to use in new test cases. Each additional value generates its own test case. The additional values are tested "as is"; that is they are not altered.</simpara>
<simpara>If the <emphasis>ExtraValues</emphasis> hint is mandatory. If the hint is not provided, this mutator is not used.</simpara>
<section xml:id="_supported_elements_21">
<title>Supported Elements</title>
<itemizedlist>
<listitem>
<simpara><link linkend="String">String</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="Number">Number</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="Blob">Blob</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="_hints_21">
<title>Hints</title>
<variablelist>
<varlistentry>
<term>ExtraValues</term>
<listitem>
<simpara>Specify a semicolon-separated list of the values to use in new test cases.</simpara>
</listitem>
</varlistentry>
</variablelist>
<warning>
<simpara>The former hint name <emphasis>ValidValues</emphasis>, is deprecated in favor of <emphasis>ExtraValues</emphasis>.</simpara>
</warning>
</section>
<section xml:id="_examples_185">
<title>Examples</title>
<example>
<title>Providing Extra Values for a String</title>
<simpara>In this example, three test cases are added to the string <emphasis>FirstName</emphasis>.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;String name="FirstName" value="Josh"&gt;
    &lt;!-- This list adds three test cases --&gt;
    &lt;Hint name="ExtraValues" value="O'Brian;O-Brian;Josh III" /&gt;
&lt;/String&gt;</programlisting>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Mutators_NumberEdgeCase">
<title>NumberEdgeCase</title>
<simpara>This mutator produces test cases for Number and String elements. String elements are only supported when the default data they contain is an integer. The test cases are generated using a Gaussian distribution around numerical edge cases. Edge cases are defined as boundaries between signed/unsigned and bit boundaries (0, 8, 16, 32, 64).</simpara>
<section xml:id="_supported_elements_22">
<title>Supported Elements</title>
<itemizedlist>
<listitem>
<simpara><link linkend="String">String</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="Number">Number</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="_hints_22">
<title>Hints</title>
<simpara>This mutator does not support hints.</simpara>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Mutators_NumberRandom">
<title>NumberRandom</title>
<simpara>This mutator produces test cases for Number and String elements. String elements are only supported when the default data they contain is an integer. The test cases produced are random integers in the numerical space of the element. For an unsigned 8-bit number that range is 0 to 255. For String elements, the range is that of a signed 64-bit integer, 9,223,372,036,854,775,808 to 9,223,372,036,854,775,807.</simpara>
<simpara>For weighting purposes and for deterministic strategies where an estimate of the number of generated test cases is needed, this mutator reports that it generates 5,000 test cases. In actuality, the number of test cases can exceed 5000.</simpara>
<section xml:id="_supported_elements_23">
<title>Supported Elements</title>
<itemizedlist>
<listitem>
<simpara><link linkend="String">String</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="Number">Number</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="_hints_23">
<title>Hints</title>
<simpara>This mutator does not support hints.</simpara>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Mutators_NumberVariance">
<title>NumberVariance</title>
<simpara>This mutator produces test cases for Number and String elements. String elements are only supported when the default data they contain is an integer. The test cases are produced using a Gaussian distribution with the current default value as the center of the distribution.</simpara>
<section xml:id="_supported_elements_24">
<title>Supported Elements</title>
<itemizedlist>
<listitem>
<simpara><link linkend="String">String</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="Number">Number</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="_hints_24">
<title>Hints</title>
<simpara>This mutator does not support hints.</simpara>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Mutators_SampleNinjaMutator">
<title>SampleNinja</title>
<simpara>The SampleNinja Mutator swaps elements between different sample files using a
<link linkend="PitTool_Ninja">Sample Ninja</link> database.</simpara>
<note>
<simpara>This mutator is enabled only if a sample ninja database exists.
You can use PitTool to create a sample ninja database.</simpara>
</note>
<section xml:id="_supported_elements_25">
<title>Supported Elements</title>
<simpara>All elements are supported.</simpara>
</section>
<section xml:id="_hints_25">
<title>Hints</title>
<simpara>This mutator does not support hints.</simpara>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Mutators_SizedDataEdgeCase">
<title>SizedDataEdgeCase</title>
<simpara>This mutator produces test cases for elements that are part of a size relationship. The SizedDataEdgeCase Mutator causes the data in a sized element to expand such that the relationship is invalid. The data portion of the relationship expands, while the physical size of the field is static.</simpara>
<simpara>Test cases are generated using a Gaussian distribution around numerical edge cases. Edge cases for integers are defined as boundaries between signed/unsigned representations and bit boundaries (0, 8, 16, 32, 64).</simpara>
<simpara>Values used in the test cases never require more storage than the maximum size the size provider can handle. For example, values used for a signed 16-bit integer do not exceed 32,767.</simpara>
<note>
<simpara>This mutator is similar to the <link linkend="Mutators_NumberEdgeCase">NumberEdgeCase</link> Mutator.</simpara>
</note>
<section xml:id="_supported_elements_26">
<title>Supported Elements</title>
<simpara>Elements that are part of a size relationship: numbers and strings. String elements are only supported when the default data they contain is integer values.</simpara>
</section>
<section xml:id="_hints_26">
<title>Hints</title>
<simpara>This mutator does not support hints.</simpara>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Mutators_SizedDataVariance">
<title>SizedDataVariance</title>
<simpara>This mutator produces test cases for elements that are part of a size relationship. The SizedDataVariance Mutator causes the data in a sized element to expand such that the relationship is invalid. The data portion of the relationship expands, while the physical size of the field is static.</simpara>
<simpara>The test cases are produced using a Gaussian distribution with the current default value as the center of the distribution.</simpara>
<simpara>Values used in the test cases never require more storage than the maximum size the size provider can handle. For example, values used for a signed 16-bit integer do not exceed 32,767.</simpara>
<note>
<simpara>This mutator is similar to the <link linkend="Mutators_NumberVariance">NumberVariance</link> Mutator.</simpara>
</note>
<section xml:id="_supported_elements_27">
<title>Supported Elements</title>
<simpara>Elements that are part of a size relationship: numbers and strings. String elements are only supported when the default data they contain is integer values.</simpara>
</section>
<section xml:id="_hints_27">
<title>Hints</title>
<simpara>This mutator does not support hints.</simpara>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Mutators_SizedEdgeCase">
<title>SizedEdgeCase</title>
<simpara>This mutator produces test cases for elements that are part of a size relationship. The SizedEdgeCase Mutator causes the data in a sized element to expand and, as needed, expands the physical size of the field to keep the relationship valid.</simpara>
<simpara>The test cases are generated using a Gaussian distribution around numerical edge cases. Edge cases for integers are defined as boundaries between signed/unsigned representations and bit boundaries (0, 8, 16, 32, 64).</simpara>
<simpara>Values used in the test cases never require more storage than the maximum size the size provider can handle. For example, values used for a signed 16-bit integer do not exceed 32,767.</simpara>
<note>
<simpara>This mutator is similar to the <link linkend="Mutators_NumberEdgeCase">NumberEdgeCase</link> Mutator.</simpara>
</note>
<section xml:id="_supported_elements_28">
<title>Supported Elements</title>
<simpara>Elements that are part of a size relationship: numbers and strings. String elements are only supported when the default data they contain is integer values.</simpara>
</section>
<section xml:id="_hints_28">
<title>Hints</title>
<simpara>This mutator does not support hints.</simpara>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Mutators_SizedVariance">
<title>SizedVariance</title>
<simpara>This mutator produces test cases for elements that are part of a size relationship. The SizedVariance Mutator causes the data in a sized element to expand and, as needed, expands the physical size of the field to keep the relationship valid.</simpara>
<simpara>The test cases are generated using a Gaussian distribution with the current default value as the center of the distribution.</simpara>
<simpara>Values used in the test cases never require more storage than the maximum size the size provider can handle. For example, values used for a signed 16-bit integer do not exceed 32,767.</simpara>
<note>
<simpara>This mutator is similar to the <link linkend="Mutators_NumberVariance">NumberVariance</link> Mutator.</simpara>
</note>
<section xml:id="_supported_elements_29">
<title>Supported Elements</title>
<simpara>Elements that are part of a size relationship: numbers and strings. String elements are only supported when the default data they contain is integer values.</simpara>
</section>
<section xml:id="_hints_29">
<title>Hints</title>
<simpara>This mutator does not support hints.</simpara>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Mutators_StateChangeRandom">
<title>StateChangeRandom</title>
<simpara>This mutator produces test cases that affect the flow of the state model. During a state change, starting with selecting the initial state, the state change can land on a randomly-selected state. This mutator can be enabled if more than one state is available.</simpara>
<note>
<simpara>Currently, state model mutations are disabled by default.</simpara>
</note>
<section xml:id="_supported_elements_30">
<title>Supported Elements</title>
<simpara>All states defined in the state model.</simpara>
</section>
<section xml:id="_hints_30">
<title>Hints</title>
<simpara>This mutator does not support hints.</simpara>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Mutators_StringAsciiRandom">
<title>StringAsciiRandom</title>
<simpara>This mutator produces test cases by generating random ASCII strings. Characters that comprise the strings use the 7-bit ASCII collating sequence, values 0x00 - 0x7F.</simpara>
<simpara>The lengths of the generated strings form a distribution that centers on the length of the current string and ranges from 0 to 65K characters.</simpara>
<section xml:id="_supported_elements_31">
<title>Supported Elements</title>
<itemizedlist>
<listitem>
<simpara><link linkend="String">String</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="_hints_31">
<title>Hints</title>
<simpara>This mutator does not support hints.</simpara>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Mutators_StringCaseLower">
<title>StringCaseLower</title>
<simpara>This mutator produces a single test case by making the characters in the string all lower case. This mutator is not enabled for strings that contain all lowercase data.</simpara>
<section xml:id="_supported_elements_32">
<title>Supported Elements</title>
<itemizedlist>
<listitem>
<simpara><link linkend="String">String</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="_hints_32">
<title>Hints</title>
<simpara>This mutator does not support hints.</simpara>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Mutators_StringCaseRandom">
<title>StringCaseRandom</title>
<simpara>This mutator produces test cases by randomly changing the case of a string.</simpara>
<section xml:id="_supported_elements_33">
<title>Supported Elements</title>
<itemizedlist>
<listitem>
<simpara><link linkend="String">String</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="_hints_33">
<title>Hints</title>
<simpara>This mutator does not support hints.</simpara>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Mutators_StringCaseUpper">
<title>StringCaseUpper</title>
<simpara>This mutator produces a single test case by making the characters in the string all upper case. This mutator is not enabled for strings that contain all upper case data.</simpara>
<section xml:id="_supported_elements_34">
<title>Supported Elements</title>
<itemizedlist>
<listitem>
<simpara><link linkend="String">String</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="_hints_34">
<title>Hints</title>
<simpara>This mutator does not support hints.</simpara>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Mutators_StringLengthEdgeCase">
<title>StringLengthEdgeCase</title>
<simpara>This mutator produces test cases for String elements. The test cases produced are length edge cases created by shrinking and growing the string as needed.</simpara>
<simpara>The lengths are generated using a Gaussian distribution around numerical edge cases. Edge cases are defined as integer boundaries for signed/unsigned number representations and for bit boundaries (0, 8, 16, 32, 64).</simpara>
<simpara>The maximum size string generated by this mutator is 65K characters.</simpara>
<section xml:id="_supported_elements_35">
<title>Supported Elements</title>
<itemizedlist>
<listitem>
<simpara><link linkend="String">String</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="_hints_35">
<title>Hints</title>
<simpara>This mutator does not support hints.</simpara>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Mutators_StringLengthVariance">
<title>StringLengthVariance</title>
<simpara>This mutator produces test cases for String elements. The test cases produced are variances of the string length.</simpara>
<simpara>The string lengths generated for the test cases form a Gaussian distribution with the current length as the center of the distribution.</simpara>
<section xml:id="_supported_elements_36">
<title>Supported Elements</title>
<itemizedlist>
<listitem>
<simpara><link linkend="String">String</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="_hints_36">
<title>Hints</title>
<simpara>This mutator does not support hints.</simpara>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Mutators_StringList">
<title>StringList</title>
<simpara>This mutator produces test cases for String elements. Test cases are generated by rotating through a list of strings read from a file.</simpara>
<simpara>This mutator is enabled for String elements that have the <literal>StringList</literal> hint, providing a valid file of strings.</simpara>
<section xml:id="_supported_elements_37">
<title>Supported Elements</title>
<itemizedlist>
<listitem>
<simpara><link linkend="String">String</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="_hints_37">
<title>Hints</title>
<variablelist>
<varlistentry>
<term>StringList</term>
<listitem>
<simpara>Name of a file that contains one or more strings. The format of the file requires the placement of one string per line.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Mutators_StringStatic">
<title>StringStatic</title>
<simpara>This mutator produces test cases for String elements by accessing an internal list of strings that have caused or that might cause a data consumer to misbehave.</simpara>
<simpara>The strings in the list include special filenames, characters, numbers, and other strings. Currently, the list produces 1667 unique test cases.</simpara>
<section xml:id="_supported_elements_38">
<title>Supported Elements</title>
<itemizedlist>
<listitem>
<simpara><link linkend="String">String</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="_hints_38">
<title>Hints</title>
<simpara>This mutator does not support hints.</simpara>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Mutators_StringUnicodeAbstractCharacters">
<title>StringUnicodeAbstractCharacters</title>
<simpara>This mutator produces test cases for Unicode String elements by generating new strings and then populating the strings with a random set of Unicode abstract characters.
The lengths of the generated strings form a distribution that centers on the current string length and ranges from 1 to 65k Unicode characters.</simpara>
<simpara>This mutator requires String elements that have a Unicode encoding type: UTF-8, UTF-16, or UTF-32.</simpara>
<section xml:id="_supported_elements_39">
<title>Supported Elements</title>
<itemizedlist>
<listitem>
<simpara><link linkend="String">String</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="_hints_39">
<title>Hints</title>
<simpara>This mutator does not support hints.</simpara>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Mutators_StringUnicodeFormatCharacters">
<title>StringUnicodeFormatCharacters</title>
<simpara>This mutator produces test cases for Unicode String elements by generating new strings and then populating the strings with a random set of Unicode format characters. A format character has no visible appearance, but can affect the appearance or behavior of neighboring or subsequent characters. The lengths of the generated strings form a distribution that centers on the current string length and ranges from 1 to 65k Unicode characters.</simpara>
<simpara>This mutator requires String elements that have a Unicode encoding type: UTF-8, UTF-16, or UTF-32.</simpara>
<simpara>Unicode 7.0 contains 152 format characters. A couple of format character examples follow:</simpara>
<itemizedlist>
<listitem>
<simpara>U+200C ZERO WIDTH NON-JOINER is a format character that inhibits ligatures.</simpara>
</listitem>
<listitem>
<simpara>U+200D ZERO WIDTH JOINER is a formation character that requests a ligature formation.</simpara>
</listitem>
</itemizedlist>
<section xml:id="_supported_elements_40">
<title>Supported Elements</title>
<itemizedlist>
<listitem>
<simpara><link linkend="String">String</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="_hints_40">
<title>Hints</title>
<simpara>This mutator does not support hints.</simpara>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Mutators_StringUnicodeInvalid">
<title>StringUnicodeInvalid</title>
<simpara>This mutator produces test cases for Unicode String elements by generating new strings and then populating the strings with randomly-selected values from a set of invalid Unicode characters. The codes for these characters are included in the Unicode space, but are currently unused or are specifically excluded.</simpara>
<simpara>The lengths of the generated strings form a distribution that centers on the current string length and ranges from 1 to 65K Unicode characters.</simpara>
<simpara>This mutator requires String elements that have a Unicode encoding type: UTF-8, UTF-16, or UTF-32.</simpara>
<section xml:id="_supported_elements_41">
<title>Supported Elements</title>
<itemizedlist>
<listitem>
<simpara><link linkend="String">String</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="_hints_41">
<title>Hints</title>
<simpara>This mutator does not support hints.</simpara>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Mutators_StringUnicodeNonCharacters">
<title>StringUnicodeNonCharacters</title>
<simpara>This mutator produces test cases for Unicode String elements by generating new strings and then populating the strings with randomly-selected values from a set of Unicode code points that do not map to actual characters. The lengths of the generated strings form a distribution that centers on the length of the current string and ranges from 1 to 65K (ushort max) Unicode characters.</simpara>
<simpara>This mutator requires String elements that have a Unicode encoding type: UTF-8, UTF-16, or UTF-32.</simpara>
<simpara>The Unicode standard includes 60 non-character code points. The set of non-character code points is stable and mature. No new non-character code points will be defined. Non-character code points have either of the following characteristics:</simpara>
<itemizedlist>
<listitem>
<simpara>code point values in the range of U+FDD0  U+FDEF</simpara>
</listitem>
<listitem>
<simpara>code point values that end with FFFE or FFFF (U+FFFE, U+FFFF, U+1FFFE, U+1FFFF, . . . , U+10FFFe, U+10FFFF).</simpara>
</listitem>
</itemizedlist>
<section xml:id="_supported_elements_42">
<title>Supported Elements</title>
<itemizedlist>
<listitem>
<simpara><link linkend="String">String</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="_hints_42">
<title>Hints</title>
<simpara>This mutator does not support hints.</simpara>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Mutators_StringUnicodePlane0">
<title>StringUnicodePlane0</title>
<simpara>This mutator produces test cases for Unicode String elements by generating new strings and populating the strings with randomly-selected values from Unicode plane 0 (basic multilingual plane) characters. The lengths of the generated strings form a distribution that centers on the length of the current string and ranges from 1 to 65K (ushort max) Unicode characters.</simpara>
<simpara>This mutator requires Strings that have a Unicode encoding type: UTF-8, UTF-16, or UTF-32.</simpara>
<section xml:id="_supported_elements_43">
<title>Supported Elements</title>
<itemizedlist>
<listitem>
<simpara><link linkend="String">String</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="_hints_43">
<title>Hints</title>
<simpara>This mutator does not support hints.</simpara>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Mutators_StringUnicodePlane1">
<title>StringUnicodePlane1</title>
<simpara>This mutator produces test cases for Unicode String elements by generating new strings and populating the strings with randomly-selected values from Unicode plane 1 (supplementary multilingual plane) characters. The lengths of the generated strings form a distribution that centers on the length of the current string and ranges from 1 to 65K (ushort max) Unicode characters.</simpara>
<simpara>This mutator requires String elements that have a Unicode encoding type: UTF-8, UTF-16, or UTF-32.</simpara>
<section xml:id="_supported_elements_44">
<title>Supported Elements</title>
<itemizedlist>
<listitem>
<simpara><link linkend="String">String</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="_hints_44">
<title>Hints</title>
<simpara>This mutator does not support hints.</simpara>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Mutators_StringUnicodePlane14">
<title>StringUnicodePlane14</title>
<simpara>This mutator produces test cases for Unicode String elements by generating new strings and populating the strings with randomly-selected values from Unicode plane 14 (supplementary special-purpose plane) characters. The lengths of the generated strings form a distribution that centers on the length of the current string and ranges from 1 to 65K (ushort max) Unicode characters.</simpara>
<simpara>This mutator requires String elements that have a Unicode encoding type: UTF-8, UTF-16, or UTF-32.</simpara>
<section xml:id="_supported_elements_45">
<title>Supported Elements</title>
<itemizedlist>
<listitem>
<simpara><link linkend="String">String</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="_hints_45">
<title>Hints</title>
<simpara>This mutator does not support hints.</simpara>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Mutators_StringUnicodePlane15And16">
<title>StringUnicodePlane15And16</title>
<simpara>This mutator produces test cases for Unicode String elements by generating new strings and populating the strings with randomly-selected values from Unicode plane 15 and 16 (private use area planes) characters. The lengths of the generated strings form a distribution that centers on the length of the current string and ranges from 1 to 65K (ushort max) Unicode characters.</simpara>
<simpara>This mutator requires String elements that have a Unicode encoding type: UTF-8, UTF-16, or UTF-32.</simpara>
<section xml:id="_supported_elements_46">
<title>Supported Elements</title>
<itemizedlist>
<listitem>
<simpara><link linkend="String">String</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="_hints_46">
<title>Hints</title>
<simpara>This mutator does not support hints.</simpara>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Mutators_StringUnicodePlane2">
<title>StringUnicodePlane2</title>
<simpara>This mutator produces test cases for Unicode String elements by generating new strings and populating the strings with randomly-selected values from Unicode plane 2 (supplementary ideographic plane) characters. The lengths of the generated strings form a distribution that centers on the length of the current string and ranges from 1 to 65K (ushort max) Unicode characters.</simpara>
<simpara>This mutator requires String elements that have a Unicode encoding type: UTF-8, UTF-16, or UTF-32.</simpara>
<section xml:id="_supported_elements_47">
<title>Supported Elements</title>
<itemizedlist>
<listitem>
<simpara><link linkend="String">String</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="_hints_47">
<title>Hints</title>
<simpara>This mutator does not support hints.</simpara>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Mutators_StringUnicodePrivateUseArea">
<title>StringUnicodePrivateUseArea</title>
<simpara>This mutator produces test cases for Unicode String elements by generating new strings and populating the strings with randomly-selected values from characters U+E000  U+F8FF of Unicode plane 0 (private use area of the BMP). The lengths of the generated strings form a distribution that centers on the length of the current string and ranges from 1 to 65K (ushort max) Unicode characters.</simpara>
<simpara>This mutator requires String elements that have a Unicode encoding type: UTF-8, UTF-16, or UTF-32.</simpara>
<section xml:id="_supported_elements_48">
<title>Supported Elements</title>
<itemizedlist>
<listitem>
<simpara><link linkend="String">String</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="_hints_48">
<title>Hints</title>
<simpara>This mutator does not support any hints.</simpara>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Mutators_StringUtf8BomLength">
<title>StringUtf8BomLength</title>
<simpara>The <emphasis>StringUtf8BomLength</emphasis> mutator produces test cases for ASCII and Unicode UTF-8 strings by altering an individual string in two ways:</simpara>
<itemizedlist>
<listitem>
<simpara>Adjust the length of the string using the <link linkend="Mutators_StringLengthVariance">StringLengthVariance</link> mutator</simpara>
</listitem>
<listitem>
<simpara>Insert 1 to 6 Unicode Byte Ordering Marks (BOMs) in arbitrary places in the string</simpara>
</listitem>
</itemizedlist>
<simpara>BOMs are not considered characters, and using them can cause buffer length calculations to be incorrect.</simpara>
<section xml:id="_supported_elements_49">
<title>Supported Elements</title>
<itemizedlist>
<listitem>
<simpara><link linkend="String">String</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="_hints_49">
<title>Hints</title>
<simpara>This mutator does not support any hints.</simpara>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Mutators_StringUtf8BomStatic">
<title>StringUtf8BomStatic</title>
<simpara>The <emphasis>StringUtf8BomStatic</emphasis> mutator produces test cases for ASCII and Unicode UTF-8 strings by creating a mutated string in two ways:</simpara>
<itemizedlist>
<listitem>
<simpara>Create a string using the <link linkend="Mutators_StringStatic">StringStatic</link> mutator</simpara>
</listitem>
<listitem>
<simpara>Inject 1 to 6 Unicode Byte Ordering Marks (BOMs) in arbitrary places in the string</simpara>
</listitem>
</itemizedlist>
<simpara>BOMs are not considered characters, and injecting BOMs into a string that might be filtered could cause
the filtering not to work and the string would be accepted.</simpara>
<section xml:id="_supported_elements_50">
<title>Supported Elements</title>
<itemizedlist>
<listitem>
<simpara><link linkend="String">String</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="_hints_50">
<title>Hints</title>
<simpara>This mutator does not support any hints.</simpara>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Mutators_StringUtf8ExtraBytes">
<title>StringUtf8ExtraBytes</title>
<simpara>This mutator produces test cases for UTF-8 String elements by generating new strings and then populating the strings with randomly-selected values. The interesting aspect of this mutator is that the storage allocated for each character ranges from 1 to 6 bytes, rather than using a single byte. The codes for these characters are included in the Unicode space and are unremarkable.</simpara>
<simpara>The lengths of the generated strings form a distribution that centers on the current string length and ranges from 1 to 65K Unicode characters.</simpara>
<section xml:id="_supported_elements_51">
<title>Supported Elements</title>
<itemizedlist>
<listitem>
<simpara><link linkend="String">String</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="_hints_51">
<title>Hints</title>
<simpara>This mutator does not support hints.</simpara>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Mutators_StringUtf8Invalid">
<title>StringUtf8Invalid</title>
<simpara>This mutator produces test cases for UTF-8 and ASCII String elements by generating new strings and then populating the strings with randomly-selected values.</simpara>
<simpara>The interesting part of this mutator flips the control bits of each generated character. The control bits manage the underlying storage for the byte sequence of the character. Each character ranges from 1 to 6 bytes. The codes for these characters are included in the Unicode space and are unremarkable.</simpara>
<simpara>The lengths of the generated strings form a distribution that centers on the current string length and ranges from 1 to 65K Unicode characters.</simpara>
<section xml:id="_supported_elements_52">
<title>Supported Elements</title>
<itemizedlist>
<listitem>
<simpara><link linkend="String">String</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="_hints_52">
<title>Hints</title>
<simpara>This mutator does not support hints.</simpara>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Mutators_StringUtf16BomLength">
<title>StringUtf16BomLength</title>
<simpara>The <emphasis>StringUtf16BomLength</emphasis> mutator produces test cases for Unicode UTF-16 strings by altering an individual string in two ways:</simpara>
<itemizedlist>
<listitem>
<simpara>Adjust the length of the string using the <link linkend="Mutators_StringLengthVariance">StringLengthVariance</link> mutator</simpara>
</listitem>
<listitem>
<simpara>Insert 1 to 6 Unicode Byte Ordering Marks (BOMs) in arbitrary places in the string</simpara>
</listitem>
</itemizedlist>
<simpara>BOMs are not considered characters, and using them can cause buffer length calculations to be incorrect.</simpara>
<simpara>BOM marks, whether for Big Endian-ness or for Little Endian-ness, are selected arbitrarily.</simpara>
<section xml:id="_supported_elements_53">
<title>Supported Elements</title>
<itemizedlist>
<listitem>
<simpara><link linkend="String">String</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="_hints_53">
<title>Hints</title>
<simpara>This mutator does not support any hints.</simpara>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Mutators_StringUtf16BomStatic">
<title>StringUtf16BomStatic</title>
<simpara>The <emphasis>StringUtf16BomStatic</emphasis> mutator produces test cases for Unicode UTF-16 strings by creating a mutated string in two ways:</simpara>
<itemizedlist>
<listitem>
<simpara>Create a string using the <link linkend="Mutators_StringStatic">StringStatic</link> mutator</simpara>
</listitem>
<listitem>
<simpara>Inject 1 to 6 Unicode Byte Ordering Marks (BOMs) in arbitrary places in the string</simpara>
</listitem>
</itemizedlist>
<simpara>BOM are not considered characters, and injecting BOMs into a string that might be filtered could cause
the filtering not to work and the string would be accepted.</simpara>
<simpara>BOM marks, whether for Big Endian-ness or for Little Endian-ness, are selected arbitrarily.</simpara>
<section xml:id="_supported_elements_54">
<title>Supported Elements</title>
<itemizedlist>
<listitem>
<simpara><link linkend="String">String</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="_hints_54">
<title>Hints</title>
<simpara>This mutator does not support any hints.</simpara>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Mutators_StringUtf32BomLength">
<title>StringUtf32BomLength</title>
<simpara>The <emphasis>StringUtf32BomLength</emphasis> mutator produces test cases for Unicode UTF-32 strings by altering an individual string in two ways:</simpara>
<itemizedlist>
<listitem>
<simpara>Adjust the length of the string using the <link linkend="Mutators_StringLengthVariance">StringLengthVariance</link> mutator</simpara>
</listitem>
<listitem>
<simpara>Insert 1 to 6 Unicode Byte Ordering Marks (BOMs) in arbitrary places in the string</simpara>
</listitem>
</itemizedlist>
<simpara>BOM are not considered characters, and using them can cause buffer length calculations to be incorrect.</simpara>
<simpara>BOM marks, whether for Big Endian-ness or for Little Endian-ness, are selected arbitrarily.</simpara>
<section xml:id="_supported_elements_55">
<title>Supported Elements</title>
<itemizedlist>
<listitem>
<simpara><link linkend="String">String</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="_hints_55">
<title>Hints</title>
<simpara>This mutator does not support any hints.</simpara>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Mutators_StringUtf32BomStatic">
<title>StringUtf32BomStatic</title>
<simpara>The <emphasis>StringUtf32BomStatic</emphasis> mutator produces test cases for Unicode UTF-32 strings by creating a mutated string in two ways:</simpara>
<itemizedlist>
<listitem>
<simpara>Create a string using the <link linkend="Mutators_StringStatic">StringStatic</link> mutator</simpara>
</listitem>
<listitem>
<simpara>Inject 1 to 6 Unicode Byte Ordering Marks (BOMs) in arbitrary places in the string</simpara>
</listitem>
</itemizedlist>
<simpara>BOMs are not considered characters, and injecting BOMs into a string that might be filtered could cause
the filtering not to work and the string would be accepted.</simpara>
<simpara>BOM marks, whether for Big Endian-ness or for Little Endian-ness, are selected arbitrarily.</simpara>
<section xml:id="_supported_elements_56">
<title>Supported Elements</title>
<itemizedlist>
<listitem>
<simpara><link linkend="String">String</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="_hints_56">
<title>Hints</title>
<simpara>This mutator does not support any hints.</simpara>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="Mutators_StringXmlW3C">
<title>StringXmlW3C</title>
<simpara>This mutator produces XML parser test cases for String elements. The test cases are defined in the <link xl:href="http://www.w3.org/XML/Test/">XML W3C Conformance Test Suite</link>.</simpara>
<simpara>This mutator is enabled for String elements that have the <literal>XML</literal> hint.</simpara>
<section xml:id="_supported_elements_57">
<title>Supported Elements</title>
<itemizedlist>
<listitem>
<simpara><link linkend="String">String</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="_hints_57">
<title>Hints</title>
<variablelist>
<varlistentry>
<term>XML</term>
<listitem>
<simpara>Enables W3C XML tests.  The hint name is "XML". The hint value is "xml".</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
</section>
<section xml:id="_common_attributes_and_parameters">
<title>Common Attributes and Parameters</title>
<simpara>The following sections contain common attributes and parameters used by other Peach Pit files elements. Other sections of the documentation reference these attributes and parameters.</simpara>
<section xml:id="constraint">
<title>Constraint Attribute</title>
<simpara>The constraint attribute specifies a scripting expression that helps Peach identify
whether the parser has cracked incoming data correctly for the data element. Peach uses the constraint expression as a post-data-cracking validation filter.</simpara>
<simpara>If the constraint expression evaluates <literal>true</literal>, the data successfully loaded into the element. Otherwise, a cracking error occurred and Peach will report the details of the error.</simpara>
<simpara>The constraint attribute does not affect how Peach mutates the value.</simpara>
<note>
<simpara>Constraints are only executed when parsing (cracking) data into a data element.</simpara>
</note>
<tip>
<simpara>Constraints are typically slower than using either <link linkend="Choice">Choice</link> or the <emphasis>token</emphasis> attribute.</simpara>
</tip>
<simpara>The following special variables are available to the expression:</simpara>
<variablelist>
<varlistentry>
<term>element</term>
<listitem>
<simpara>The data element instance.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>value</term>
<listitem>
<simpara>The value of the data cracked into the data element.  This value is cast to a string or to a byte array.</simpara>
</listitem>
</varlistentry>
</variablelist>
<section xml:id="_example_6">
<title>Example</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;!-- Operate on number and check result --&gt;
&lt;Number name="constrainedNum" size="32" constraint="int(value) &amp; 0xfefe == 5" /&gt;</programlisting>
<programlisting language="xml" linenumbering="unnumbered">&lt;!-- Case insensitive equals --&gt;
&lt;String constraint="value.lower() == 'peach'" /&gt;

&lt;!-- Value contains peach --&gt;
&lt;String constraint="value.find('peach') != -1" /&gt;</programlisting>
<programlisting language="xml" linenumbering="unnumbered">&lt;!-- Length is less than 100 bytes --&gt;
&lt;Blob constraint="len(value) &lt; 100" /&gt;</programlisting>
</section>
</section>
<section xml:id="endian">
<title>Endian Attribute</title>
<simpara>Specify the byte order of a field.</simpara>
<simpara>For more information about endian-ness, see <link xl:href="http://en.wikipedia.org/wiki/Endian">the Endian Wikipedia article</link>.</simpara>
<simpara><emphasis role="strong">Valid Values:</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>big or network&#8201;&#8212;&#8201;Most significant byte first</simpara>
</listitem>
<listitem>
<simpara>little&#8201;&#8212;&#8201;Least significant byte first</simpara>
</listitem>
</itemizedlist>
<section xml:id="_examples_186">
<title>Examples:</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;DataModel name="NumberExample6"&gt;
 &lt;Number name="Hi5" value="AB CD" valueType="hex" size="16" signed="false" endian="big" /&gt;
&lt;/DataModel&gt;</programlisting>
<simpara>Produces the bytes in the following order.</simpara>
<screen> AB CD</screen>
<programlisting language="xml" linenumbering="unnumbered">&lt;DataModel name="NumberExample7"&gt;
 &lt;Number name="Hi5" value="AB CD" valueType="hex" size="16" signed="false" endian="little" /&gt;
&lt;/DataModel&gt;</programlisting>
<simpara>Produces the bytes in the following order.</simpara>
<screen> CD AB</screen>
</section>
</section>
<section xml:id="Field">
<title>Field</title>
<simpara>The Field element specifies the data that replaces the default value in a DataModel element.</simpara>
<section xml:id="_attributes_98">
<title>Attributes</title>
<simpara><emphasis>Required:</emphasis></simpara>
<variablelist>
<varlistentry>
<term><link linkend="name">name</link></term>
<listitem>
<simpara>Name of the DataModel element.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>Optional:</emphasis></simpara>
<variablelist>
<varlistentry>
<term><link linkend="value">value</link></term>
<listitem>
<simpara>The value to set.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="valueType">valueType</link></term>
<listitem>
<simpara>The format in which the default value is expressed (i.e. hex, string, or literal).</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_187">
<title>Examples</title>
<example>
<title>Basic Example</title>
<simpara>Data used to overwrite <emphasis>Good Afternoon World!</emphasis> with <emphasis>Hello World!</emphasis>.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;DataModel name="TheDataModel"&gt;
  &lt;Block name="Block1"&gt;
    &lt;String name="Key" value="Output: " /&gt;
    &lt;String name="Value" value="Good Afternoon World!"/&gt;
  &lt;/Block&gt;
&lt;/DataModel&gt;

&lt;StateModel name="TheState"&gt;
  &lt;State name="initial"&gt;
    &lt;Action type="output"&gt;
      &lt;DataModel ref="TheDataModel" /&gt;
      &lt;Data name="SampleData"&gt;
        &lt;Field name="Block1.Value" value="Hello World!" /&gt;
      &lt;/Data&gt;
    &lt;/Action&gt;
  &lt;/State&gt;
&lt;/StateModel&gt;</programlisting>
</example>
</section>
</section>
<section xml:id="fileName">
<title>fileName</title>
<simpara>When used with the <link linkend="Data">Data</link> element, <emphasis>fileName</emphasis> can specify any of the following:</simpara>
<itemizedlist>
<listitem>
<simpara>A single file ("<literal>sample.png</literal>"),</simpara>
</listitem>
<listitem>
<simpara>Multiple files by pointing to a folder ("<literal>samples</literal>"), or</simpara>
</listitem>
<listitem>
<simpara>Multiple files by providing a file glob ("<literal>samples_*.jpg</literal>").</simpara>
</listitem>
</itemizedlist>
<simpara>If a folder or file glob specifies multiple files, use the <emphasis>switchCount</emphasis>  attribute with the <link linkend="MutationStrategies">random strategy</link> to specify the number of iterations performed before switching to the next file.</simpara>
<important>
<simpara>Multiple files are ONLY supported by the random mutation strategy.</simpara>
</important>
</section>
<section xml:id="Hint">
<title>Hint</title>
<simpara>Hints are a <link linkend="Mutators">Mutator</link> extension; they can be attached to data elements to provide the Peach engine more information about parsed data (including how to treat it). For example, when a <link linkend="String">String</link> contains a number, only the numerical tests contained within the string mutator would execute.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;String value="250"&gt;
   &lt;Hint name="NumericalVarianceMutator-N" value="100" /&gt;
&lt;/String&gt;</programlisting>
<simpara><emphasis>Available Hints</emphasis>:</simpara>
<itemizedlist>
<listitem>
<simpara>ArrayVarianceMutator-N</simpara>
</listitem>
<listitem>
<simpara>BitFlipperMutator-N</simpara>
</listitem>
<listitem>
<simpara>DWORDSliderMutator</simpara>
</listitem>
<listitem>
<simpara>FiniteRandomNumbersMutator-N</simpara>
</listitem>
<listitem>
<simpara>NumericalEdgeCaseMutator-N</simpara>
</listitem>
<listitem>
<simpara>NumericalVarianceMutator-N</simpara>
</listitem>
<listitem>
<simpara>SizedDataNumericalEdgeCasesMutator-N</simpara>
</listitem>
<listitem>
<simpara>SizedDataVaranceMutator-N</simpara>
</listitem>
<listitem>
<simpara>SizedNumericalEdgeCasesMutator-N</simpara>
</listitem>
<listitem>
<simpara>SizedVaranceMutator-N</simpara>
</listitem>
<listitem>
<simpara>type</simpara>
</listitem>
<listitem>
<simpara>ValidValues</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="length">
<title>Length Attribute</title>
<simpara>The <emphasis>length</emphasis> attribute defines the Blob or String size in bytes.</simpara>
<section xml:id="_examples_188">
<title>Examples</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;Blob name="MagicNumber" length="8" value="01 02 03 04 05 06 07 08" valueType="hex" /&gt;

&lt;String name="Token" value="MAGIC" length="5"/&gt;</programlisting>
</section>
</section>
<section xml:id="lengthType">
<title>Length Type Attribute</title>
<simpara>The <emphasis>lengthType</emphasis> attribute defines the units of measure of the <emphasis>length</emphasis> attribute.</simpara>
<note>
<simpara>A <emphasis>length</emphasis> attribute must be defined before using <emphasis>lengthType</emphasis>.</simpara>
</note>
<variablelist>
<varlistentry>
<term>bits</term>
<listitem>
<simpara>Length is specified as a number of bits.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>bytes</term>
<listitem>
<simpara>Length is specified as a number of bytes (default).</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>chars</term>
<listitem>
<simpara>Length is specified as a number of characters (only applies to <link linkend="String">String</link>).</simpara>
</listitem>
</varlistentry>
</variablelist>
<section xml:id="_examples_189">
<title>Examples</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;Blob length="8" lengthType="bytes" value="01 02 03 04 05 06 07 08" valueType="hex" /&gt;

&lt;String value="MAGIC" length="5" lengthType="chars"/&gt;

&lt;String value="MAGIC" lengthType="calc" lengthCalc="4+1"/&gt;</programlisting>
</section>
</section>
<section xml:id="maxOccurs">
<title>Maximum Occurrence Attribute</title>
<simpara><emphasis>maxOccurs</emphasis> specifies the maximum number of times an element can occur. Peach treats a data element with <emphasis>maxOccurs</emphasis> as an array.</simpara>
<simpara>Peach uses the occurrence attributes in cracking, producing, and mutating data.</simpara>
<simpara>The <emphasis>maxOccurs</emphasis> attribute specifies an upper limit on the number of array elements that can occur. A similar attribute, the <link linkend="minOccurs">minOccurs</link> attribute specifies a lower limit on the number of array elements that can occur. When used together, these two attributes define a range of an element&#8217;s occurrence.</simpara>
<simpara>Related attributes: <link linkend="minOccurs">minOccurs</link>, <link linkend="occurs">occurs</link>.</simpara>
<section xml:id="_examples_190">
<title>Examples</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;!-- Can occur a maximum of two times --&gt;
&lt;Block name="OtherThings" maxOccurs="2"&gt;
  &lt;String name="A" value="A" /&gt;
  &lt;String name="B" value="B" /&gt;
  &lt;String name="C" value="C" /&gt;
&lt;/Block&gt;

&lt;!-- Can occur a maximum of 1000 times --&gt;
&lt;String name="OptionalValue" maxOccurs="1000" /&gt;</programlisting>
</section>
</section>
<section xml:id="minOccurs">
<title>Minimum Occurrence Attribute</title>
<simpara><emphasis>minOccurs</emphasis> specifies the minimum number of times an element can occur. Peach treats a data element with <emphasis>minOccurs</emphasis> as an array.</simpara>
<simpara>Occurrence attributes are used when cracking, producing, and mutating data.</simpara>
<simpara>The <emphasis>minOccurs</emphasis> attribute specifies a lower limit on the number of array elements
that can occur. A similar attribute, the <link linkend="maxOccurs">maxOccurs</link> attribute
specifies an upper limit on the number of array elements that can occur. When
used together, these two attributes define a range of an elements occurrence.</simpara>
<simpara>Related attributes: <link linkend="maxOccurs">maxOccurs</link>, <link linkend="occurs">occurs</link>.</simpara>
<section xml:id="_examples_191">
<title>Examples</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;!-- Must occur at least twice --&gt;
&lt;Block name="OtherThings" minOccurs="2"&gt;
  &lt;String name="A" value="A" /&gt;
  &lt;String name="B" value="B" /&gt;
  &lt;String name="C" value="C" /&gt;
&lt;/Block&gt;

&lt;!-- Can occur 0 or more times --&gt;
&lt;String name="OptionalValue" minOccurs="0" /&gt;</programlisting>
</section>
</section>
<section xml:id="mutable">
<title>Mutable Attribute</title>
<simpara>Mutable declares whether to fuzz this element, block, or data type. The default value is true, meaning that Peach fuzzes the element, block,  or data type.</simpara>
<important>
<simpara>Marking an element as non-mutable disables the mutators that normally operate on that element. Even when an element is marked as non-mutable, it may still be modified as the fuzzer fuzzes the other elements.</simpara>
</important>
<warning>
<simpara>Marking elements as non-mutable usually leads to missing faults.  With that in mind, withhold use of this attribute unless:<?asciidoc-br?>
1) You know that the marked elements have already undergone fuzzing, and<?asciidoc-br?>
2) You are very familiar with the effects of this attribute (that is, you know what you are doing).</simpara>
</warning>
<section xml:id="_examples_192">
<title>Examples</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;DataModel name="Header"&gt;
  &lt;Number name="ReservedForFutureuse" size="8" mutable="false" /&gt;
  &lt;Number size="8" /&gt;
  &lt;Number size="8" /&gt;
  &lt;Number size="8" /&gt;
&lt;DataModel&gt;</programlisting>
</section>
</section>
<section xml:id="name">
<title>Name Attribute</title>
<simpara>Virtually all the Peach Pit file elements support the <emphasis>name</emphasis> attribute.  Names are used for readability and <link linkend="ref">referencing</link> other elements in a Pit file.</simpara>
<important>
<simpara>Names should not contain punctuation. Punctuation marks like period (.), slash (\\), and colon (:) have special <link linkend="ref">references</link> meanings.</simpara>
</important>
<simpara>Names are case sensitive and must be unique at the current scope level.</simpara>
<section xml:id="_examples_193">
<title>Examples</title>
<simpara><emphasis>Correct:</emphasis></simpara>
<simpara>The following example has unique names for each element.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;Block name="Header"&gt;
  &lt;Number name="Value1" size="8"/&gt;
  &lt;Number name="Value2" size="8"/&gt;
  &lt;Number name="Value3" size="8"/&gt;
  &lt;Number name="Value4" size="8"/&gt;
&lt;/Block&gt;</programlisting>
<simpara>The following example does not provide names for all values. This practice is okay, as long as you don&#8217;t want to access the unnamed element.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;Block name="Header"&gt;
  &lt;Number size="8"/&gt;
  &lt;Number size="8"/&gt;
  &lt;Number size="8"/&gt;
  &lt;Number size="8"/&gt;
&lt;/Block&gt;</programlisting>
<simpara><emphasis>Incorrect:</emphasis></simpara>
<simpara>The following has duplicate names at the same document level.  This causes an error.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;Block name="Header"&gt;
  &lt;Number name="Value" size="8"/&gt;
  &lt;Number name="Value" size="8"/&gt;
  &lt;Number name="Value" size="8"/&gt;
  &lt;Number name="Value" size="8"/&gt;
&lt;/Block&gt;</programlisting>
</section>
</section>
<section xml:id="occurs">
<title>Occurs Attribute</title>
<simpara><emphasis>occurs</emphasis> is a combination of <link linkend="minOccurs">minOccurs</link> and <link linkend="maxOccurs">maxOccurs</link>.</simpara>
<simpara>The <emphasis>occurs</emphasis> value (for the specified data element) is the exact number of element occurrences. Peach treats <emphasis>occurs</emphasis> as an array.</simpara>
<section xml:id="_example_7">
<title>Example</title>
<simpara>The following block is an array that occurs a fixed number of times.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;Block name="OccursBlock" occurs="5"&gt;
  &lt;String name="occurs" value="A"/&gt;
&lt;/Block&gt;</programlisting>
<simpara>Produces the output:</simpara>
<screen>AAAAA</screen>
</section>
</section>
<section xml:id="State_onStart">
<title>State onStart Attribute</title>
<simpara>The <emphasis>onStart</emphasis> attribute is a python expression that is evaluated prior to performing the actions in a <link linkend="State">State</link>.
This expression can be used to increment a counter or to call some other function defined in a separate file included with the <link linkend="Import">Import</link> element.</simpara>
<tip>
<simpara><emphasis><link linkend="State_onComplete">onComplete</link></emphasis> is the sibling attribute.</simpara>
</tip>
<sidebar>
<title>Keeping State</title>
<simpara>State bags are defined as <emphasis>Dictionary&lt;string, object&gt;</emphasis> in C#.
If you use one of two state bags exposed through the RunContext instance,
you can store state during the lifetime of the current iteration or for the entire fuzzing session.</simpara>
<simpara>A full example of using the iteration state bag is provided in the examples section.</simpara>
<simpara><emphasis>Using the Session State:</emphasis></simpara>
<simpara>This state stored in this state bag persists for the entire fuzzing session,
from the point of creation to the end of the session.</simpara>
<programlisting language="python" linenumbering="unnumbered">context.stateStore['my_counter'] = 0</programlisting>
<simpara><emphasis>Using the Iteration State:</emphasis></simpara>
<simpara>The state stored in this state bag exists for the current iteration.</simpara>
<programlisting language="python" linenumbering="unnumbered">context.iterationStateStore['my_counter'] = 0</programlisting>
</sidebar>
<section xml:id="_syntax_118">
<title>Syntax</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;State name="Initial" onStart="xyz.reset_counter(self)"&gt;

  &lt;Action type="output"&gt;
    &lt;DataModel ref="TheDataModel" /&gt;
  &lt;/Action&gt;

&lt;/State&gt;</programlisting>
</section>
<section xml:id="_scripting_scope">
<title>Scripting Scope</title>
<variablelist>
<varlistentry>
<term>context</term>
<listitem>
<simpara>RunContext instance</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>state</term>
<listitem>
<simpara>State instance</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>stateModel</term>
<listitem>
<simpara>StateModel instance</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>self</term>
<listitem>
<simpara>State instance</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>test</term>
<listitem>
<simpara>Test instance</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_194">
<title>Examples</title>
<example>
<title>Display a Message from <emphasis>onStart</emphasis></title>
<simpara>This example prints a message when the <emphasis>onStart</emphasis> statement is run.</simpara>
<screen>&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

  &lt;DataModel name="File1Model"&gt;
    &lt;String value="Data for the file" /&gt;
  &lt;/DataModel&gt;

  &lt;StateModel name="State" initialState="Initial"&gt;
    &lt;State name="Initial" onStart="print 'Hello from onStart!'"&gt;

      &lt;Action type="output"&gt;
        &lt;DataModel ref="File1Model" /&gt;
      &lt;/Action&gt;

    &lt;/State&gt;
  &lt;/StateModel&gt;

  &lt;Test name="Default"&gt;
    &lt;StateModel ref="State"/&gt;

    &lt;Publisher class="File"&gt;
      &lt;Param name="FileName" value="fuzzed.txt" /&gt;
    &lt;/Publisher&gt;
  &lt;/Test&gt;

&lt;/Peach&gt;</screen>
<simpara>The following is the resulting output:</simpara>
<screen>&gt; peach -1 --debug example.xml

[*] Test 'Default' starting with random seed 23438.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Hello from onStart!                                                          <co xml:id="CO62-1"/>
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.FilePublisher start()
Peach.Core.Publishers.FilePublisher open()
Peach.Core.Publishers.FilePublisher output(17 bytes)
Peach.Core.Publishers.FilePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.FilePublisher stop()

[*] Test 'Default' finished.</screen>
<calloutlist>
<callout arearefs="CO62-1">
<para>Output from <emphasis>onStart</emphasis></para>
</callout>
</calloutlist>
</example>
<example>
<title>Loop Using Iteration State Bag</title>
<simpara>This example uses the iteration state bag to simulate a for loop.</simpara>
<screen>&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

  &lt;DataModel name="TheDataModel"&gt;
    &lt;String value="Looping!\n" /&gt;
  &lt;/DataModel&gt;

  &lt;StateModel name="State" initialState="Initial"&gt;
    &lt;State name="Initial" onStart="context.iterationStateStore['count'] = 0"&gt;

	  &lt;!-- Initialize our counter --&gt;
	  &lt;Action type="changeState" ref="Loop" /&gt;

	&lt;/State&gt;

	&lt;State name="Loop" onStart="context.iterationStateStore['count'] = context.iterationStateStore['count'] + 1"&gt;

	  &lt;!-- onStart will increment counter --&gt;
      &lt;Action type="output"&gt;
        &lt;DataModel ref="TheDataModel" /&gt;
      &lt;/Action&gt;

	  &lt;!-- Loop until our counter is greater than 3 --&gt;
	  &lt;Action type="changeState" ref="Loop" when="context.iterationStateStore['count'] &amp;lt; 3" /&gt;

    &lt;/State&gt;

  &lt;/StateModel&gt;

  &lt;Test name="Default"&gt;
    &lt;StateModel ref="State"/&gt;

    &lt;Publisher class="Console"/&gt;
  &lt;/Test&gt;

&lt;/Peach&gt;</screen>
<simpara>The following is the resulting output:</simpara>
<screen>&gt; peach -1 --debug example.xml

[*] Test 'Default' starting with random seed 28742.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.ChangeState
Peach.Core.Dom.Action Changing to state: Loop
Peach.Core.Dom.StateModel Run(): Changing to state "Loop".
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher start()
Peach.Core.Publishers.ConsolePublisher open()
Peach.Core.Publishers.ConsolePublisher output(9 bytes)
Looping!                                                                     <co xml:id="CO63-1"/>
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.ChangeState
Peach.Core.Dom.Action Changing to state: Loop
Peach.Core.Dom.StateModel Run(): Changing to state "Loop".
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher output(9 bytes)
Looping!                                                                     <co xml:id="CO63-2"/>
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.ChangeState
Peach.Core.Dom.Action Changing to state: Loop
Peach.Core.Dom.StateModel Run(): Changing to state "Loop".
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher output(9 bytes)
Looping!                                                                     <co xml:id="CO63-3"/>
Peach.Core.Dom.Action Run: action 'Action_1' when returned false             <co xml:id="CO63-4"/>
Peach.Core.Publishers.ConsolePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.ConsolePublisher stop()

[*] Test 'Default' finished.</screen>
<calloutlist>
<callout arearefs="CO63-1">
<para>Output from iteration 1</para>
</callout>
<callout arearefs="CO63-2">
<para>Output from iteration 2</para>
</callout>
<callout arearefs="CO63-3">
<para>Output from iteration 3</para>
</callout>
<callout arearefs="CO63-4">
<para><emphasis>when</emphasis> expression returning false causing exit from loop</para>
</callout>
</calloutlist>
</example>
</section>
</section>
<section xml:id="State_onComplete">
<title>State onComplete Attribute</title>
<simpara>The <emphasis>onComplete</emphasis> attribute is a python expression that is evaluated after performing the actions in a <link linkend="State">State</link>.
This expression can be used to increment a counter or to call some other function defined in a separate file included with the <link linkend="Import">Import</link> element.</simpara>
<tip>
<simpara><emphasis><link linkend="State_onStart">onStart</link></emphasis> is the sibling attribute.</simpara>
</tip>
<sidebar>
<title>Keeping State</title>
<simpara>State bags are defined as <emphasis>Dictionary&lt;string, object&gt;</emphasis> in C#.
If you use one of two state bags exposed through the RunContext instance,
you can store state during the lifetime of the current iteration or for the entire fuzzing session.</simpara>
<simpara>A full example of using the iteration state bag is provided in the examples section.</simpara>
<simpara><emphasis>Using the Session State:</emphasis></simpara>
<simpara>This state stored in this state bag persists for the entire fuzzing session,
from the point of creation to the end of the session.</simpara>
<programlisting language="python" linenumbering="unnumbered">context.stateStore['my_counter'] = 0</programlisting>
<simpara><emphasis>Using the Iteration State:</emphasis></simpara>
<simpara>The state stored in this state bag exists for the current iteration.</simpara>
<programlisting language="python" linenumbering="unnumbered">context.iterationStateStore['my_counter'] = 0</programlisting>
</sidebar>
<section xml:id="_syntax_119">
<title>Syntax</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;State name="Initial" onComplete="xyz.reset_counter(self)"&gt;

  &lt;Action type="output"&gt;
    &lt;DataModel ref="TheDataModel" /&gt;
  &lt;/Action&gt;

&lt;/State&gt;</programlisting>
</section>
<section xml:id="_scripting_scope_2">
<title>Scripting Scope</title>
<variablelist>
<varlistentry>
<term>context</term>
<listitem>
<simpara>RunContext instance</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>state</term>
<listitem>
<simpara>State instance</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>stateModel</term>
<listitem>
<simpara>StateModel instance</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>self</term>
<listitem>
<simpara>State instance</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>test</term>
<listitem>
<simpara>Test instance</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_195">
<title>Examples</title>
<example>
<title>Display a Message from <emphasis>onComplete</emphasis></title>
<simpara>This example prints a message when the <emphasis>onComplete</emphasis> statement is run.</simpara>
<screen>&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

  &lt;DataModel name="File1Model"&gt;
    &lt;String value="Data for the file" /&gt;
  &lt;/DataModel&gt;

  &lt;StateModel name="State" initialState="Initial"&gt;
    &lt;State name="Initial" onComplete="print 'Hello from onComplete!'"&gt;

      &lt;Action type="output"&gt;
        &lt;DataModel ref="File1Model" /&gt;
      &lt;/Action&gt;

    &lt;/State&gt;
  &lt;/StateModel&gt;

  &lt;Test name="Default"&gt;
    &lt;StateModel ref="State"/&gt;

    &lt;Publisher class="File"&gt;
      &lt;Param name="FileName" value="fuzzed.txt" /&gt;
    &lt;/Publisher&gt;  &lt;/Test&gt;

&lt;/Peach&gt;</screen>
<simpara>This is the resulting output:</simpara>
<screen>&gt; peach -1 --debug example.xml

[*] Test 'Default' starting with random seed 27537.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.FilePublisher start()
Peach.Core.Publishers.FilePublisher open()
Peach.Core.Publishers.FilePublisher output(17 bytes)
Hello from onComplete!                                                       <co xml:id="CO64-1"/>
Peach.Core.Publishers.FilePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.FilePublisher stop()

[*] Test 'Default' finished.</screen>
<calloutlist>
<callout arearefs="CO64-1">
<para>Output from <emphasis>onComplete</emphasis></para>
</callout>
</calloutlist>
</example>
<example>
<title>Loop Using Iteration State Bag</title>
<simpara>This example uses the iteration state bag to simulate a for loop.</simpara>
<screen>&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

  &lt;DataModel name="TheDataModel"&gt;
    &lt;String value="Looping!\n" /&gt;
  &lt;/DataModel&gt;

  &lt;StateModel name="State" initialState="Initial"&gt;
    &lt;State name="Initial" onStart="context.iterationStateStore['count'] = 0"&gt;

	  &lt;!-- Initialize our counter --&gt;
	  &lt;Action type="changeState" ref="Loop" /&gt;

	&lt;/State&gt;

	&lt;State name="Loop" onComplete="context.iterationStateStore['count'] = context.iterationStateStore['count'] + 1"&gt;

	  &lt;!-- onStart will increment counter --&gt;
      &lt;Action type="output"&gt;
        &lt;DataModel ref="TheDataModel" /&gt;
      &lt;/Action&gt;

	  &lt;!-- Loop until our counter is greater than 3 --&gt;
	  &lt;Action type="changeState" ref="Loop" when="context.iterationStateStore['count'] &amp;lt; 3" /&gt;

    &lt;/State&gt;

  &lt;/StateModel&gt;

  &lt;Test name="Default"&gt;
    &lt;StateModel ref="State"/&gt;

    &lt;Publisher class="Console"/&gt;  &lt;/Test&gt;

&lt;/Peach&gt;</screen>
<simpara>This is the resulting output:</simpara>
<screen>&gt; peach -1 --debug example.xml

[*] Test 'Default' starting with random seed 28742.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.ChangeState
Peach.Core.Dom.Action Changing to state: Loop
Peach.Core.Dom.StateModel Run(): Changing to state "Loop".
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher start()
Peach.Core.Publishers.ConsolePublisher open()
Peach.Core.Publishers.ConsolePublisher output(9 bytes)
Looping!                                                                     <co xml:id="CO65-1"/>
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.ChangeState
Peach.Core.Dom.Action Changing to state: Loop
Peach.Core.Dom.StateModel Run(): Changing to state "Loop".
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher output(9 bytes)
Looping!                                                                     <co xml:id="CO65-2"/>
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.ChangeState
Peach.Core.Dom.Action Changing to state: Loop
Peach.Core.Dom.StateModel Run(): Changing to state "Loop".
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher output(9 bytes)
Looping!                                                                     <co xml:id="CO65-3"/>
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.ChangeState
Peach.Core.Dom.Action Changing to state: Loop
Peach.Core.Dom.StateModel Run(): Changing to state "Loop".
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher output(9 bytes)
Looping!                                                                     <co xml:id="CO65-4"/>
Peach.Core.Dom.Action Run: action 'Action_1' when returned false             <co xml:id="CO65-5"/>
Peach.Core.Publishers.ConsolePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.ConsolePublisher stop()

[*] Test 'Default' finished.</screen>
<calloutlist>
<callout arearefs="CO65-1">
<para>Output from iteration 1</para>
</callout>
<callout arearefs="CO65-2">
<para>Output from iteration 2</para>
</callout>
<callout arearefs="CO65-3">
<para>Output from iteration 3</para>
</callout>
<callout arearefs="CO65-4">
<para>Output from iteration 4</para>
</callout>
<callout arearefs="CO65-5">
<para><emphasis>when</emphasis> expression returning false causing exit from loop</para>
</callout>
</calloutlist>
</example>
</section>
</section>
<section xml:id="Action_onComplete">
<title>Action onComplete Attribute</title>
<simpara>The onComplete attribute is an expression that is evaluated after performing an action.
This expression can be used to increment a counter or to perform other functions defined in separate files, such as those brought into the model using the <link linkend="Import">Import</link> tag.</simpara>
<sidebar>
<title>Keeping State</title>
<simpara>Peach provides a mechanism for the user to store state during for the lifetime of the current iteration, or the fuzzing session.
This is accomplished using one of two state bags exposed through the RunContext instance.
The state bags are defined as <emphasis>Dictionary&lt;string, object&gt;</emphasis> in C#.
A full example of using the iteration state bag is provided in the examples section.</simpara>
<simpara><emphasis>Using the Session State:</emphasis></simpara>
<simpara>This state stored in this state bag persists for the entire fuzzing session, from the point of creation to the end of the fuzzing session.</simpara>
<programlisting language="python" linenumbering="unnumbered">context.stateStore['my_counter'] = 0</programlisting>
<simpara><emphasis>Using the Iteration State:</emphasis></simpara>
<simpara>The state stored in this state bag exists only for the current iteration.</simpara>
<programlisting language="python" linenumbering="unnumbered">context.iterationStateStore['my_counter'] = 0</programlisting>
</sidebar>
<section xml:id="_syntax_120">
<title>Syntax</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;State name="Initial"&gt;

  &lt;Action type="changeState" ref="NextState" onComplete="xyz.reset_counter(self)"/&gt;

&lt;/State&gt;</programlisting>
</section>
<section xml:id="_scripting_scope_3">
<title>Scripting Scope</title>
<variablelist>
<varlistentry>
<term>action</term>
<listitem>
<simpara>Action instance</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>context</term>
<listitem>
<simpara>RunContext instance</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>state</term>
<listitem>
<simpara>State instance</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>stateModel</term>
<listitem>
<simpara>StateModel instance</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>self</term>
<listitem>
<simpara>Action instance</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>test</term>
<listitem>
<simpara>Test instance</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_196">
<title>Examples</title>
<example>
<title>Display a Message from <emphasis>onComplete</emphasis></title>
<simpara>This example prints a message when the <emphasis>onComplete</emphasis> expression is run.</simpara>
<screen>&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

  &lt;DataModel name="File1Model"&gt;
    &lt;String value="Data for the file" /&gt;
  &lt;/DataModel&gt;

  &lt;StateModel name="State" initialState="Initial"&gt;
    &lt;State name="Initial"&gt;

      &lt;Action type="output" onComplete="print 'Hello from onComplete!'"&gt;
        &lt;DataModel ref="File1Model" /&gt;
      &lt;/Action&gt;

    &lt;/State&gt;
  &lt;/StateModel&gt;

  &lt;Test name="Default"&gt;
    &lt;StateModel ref="State"/&gt;

    &lt;Publisher class="File"&gt;
      &lt;Param name="FileName" value="fuzzed.txt" /&gt;
    &lt;/Publisher&gt;  &lt;/Test&gt;

&lt;/Peach&gt;</screen>
<screen>&gt; peach -1 --debug example.xml

[*] Test 'Default' starting with random seed 27073.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.FilePublisher start()
Peach.Core.Publishers.FilePublisher open()
Peach.Core.Publishers.FilePublisher output(17 bytes)
Hello from onComplete!                                                       <co xml:id="CO66-1"/>
Peach.Core.Publishers.FilePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.FilePublisher stop()

[*] Test 'Default' finished.</screen>
<calloutlist>
<callout arearefs="CO66-1">
<para>Output from <emphasis>onComplete</emphasis></para>
</callout>
</calloutlist>
</example>
<example>
<title>Loop Using Iteration State Bag</title>
<simpara>This example uses the iteration state bag to simulate a for loop.</simpara>
<screen>&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

  &lt;DataModel name="TheDataModel"&gt;
    &lt;String value="Looping!\n" /&gt;
  &lt;/DataModel&gt;

  &lt;StateModel name="State" initialState="Initial"&gt;
    &lt;State name="Initial"&gt;

	  &lt;!-- Initialize our counter --&gt;
	  &lt;Action type="changeState" ref="Loop" onStart="context.iterationStateStore['count'] = 0" /&gt;

	&lt;/State&gt;

	&lt;State name="Loop"&gt;

	  &lt;!-- onComplete will increment counter --&gt;
      &lt;Action type="output" onComplete="context.iterationStateStore['count'] = context.iterationStateStore['count'] + 1"&gt;
        &lt;DataModel ref="TheDataModel" /&gt;
      &lt;/Action&gt;

	  &lt;!-- Loop until our counter is greater than 3 --&gt;
	  &lt;Action type="changeState" ref="Loop" when="context.iterationStateStore['count'] &amp;lt; 3" /&gt;

    &lt;/State&gt;

  &lt;/StateModel&gt;

  &lt;Test name="Default"&gt;
    &lt;StateModel ref="State"/&gt;

    &lt;Publisher class="Console"/&gt;  &lt;/Test&gt;

&lt;/Peach&gt;</screen>
<screen>&gt; peach -1 --debug example.xml

[*] Test 'Default' starting with random seed 28742.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.ChangeState
Peach.Core.Dom.Action Changing to state: Loop
Peach.Core.Dom.StateModel Run(): Changing to state "Loop".
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher start()
Peach.Core.Publishers.ConsolePublisher open()
Peach.Core.Publishers.ConsolePublisher output(9 bytes)
Looping!                                                                     <co xml:id="CO67-1"/>
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.ChangeState
Peach.Core.Dom.Action Changing to state: Loop
Peach.Core.Dom.StateModel Run(): Changing to state "Loop".
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher output(9 bytes)
Looping!                                                                     <co xml:id="CO67-2"/>
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.ChangeState
Peach.Core.Dom.Action Changing to state: Loop
Peach.Core.Dom.StateModel Run(): Changing to state "Loop".
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher output(9 bytes)
Looping!                                                                     <co xml:id="CO67-3"/>
Peach.Core.Dom.Action Run: action 'Action_1' when returned false             <co xml:id="CO67-4"/>
Peach.Core.Publishers.ConsolePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.ConsolePublisher stop()

[*] Test 'Default' finished.</screen>
<calloutlist>
<callout arearefs="CO67-1">
<para>Output from iteration 1</para>
</callout>
<callout arearefs="CO67-2">
<para>Output from iteration 2</para>
</callout>
<callout arearefs="CO67-3">
<para>Output from iteration 3</para>
</callout>
<callout arearefs="CO67-4">
<para><emphasis>when</emphasis> expression returning false causing exit from loop</para>
</callout>
</calloutlist>
</example>
</section>
</section>
<section xml:id="Action_onStart">
<title>Action onStart Attribute</title>
<simpara>The onStart attribute is an expression that is evaluated before performing an action.
This expression can be used to increment a counter or to perform other functions defined in separate files, such as those brought into the model using the <link linkend="Import">Import</link> tag.</simpara>
<note>
<simpara>If the <emphasis>onStart</emphasis> expression is part of the very first explicit action, it executes prior to the implicit actions.</simpara>
</note>
<sidebar>
<title>Keeping State</title>
<simpara>Peach provides a mechanism for the user to store state during for the lifetime of the current iteration, or the fuzzing session.
This is accomplished using one of two state bags exposed through the RunContext instance.
The state bags are defined as <emphasis>Dictionary&lt;string, object&gt;</emphasis> in C#.
A full example of using the iteration state bag is provided in the examples section.</simpara>
<simpara><emphasis>Using the Session State:</emphasis></simpara>
<simpara>This state stored in this state bag persists for the entire fuzzing session, from the point of creation to the end of the fuzzing session.</simpara>
<programlisting language="python" linenumbering="unnumbered">context.stateStore['my_counter'] = 0</programlisting>
<simpara><emphasis>Using the Iteration State:</emphasis></simpara>
<simpara>The state stored in this state bag exists only for the current iteration.</simpara>
<programlisting language="python" linenumbering="unnumbered">context.iterationStateStore['my_counter'] = 0</programlisting>
</sidebar>
<section xml:id="_syntax_121">
<title>Syntax</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;State name="Initial"&gt;

  &lt;Action type="changeState" ref="NextState" onStart="xyz.reset_counter(self)"/&gt;

&lt;/State&gt;</programlisting>
</section>
<section xml:id="_scripting_scope_4">
<title>Scripting Scope</title>
<variablelist>
<varlistentry>
<term>action</term>
<listitem>
<simpara>Action instance</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>context</term>
<listitem>
<simpara>RunContext instance</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>state</term>
<listitem>
<simpara>State instance</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>stateModel</term>
<listitem>
<simpara>StateModel instance</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>self</term>
<listitem>
<simpara>Action instance</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>test</term>
<listitem>
<simpara>Test instance</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_197">
<title>Examples</title>
<example>
<title>Display a Message from <emphasis>onStart</emphasis></title>
<simpara>This example prints a message when the <emphasis>onStart</emphasis> expression is run.</simpara>
<screen>&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

  &lt;DataModel name="File1Model"&gt;
    &lt;String value="Data for the file" /&gt;
  &lt;/DataModel&gt;

  &lt;StateModel name="State" initialState="Initial"&gt;
    &lt;State name="Initial"&gt;

      &lt;Action type="output" onStart="print 'Hello from onStart!'"&gt;
        &lt;DataModel ref="File1Model" /&gt;
      &lt;/Action&gt;

    &lt;/State&gt;
  &lt;/StateModel&gt;

  &lt;Test name="Default"&gt;
    &lt;StateModel ref="State"/&gt;

    &lt;Publisher class="File"&gt;
      &lt;Param name="FileName" value="fuzzed.txt" /&gt;
    &lt;/Publisher&gt;  &lt;/Test&gt;

&lt;/Peach&gt;</screen>
<screen>&gt; peach -1 --debug example.xml

[*] Test 'Default' starting with random seed 27537.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Hello from onStart!                                                          <co xml:id="CO68-1"/>
Peach.Core.Publishers.FilePublisher start()
Peach.Core.Publishers.FilePublisher open()
Peach.Core.Publishers.FilePublisher output(17 bytes)
Peach.Core.Publishers.FilePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.FilePublisher stop()

[*] Test 'Default' finished.</screen>
<calloutlist>
<callout arearefs="CO68-1">
<para>Output from <emphasis>onStart</emphasis></para>
</callout>
</calloutlist>
</example>
<example>
<title>Loop Using Iteration State Bag</title>
<simpara>This example use the iteration state bag to simulate a for loop.</simpara>
<screen>&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

  &lt;DataModel name="TheDataModel"&gt;
    &lt;String value="Looping!\n" /&gt;
  &lt;/DataModel&gt;

  &lt;StateModel name="State" initialState="Initial"&gt;
    &lt;State name="Initial"&gt;

	  &lt;!-- Initialize our counter --&gt;
	  &lt;Action type="changeState" ref="Loop" onStart="context.iterationStateStore['count'] = 0" /&gt;

	&lt;/State&gt;

	&lt;State name="Loop"&gt;

	  &lt;!-- onStart will increment counter --&gt;
      &lt;Action type="output" onStart="context.iterationStateStore['count'] = context.iterationStateStore['count'] + 1"&gt;
        &lt;DataModel ref="TheDataModel" /&gt;
      &lt;/Action&gt;

	  &lt;!-- Loop until our counter is greater than 3 --&gt;
	  &lt;Action type="changeState" ref="Loop" when="context.iterationStateStore['count'] &amp;lt; 3" /&gt;

    &lt;/State&gt;

  &lt;/StateModel&gt;

  &lt;Test name="Default"&gt;
    &lt;StateModel ref="State"/&gt;

    &lt;Publisher class="Console"/&gt;  &lt;/Test&gt;

&lt;/Peach&gt;</screen>
<screen>&gt; peach -1 --debug example.xml

[*] Test 'Default' starting with random seed 28742.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.ChangeState
Peach.Core.Dom.Action Changing to state: Loop
Peach.Core.Dom.StateModel Run(): Changing to state "Loop".
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher start()
Peach.Core.Publishers.ConsolePublisher open()
Peach.Core.Publishers.ConsolePublisher output(9 bytes)
Looping!                                                                     <co xml:id="CO69-1"/>
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.ChangeState
Peach.Core.Dom.Action Changing to state: Loop
Peach.Core.Dom.StateModel Run(): Changing to state "Loop".
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher output(9 bytes)
Looping!                                                                     <co xml:id="CO69-2"/>
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.ChangeState
Peach.Core.Dom.Action Changing to state: Loop
Peach.Core.Dom.StateModel Run(): Changing to state "Loop".
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher output(9 bytes)
Looping!                                                                     <co xml:id="CO69-3"/>
Peach.Core.Dom.Action Run: action 'Action_1' when returned false             <co xml:id="CO69-4"/>
Peach.Core.Publishers.ConsolePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.ConsolePublisher stop()

[*] Test 'Default' finished.</screen>
<calloutlist>
<callout arearefs="CO69-1">
<para>Output from iteration 1</para>
</callout>
<callout arearefs="CO69-2">
<para>Output from iteration 2</para>
</callout>
<callout arearefs="CO69-3">
<para>Output from iteration 3</para>
</callout>
<callout arearefs="CO69-4">
<para><emphasis>when</emphasis> expression returning false causing exit from loop</para>
</callout>
</calloutlist>
</example>
</section>
</section>
<section xml:id="ref">
<title>Ref Attribute</title>
<simpara>The ref attribute specifies a reference to another element by name or by class structure.  References can be relative or fully qualified.</simpara>
<section xml:id="_examples_198">
<title>Examples</title>
<simpara><emphasis>Relative by Name:</emphasis></simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;Block ref="ElementName"/&gt;</programlisting>
<simpara><emphasis>Fully qualified with namespace prefix:</emphasis></simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;Block ref="namespace:parent.parent.child"/&gt;</programlisting>
<simpara><emphasis>Fully qualified:</emphasis></simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;Block ref="parent.parent.child"/&gt;</programlisting>
</section>
</section>
<section xml:id="signed">
<title>Signed Attribute</title>
<simpara>Specifies whether a number contains a signed value.  The default value is true.</simpara>
<simpara><emphasis>signed</emphasis> is useful when parsing length data.</simpara>
<section xml:id="_examples_199">
<title>Examples:</title>
<simpara>Specify a data element is unsigned by setting the signed attribute to "false".</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;DataModel name="NumberExample3"&gt;
 &lt;Number name="Hi5" value="5" size="32" signed="false"/&gt;
&lt;/DataModel&gt;</programlisting>
</section>
</section>
<section xml:id="size">
<title>Size Attribute</title>
<simpara>The <emphasis>size</emphasis> attribute speicifies the size of a data element in BITS. Size typically applies to <link linkend="Number">Number</link> or bit <link linkend="Flags">Flags</link> elements.</simpara>
<section xml:id="_examples_200">
<title>Examples</title>
<simpara>This example creates an 8-bit number with a default value of 42.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;Number name="TheAnswer" size="8" value="42" /&gt;</programlisting>
</section>
</section>
<section xml:id="token">
<title>Token Attribute</title>
<simpara>A token is a data element that Peach seeks when parsing incoming data.  Tokens do not affect how elements are mutated.  If a token attribute is specified the element must have a default value specified in the XML.</simpara>
<section xml:id="_examples_201">
<title>Examples</title>
<simpara>If you are trying to parse "length:42" and you want the header and value to be considered separate elements, label the colon delimiter ":" as a token.</simpara>
<formalpara>
<title>Example Data to Crack</title>
<para>
<screen>  length:42</screen>
</para>
</formalpara>
<simpara>The following model looks for a ":" and puts the value of "length" into the header string and a 42 into the val string.</simpara>
<simpara>If a ":" is not found in the data stream, an exception will be raised and cracking will fail.</simpara>
<programlisting language="xml" linenumbering="unnumbered"> &lt;String name="header" /&gt;
 &lt;String name="delimiter" value=":" token="true"/&gt;
 &lt;String name="val" /&gt;</programlisting>
<formalpara>
<title>Example Data</title>
<para>
<screen>Host: www.peachfuzzer.com\r\n</screen>
</para>
</formalpara>
<formalpara>
<title>Example xml to parse</title>
<para>
<programlisting language="xml" linenumbering="unnumbered"> &lt;String name="header" /&gt;
 &lt;String name="delimiter" value=": " token="true"/&gt;
 &lt;String name="val" /&gt;
 &lt;String name="CRLF" value="\r\n" token="true" /&gt;</programlisting>
</para>
</formalpara>
</section>
</section>
<section xml:id="value">
<title>Value Attribute</title>
<simpara>The <emphasis>value</emphasis> attribute specifies a default value for a data element when Peach is not mutating the element.</simpara>
<simpara>All Peach data element types support  <emphasis>value</emphasis>.</simpara>
<section xml:id="_examples_202">
<title>Examples</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;Number name="five" size="8" value="5" /&gt;

&lt;String name="five" value="five" /&gt;</programlisting>
</section>
</section>
<section xml:id="valueType">
<title>ValueType Attribute</title>
<simpara>The <emphasis>valueType</emphasis> attribute specifies what type of data is contained in the <emphasis>value</emphasis> attribute.
Valid values are <literal>string</literal>, <literal>hex</literal>, and <literal>literal</literal>.</simpara>
<variablelist>
<varlistentry>
<term>string</term>
<listitem>
<simpara>String is the default <emphasis>valueType</emphasis>.<?asciidoc-br?>
The value provided is a string value.
String value is converted into the appropriate data element type.
The <emphasis>Number</emphasis> element expects numerical values while <emphasis>String</emphasis> and <emphasis>Blob</emphasis> accept any values.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>hex</term>
<listitem>
<simpara>The value specified as a stream of hex bytes.<?asciidoc-br?>
Peach is fairly good about figuring out different types of hex strings like "<literal>0x00 0x00</literal>" or "<literal>\x00 \x00</literal>" or "<literal>00 00 00 00 00</literal>".</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>literal</term>
<listitem>
<simpara>Specify a python or ruby statement that evaluates to the wanted value.<?asciidoc-br?>
The evaluation occurs only once when the Pit is parsed into an internal DOM tree.</simpara>
</listitem>
</varlistentry>
</variablelist>
<warning>
<simpara>A literal should <emphasis role="strong">not</emphasis> be used in place of a <link linkend="Relation">Relation</link> or a <link linkend="Fixup">Fixup</link>. Literals are only to be used for quick one-time expressions.</simpara>
</warning>
<section xml:id="_examples_203">
<title>Examples</title>
<example>
<title>string</title>
<simpara>A numerical representation of value 65.</simpara>
<programlisting language="xml" linenumbering="unnumbered">   &lt;Number valueType="string" value="65" /&gt;</programlisting>
<simpara>Output</simpara>
<programlisting language="xml" linenumbering="unnumbered">A</programlisting>
<simpara>A string representation of value 65.</simpara>
<programlisting language="xml" linenumbering="unnumbered">   &lt;Number valueType="string" value="65" /&gt;</programlisting>
<simpara>Output</simpara>
<programlisting language="xml" linenumbering="unnumbered"> 65</programlisting>
</example>
<example>
<title>hex</title>
<simpara>A numerical representation of value 0x41.</simpara>
<programlisting language="xml" linenumbering="unnumbered">   &lt;String valueType="hex" value="41" /&gt;</programlisting>
<simpara>Output</simpara>
<programlisting language="xml" linenumbering="unnumbered">A</programlisting>
<simpara>A numerical representation of value 0x41.</simpara>
<programlisting language="xml" linenumbering="unnumbered">   &lt;Number valueType="hex" value="41" /&gt;</programlisting>
<simpara>Output</simpara>
<programlisting language="xml" linenumbering="unnumbered">A</programlisting>
<note>
<simpara>The hex values must be EVEN numbered! This is WRONG: "<literal>0x000</literal>" and this is CORRECT: "<literal>0x0000</literal>"</simpara>
</note>
</example>
<example>
<title>literal</title>
<programlisting language="xml" linenumbering="unnumbered">   &lt;String valueType="literal" value="(1 + 2 + 3)**2" /&gt;</programlisting>
<simpara>Output</simpara>
<programlisting language="xml" linenumbering="unnumbered">36</programlisting>
<programlisting language="xml" linenumbering="unnumbered">   &lt;String valueType="literal" value="'hello world!'.upper()" /&gt;</programlisting>
<simpara>Output</simpara>
<programlisting language="xml" linenumbering="unnumbered">HELLO WORLD!</programlisting>
</example>
</section>
</section>
<section xml:id="Action_when">
<title>Action when Attribute</title>
<simpara>The <emphasis>when</emphasis> attribute is a Python Boolean expression that is evaluated before performing an action. If the expression evaluates to true, the action is performed; otherwise, the action is skipped.</simpara>
<sidebar>
<title>Keeping State</title>
<simpara>Peach provides a mechanism for the user to store state during for the lifetime of the current iteration, or the fuzzing session.
This is accomplished using one of two state bags exposed through the RunContext instance.
The state bags are defined as <emphasis>Dictionary&lt;string, object&gt;</emphasis> in C#.
A full example of using the iteration state bag is provided in the examples section.</simpara>
<simpara><emphasis>Using the Session State:</emphasis></simpara>
<simpara>This state stored in this state bag persists for the entire fuzzing session, from the point of creation to the end of the fuzzing session.</simpara>
<programlisting language="python" linenumbering="unnumbered">context.stateStore['my_counter'] = 0</programlisting>
<simpara><emphasis>Using the Iteration State:</emphasis></simpara>
<simpara>The state stored in this state bag exists only for the current iteration.</simpara>
<programlisting language="python" linenumbering="unnumbered">context.iterationStateStore['my_counter'] = 0</programlisting>
</sidebar>
<section xml:id="_syntax_122">
<title>Syntax</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;State name="Initial"&gt;

  &lt;Action type="changeState" ref="State2" when="int(state.actions[0].dataModel.find('Type').DefaultValue) == 2"/&gt;

&lt;/State&gt;</programlisting>
</section>
<section xml:id="_scripting_scope_5">
<title>Scripting Scope</title>
<variablelist>
<varlistentry>
<term>action</term>
<listitem>
<simpara>Action instance</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>context</term>
<listitem>
<simpara>RunContext instance</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>state</term>
<listitem>
<simpara>State instance</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>stateModel</term>
<listitem>
<simpara>StateModel instance</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>self</term>
<listitem>
<simpara>Action instance</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>test</term>
<listitem>
<simpara>Test instance</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_examples_204">
<title>Examples</title>
<example>
<title>Conditional <emphasis>changeState</emphasis> Based on <emphasis>when</emphasis> Expression</title>
<simpara>The following example changes its behavior based on input received from the target client.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

  &lt;DataModel name="Ping"&gt;
    &lt;Choice&gt;
      &lt;String name="PingPingStr" value="PINGPING" token="true" /&gt;
      &lt;String name="PingStr" value="PING" token="true"/&gt;
    &lt;/Choice&gt;
  &lt;/DataModel&gt;

  &lt;DataModel name="Pong"&gt;
    &lt;String value="PONG" /&gt;
  &lt;/DataModel&gt;

  &lt;DataModel name="PongPong"&gt;
    &lt;String value="PONGPONG" /&gt;
  &lt;/DataModel&gt;

  &lt;StateModel name="TheStateModel" initialState="InitialState"&gt;
    &lt;State name="InitialState"&gt;

      &lt;Action type="accept" /&gt;

      &lt;Action type="input"&gt;
        &lt;DataModel ref="Ping"/&gt;
      &lt;/Action&gt;

      &lt;!-- Switch states only when input was PINGPING --&gt;
      &lt;Action type="changeState" ref="PongPongBack"
        when="state.actions[1].dataModel.find('PingPingStr') != None" /&gt;

      &lt;Action type="output"&gt;
        &lt;DataModel ref="Pong"/&gt;
      &lt;/Action&gt;

    &lt;/State&gt;

    &lt;!-- This state is only reached when input was PINGPING --&gt;
    &lt;State name="PongPongBack"&gt;

      &lt;Action type="output"&gt;
        &lt;DataModel ref="PongPong"/&gt;
      &lt;/Action&gt;

    &lt;/State&gt;

  &lt;/StateModel&gt;

  &lt;Test name="Default"&gt;
    &lt;StateModel ref="TheStateModel"/&gt;
    &lt;Publisher class="TcpListener"&gt;
      &lt;Param name="Interface" value="0.0.0.0" /&gt;
      &lt;Param name="Port" value="31337" /&gt;
      &lt;Param name="AcceptTimeout" value="10000" /&gt;
      &lt;Param name="Timeout" value="10000" /&gt;
    &lt;/Publisher&gt;

    &lt;Logger class="File" &gt;
      &lt;Param name="Path" value="logs"/&gt;
      &lt;/Logger&gt;
  &lt;/Test&gt;
&lt;/Peach&gt;</programlisting>
</example>
<example>
<title>Loop Using Iteration State Bag</title>
<simpara>This example uses the iteration state bag to simulate a for loop.</simpara>
<screen>&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Peach xmlns="http://peachfuzzer.com/2012/Peach"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"&gt;

  &lt;DataModel name="TheDataModel"&gt;
    &lt;String value="Looping!\n" /&gt;
  &lt;/DataModel&gt;

  &lt;StateModel name="State" initialState="Initial"&gt;
    &lt;State name="Initial"&gt;

	  &lt;!-- Initialize our counter --&gt;
	  &lt;Action type="changeState" ref="Loop" onStart="context.iterationStateStore['count'] = 0" /&gt;

	&lt;/State&gt;

	&lt;State name="Loop"&gt;

	  &lt;!-- onComplete will increment counter --&gt;
      &lt;Action type="output" onComplete="context.iterationStateStore['count'] = context.iterationStateStore['count'] + 1"&gt;
        &lt;DataModel ref="TheDataModel" /&gt;
      &lt;/Action&gt;

	  &lt;!-- Loop until our counter is greater than 3 --&gt;
	  &lt;Action type="changeState" ref="Loop" when="context.iterationStateStore['count'] &amp;lt; 3" /&gt;

    &lt;/State&gt;

  &lt;/StateModel&gt;

  &lt;Test name="Default"&gt;
    &lt;StateModel ref="State"/&gt;

    &lt;Publisher class="Console"/&gt;  &lt;/Test&gt;

&lt;/Peach&gt;</screen>
<screen>&gt; peach -1 --debug example.xml

[*] Test 'Default' starting with random seed 28742.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.ChangeState
Peach.Core.Dom.Action Changing to state: Loop
Peach.Core.Dom.StateModel Run(): Changing to state "Loop".
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher start()
Peach.Core.Publishers.ConsolePublisher open()
Peach.Core.Publishers.ConsolePublisher output(9 bytes)
Looping!                                                                     <co xml:id="CO70-1"/>
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.ChangeState
Peach.Core.Dom.Action Changing to state: Loop
Peach.Core.Dom.StateModel Run(): Changing to state "Loop".
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher output(9 bytes)
Looping!                                                                     <co xml:id="CO70-2"/>
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.ChangeState
Peach.Core.Dom.Action Changing to state: Loop
Peach.Core.Dom.StateModel Run(): Changing to state "Loop".
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher output(9 bytes)
Looping!                                                                     <co xml:id="CO70-3"/>
Peach.Core.Dom.Action Run: action 'Action_1' when returned false             <co xml:id="CO70-4"/>
Peach.Core.Publishers.ConsolePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.ConsolePublisher stop()

[*] Test 'Default' finished.</screen>
<calloutlist>
<callout arearefs="CO70-1">
<para>Output from iteration 1</para>
</callout>
<callout arearefs="CO70-2">
<para>Output from iteration 2</para>
</callout>
<callout arearefs="CO70-3">
<para>Output from iteration 3</para>
</callout>
<callout arearefs="CO70-4">
<para><emphasis>when</emphasis> expression returning false causing exit from loop</para>
</callout>
</calloutlist>
</example>
</section>
</section>
<section xml:id="xpath">
<title>xpath</title>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
</section>
<section xml:id="Extending">
<title>Extending Peach</title>
<simpara>Peach Fuzzer Professional was designed to be extended,
allowing you to increase Peach&#8217;s capabilities.
The most common reasons for extending Peach include:</simpara>
<itemizedlist>
<listitem>
<simpara>Custom validation algorithms (such as checksums)</simpara>
</listitem>
<listitem>
<simpara>Custom publishers (I/O adapters)</simpara>
</listitem>
<listitem>
<simpara>Monitoring</simpara>
</listitem>
</itemizedlist>
<simpara>Peach can use custom implementations of the following to extend its functionality:</simpara>
<itemizedlist>
<listitem>
<simpara><link linkend="Agent">Agents</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="Analyzers">Analyzers</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="Fixup">Fixups</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="Logger">Loggers</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="Monitors">Monitors</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="Publisher">Publishers</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="Transformer">Transformers</link></simpara>
</listitem>
</itemizedlist>
<simpara>All extensions follow the same paradigm:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Create a C# class that derives from the appropriate Peach base class.</simpara>
</listitem>
<listitem>
<simpara>Decorate the class with the appropriate plugin attribute.</simpara>
</listitem>
<listitem>
<simpara>Compile the class into an assembly and place the assembly in the Plugins directory.</simpara>
</listitem>
</orderedlist>
<simpara>This section covers the most common types of extensions for Peach.</simpara>
<section xml:id="Extend_Plugins">
<title>Peach Plug-ins</title>
<simpara>If your target has something in its data model that Peach does not support
(like a custom checksum algorithm or a custom data format),
you may need to extend Peach&#8217;s functionality by using Peach plugins.</simpara>
<simpara>Peach plugins are either C# class libraries or python files that implement C# classes.
Custom Peach plugins should be placed in the <literal>Plugins</literal> subdirectory of the Peach installation folder.
When Peach starts it scans all <literal>.dll</literal> and <literal>.py</literal> files in the folder looking for plugins.</simpara>
<simpara>To see a list of all detected plugins and their parameters, run <literal>peach --showenv</literal>.</simpara>
<simpara>All Peach plugins take a C# dictionary as a construction argument.
This argument dictionary is populated with the Param elements names and values defined in the Peach Pit.</simpara>
<simpara>Peach plugins use ParameterAttribute to define all of their supported configuration arguments (name, type, description, and optional default value).</simpara>
<itemizedlist>
<listitem>
<simpara>The name and type specified in the ParameterAttribute must match a public property on the plugin class.</simpara>
</listitem>
<listitem>
<simpara>If the name parameter happens to be a C# reserved keyword, prefix the associated class property with an underscore.</simpara>
</listitem>
<listitem>
<simpara>The default value is always given as a string, regardless of the type of the parameter.</simpara>
</listitem>
</itemizedlist>
<note>
<simpara>If the default value is omitted from the ParameterAttribute, Peach treats the parameter as required.</simpara>
</note>
<simpara>ParameterParser.Parse() uses the arguments dictionary to automatically populate all plugin properties.</simpara>
<itemizedlist>
<listitem>
<simpara>When populating the properties, type conversion converts the string specified in the pit to the concrete type defined in the plugin.</simpara>
</listitem>
<listitem>
<simpara>When performing automatic type conversion, the ParameterParser supports System.Enum as well as any type that implements IConvertible.</simpara>
</listitem>
</itemizedlist>
<simpara>This method uses reflection to:</simpara>
<itemizedlist>
<listitem>
<simpara>Enforce missing required parameters.</simpara>
</listitem>
<listitem>
<simpara>Initialize optional parameters from default values.</simpara>
</listitem>
<listitem>
<simpara>Convert types from string to a concrete type.</simpara>
</listitem>
<listitem>
<simpara>Validate all type conversions</simpara>
<itemizedlist>
<listitem>
<simpara>-100 is valid int.</simpara>
</listitem>
<listitem>
<simpara>-100 is not a valid byte.</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
<simpara>General Peach plugin best practices:</simpara>
<itemizedlist>
<listitem>
<simpara>Use stream operations whenever possible.</simpara>
</listitem>
<listitem>
<simpara>Avoid using large arrays of contiguous data.</simpara>
</listitem>
<listitem>
<simpara>Validate parameter types in the plugin constructors.</simpara>
</listitem>
<listitem>
<simpara>Provide useful error messages.</simpara>
</listitem>
<listitem>
<simpara>Throw PeachException() when non-recoverable errors occur such as:</simpara>
<itemizedlist>
<listitem>
<simpara>A parameter is out of range.</simpara>
</listitem>
<listitem>
<simpara>A user lacks appropriate permissions.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Throw SoftException when recoverable errors occur such as:</simpara>
<itemizedlist>
<listitem>
<simpara>A file is in use.</simpara>
</listitem>
<listitem>
<simpara>An error occurs when starting a process.</simpara>
</listitem>
<listitem>
<simpara>A socket connection is refused.</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
<section xml:id="_examples_205">
<title>Examples</title>
<example>
<title>Transformer</title>
<simpara>This example shows the arguments in the JsEncode transformer constructor.</simpara>
<programlisting language="java" linenumbering="unnumbered">[Transformer("JsEncode")]
public class JsEncode : Transformer
{
	public JsEncode(Dictionary&lt;string, Variant&gt; args)
		: base(args)
	{
	}
}</programlisting>
</example>
<example>
<title>Fixup</title>
<simpara>This example shows the class definition for a custom fixup called "MyFixup".</simpara>
<programlisting language="java" linenumbering="unnumbered">[Fixup("MyFixup", true)]
public class MyFixup : Peach.Core.Fixup
{
}</programlisting>
</example>
<example>
<title>ParameterAttribute</title>
<simpara>This example shows the ParameterAttribute usage.</simpara>
<programlisting language="java" linenumbering="unnumbered">[Transformer("MyTransformer")]
[Parameter("level", typeof(int), "Specifies the level, default: 9", "9")]
[Parameter("class", typeof(string), "Specifies the class, required!")]
public class MyTransformer : Transformer
{
	// Type matches typeof(int) in ParameterAttribute
	public int level { get; set; }

	// Name is '_class' since 'class' is a C# keyword
	public string _class { get; set; }

	public MyTransformer(Dictionary&lt;string, Variant&gt; args)
		: base(args)
	{
	}
}</programlisting>
</example>
<example>
<title>Transformer</title>
<simpara>This example shows the class definition for a custom transformer called "MyTransformer".</simpara>
<programlisting language="java" linenumbering="unnumbered">[Transformer("MyTransformer", true)]
public class MyTransformer : Peach.Core.Transformer
{
}</programlisting>
</example>
<example>
<title>Publisher</title>
<simpara>This example shows the class definition for a custom publisher called "MyPublisher".</simpara>
<programlisting language="java" linenumbering="unnumbered">[Publisher("MyPublisher", true)]
public class MyPublisher : Peach.Core.Publisher
{
}</programlisting>
</example>
<example>
<title>Monitor</title>
<simpara>This example shows the class definition for a custom monitor called "MyMonitor".</simpara>
<programlisting language="java" linenumbering="unnumbered">[Monitor("MyMonitor", true)]
public class MyMonitor : Peach.Core.Monitor
{
}</programlisting>
</example>
</section>
</section>
<section xml:id="Extend_Fixup">
<title>Fixup</title>
<simpara>A fixup computes a value based on one or more data elements. Since the value is
based on other elements, each fixup tracks whenever a referenced element changes so it  can recompute its value. For example, the Crc32 fixup needs to know whenever the referenced element changes, so that a new CRC can be computed.</simpara>
<simpara>Each fixup implementation needs to implement a single function: fixupImpl().
This function returns the result of the fixup computation.</simpara>
<simpara>Since fixups compute their value from other elements, each fixup must register its dependent elements with the fuzzing engine.
The tracking of dependent elements is important so that the fixup will recompute its value when any of its dependent elements are mutated.
The common convention for specifying dependent elements to a fixup is to use a <emphasis>ref</emphasis> parameter.</simpara>
<simpara>Each Fixup implementation must tell the base Fixup class which parameters refer to data elements.
This accomplished by passing the appropriate parameter names to the base fixup constructor.
Inside of fixupImpl(), the resolved data element references are obtained through the dictionary <emphasis>this.elements</emphasis>.
The key to this dictionary is the name of the parameter (eg: <emphasis>ref</emphasis>) and the value is the appropriate data element.</simpara>
<example>
<title>Fixup that references a dependent element</title>
<simpara>Consider a custom fixup that needs to MD5 an element named <emphasis>DateHeader</emphasis>.</simpara>
<simpara>First, use a <emphasis>ref</emphasis> param in the pit to tell the fixup the specific element to target.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;Fixup class="DateMd5"&gt;
  &lt;Param name="ref" value="DateHeader" /&gt;
&lt;/Fixup&gt;</programlisting>
<simpara>Second, obtain the target element in the fixupImpl().</simpara>
<programlisting language="java" linenumbering="unnumbered">protected override Variant fixupImpl()
{
  // Find the element specified in the 'ref' parameter
  var dateHeaderElement = this.elements["ref"];
  // Compute the MD5 of said element's value
  return MD5(dateHeaderElement.Value);
}</programlisting>
</example>
<simpara>It is important to maintain the element type information when returning results from a fixup.
The data element type returned by the fixup should match the data element type of the resulting field; the only exception is a string that can be the resulting field when the fixup element inputs a number.</simpara>
<simpara>If the fixup evaluates to an integer, an int type should be returned.  Similarly, if the fixup evaluates to a string, a string type should be returned. This allows Peach to perform proper byte encoding when creating the final value for a data element.</simpara>
<simpara>Because the Crc fixup returns its value in an unsigned integer type, Peach outputs the bytes in the endianness defined on the parent data element.</simpara>
<section xml:id="_examples_206">
<title>Examples</title>
<example>
<title>Single data element</title>
<simpara>This is an example of a fixup with a single data element reference.</simpara>
<programlisting language="java" linenumbering="unnumbered">[Fixup("CustomFixupOne", true)]
[Parameter("ref", typeof(string), "Reference to data element")]
[Serializable]
public class CustomFixupOne : Fixup
{
	public CustomFixupThree(DataElement parent, Dictionary&lt;string, Variant&gt; args)
		: base(parent, args, "ref")
	{
	}
}</programlisting>
</example>
<example>
<title>Multi-data element</title>
<simpara>This is an example of a fixup with three data element references.</simpara>
<programlisting language="java" linenumbering="unnumbered">[Fixup("CustomFixupThree", true)]
[Parameter("refOne", typeof(string), "Reference to first data element")]
[Parameter("refTwo", typeof(string), "Reference to second data element")]
[Parameter("refThree", typeof(string), "Reference to third data element")]
[Serializable]
public class CustomFixupThree : Fixup
{
	public CustomFixupThree(DataElement parent, Dictionary&lt;string, Variant&gt; args)
		: base(parent, args, "refOne", "refTwo", "refThree")
	{
	}
}</programlisting>
</example>
<example>
<title>fixupImpl function</title>
<simpara>This is an example of the fixupImpl function of a Crc fixup.</simpara>
<programlisting language="java" linenumbering="unnumbered">protected override Variant fixupImpl()
{
	// Get the element we need to compute the CRC of
	var elem = this.elements["ref"];
	// Get the stream of data for the target element
	var data = elem.Value;

	// Ensure we are at the beginning of the data
	data.Seek(0, System.IO.SeekOrigin.Begin);

	// Initialize the CRCTool
	CRCTool crcTool = new CRCTool();
	crcTool.Init(CRCTool.CRCCode.CRC32);

	// Return the CRC of data as a uint
	return new Variant((uint)crcTool.crctablefast(data));
}</programlisting>
</example>
</section>
</section>
<section xml:id="Extend_Monitor">
<title>Monitor</title>
<simpara>Custom monitors must implement the following functions:</simpara>
<itemizedlist>
<listitem>
<simpara>StopMonitor()</simpara>
</listitem>
<listitem>
<simpara>SessionStarting()</simpara>
</listitem>
<listitem>
<simpara>SessionFinished()</simpara>
</listitem>
<listitem>
<simpara>IterationStarting()</simpara>
</listitem>
<listitem>
<simpara>IterationFinished()</simpara>
</listitem>
<listitem>
<simpara>DetectedFault()</simpara>
</listitem>
<listitem>
<simpara>GetMonitorData()</simpara>
</listitem>
<listitem>
<simpara>MustStop()</simpara>
</listitem>
<listitem>
<simpara>Message()</simpara>
</listitem>
</itemizedlist>
<simpara>The SessionStarting and SessionFinished functions are called once per fuzzing session.
These functions are responsible for any initialization and cleanup required by the monitor.
Monitors can run remotely and multiple monitors can be defined in a Peach pit.
It is possible that calling SessionStarting on the first monitor
triggers some behavior on the target that allows subsequent monitors to be able to start without error.
This means things like parameter validation and initialization should occur in the SessionStarting function
as opposed to the monitor&#8217;s constructor.</simpara>
<simpara>The IterationStarting and IterationFinished functions are called once per fuzzing iteration.
All per-iteration logic is implemented in these functions.
Monitors that perform per-iteration process control will start and stop the target process in these functions.
Most importantly, any per-iteration state must be reset in calls to IterationFinished().
The current fuzzing iteration is driven by the Peach engine, and monitors must not use past iterations to make any
assumptions about future iterations.</simpara>
<simpara>The Message function is used to signal monitors at specific places in the StateModel execution.
This functionality is primarily used for state synchronization.
It allows the monitor to pause the execution of the StateModel at a specific point until some desired event happens.
For example, a custom monitor could use the Message function to wait until a proprietary embedded device
has rebooted and is ready to accept input data.</simpara>
<simpara>It is important to note that call actions on the "Peach.Agent" publisher result in
the Message function being called on every monitor. Each monitor must filter for
their desired messages, ignoring all unexpected message calls by returning null.</simpara>
<simpara>The DetectedFault and GetMonitorData functions are used to report faults back to
Peach. At the end of each iteration, the Peach engine calls DetectedFault() on
every monitor. If any monitor reports that a fault occurred, Peach calls
GetMonitorData() on every monitor. The GetMonitorData function returns a Fault record, and the type of the record can be either Fault or Data.</simpara>
<simpara>Fault Detection:</simpara>
<itemizedlist>
<listitem>
<simpara>Return true from DetectedFault().</simpara>
</listitem>
<listitem>
<simpara>Any monitor that detects a fault causes Peach to call ALL monitors to return monitor data.</simpara>
</listitem>
<listitem>
<simpara>GetMonitorData() returns applicable data.</simpara>
</listitem>
<listitem>
<simpara>Returned fault can be <literal>fault</literal> or <literal>data</literal>.</simpara>
<itemizedlist>
<listitem>
<simpara>Debugger stack trace is <literal>fault</literal>.</simpara>
</listitem>
<listitem>
<simpara>Network packet capture is <literal>data</literal>.</simpara>
</listitem>
<listitem>
<simpara>Log file is <literal>data</literal>.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Faults can include a hash for bucketing information.</simpara>
</listitem>
</itemizedlist>
<simpara>Monitor best practices:</simpara>
<itemizedlist>
<listitem>
<simpara>Indicate errors with SoftExceptions().</simpara>
</listitem>
<listitem>
<simpara>Keep monitors simple.</simpara>
</listitem>
<listitem>
<simpara>Prefer multiple small monitors.</simpara>
</listitem>
<listitem>
<simpara>Agent/Monitor order within a pit is honored by Peach.</simpara>
<itemizedlist>
<listitem>
<simpara>Starting functions are called in order.</simpara>
</listitem>
<listitem>
<simpara>Finished functions are called in reverse order.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Avoid one large complicated monitor.</simpara>
</listitem>
<listitem>
<simpara>Remember monitors can run in remote agents.</simpara>
</listitem>
<listitem>
<simpara>Maintain cross platform compatibility.</simpara>
<itemizedlist>
<listitem>
<simpara>Windows Peach with Linux Agent.</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</section>
<section xml:id="Extend_Publisher">
<title>Publisher</title>
<simpara>Publishers need to be extended whenever Peach needs to send or receive data through a custom IO channel.
Publishers support both a <emphasis>stream</emphasis> view (open, input, output, close) and a <emphasis>function</emphasis> view (call, setProperty, getProperty).
Each publisher method corresponds to a single action type used in the StateModel.
While publishers can support all action types, most do not need to.  For example, the File publisher does not
implement call, accept, setProperty and getProperty.
It is up to the developer to implement the appropriate set of functions.</simpara>
<simpara>All of the publisher&#8217;s public functions are implemented in the base class.
The public functions ensure the publisher is in the proper state and
that they call the protected implementation functions when needed. For example, the public open function
calls the protected OnOpen function only when the publisher is not open.
When developers implement custom publishers, they override the protected functions.
The default implementation of these protected functions is to throw a NotImplementedException().</simpara>
<simpara>The list of functions that users may override are:</simpara>
<itemizedlist>
<listitem>
<simpara>OnStart()</simpara>
</listitem>
<listitem>
<simpara>OnStop()</simpara>
</listitem>
<listitem>
<simpara>OnOpen()</simpara>
</listitem>
<listitem>
<simpara>OnClose()</simpara>
</listitem>
<listitem>
<simpara>OnAccept()</simpara>
</listitem>
<listitem>
<simpara>OnInput()</simpara>
</listitem>
<listitem>
<simpara>OnOutput()</simpara>
</listitem>
<listitem>
<simpara>OnCall()</simpara>
</listitem>
<listitem>
<simpara>OnSetProperty()</simpara>
</listitem>
<listitem>
<simpara>OnGetProperty()</simpara>
</listitem>
</itemizedlist>
<simpara>The OnStart and OnStop functions perform initialization and teardown.
These functions are normally called once per test.
The Peach engine automatically calls stop on all publishers when the test
completes. The OnOpen and OnClose functions control access to the underlying resource.
These functions are normally called once per iteration.
The Peach engine automatically calls close on all publishers when each iteration completes.</simpara>
<simpara>The OnOutput function writes all the provided data to the underlying resource.
The data is provided in a stream, and it is best to write the data to the resource one block at a time instead of making a single large contiguous buffer.
If the underlying resource only consumes data in a single contiguous buffer, it is best to have a configurable maximum size and truncate data that exceeds it.</simpara>
<simpara>The OnInput function tells the publisher to read data from the underlying resource.
The data is then stored internally in a seek-able stream and used by Peach for cracking the data model.
If the underlying resource already provides a seek-able stream (eg: a file stream) then OnInput doesn&#8217;t have to do anything.
However, for publishers like Udp, the OnInput function causes the next packet to be received.
When implementing the OnInput function for publishers that block, it is best to expose a user configurable input timeout.
If no data is received from the underlying resource after the timeout interval, a SoftException() should be thrown to
indicate to the Peach engine that the action did not complete successfully.</simpara>
<simpara>To assist developers in quickly writing publishers, Peach comes with two helper classes: StreamPublisher and BufferedStreamPublisher.
Both of these classes make it easy to quickly write publishers for IO interfaces that already implement the C# System.IO.Stream interface.</simpara>
<itemizedlist>
<listitem>
<simpara>StreamPublisher is used when the underlying stream supports the Seek() function (eg: file streams). To use the StreamPublisher, the developer only needs to override OnOpen() and set the <emphasis>this.stream</emphasis> property.</simpara>
</listitem>
<listitem>
<simpara>BufferedStreamPublisher is used when the underlying stream does not support the Seek() function (eg: TCP Streams, SerialPort). The BufferedStreamPublisher automatically performs asynchronous reads on the underlying stream, and buffers the accumulated data in a seek-able stream.</simpara>
<simpara>To use the BufferedStreamPublisher, the developer needs to do two things.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Override OnOpen() and set this._client to the System.IO.Stream and call the StartClient() function.</simpara>
</listitem>
<listitem>
<simpara>If extra cleanup code is required other than simply closing the stream,
the developer needs to override ClientClose() and clean up any additional resources acquired during OnOpen().</simpara>
</listitem>
</orderedlist>
</listitem>
</itemizedlist>
<simpara>An example of a File publisher deriving from StreamPublisher.</simpara>
<programlisting language="java" linenumbering="unnumbered">[Publisher("File", true)]
[Publisher("FileStream")]
[Publisher("file.FileWriter")]
[Publisher("file.FileReader")]
[Parameter("FileName", typeof(string), "Name of file to open for reading/writing")]
[Parameter("Overwrite", typeof(bool), "Replace existing file? [true/false, default true]", "true")]
[Parameter("Append", typeof(bool), "Append to end of file [true/false, default false]", "false")]
public class FilePublisher : StreamPublisher
{
	private static NLog.Logger logger = LogManager.GetCurrentClassLogger();
	protected override NLog.Logger Logger { get { return logger; } }

	public string FileName { get; set; }
	public bool Overwrite { get; set; }
	public bool Append { get; set; }

	private FileMode fileMode = FileMode.OpenOrCreate;

	public FilePublisher(Dictionary&lt;string, Variant&gt; args)
		: base(args)
	{
		if (Overwrite &amp;&amp; Append)
			throw new PeachException("File publisher does not support Overwrite and Append being enabled at once.");
		else if (Overwrite)
			fileMode = FileMode.Create;
		else if (Append)
			fileMode = FileMode.Append | FileMode.OpenOrCreate;
		else
			fileMode = FileMode.OpenOrCreate;
	}

	protected override void OnOpen()
	{
		stream = System.IO.File.Open(FileName, FileMode);
	}
}</programlisting>
<simpara>An example of a Serial publisher deriving from BufferedStreamPublisher.</simpara>
<programlisting language="java" linenumbering="unnumbered">[Publisher("SerialPort", true)]
[Parameter("PortName", typeof(string), "Com interface for the device to connect to")]
[Parameter("Baudrate", typeof(int), "The serial baud rate.")]
[Parameter("Parity", typeof(Parity), "The parity-checking protocol.")]
[Parameter("DataBits", typeof(int), "Standard length of data bits per byte.")]
[Parameter("StopBits", typeof(StopBits), "The standard number of stop bits per byte.")]
public class SerialPortPublisher : BufferedStreamPublisher
{
    private static NLog.Logger logger = LogManager.GetCurrentClassLogger();
    protected override NLog.Logger Logger { get { return logger; } }

    public string PortName { get; protected set; }
    public int Baudrate { get; protected set; }
    public Parity Parity { get; protected set; }
    public int DataBits { get; protected set; }
    public StopBits StopBits { get; protected set; }

    protected SerialPort _serial;

    public SerialPortPublisher(Dictionary&lt;string, Variant&gt; args)
        : base(args)
    {
    }

    protected override void OnOpen()
    {
        base.OnOpen();

        try
        {
            _serial = new SerialPort(PortName, Baudrate, Parity, DataBits, StopBits);
            _serial.Handshake = Handshake;
            _serial.DtrEnable = DtrEnable;
            _serial.RtsEnable = RtsEnable;
            _serial.Open();
            // Set _clientName so logs from the base class are pretty
            _clientName = _serial.PortName;
            // Set _client to use for async IO
            _client = _serial.BaseStream;
        }
        catch (Exception ex)
        {
            string msg = "Unable to open Serial Port {0}. {1}.".Fmt(PortName, ex.Message);
            Logger.Error(msg);
            throw new PeachException(msg, ex);
        }

        // Start the async read operations
        StartClient();
    }

    protected override void ClientClose()
    {
        base.ClientClose();

        // No custom closing required
        _serial = null;
    }
}</programlisting>
<simpara>Some Publishers use the Function view metaphor (call, setProperty, getProperty). For this type of Publisher, sharing information occurs by implementing properties of the publisher that other parts of the Peach can access. For example, the StateModel or a script could make use of the ports that a Publisher uses, as in the following example.</simpara>
<note>
<simpara>Remote agents can host Publishers; therefore, Publishers should not directly use the IterationStateStore bag.</simpara>
</note>
<simpara>An example of a Serial publisher deriving from BufferedStreamPublisher.</simpara>
<programlisting language="java" linenumbering="unnumbered">    protected override Variant OnGetProperty(string property)
    {
        switch(property)
        {
            case "Port":
                return new Variant(Port);
           case "SrcPort":
                return new Variant(SrcPort);
        }
        return base.OnGetProperty(property);
    }</programlisting>
<simpara>The property is then accessible in the state model using the getProperty action, or using a script as in the following:</simpara>
<programlisting language="java" linenumbering="unnumbered">Port = int(context.test.publishers[0].getProperty(Port))</programlisting>
</section>
<section xml:id="Extend_Transformer">
<title>Transformer</title>
<simpara>Peach includes support for common encoding transformations such as encryption and compression.
Custom transformers are used whenever the target requires special encoding of the data not included with Peach.
Custom transformer implementations must implement two functions: internalEncode and internalDecode.</simpara>
<simpara>Peach calls the internalEncode function when outputting data to a publisher.
Inside this function, the provided source data of the parent data element is transformed into a new stream and the new stream is returned to Peach.
For example, the AES transformer&#8217;s implementation of this function encrypts the source data and returns the encrypted data.</simpara>
<simpara>Peach calls the internalDecode function when cracking input data into the transformer&#8217;s parent data element.
This function call results from an input action or from a DataSet being applied.
The internalDecode function is given a stream of encoded data.
The function performs the necessary decoding logic and returns a new stream of decoded data.
The decoded data is then used by the transformer&#8217;s parent element for cracking.
For example, the AES transformer&#8217;s implementation of this function decrypts the source data and returns the decrypted data.</simpara>
</section>
<section xml:id="Extend_Mutator">
<title>Mutator</title>
<simpara>Peach includes mutators for common data types and patterns.  Occasionally it is necessary
to extend the mutation capabilities with a custom mutator.  Custom mutators follow a similar pattern
to all other Peach plug-ins, implement a class that derives from the base class,  Peach.Core.Mutator class, and
decorate the class with a MutatorAttribute.</simpara>
<simpara>In order for Peach to select a mutator when fuzzing, every mutator must implement a static supportedDataElement function.
This function gets called with every data element in the DOM and returns true
if the mutator can mutate the data element.</simpara>
<simpara>An example of the supportedDataElement function for a string mutator.</simpara>
<programlisting language="java" linenumbering="unnumbered">public new static bool supportedDataElement(DataElement obj)
{
	if (obj is Dom.String &amp;&amp; obj.isMutable)
		return true;

	return false;
}</programlisting>
<simpara>When the Peach engine determines that a mutator is capable of mutating a data element, an instance of the mutator class is created for each supported data element.
Once Peach creates all of the mutator instances, each mutator needs to provide the number of mutations that can be performed.
The supported mutation count is provided with the <emphasis>count</emphasis> property.</simpara>
<simpara>Each mutator implements two functions for performing the actual mutation: sequentialMutation and randomMutation.
These functions correspond to the type of mutation strategy defined in the Peach pit.
When the Peach configuration uses the Random strategy, the randomMutation function performs mutations.
When the Peach configuration uses the Sequential strategy, the mutator&#8217;s <emphasis>mutation</emphasis> attribute will be set to the desired value (between 0 and count) and the sequentialMutation function performs mutations.</simpara>
<simpara>When picking random numbers inside the mutator, it is important to use the random number generator provided by the mutation strategy.
Mutators access the random number generator with the <emphasis>this.context.Random</emphasis> variable.
The mutation strategy guarantees that the random number generator is different across different fuzzing iterations.
Additionally, the mutation strategy guarantees the random number generator is identical for the same iterations.
This allows Peach to produce identical mutations when replaying the same fuzz iteration to reproduce faults or when re-running a test of the same seed at a future date.</simpara>
<simpara>An example of a string mutator that mutates string elements with the values "Hello", "World" or "Hello World".</simpara>
<programlisting language="java" linenumbering="unnumbered">[Mutator("StringMutator")]
[Description("Replace strings with hello world")]
public class HelloWorldMutator : Peach.Core.Mutator
{
	uint pos = 0;
	static string[] values = new string[] { "Hello", "World", "Hello World" };

	public StringMutator(DataElement obj)
	{
		pos = 0;
		name = "HelloWorldMutator";
	}

	public new static bool supportedDataElement(DataElement obj)
	{
		if (obj is Dom.String &amp;&amp; obj.isMutable)
			return true;

		return false;
	}

	public override int count
	{
		get { return values.Length; }
	}

	public override uint mutation
	{
		get { return pos; }
		set { pos = value; }
	}

	public override void sequentialMutation(DataElement obj)
	{
		obj.mutationFlags = MutateOverride.Default;
		obj.MutatedValue = new Variant(values[pos]);
	}

	public override void randomMutation(DataElement obj)
	{
		obj.mutationFlags = MutateOverride.Default;
		obj.MutatedValue = new Variant(this.context.Random.Choice&lt;string&gt;(values));
	}
}</programlisting>
<simpara>In order for Peach to select a mutator when fuzzing, every mutator must implement a static supportedDataElement function.
This function is called with every data element in the DOM and returns true
if the mutator can mutate the data element.</simpara>
<simpara>An example of the supportedDataElement function for a string mutator.</simpara>
<programlisting language="java" linenumbering="unnumbered">public new static bool supportedDataElement(DataElement obj)
{
	if (obj is Dom.String &amp;&amp; obj.isMutable)
		return true;

	return false;
}</programlisting>
</section>
<section xml:id="Extend_Agent">
<title>Agent</title>
<simpara>Custom agents are useful when the target system does not support a .NET runtime (like Mono) or the device is too slow (speed is a common problem for embedded devices that require running a native agent in C/C++).</simpara>
<simpara>Agents in Peach communicate over protocols called channels.  While you can develop custom channel protocols, an existing channel usually creates a custom Peach agent. Agents can be written in any language; To make it easy to author your own, Peach comes with some example implementations designed for languages like as Python and C++. The REST based protocol (which transmits data in JSON messages) is the easiest channel protocol to use with custom agents.</simpara>
<simpara>When you write a custom publisher, we recommend you start with one of the examples in the SDK and extend it to meet your requirements. The examples in the SDK already implement the agent channel protocol with stub methods ready to be implemented. If this is not an option, the following example channel sessions can be used as documentation for the protocol. The second example includes the use of a remote publisher.</simpara>
<example>
<title>Sample session</title>
<simpara>This example shows a complete agent session using the REST JSON agent channel (protocol prefix <emphasis>http</emphasis>) with matching pit.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;Agent name="TheAgent" location="http://127.0.0.1:9980"&gt;
	&lt;Monitor class="WindowsDebugger"&gt;
		&lt;Param name="Executable" value="mspaint.exe" /&gt;
		&lt;Param name="Arguments" value="fuzzed.png" /&gt;
		&lt;Param name="WinDbgPath" value="C:\Program Files (x86)\Debugging Tools for Windows (x86)" /&gt;
		&lt;Param name="StartOnCall" value="ScoobySnacks"/&gt;
	&lt;/Monitor&gt;
	&lt;Monitor class="PageHeap"&gt;
		&lt;Param name="Executable" value="mspaint.exe"/&gt;
		&lt;Param name="WinDbgPath" value="C:\Program Files (x86)\Debugging Tools for Windows (x86)" /&gt;
	&lt;/Monitor&gt;
&lt;/Agent&gt;

&lt;Test name="Default"&gt;
	&lt;Agent ref="TheAgent"/&gt;
	&lt;StateModel ref="TheState"/&gt;

	&lt;Publisher class="File"&gt;
		&lt;Param name="FileName" value="fuzzed.png"/&gt;
	&lt;/Publisher&gt;

&lt;/Test&gt;</programlisting>
<programlisting language="java" linenumbering="unnumbered">GET /Agent/AgentConnect
&lt;&lt; { "Status":"true" }

POST /Agent/StartMonitor?name=Monitor_0&amp;cls=WindowsDebugger
&gt;&gt; {"args":{"Executable":"mspaint.exe,"Arguments":"fuzzed.png","WinDbgPath":"C:\\Program Files (x86)\\Debugging Tools for Windows (x86)","StartOnCall":"ScoobySnacks"}}
&lt;&lt; { "Status":"true" }

POST /Agent/StartMonitor?name=Monitor_1&amp;cls=PageHeap
&gt;&gt; {"args":{"Executable":"mspaint.exe","WinDbgPath":"C:\\Program Files (x86)\\Debugging Tools for Windows (x86)"}}
&lt;&lt; { "Status":"true" }

GET /Agent/SessionStarting
&lt;&lt; { "Status":"true" }

GET /Agent/IterationStarting?iterationCount=1&amp;isReproduction=False
&lt;&lt; { "Status":"true" }

GET /Agent/IterationFinished
&lt;&lt; { "Status":"true" }

GET /Agent/DetectedFault
&lt;&lt; { "Status":"true" }
// Status of true indicates a fault was detected. False for no fault.

GET /Agent/GetMonitorData
&lt;&lt; {
	"Results":[
		{
			"iteration":0,
			"controlIteration":false,
			"controlRecordingIteration":false,
			"type":0,  (0 unknown, 1 Fault, 2 Data)
			"detectionSource":null,
			"title":null,
			"description":null,
			"majorHash":null,
			"minorHash":null,
			"exploitability":null,
			"folderName":null,
			"collectedData":[
				{"Key":"data1","Value":"AA=="}
			]
		}
	]
}

GET /Agent/IterationStarting?iterationCount=1&amp;isReproduction=True
&lt;&lt; { "Status":"true" }

GET /Agent/IterationFinished
&lt;&lt; { "Status":"true" }

GET /Agent/DetectedFault
&lt;&lt; { "Status":"true" }
// Status of true indicates a fault was detected. False for no fault.

GET /Agent/GetMonitorData
&lt;&lt; {
	"Results":[
		{
			"iteration":0,
			"controlIteration":false,
			"controlRecordingIteration":false,
			"type":0,  (0 unknown, 1 Fault, 2 Data)
			"detectionSource":null,
			"title":null,
			"description":null,
			"majorHash":null,
			"minorHash":null,
			"exploitability":null,
			"folderName":null,
			"collectedData":[
				{"Key":"data1","Value":"AA=="}
			]
		}
	]
}

GET /Agent/Publisher/stop
&lt;&lt; { "Status":"true" }

GET /Agent/SessionFinished
&lt;&lt; { "Status":"true" }

GET /Agent/StopAllMonitors
&lt;&lt; { "Status":"true" }

GET /Agent/AgentDisconnect
&lt;&lt; { "Status":"true" }</programlisting>
</example>
<example>
<title>Sample session with remote publisher</title>
<simpara>This example shows the channel messages when a remote publisher is in use.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;Agent name="TheAgent" location="http://127.0.0.1:9980"&gt;
	&lt;Monitor class="WindowsDebugger"&gt;
		&lt;Param name="Executable" value="mspaint.exe" /&gt;
		&lt;Param name="Arguments" value="fuzzed.png" /&gt;
		&lt;Param name="WinDbgPath" value="C:\Program Files (x86)\Debugging Tools for Windows (x86)" /&gt;
		&lt;Param name="StartOnCall" value="ScoobySnacks"/&gt;
	&lt;/Monitor&gt;
	&lt;Monitor class="PageHeap"&gt;
		&lt;Param name="Executable" value="mspaint.exe"/&gt;
		&lt;Param name="WinDbgPath" value="C:\Program Files (x86)\Debugging Tools for Windows (x86)" /&gt;
	&lt;/Monitor&gt;
&lt;/Agent&gt;

&lt;Test name="Default"&gt;
	&lt;Agent ref="TheAgent"/&gt;
	&lt;StateModel ref="TheState"/&gt;

	&lt;Publisher class="Remote"&gt;
		&lt;Param name="Agent" value="TheAgent"/&gt;
		&lt;Param name="Class" value="File"/&gt;
		&lt;Param name="FileName" value="fuzzed.png"/&gt;
	&lt;/Publisher&gt;

&lt;/Test&gt;</programlisting>
<programlisting language="java" linenumbering="unnumbered">GET /Agent/AgentConnect
&lt;&lt; { "Status":"true" }

POST /Agent/StartMonitor?name=Monitor_0&amp;cls=WindowsDebugger
&gt;&gt; {"args":{"Executable":"mspaint.exe","Arguments":"fuzzed.png","WinDbgPath":"C:\\Program Files (x86)\\Debugging Tools for Windows (x86)","StartOnCall":"ScoobySnacks"}}
&lt;&lt; { "Status":"true" }

POST /Agent/StartMonitor?name=Monitor_1&amp;cls=PageHeap
&gt;&gt; {"args":{"Executable":"mspaint.exe","WinDbgPath":"C:\\Program Files (x86)\\Debugging Tools for Windows (x86)"}}
&lt;&lt; { "Status":"true" }

GET /Agent/SessionStarting
&lt;&lt; { "Status":"true" }

GET /Agent/IterationStarting?iterationCount=1&amp;isReproduction=False
&lt;&lt; { "Status":"true" }

POST /Agent/Publisher/Set_Iteration
&gt;&gt; {"iteration":1}
&lt;&lt; { "error":"false", "errorString":null }

POST /Agent/Publisher/Set_IsControlIteration
&gt;&gt; {"isControlIteration":true}
&lt;&lt; { "error":"false", "errorString":null }

POST /Agent/Publisher/Set_IsControlIteration
&gt;&gt; {"isControlIteration":true}
&lt;&lt; { "error":"false", "errorString":null }

POST /Agent/Publisher/Set_Iteration
&gt;&gt; {"iteration":1}
&lt;&lt; { "error":"false", "errorString":null }

GET /Agent/Publisher/start
&lt;&lt; { "error":"false", "errorString":null }

GET /Agent/Publisher/open
&lt;&lt; { "error":"false", "errorString":null }

POST /Agent/Publisher/output
&gt;&gt; {"data":"SGVsbG8gV29ybGQ="}
&lt;&lt; { "error":"false", "errorString":null }

GET /Agent/Publisher/close
&lt;&lt; { "error":"false", "errorString":null }

POST /Agent/Publisher/call
&gt;&gt; {"method":"ScoobySnacks","args":[{"name":"p1","data":"SGVsbG8gV29ybGQ=","type":0}]}
&lt;&lt; { "error":"false", "errorString":null }

GET /Agent/IterationFinished
&lt;&lt; { "Status":"true" }

GET /Agent/DetectedFault
&lt;&lt; { "Status":"true" }
// Status of true indicates a fault was detected. False for no fault.

GET /Agent/GetMonitorData
&lt;&lt; {
	"Results":[
		{
			"iteration":0,
			"controlIteration":false,
			"controlRecordingIteration":false,
			"type":0,  (0 unknown, 1 Fault, 2 Data)
			"detectionSource":null,
			"title":null,
			"description":null,
			"majorHash":null,
			"minorHash":null,
			"exploitability":null,
			"folderName":null,
			"collectedData":[
				{"Key":"data1","Value":"AA=="}
			]
		}
	]
}

GET /Agent/IterationStarting?iterationCount=1&amp;isReproduction=True
&lt;&lt; { "Status":"true" }

POST /Agent/Publisher/Set_Iteration
&gt;&gt; {"iteration":1}
&lt;&lt; { "error":"false", "errorString":null }

POST /Agent/Publisher/Set_IsControlIteration
&gt;&gt; {"isControlIteration":true}
&lt;&lt; { "error":"false", "errorString":null }

POST /Agent/Publisher/Set_IsControlIteration
&gt;&gt; {"isControlIteration":true}
&lt;&lt; { "error":"false", "errorString":null }

POST /Agent/Publisher/Set_Iteration
&gt;&gt; {"iteration":1}
&lt;&lt; { "error":"false", "errorString":null }

GET /Agent/Publisher/start
&lt;&lt; { "error":"false", "errorString":null }

GET /Agent/Publisher/open
&lt;&lt; { "error":"false", "errorString":null }

POST /Agent/Publisher/output
&gt;&gt; {"data":"SGVsbG8gV29ybGQ="}
&lt;&lt; { "error":"false", "errorString":null }

GET /Agent/Publisher/close
&lt;&lt; { "error":"false", "errorString":null }

POST /Agent/Publisher/call
&gt;&gt; {"method":"ScoobySnacks","args":[{"name":"p1","data":"SGVsbG8gV29ybGQ=","type":0}]}
&lt;&lt; { "error":"false", "errorString":null }

GET /Agent/IterationFinished
&lt;&lt; { "Status":"true" }

GET /Agent/DetectedFault
&lt;&lt; { "Status":"true" }
// Status of true indicates a fault was detected. False for no fault.

GET /Agent/GetMonitorData
&lt;&lt; {
	"Results":[
		{
			"iteration":0,
			"controlIteration":false,
			"controlRecordingIteration":false,
			"type":0,  (0 unknown, 1 Fault, 2 Data)
			"detectionSource":null,
			"title":null,
			"description":null,
			"majorHash":null,
			"minorHash":null,
			"exploitability":null,
			"folderName":null,
			"collectedData":[
				{"Key":"data1","Value":"AA=="}
			]
		}
	]
}

GET /Agent/Publisher/stop
&lt;&lt; { "Status":"true" }

GET /Agent/SessionFinished
&lt;&lt; { "Status":"true" }

GET /Agent/StopAllMonitors
&lt;&lt; { "Status":"true" }

GET /Agent/AgentDisconnect
&lt;&lt; { "Status":"true" }</programlisting>
</example>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="_tutorials">
<title>Tutorials</title>
<simpara>The following tutorials provide information on how to get started fuzzing with Peach.</simpara>
<itemizedlist>
<listitem>
<simpara>Beginner: <link linkend="TutorialDumbFuzzing">Dumb File Fuzzing (command line)</link></simpara>
</listitem>
<listitem>
<simpara>Beginner: <link linkend="TutorialFileFuzzing">File Fuzzing</link></simpara>
</listitem>
</itemizedlist>
<simpara><?asciidoc-pagebreak?></simpara>
<section xml:id="TutorialDumbFuzzing">
<title>Tutorial: Dumb Fuzzing</title>
<simpara>Welcome to the dumb fuzzing tutorial. In this tutorial, we are going to build a simple dumb fuzzer for PNG graphics files (.png).
Our dumb fuzzer will use several sample files (also known as seed files) to mutate using methods like bit flipping, dword slides, etc.</simpara>
<simpara>The target of this fuzzer is <literal>mspaint</literal> on Windows, <literal>feh</literal> on Linux, and <literal>Safari</literal> on OSX.</simpara>
<orderedlist numeration="arabic">
<title>Tutorial Outline</title>
<listitem>
<simpara><link linkend="TutorialDumbFuzzing_DevelopmentEnvironment">Development environment</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="TutorialDumbFuzzing_CreateDataModel">Creating the data model</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="TutorialDumbFuzzing_CreateStateModel">Creating the state model</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="TutorialDumbFuzzing_ConfigurePublisher">Configuring a publisher</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="TutorialDumbFuzzing_AgentAndMonitor">Adding an agent and monitor</link></simpara>
</listitem>
</orderedlist>
<section xml:id="TutorialDumbFuzzing_DevelopmentEnvironment">
<title>The Peach Development Environment</title>
<simpara>Before we start building our Peach fuzzer let&#8217;s first take a moment to talk about a normal Peach development environment.  Here is what a typical environment looks like:</simpara>
<section xml:id="_xml_editor">
<title>XML Editor</title>
<simpara>A good XML editor is definitely a must.  A good free XML editor for Windows is <link xl:href="http://www.microsoft.com/Express/">Microsoft Visual Studio Express</link> edition.  If you already have an XML editor that supports intelliSense via XML Schema, you&#8217;re all set.</simpara>
</section>
<section xml:id="_latest_peach">
<title>Latest Peach</title>
<simpara>Always stay up to date on the version of Peach to ensure you have the latest bug fixes.</simpara>
</section>
<section xml:id="_debugger_and_support_tools">
<title>Debugger and support tools</title>
<simpara>There are several support tools that make things work a lot nicer:</simpara>
<itemizedlist>
<listitem>
<simpara>On Windows, download the following for this lab:</simpara>
<itemizedlist>
<listitem>
<simpara><link xl:href="http://msdl.microsoft.com/download/symbols/debuggers/dbg_x86_6.8.4.0.msi">Microsoft Debugging Tools</link> (pick the latest version available)</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>On OS X, download the following for this lab:</simpara>
<itemizedlist>
<listitem>
<simpara><link xl:href="https://connect.apple.com/cgi-bin/WebObjects/MemberSite.woa/wa/getSoftware?bundleID=20390">CrashWrangler</link> (Apple Developer Connection account required)</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="TutorialDumbFuzzing_CreateDataModel">
<title>Creating Data Models</title>
<simpara>Now we are going to dive right in.  Let&#8217;s start by making a copy of <literal>template.xml</literal> (found in your Peach folder) to <literal>png.xml</literal>.  This will hold all of the information about our PNG dumb fuzzer.  Also, You want several samples PNG files; start with 10.</simpara>
<simpara>Go ahead and load up <literal>png.xml</literal> into your XML editor.</simpara>
<simpara>For our dumb fuzzer, we only need one data model to hold all the data from the PNG file.  The data model does not know anything about the PNG data structure, instead keeping all the data in a "Blob" element (binary large object or byte array).</simpara>
<section xml:id="_creating_the_datamodel">
<title>Creating the DataModel</title>
<simpara>Okay, head over to your <literal>png.xml</literal> file and let&#8217;s start writing some XML!  Locate the <link linkend="DataModel">DataModel</link> called <emphasis>TheDataModel</emphasis> is should look something like this:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;!-- TODO: Create data model --&gt;
&lt;DataModel name="TheDataModel"&gt;
&lt;/DataModel&gt;</programlisting>
<simpara>Read more about: <link linkend="DataModel">DataModel</link></simpara>
<simpara>We are going to add a single data element to our data model as follows:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;DataModel name="TheDataModel"&gt;
    &lt;Blob /&gt;
&lt;/DataModel&gt;</programlisting>
<simpara>Read more about: <link linkend="DataModel">DataModel</link>, <link linkend="Blob">Blob</link></simpara>
<simpara>Okay, that&#8217;s all we need for our data model.  The "Blob" element will end up holding all of our PNG data.</simpara>
</section>
</section>
<section xml:id="TutorialDumbFuzzing_CreateStateModel">
<title>Create State Model</title>
<simpara>Now that you have created the data model we can create the state model.  For file fuzzing, the state model is very simple.  All we want to do is write out the file and launch the target process.  We can do this using three actions:</simpara>
<itemizedlist>
<listitem>
<simpara>output&#8201;&#8212;&#8201;Write the file</simpara>
</listitem>
<listitem>
<simpara>close&#8201;&#8212;&#8201;Close the file</simpara>
</listitem>
<listitem>
<simpara>call&#8201;&#8212;&#8201;Launch the application</simpara>
</listitem>
</itemizedlist>
<simpara>Go ahead and locate the state model in the <literal>png.xml</literal> file called <emphasis>TheState</emphasis>.  We will expand on this state model to include our three actions as follows:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;!-- This is our simple png state model --&gt;
&lt;StateModel name="TheState" initialState="Initial"&gt;
	&lt;State name="Initial"&gt;

		&lt;!-- Write out our png file --&gt;
		&lt;Action type="output"&gt;
			&lt;DataModel ref="TheDataModel"/&gt;

			&lt;!-- This is our folder of sample files to read in --&gt;
			&lt;Data name="data" fileName="samples_png/*.png"/&gt;
		&lt;/Action&gt;

		&lt;Action type="close"/&gt;

		&lt;!-- Launch the target process --&gt;
		&lt;Action type="call" method="LaunchViewer" publisher="Peach.Agent"/&gt;
	&lt;/State&gt;
&lt;/StateModel&gt;</programlisting>
<simpara>Read more about: <link linkend="StateModel">StateModel</link>, <link linkend="State">State</link>, <link linkend="Action">Action</link>, <link linkend="DataModel">DataModel</link>, <link linkend="Data">Data</link></simpara>
<simpara>In the final "call" action, notice that we have configured an attribute called "publisher" with the value "Peach.Agent".
This attribute causes this action to send a "call" message to any configured Agent (see the next page) with the message "LaunchViewer".
This is how the debugger monitor knows to launch the process.</simpara>
<simpara>We are all set!  Next we just need to configure our debugger and publishers.</simpara>
</section>
<section xml:id="TutorialDumbFuzzing_ConfigurePublisher">
<title>Configure Publisher</title>
<simpara>The last thing we need to do before we can try out our nifty fuzzer is to configure a <link linkend="Publisher">Publisher</link>.
<link linkend="Publisher">Publishers</link> are I_O connectors that implement the plumbing between actions like <emphasis>output</emphasis>, <emphasis>input</emphasis>, and <emphasis>call</emphasis>.
For our file fuzzer, we will use the <link linkend="Publisher">Publisher</link> called <link linkend="Publishers_File">File</link>.
This publisher allows us to write out a file.</simpara>
<simpara>Configuring our publisher is easy, just locate the following XML near the bottom of the <literal>png.xml</literal> file;
it is a child of <link linkend="Test">Test</link>.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;!-- TODO: Complete publisher --&gt;
&lt;Publisher /&gt;</programlisting>
<simpara>Now, this publisher takes a single parameter called <emphasis>FileName</emphasis> that contains the file name of the fuzzed file.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;Publisher class="File"&gt;
	&lt;Param name="FileName" value="fuzzed.png"/&gt;
&lt;/Publisher&gt;</programlisting>
<section xml:id="_whats_next">
<title>What&#8217;s Next?</title>
<simpara>We will need to configure a way to detect when our target crashes.
We will also want to collect some information like a stack trace to look at later on.
Head to the next section to learn how to configure an agent and monitor.</simpara>
</section>
</section>
<section xml:id="TutorialDumbFuzzing_AgentAndMonitor">
<title>Agent and Monitor</title>
<simpara>Now we are ready to configure our agent and monitors.
Agents are special Peach processes that can be run locally in process or remote over a network connection.
These agents host one or more monitors that can perform such actions as attaching debuggers,
watching memory consumption, etc.
For this tutorial we are going to configure Peach to use monitors specific to each target platform.
Windows will be configured to use Microsoft WinDbg to monitor <literal>mspaint.exe</literal> for exceptions and other common issues.
Additionally on Windows we will enable the HEAP debugging for the target process.
Linux will be configured to monitor for the presence of core files.
OSX will be configured to use CrashWrangler to monitor <literal>Safari</literal> for exceptions and other common issues.</simpara>
<section xml:id="_configure_the_agent_and_monitor">
<title>Configure the Agent and Monitor</title>
<simpara>First, let&#8217;s locate the commented out <literal>Agent</literal> element in the template file, it looks something like this:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;!-- TODO: Configure agent --&gt;
&lt;Agent name="TheAgent" location="http://127.0.0.1:9000"/&gt;</programlisting>
<simpara>We are going to uncomment this section and remove the "location" attribute.
When no "location" attribute is present, Peach automatically starts a local Peach Agent.
We will configure three agents, one for Windows, one for Linux and one for OSX.
The Windows agent will be comprised of two monitors: WindowsDebugger and PageHeap.
The Linux agent will also be comprised of one monitor: Gdb.
The OSX agent will only be comprised of a single monitor: CrashWrangler.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;Agent name="WinAgent"&gt;
   &lt;Monitor class="WindowsDebugger"&gt;

        &lt;!-- The command line to run.  Notice the filename provided matched up
             to what is provided below in the Publisher configuration --&gt;
        &lt;Param name="Executable" value="mspaint.exe" /&gt;
        &lt;Param name="Arguments" value="fuzzed.png" /&gt;

        &lt;!-- This parameter will cause the debugger to wait for an action-call in
             the state model with a method="LaunchViewer" before running
             program.
        --&gt;
        &lt;Param name="StartOnCall" value="LaunchViewer" /&gt;

        &lt;!-- This parameter will cause the monitor to terminate the process
             once the CPU usage reaches zero.
        --&gt;
        &lt;Param name="CpuKill" value="true"/&gt;

    &lt;/Monitor&gt;

    &lt;!-- Enable heap debugging on our process as well. --&gt;
    &lt;Monitor class="PageHeap"&gt;
        &lt;Param name="Executable" value="mspaint.exe"/&gt;
    &lt;/Monitor&gt;

&lt;/Agent&gt;

&lt;Agent name="LinAgent"&gt;
    &lt;!-- Register for core file notifications. --&gt;
    &lt;Monitor class="Gdb"/&gt;

        &lt;!-- This is the program we're going to run inside of the debugger --&gt;
        &lt;Param name="Executable" value="feh"/&gt;

        &lt;!-- These are arguments to the executable we want to run --&gt;
        &lt;Param name="Arguments"  value="fuzzed.png"/&gt;

        &lt;!-- This parameter will cause the monitor to terminate the process
             once the CPU usage reaches zero.
        --&gt;
        &lt;Param name="CpuKill" value="true"/&gt;

&lt;/Agent&gt;

&lt;Agent name="OsxAgent"&gt;
    &lt;Monitor class="CrashWrangler"&gt;
        &lt;!-- The executable to run. --&gt;
        &lt;Param name="Command" value="/Applications/Safari.app/Contents/MacOS/Safari" /&gt;

        &lt;!-- The program arguments.  Notice the filename provided matched up
             to what is provided below in the Publisher configuration --&gt;
        &lt;Param name="Arguments" value="fuzzed.png" /&gt;

        &lt;!-- Do not use debug malloc. --&gt;
        &lt;Param name="UseDebugMalloc" value="false" /&gt;

        &lt;!-- Treat read access violations as exploitable. --&gt;
        &lt;Param name="ExploitableReads" value="true" /&gt;

        &lt;!-- Path to Crash Wrangler Execution Handler program. --&gt;
        &lt;Param name="ExecHandler" value="/usr/local/bin/exc_handler" /&gt;

        &lt;!-- This parameter will cause the monitor to wait for an action-call in
             the state model with a method="LaunchViewer" before running
             program.
        --&gt;
        &lt;Param name="StartOnCall" value="LaunchViewer" /&gt;

    &lt;/Monitor&gt;
&lt;/Agent&gt;</programlisting>
</section>
<section xml:id="_configure_test">
<title>Configure Test</title>
<simpara>Okay, now we just need to enable the agent for our test.
Head down to the <literal>Test</literal> element, specifically we are looking to uncomment this line,
and modify our Launcher publisher.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;!-- &lt;Agent ref="LocalAgent"/&gt; --&gt;</programlisting>
<simpara>Leaving us with this:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;Test name="Default"&gt;
    &lt;Agent ref="WinAgent" platform="windows"/&gt;
    &lt;Agent ref="LinAgent" platform="linux"/&gt;
    &lt;Agent ref="OsxAgent" platform="osx"/&gt;

    &lt;StateModel ref="TheState"/&gt;

    &lt;Publisher class="File"&gt;
        &lt;Param name="FileName" value="fuzzed.png"/&gt;
    &lt;/Publisher&gt;
&lt;/Test&gt;</programlisting>
</section>
<section xml:id="_configure_fuzzing_strategy">
<title>Configure Fuzzing Strategy</title>
<simpara>Since we are dumb fuzzing with multiple files, we want to change the default fuzzing strategy Peach uses to one more suited to our needs.  The best fuzzing strategy for dumb fuzzing is the random strategy.  We can configure it by adding a <literal>Strategy</literal> element to our <literal>Test</literal> section.</simpara>
<simpara>We add this:</simpara>
<programlisting language="xml" linenumbering="unnumbered">     &lt;Strategy class="Random"/&gt;</programlisting>
<simpara>Leaving us with this:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;Test name="Default"&gt;
    &lt;Agent ref="WinAgent" platform="windows"/&gt;
    &lt;Agent ref="LinAgent" platform="linux"/&gt;
    &lt;Agent ref="OsxAgent" platform="osx"/&gt;

    &lt;StateModel ref="TheState"/&gt;

    &lt;Publisher class="File"&gt;
        &lt;Param name="FileName" value="fuzzed.png"/&gt;
    &lt;/Publisher&gt;

    &lt;Strategy class="Random"/&gt;
&lt;/Test&gt;</programlisting>
</section>
</section>
<section xml:id="_running_the_fuzzer">
<title>Running the Fuzzer</title>
<simpara>Now, let&#8217;s actually kick off our fuzzer for real!  Every 200 or so iterations, the strategy will switch to a different sample file.</simpara>
<screen>peach png.xml</screen>
<section xml:id="_whats_next_2">
<title>What&#8217;s Next?</title>
<simpara>From here you will want to:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Collect additional samples files</simpara>
</listitem>
<listitem>
<simpara>Run minset on the sample files to remove any files that cause duplicate code paths</simpara>
</listitem>
<listitem>
<simpara>Collect bugs!</simpara>
</listitem>
</orderedlist>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
</section>
<section xml:id="TutorialFileFuzzing">
<title>Tutorial: File Fuzzing</title>
<simpara>Welcome to the file fuzzing tutorial. In this tutorial, we are going to build a wave (.wav) file fuzzer. Wave files are based on the RIFF file format. This format is not overly complex and will show off several features of Peach. The target of this fuzzer is <link xl:href="http://www.mplayerhq.hu/">mplayer</link>, an open-source, cross-platform, command line media player.</simpara>
<orderedlist numeration="arabic">
<title>Tutorial Outline</title>
<listitem>
<simpara><link linkend="TutorialFileFuzzing_DevelopmentEnvironment">Development environment</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="TutorialFileFuzzing_CreateDataModel">Creating the data model</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="TutorialFileFuzzing_CreateStateModel">Creating the state model</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="TutorialFileFuzzing_ConfigurePublisher">Configuring a publisher</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="TutorialFileFuzzing_AgentAndMonitor">Adding an agent and monitor</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="TutorialFileFuzzing_OptimizeTesting">Optimizing test count</link></simpara>
</listitem>
</orderedlist>
<section xml:id="TutorialFileFuzzing_DevelopmentEnvironment">
<title>The Peach Development Environment</title>
<simpara>Before we start building our Peach fuzzer let&#8217;s first take a moment to talk about a normal Peach development environment.  Here is what a typical environment looks like:</simpara>
<section xml:id="_xml_editor_2">
<title>XML Editor</title>
<simpara>A good XML editor is definitely a must.  A good free XML editor for Windows is <link xl:href="http://www.microsoft.com/Express/">Microsoft Visual Studio Express</link> edition.  If you already have an XML editor that supports intelliSense via XML Schema, you&#8217;re all set.</simpara>
</section>
<section xml:id="_latest_peach_2">
<title>Latest Peach</title>
<simpara>Always stay up to date on the version of Peach you are using to get the latest bug fixes.</simpara>
</section>
<section xml:id="_debugger_and_support_tools_2">
<title>Debugger and support tools</title>
<simpara>There are several support tools that make things work a lot nicer.</simpara>
<itemizedlist>
<listitem>
<simpara>On Windows, download the Microsoft Debugging Tools for Windows.</simpara>
</listitem>
<listitem>
<simpara>On OS X, download CrashWrangler.</simpara>
</listitem>
</itemizedlist>
<simpara>Both of these tools are covered in the installation chapter.</simpara>
</section>
</section>
<section xml:id="TutorialFileFuzzing_CreateDataModel">
<title>Creating Wave Data Models</title>
<simpara>Now we are going to dive right in.
Let&#8217;s start by making a copy of <literal>template.xml</literal> (found in your Peach folder) to <literal>wav.xml</literal>.
This will hold all of the information about our WAV fuzzer.
You will also want a sample WAV file, grab <link xl:href="http://www-mmsp.ece.mcgill.ca/documents/AudioFormats/WAVE/Samples/AFsp/M1F1-int32WE-AFsp.wav">this one</link>.</simpara>
<simpara>Go ahead and load up <literal>wav.xml</literal> into your XML editor.</simpara>
<simpara>Now, you want to check out the following two specifications to get an idea for the format of WAV:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara><link xl:href="http://www.sonicspot.com/guide/wavefiles.html">Wave File Format</link></simpara>
</listitem>
<listitem>
<simpara>RIFF File Specification (Microsoft)</simpara>
</listitem>
</orderedlist>
<simpara>If you glance through the wave file format, notice that the wave file is composed of a file header followed by a number of chunks.
This is fairly common for file formats and also for network packets.
Typically, each chunk has the same format that follows some form of T-L-V or Type-Length-Value. In fact, wave file chunks are just that, a type followed by length followed by data.
Each chunk type will define what its data looks like.</simpara>
<simpara>Based on this basic information we can plan out our fuzzer.
We have several top level "<link linkend="DataModel">DataModel</link>" elements that will be called:</simpara>
<itemizedlist>
<listitem>
<simpara>Chunk</simpara>
</listitem>
<listitem>
<simpara>ChunkFmt</simpara>
</listitem>
<listitem>
<simpara>ChunkData</simpara>
</listitem>
<listitem>
<simpara>ChunkFact</simpara>
</listitem>
<listitem>
<simpara>ChunkCue</simpara>
</listitem>
<listitem>
<simpara>ChunkPlst</simpara>
</listitem>
<listitem>
<simpara>ChunkList</simpara>
</listitem>
<listitem>
<simpara>ChunkLabl</simpara>
</listitem>
<listitem>
<simpara>ChunkLtxt</simpara>
</listitem>
<listitem>
<simpara>ChunkNote</simpara>
</listitem>
<listitem>
<simpara>ChunkSmpl</simpara>
</listitem>
<listitem>
<simpara>ChunkInst</simpara>
</listitem>
<listitem>
<simpara>Wav</simpara>
</listitem>
</itemizedlist>
<simpara>The <link linkend="DataModel">DataModel</link> called <emphasis>Chunk</emphasis> will be a template for each of the following types of
chunks and we will pull all of it together, and also define our header in the last
<link linkend="DataModel">DataModel</link> called <emphasis>Wav</emphasis>.</simpara>
<section xml:id="_setting_defaults_for_number_element">
<title>Setting Defaults for Number element</title>
<simpara>The majority of numbers used in WAV are unsigned.
We can make that the default by adding this XML to our PIT:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;Defaults&gt;
    &lt;Number signed="false" /&gt;
&lt;/Defaults&gt;</programlisting>
</section>
<section xml:id="_creating_the_wav_datamodel">
<title>Creating the Wav DataModel</title>
<simpara>Okay, head over to your <literal>wav.xml</literal> file and let&#8217;s start writing some XML!
Locate the <link linkend="DataModel">DataModel</link> called <emphasis>TheDataModel</emphasis> is should look something like this:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;!-- TODO: Create data model --&gt;
&lt;DataModel name="TheDataModel"&gt;
&lt;/DataModel&gt;</programlisting>
<simpara>Read more about: <link linkend="DataModel">DataModel</link></simpara>
<simpara>We are going to rename this <emphasis>Wav</emphasis> and define the header for our wave file.
Looking at the specification I notice that the format for the wave header is:</simpara>
<itemizedlist>
<listitem>
<simpara>File magic: 4-character string, always "RIFF"</simpara>
</listitem>
<listitem>
<simpara>Length of file: 32-bit unsigned integer</simpara>
</listitem>
<listitem>
<simpara>Riff type: 4-character string, always "WAVE"</simpara>
</listitem>
</itemizedlist>
<simpara>We can define that in Peach using the following XML:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;!-- Defines the format of a WAV file --&gt;
&lt;DataModel name="Wav"&gt;
    &lt;!-- wave header --&gt;
    &lt;String value="RIFF" token="true" /&gt;
    &lt;Number size="32" /&gt;
    &lt;String value="WAVE" token="true"/&gt;
&lt;/DataModel&gt;</programlisting>
<simpara>Read more about: <link linkend="DataModel">DataModel</link>, <link linkend="String">String</link>, <link linkend="Number">Number</link></simpara>
<simpara>Otherwise, we can continue and define the <emphasis>Chunk</emphasis> DataModel.</simpara>
</section>
<section xml:id="_chunk_datamodel">
<title>Chunk DataModel</title>
<simpara>The <emphasis>Chunk</emphasis> data model should be the first data model in the Peach Pit file,
so let&#8217;s add it in above the <emphasis>Wav</emphasis> data model as follows:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;!-- Defines the common wave chunk --&gt;
&lt;DataModel name="Chunk"&gt;
&lt;/DataModel&gt;

&lt;!-- Defines the format of a WAV file --&gt;
&lt;DataModel name="Wav"&gt;
    &lt;!-- wave header --&gt;
    &lt;String value="RIFF" token="true" /&gt;
    &lt;Number size="32" /&gt;
    &lt;String value="WAVE" token="true"/&gt;
&lt;/DataModel&gt;</programlisting>
<simpara>Read more about: <link linkend="DataModel">DataModel</link>, <link linkend="String">String</link>, <link linkend="Number">Number</link></simpara>
<simpara>Notice that the <emphasis>Chunk</emphasis> data model occurs before the <emphasis>Wav</emphasis> data model.
This is important, we will reference this data model later and it must be defined before we use it.</simpara>
<simpara>Looking at the specification, we know that the wave chunk format is as follows:</simpara>
<itemizedlist>
<listitem>
<simpara>ID: 4-character string padded with spaces</simpara>
</listitem>
<listitem>
<simpara>Size: 4-byte unsigned integer</simpara>
</listitem>
<listitem>
<simpara>Data: bytes of data the size of Size</simpara>
</listitem>
</itemizedlist>
<simpara>We can model that in Peach using the following XML:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;!-- Defines the common wave chunk --&gt;
&lt;DataModel name="Chunk"&gt;
    &lt;String name="ID" length="4" padCharacter=" " /&gt;
    &lt;Number name="Size" size="32" &gt;
        &lt;Relation type="size" of="Data" /&gt;
    &lt;/Number&gt;
    &lt;Blob name="Data" /&gt;
    &lt;Padding alignment="16" /&gt;
&lt;/DataModel&gt;</programlisting>
<simpara>Read more about: <link linkend="DataModel">DataModel</link>, <link linkend="String">String</link>, <link linkend="Number">Number</link>, <link linkend="Relation">Relation</link>, <link linkend="Blob">Blob</link>, <link linkend="Padding">Padding</link></simpara>
<simpara>Notice that we have created a size <link linkend="Relation">relationship</link> between <emphasis>Size</emphasis> and <emphasis>Data</emphasis>.
By doing this, <emphasis>Size</emphasis> automatically updates with the size of <emphasis>Data</emphasis> when we produce data.
When we parse in a sample file to use as default values, this instructs the parser that it can
find the size of <emphasis>Data</emphasis> by looking at <emphasis>Size</emphasis>.</simpara>
<simpara>Now we can use a Padding type to pad out our DataModel correctly.
Notice that the alignment attribute is set to 16.
This tells the <link linkend="Padding">Padding</link> element to automatically size itself so that the <emphasis>Chunk</emphasis> DataModel ends
on a 16-bit (2-byte) boundary.</simpara>
</section>
<section xml:id="_format_chunk">
<title>Format Chunk</title>
<simpara>Now we are going to define the details of the format chunk.
We will use the generic chunk we already defined as a template for this chunk.
That allows us to specify only the specifics of this chunk and save some typing.</simpara>
<simpara>Looking at the wave specification, we can tell that the format chunk is as follows:</simpara>
<itemizedlist>
<listitem>
<simpara>ID: Always 'fmt '</simpara>
</listitem>
<listitem>
<simpara>Data:</simpara>
<itemizedlist>
<listitem>
<simpara>Compression code: 16-bit unsigned int</simpara>
</listitem>
<listitem>
<simpara>Number of channels: 16-bit unsigned int</simpara>
</listitem>
<listitem>
<simpara>Sample rate: 32-bit unsigned int</simpara>
</listitem>
<listitem>
<simpara>Average bytes per second: 32-bit unsigned int</simpara>
</listitem>
<listitem>
<simpara>Block align: 16-bit unsigned int</simpara>
</listitem>
<listitem>
<simpara>Significant bits per sample: 16-bit unsigned int</simpara>
</listitem>
<listitem>
<simpara>Extra format bytes: 16-bit unsigned int</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
<simpara>The <emphasis>ChunkFmt</emphasis> data model will be defined after <emphasis>Chunk</emphasis> but before <emphasis>Wav</emphasis>:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;DataModel name="ChunkFmt" ref="Chunk"&gt;
    &lt;String name="ID" value="fmt " token="true"/&gt;
    &lt;Block name="Data"&gt;
        &lt;Number name="CompressionCode" size="16" /&gt;
        &lt;Number name="NumberOfChannels" size="16" /&gt;
        &lt;Number name="SampleRate" size="32" /&gt;
        &lt;Number name="AverageBytesPerSecond" size="32" /&gt;
        &lt;Number name="BlockAlign" size="16" /&gt;
        &lt;Number name="SignificantBitsPerSample" size="16" /&gt;
        &lt;Number name="ExtraFormatBytes" size="16" /&gt;
        &lt;Blob name="ExtraData" /&gt;
    &lt;/Block&gt;
&lt;/DataModel&gt;</programlisting>
<simpara>Read more about: <link linkend="DataModel">DataModel</link>, <link linkend="Block">Block</link>, <link linkend="String">String</link>, <link linkend="Number">Number</link>, <link linkend="Blob">Blob</link></simpara>
<simpara>Now, if you look at this, notice a number of cool things.
First off, if you check out the DataModel element, you can see an attribute called <emphasis>ref</emphasis> which has a value of <emphasis>Chunk</emphasis>.
This tells Peach to copy the <emphasis>Chunk</emphasis> data model and make it the basis for our new data model called <emphasis>ChunkFmt</emphasis>.
This means that all the elements defined in <emphasis>Chunk</emphasis> are in our new <emphasis>ChunkFmt</emphasis> by default!
This is way cool and our first look at re-use in Peach.
Next, we have two elements in our data model that have the same name as elements in the <emphasis>Chunk</emphasis> model (ID and Data).
This causes the old elements to be replaced with our new ones.
This allows us to override the old elements based on the needs of our format chunk type.</simpara>
<simpara>Now, you might be asking why we needed to override ID.
This is a good question. We override ID here to specify the static string that it will always be for this format chunk.
Later, we will specify a sample wave file to use and the parser will need hints on how to select the correct chunk.
More on that later when we introduce the <link linkend="Choice">Choice</link> element :)</simpara>
<simpara>Otherwise, I think things should largely make sense.</simpara>
</section>
<section xml:id="_data_chunk">
<title>Data Chunk</title>
<simpara>Next up is the data chunk.  This one is easy because the <emphasis>Data</emphasis> portion of the packet has no structure.  We can define this chunk as follows:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;DataModel name="ChunkData" ref="Chunk"&gt;
    &lt;String name="ID" value="data" token="true"/&gt;
&lt;/DataModel&gt;</programlisting>
<simpara>Read more about: <link linkend="DataModel">DataModel</link>, <link linkend="String">String</link></simpara>
</section>
<section xml:id="_fact_chunk">
<title>Fact Chunk</title>
<simpara>Okay, now we have the fact chunk.  This chunk is defined as follows:</simpara>
<itemizedlist>
<listitem>
<simpara>ID: "fact", 4-character string</simpara>
</listitem>
<listitem>
<simpara>Data:</simpara>
<itemizedlist>
<listitem>
<simpara>Number of samples: 32-bit unsigned int</simpara>
</listitem>
<listitem>
<simpara>Unknown? Unknown trailing bytes</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
<simpara>Another easy one to define in XML:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;DataModel name="ChunkFact" ref="Chunk"&gt;
    &lt;String name="ID" value="fact" token="true"/&gt;
    &lt;Block name="Data"&gt;
        &lt;Number size="32" /&gt;
        &lt;Blob/&gt;
    &lt;/Block&gt;
&lt;/DataModel&gt;</programlisting>
<simpara>Read more about: <link linkend="DataModel">DataModel</link>, <link linkend="Block">Block</link>, <link linkend="String">String</link>, <link linkend="Number">Number</link>, <link linkend="Blob">Blob</link></simpara>
<simpara>Notice that I was lazy and decided not to name the <link linkend="Number">Number</link> or <link linkend="Blob">Blob</link> here.
Peach does not require that all elements have names, only those that are being referenced.</simpara>
</section>
<section xml:id="_wave_list_chunk">
<title>Wave List Chunk</title>
<simpara>This chunk it a bit different.
The wave list chunk is comprised of a silent chunk and data chunks, alternating in a list.
So, before we can complete the wave list chunk, we will need to define the silent chunk.
Let&#8217;s do that now.</simpara>
<simpara>The silent chunk of easy, it&#8217;s just a 4-byte unsigned integer. The data model looks like this:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;DataModel name="ChunkSint" ref="Chunk"&gt;
    &lt;String name="ID" value="sInt" token="true"/&gt;
    &lt;Block name="Data"&gt;
        &lt;Number size="32" /&gt;
    &lt;/Block&gt;
&lt;/DataModel&gt;</programlisting>
<simpara>Read more about: <link linkend="DataModel">DataModel</link>, <link linkend="Block">Block</link>, <link linkend="String">String</link>, <link linkend="Number">Number</link></simpara>
<simpara>Now that that&#8217;s out of the way, we can get on with our wave list chunk.
The data portion is an array of silent and data chunks.
Here is how we do that:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;DataModel name="ChunkWavl" ref="Chunk"&gt;
    &lt;String name="ID" value="wavl" token="true"/&gt;
    &lt;Block name="Data"&gt;
        &lt;Block name="ArrayOfChunks" maxOccurs="3000"&gt;
            &lt;Block ref="ChunkSint"/&gt;
            &lt;Block ref="ChunkData" /&gt;
        &lt;/Block&gt;
    &lt;/Block&gt;
&lt;/DataModel&gt;</programlisting>
<simpara>Read more about: <link linkend="DataModel">DataModel</link>, <link linkend="Block">Block</link>, <link linkend="String">String</link></simpara>
<simpara>This definition introduces the concept of arrays, or repeating elements.
Notice that we have a <link linkend="Block">Block</link> element that has an attribute <emphasis>maxOccurs</emphasis>.
This tells Peach that this block occurs once or more, up to 3,000 times.
Also, notice that we are using the <emphasis>ref</emphasis> attribute with the <link linkend="Block">Block</link> element.
This is just like using it with the data model, but allows us to get re-use inside of the data model as well.</simpara>
</section>
<section xml:id="_cue_chunk">
<title>Cue Chunk</title>
<simpara>Now onto the cue chunk.
This chunk should be easy now that we know about the <emphasis>maxOccurs</emphasis> attribute.
This chunk is also an array.
The array is comprised of the following:</simpara>
<itemizedlist>
<listitem>
<simpara>ID: 4 bytes</simpara>
</listitem>
<listitem>
<simpara>Position: 4-byte unsigned integer</simpara>
</listitem>
<listitem>
<simpara>Data Chunk ID: 4-byte RIFF ID</simpara>
</listitem>
<listitem>
<simpara>Chunk start: 4-byte unsigned integer offset of data chunk</simpara>
</listitem>
<listitem>
<simpara>Block start: 4-byte unsigned integer offset to sample of first channel</simpara>
</listitem>
<listitem>
<simpara>Sample offset: 4-byte unsigned integer offset to sample byte of first channel</simpara>
</listitem>
</itemizedlist>
<simpara>We don&#8217;t have to worry about the fact the last 3 numbers are offsets.  The data is already parsed in the wave list chunk, we just need to read them in.  So let&#8217;s build the XML!</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;DataModel name="ChunkCue" ref="Chunk"&gt;
    &lt;String name="ID" value="cue " token="true"/&gt;
    &lt;Block name="Data"&gt;
        &lt;Block name="ArrayOfCues" maxOccurs="3000"&gt;
            &lt;String length="4" /&gt;
            &lt;Number size="32" /&gt;
            &lt;String length="4" /&gt;
            &lt;Number size="32" /&gt;
            &lt;Number size="32" /&gt;
            &lt;Number size="32" /&gt;
        &lt;/Block&gt;
    &lt;/Block&gt;
&lt;/DataModel&gt;</programlisting>
<simpara>Read more about: <link linkend="DataModel">DataModel</link>, <link linkend="Block">Block</link>, <link linkend="String">String</link>, <link linkend="Number">Number</link></simpara>
<simpara>There shouldn&#8217;t be any surprises here, we are just re-using the same stuff as before.
Once again, I&#8217;m being a bit lazy and not giving everything a name.
This is okay, but it can be nice sometimes to use the names as documentation :)</simpara>
</section>
<section xml:id="_playlist_chunk">
<title>Playlist Chunk</title>
<simpara>Looking at this chunk, I notice that <emphasis>Data</emphasis> will be comprised of an array (again); but, this time the count will be included before the array.
We use a count-of relationship to model this.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;DataModel name="ChunkPlst" ref="Chunk"&gt;
    &lt;String name="ID" value="plst" token="true"/&gt;
    &lt;Block name="Data"&gt;
        &lt;Number name="NumberOfSegments" size="32" &gt;
            &lt;Relation type="count" of="ArrayOfSegments"/&gt;
        &lt;/Number&gt;
        &lt;Block name="ArrayOfSegments" maxOccurs="3000"&gt;
            &lt;String length="4" /&gt;
            &lt;Number size="32" /&gt;
            &lt;Number size="32" /&gt;
        &lt;/Block&gt;
    &lt;/Block&gt;
&lt;/DataModel&gt;</programlisting>
<simpara>Read more about: <link linkend="DataModel">DataModel</link>, <link linkend="Block">Block</link>, <link linkend="Number">Number</link>, <link linkend="String">String</link>, <link linkend="Relation">Relation</link></simpara>
<simpara>Notice in this XML, that we setup a relationship between <emphasis>NumberOfSegments</emphasis> and <emphasis>ArrayOfSegments</emphasis> that will indicate the count.</simpara>
</section>
<section xml:id="_associated_data_list_chunk">
<title>Associated Data List Chunk</title>
<simpara>This chunk is an array of label chunks, name chunks, and text chunks.
We will not know in what order they will appear, so we will need to support them in any order.
This is actually be fairly easy, but first we need to define each of the tree chunks before we define our data list chunk.
Let&#8217;s do that now.</simpara>
<section xml:id="_label_chunk">
<title>Label Chunk</title>
<simpara>First up is the label chunk. Its data portion contains a null-terminated string, and possibly, a single pad byte.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;DataModel name="ChunkLabl" ref="Chunk"&gt;
    &lt;String name="ID" value="labl" token="true"/&gt;
    &lt;Block name="Data"&gt;
        &lt;Number size="32" /&gt;
        &lt;String nullTerminated="true" /&gt;
    &lt;/Block&gt;
&lt;/DataModel&gt;</programlisting>
<simpara>Read more about: <link linkend="DataModel">DataModel</link>, <link linkend="Block">Block</link>, <link linkend="Number">Number</link>, <link linkend="String">String</link></simpara>
<simpara>We will automatically get the pad byte from the <emphasis>Chunk</emphasis>.</simpara>
</section>
<section xml:id="_note_chunk">
<title>Note Chunk</title>
<simpara>Now onto the note chunk. It turns out this chunk is exactly the same as the label chunk!
So, we will just create an alias for it like this:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;DataModel name="ChunkNote" ref="ChunkLabl"&gt;
    &lt;String name="ID" value="note" token="true"/&gt;
&lt;/DataModel&gt;</programlisting>
<simpara>Read more about: <link linkend="DataModel">DataModel</link>, <link linkend="String">String</link></simpara>
<simpara>Yup, that&#8217;s it!  Nice and easy :)</simpara>
</section>
<section xml:id="_labeled_text_chunk">
<title>Labeled Text Chunk</title>
<simpara>This one is also very similar to the note and label chunks but has several more numbers included in it.
I&#8217;ll copy the data model for the label chunk and expand it like this:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;DataModel name="ChunkLtxt" ref="Chunk"&gt;
    &lt;String name="ID" value="ltxt" token="true"/&gt;
    &lt;Block name="Data"&gt;
        &lt;Number size="32" /&gt;
        &lt;Number size="32" /&gt;
        &lt;Number size="32" /&gt;
        &lt;Number size="16" /&gt;
        &lt;Number size="16" /&gt;
        &lt;Number size="16" /&gt;
        &lt;Number size="16" /&gt;
        &lt;String nullTerminated="true" /&gt;
    &lt;/Block&gt;
&lt;/DataModel&gt;</programlisting>
<simpara>Read more about: <link linkend="DataModel">DataModel</link>, <link linkend="Block">Block</link>, <link linkend="Number">Number</link>, <link linkend="String">String</link></simpara>
<simpara>As we can see, it&#8217;s very similar to the label chunk.</simpara>
</section>
<section xml:id="_back_to_associated_data_list_chunk">
<title>Back to Associated Data List Chunk</title>
<simpara>Okay, we are ready to combine all the chunks into an array.
It will end up looking like this:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;DataModel name="ChunkList" ref="Chunk"&gt;
    &lt;String name="ID" value="list" token="true"/&gt;
    &lt;Block name="Data"&gt;
        &lt;String value="adtl" token="true" /&gt;
        &lt;Choice maxOccurs="3000"&gt;
            &lt;Block ref="ChunkLabl"/&gt;
            &lt;Block ref="ChunkNote"/&gt;
            &lt;Block ref="ChunkLtxt"/&gt;
            &lt;Block ref="Chunk"/&gt;
        &lt;/Choice&gt;
    &lt;/Block&gt;
&lt;/DataModel&gt;</programlisting>
<simpara>Read more about: <link linkend="DataModel">DataModel</link>, <link linkend="Block">Block</link>, <link linkend="Number">Number</link>, <link linkend="String">String</link>, <link linkend="Choice">Choice</link></simpara>
<simpara>Here we are introducing the <link linkend="Choice">Choice</link> element.
This element will try each of the <link linkend="Block">Block</link>s we specify looking for the best match.
Notice that <emphasis>Chunk</emphasis>, our catch-all, is at the end of the list.
The specification indicates that other types of blocks could show up here.</simpara>
</section>
</section>
<section xml:id="_sampler_chunk">
<title>Sampler Chunk</title>
<simpara>The sampler chunk is similar to what we have already seen. It contains several numbers and an array of some values.
We will define it as follows:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;DataModel name="ChunkSmpl" ref="Chunk"&gt;
    &lt;String name="ID" value="smpl" token="true"/&gt;
    &lt;Block name="Data"&gt;
        &lt;Number size="32" /&gt;
        &lt;Number size="32" /&gt;
        &lt;Number size="32" /&gt;
        &lt;Number size="32" /&gt;
        &lt;Number size="32" /&gt;
        &lt;Number size="32" /&gt;
        &lt;Number size="32" /&gt;
        &lt;Number size="32" /&gt;
        &lt;Number size="32" /&gt;
        &lt;Block maxOccurs="3000"&gt;
            &lt;Number size="32" /&gt;
            &lt;Number size="32" /&gt;
            &lt;Number size="32" /&gt;
            &lt;Number size="32" /&gt;
            &lt;Number size="32" /&gt;
            &lt;Number size="32" /&gt;
        &lt;/Block&gt;
    &lt;/Block&gt;
&lt;/DataModel&gt;</programlisting>
<simpara>Read more about: <link linkend="DataModel">DataModel</link>, <link linkend="Block">Block</link>, <link linkend="Number">Number</link>, <link linkend="String">String</link></simpara>
<simpara>Again, that was straight forward. :)</simpara>
</section>
<section xml:id="_instrument_chunk">
<title>Instrument Chunk</title>
<simpara>Whew! This is our last chunk to define and it&#8217;s an easy one.
It&#8217;s comprised of just seven (7) 8-bit numbers.  This will be super easy.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;DataModel name="ChunkInst" ref="Chunk"&gt;
    &lt;String name="ID" value="inst" token="true"/&gt;
    &lt;Block name="Data"&gt;
        &lt;Number size="8"/&gt;
        &lt;Number size="8"/&gt;
        &lt;Number size="8"/&gt;
        &lt;Number size="8"/&gt;
        &lt;Number size="8"/&gt;
        &lt;Number size="8"/&gt;
        &lt;Number size="8"/&gt;
    &lt;/Block&gt;
&lt;/DataModel&gt;</programlisting>
<simpara>Read more about: <link linkend="DataModel">DataModel</link>, <link linkend="Block">Block</link>, <link linkend="Number">Number</link>, <link linkend="String">String</link></simpara>
<simpara>Notice that the numbers in this case are signed.
The values they can have include both negative to positive numbers.</simpara>
</section>
</section>
<section xml:id="_finishing_the_wav_model">
<title>Finishing the Wav Model</title>
<simpara>Time to wrap this modeling up!
Let&#8217;s head down to the <emphasis>Wav</emphasis> chunk. The last time we touched, it looked like this:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;!-- Defines the format of a WAV file --&gt;
&lt;DataModel name="Wav"&gt;
    &lt;!-- wave header --&gt;
    &lt;String value="RIFF" token="true" /&gt;
    &lt;Number size="32" /&gt;
    &lt;String value="WAVE" token="true"/&gt;
&lt;/DataModel&gt;</programlisting>
<simpara>Read more about: <link linkend="DataModel">DataModel</link>, <link linkend="Number">Number</link>, <link linkend="String">String</link></simpara>
<simpara>We are going to add an array of chunks; however, we don&#8217;t know in what order all these chunks will occur. So, we will use our friend, the <link linkend="Choice">Choice</link> element, to have Peach decide  this, using the input file.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;!-- Defines the format of a WAV file --&gt;
&lt;DataModel name="Wav"&gt;
    &lt;!-- wave header --&gt;
    &lt;String value="RIFF" token="true" /&gt;
    &lt;Number size="32" /&gt;
    &lt;String value="WAVE" token="true"/&gt;

    &lt;Choice maxOccurs="30000"&gt;
        &lt;Block ref="ChunkFmt"/&gt;
        &lt;Block ref="ChunkData"/&gt;
        &lt;Block ref="ChunkFact"/&gt;
        &lt;Block ref="ChunkSint"/&gt;
        &lt;Block ref="ChunkWavl"/&gt;
        &lt;Block ref="ChunkCue"/&gt;
        &lt;Block ref="ChunkPlst"/&gt;
        &lt;Block ref="ChunkLtxt"/&gt;
        &lt;Block ref="ChunkSmpl"/&gt;
        &lt;Block ref="ChunkInst"/&gt;
        &lt;Block ref="Chunk"/&gt;
    &lt;/Choice&gt;
&lt;/DataModel&gt;</programlisting>
<simpara>Read more about: <link linkend="DataModel">DataModel</link>, <link linkend="Block">Block</link>, <link linkend="Number">Number</link>, <link linkend="String">String</link>, <link linkend="Choice">Choice</link></simpara>
<simpara>That wasn&#8217;t so hard! Was it?</simpara>
<section xml:id="_next_steps">
<title>Next Steps</title>
<simpara>All the hard work is over, but there is still stuff we need to do before we can run our fuzzer!</simpara>
</section>
</section>
<section xml:id="TutorialFileFuzzing_CreateStateModel">
<title>Create State Model</title>
<simpara>Now that you have created the data models we can create the state model.
For file fuzzing the state model is very simple.
All we want to do is write out the file and launch the target process.
We can do this using three actions:</simpara>
<itemizedlist>
<listitem>
<simpara>output&#8201;&#8212;&#8201;Write the file</simpara>
</listitem>
<listitem>
<simpara>close&#8201;&#8212;&#8201;Close the file</simpara>
</listitem>
<listitem>
<simpara>call&#8201;&#8212;&#8201;Launch the application</simpara>
</listitem>
</itemizedlist>
<simpara>Go ahead and locate the state model in the <literal>wav.xml</literal> file called <emphasis>TheState</emphasis>.
We will expand on this state model to include our three actions as follows:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;!-- This is our simple wave state model --&gt;
&lt;StateModel name="TheState" initialState="Initial"&gt;
    &lt;State name="Initial"&gt;

        &lt;!-- Write out our wave file --&gt;
        &lt;Action type="output"&gt;
            &lt;DataModel ref="Wav"/&gt;
            &lt;!-- This is our sample file to read in --&gt;
            &lt;Data fileName="sample.wav"/&gt;
        &lt;/Action&gt;

        &lt;Action type="close"/&gt;

        &lt;!-- Launch the target process --&gt;
        &lt;Action type="call" method="StartMPlayer" publisher="Peach.Agent" /&gt;
    &lt;/State&gt;
&lt;/StateModel&gt;</programlisting>
<simpara>Read more about: <link linkend="StateModel">StateModel</link>, <link linkend="State">State</link>, <link linkend="Action">Action</link>, <link linkend="DataModel">DataModel</link>, <link linkend="Data">Data</link>, <link linkend="Field">Field</link></simpara>
<simpara>Now on to configuring our Publisher!</simpara>
</section>
<section xml:id="TutorialFileFuzzing_ConfigurePublisher">
<title>Configure Publisher</title>
<simpara>The last thing we need to do before we can try out our nifty fuzzer is to configure a <link linkend="Publisher">Publisher</link>.
<link linkend="Publisher">Publisher</link>s are I_O connectors that implement the plumbing between actions like <emphasis>output</emphasis>, <emphasis>input</emphasis>, and <emphasis>call</emphasis>.
For our file fuzzer, we will use the <link linkend="Publisher">Publisher</link> called <link linkend="Publishers_File">File</link>.
This publisher allows us to write out a file and then launch a process using the <emphasis>call</emphasis> action like we setup in last section.</simpara>
<simpara>Configuring our publisher is easy, just locate the following XML near the bottom of the <literal>wav.xml</literal> file,
it is a child of <link linkend="Test">Test</link>.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;!-- TODO: Complete publisher --&gt;
&lt;Publisher /&gt;</programlisting>
<simpara>Now, this publisher takes a single parameter called <emphasis>FileName</emphasis> that contains the file name of the fuzzed file.
This should be the same as the file name we specified in the <emphasis>call</emphasis> action (<literal>fuzzed.wav</literal>).</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;Publisher class="File"&gt;
    &lt;Param name="FileName" value="fuzzed.wav"/&gt;
&lt;/Publisher&gt;</programlisting>
<section xml:id="_whats_next_3">
<title>What&#8217;s Next?</title>
<simpara>Now we need a way to detect when our target crashes and also run our target.
We will also want to collect some information like a stack trace to look at later on.
Head to the next section to learn how to configure an agent and monitor.</simpara>
</section>
</section>
<section xml:id="TutorialFileFuzzing_AgentAndMonitor">
<title>Agent and Monitor</title>
<simpara>Now we are ready to configure our agent and monitors.
Agents are special Peach processes that can run locally or remote.
These processes host one or more monitors that can perform such actions as attaching debuggers,
watching memory consumption, etc.
For this tutorial, we are going to configure Microsoft WinDbg to monitor <literal>mplayer.exe</literal> for exceptions
and other common issues.
Additionally, we will enable the HEAP debugging for the target process.</simpara>
<section xml:id="_configure_the_agent_and_monitor_2">
<title>Configure the Agent and Monitor</title>
<simpara>First lets locate the commented out <literal>&lt;Agent&gt;</literal> element in the template file, it looks something like this:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;!-- TODO: Configure agent --&gt;
&lt;Agent name="TheAgent" location="http://127.0.0.1:9000"/&gt;</programlisting>
<simpara>We are going to uncomment this section and remove the "location" attribute.
When no "location" attribute is present, Peach automatically starts a local Peach Agent.
We will configure three agents, one for Windows, one for Linux and one for OSX.
The Windows agent will be comprised of two monitors: WindowsDebugger and PageHeap.
The Linux agent will also be comprised of one monitor: Gdb.
The OSX agent will only be comprised of a single monitor: CrashWrangler.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;Agent name="WinAgent"&gt;
   &lt;Monitor class="WindowsDebugger"&gt;

        &lt;!-- The command line to run.  Notice the filename provided matched up
             to what is provided below in the Publisher configuration --&gt;
        &lt;Param name="Executable" value="c:\mplayer\mplayer.exe" /&gt;
        &lt;Param name="Arguments" value="fuzzed.wav" /&gt;

        &lt;!-- This parameter will cause the debugger to wait for an action-call in
             the state model with a method="StartMPlayer" before running
             program.
        --&gt;
        &lt;Param name="StartOnCall" value="StartMPlayer" /&gt;

        &lt;!-- This parameter will cause the monitor to terminate the process
             once the CPU usage reaches zero.
        --&gt;
        &lt;Param name="CpuKill" value="true"/&gt;

    &lt;/Monitor&gt;

    &lt;!-- Enable heap debugging on our process as well. --&gt;
    &lt;Monitor class="PageHeap"&gt;
        &lt;Param name="Executable" value="mplayer.exe"/&gt;
    &lt;/Monitor&gt;

&lt;/Agent&gt;

&lt;Agent name="LinAgent"&gt;
    &lt;!-- Register for core file notifications. --&gt;
    &lt;Monitor class="Gdb"&gt;

        &lt;!-- This is the program we're going to run inside of the debugger --&gt;
        &lt;Param name="Executable" value="mplayer"/&gt;

        &lt;!-- These are arguments to the executable we want to run --&gt;
        &lt;Param name="Arguments"  value="sample.wav"/&gt;

        &lt;!-- This parameter will cause the monitor to terminate the process
             once the CPU usage reaches zero.
        --&gt;
        &lt;Param name="CpuKill" value="true"/&gt;

    &lt;/Monitor&gt;

&lt;/Agent&gt;

&lt;Agent name="OsxAgent"&gt;
    &lt;Monitor class="CrashWrangler"&gt;
        &lt;!-- The executable to run. --&gt;
        &lt;Param name="Command" value="mplayer" /&gt;

        &lt;!-- The program arguments.  Notice the filename provided matched up
             to what is provided below in the Publisher configuration --&gt;
        &lt;Param name="Arguments" value="fuzzed.wav" /&gt;

        &lt;!-- Do not use debug malloc. --&gt;
        &lt;Param name="UseDebugMalloc" value="false" /&gt;

        &lt;!-- Treat read access violations as exploitable. --&gt;
        &lt;Param name="ExploitableReads" value="true" /&gt;

        &lt;!-- Path to Crash Wrangler Execution Handler program. --&gt;
        &lt;Param name="ExecHandler" value="/usr/local/bin/exc_handler" /&gt;

        &lt;!-- This parameter will cause the monitor to wait for an action-call in
             the state model with a method="StartMPlayer" before running
             program.
        --&gt;
        &lt;Param name="StartOnCall" value="StartMPlayer" /&gt;

    &lt;/Monitor&gt;
&lt;/Agent&gt;</programlisting>
<simpara>Read more about: <link linkend="Agent">Agent</link>, <link linkend="Monitors_WindowsDebugger">WindowsDebugger</link>, <link linkend="Monitors_PageHeap">PageHeap</link></simpara>
</section>
<section xml:id="_configure_test_2">
<title>Configure Test</title>
<simpara>Okay, now we just need to enable the agent for our test.
Head down to the <literal>&lt;Test&gt;</literal> element, specifically we are looking to uncomment this line,
and add a new parameter to the Publisher indicating an agent has been configured.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;!-- &lt;Agent ref="LocalAgent"/&gt; --&gt;</programlisting>
<simpara>Leaving us with this:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;Test name="Default"&gt;
    &lt;Agent ref="WinAgent" platform="windows"/&gt;
    &lt;Agent ref="LinAgent" platform="linux"/&gt;
    &lt;Agent ref="OsxAgent" platform="osx"/&gt;

    &lt;StateModel ref="TheState"/&gt;

    &lt;Publisher class="File"&gt;
        &lt;Param name="FileName" value="fuzzed.wav"/&gt;
    &lt;/Publisher&gt;
&lt;/Test&gt;</programlisting>
<simpara>Read more about: <link linkend="Test">Test</link></simpara>
</section>
<section xml:id="_running_the_fuzzer_2">
<title>Running the Fuzzer</title>
<simpara>Now let&#8217;s actually kick off our fuzzer for real!</simpara>
<screen>c:\wav&gt;c:\peach\peach.exe wav.xml</screen>
</section>
</section>
<section xml:id="TutorialFileFuzzing_OptimizeTesting">
<title>Optimize Testing</title>
<simpara>At this point, we could just kick off our fuzzer and grab a beer; but, we can optimize our fuzzer in a few ways to reduce the number of iterations it will perform.  For example, all of the actual PCM/WAV samples and music data is probably something that doesn&#8217;t need much fuzzing.  All that fuzzing the music data will do is create unhappy sounds.
So, let&#8217;s dial down the mutators that will run against them.</simpara>
</section>
</section>
</section>
</article>