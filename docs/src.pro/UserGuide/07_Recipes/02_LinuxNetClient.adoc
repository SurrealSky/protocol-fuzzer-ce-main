[[Recipe_LinuxNetClient]]
=== Recipe: Monitoring a Linux Network Service Client

This recipe describes the base setup needed to fuzz a client of a Linux network service.
When fuzzing a network client, Peach impersonates the network service, the other endpoint of the network connection.

The recipe is a model that you can follow closely. Or, use the model as
a starting point and augment the model for your specific situation. This recipe
consists of the following parts:

1.	The workflow for the fuzzing session
2.	The Peach components to use in configuring the fuzzing setup
This section focuses on the monitoring needs and the agents that house the monitors.
3.	Configuration settings used to fuzz a service client (`snmpget`) running this workflow

IMPORTANT: Assumptions/Givens in this recipe are that a Pit is ready to use, Peach is ready to run, and any software module needed to perform the fuzzing job is installed.

==== Workflow for the Fuzzing Session

The workflow lists the task sequence that occurs when running the fuzzing session.
The setup needed to implement the workflow follows in the next section. Start with
defining the workflow, especially if you plan to embellish the recipe.

Here is the workflow that Peach performs in fuzzing a Linux network service client:

1. Revert to a virtual machine snapshot.
2. Wait for the machine to boot up.
3. Perform fuzzing. Create and run test cases.

.. Peach launches the network client. The client initiates contact with the server and sends requests to the server.
.. Peach impersonates the server and replies to client queries. Query responses contain fuzzed data.
.. 	Perform fault detection on the client.
.. If a fault occurs, collect data surrounding the test case.
.. Revert to the VM snapshot.

4.	Loop to step three (resume fuzzing).

==== Peach Components Needed in the Fuzzing Configuration

Defining the Peach components divides in two parts: identifying the monitors to use in the configuration and identifying where to locate the specified monitors.

===== Identifying Monitors

This part of the recipe revisits each step of the workflow to identify the monitors needed to implement the configuration:

1. Revert to a snapshot of a virtual machine.
+
Peach needs to automate the test environment and remove human interaction during the fuzzing job. We place the service in a virtual machine (VM) because Peach can use a VM monitor to automatically start and reset the test environment when needed.
+
The VM snapshot is taken while the guest OS and the Peach agent are running. Using such a snapshot avoids the wait time associated with booting up the virtual machine. Also, the same snapshot is used when Peach refreshes the test environment after a fault occurs.
+
The monitor for the VM environment, xref:Monitors_Vmware[VMware] monitor, resides on the host machine.

2. Wait for the machine to boot up.
+
Peach waits for the VM snapshot to resume.

3. Perform fuzzing, checking for faults.

.. Launch the network client.
+
The Peach agent launches the client service through GDB. The client submits requests from the remote machine. The debugger and the client both reside on the remote machine.

.. Reply to the client request with fuzzed data.
+
Peach impersonates the network server and sends fuzzed replies in response to client queries.

.. Perform fault detection in the VM.
+
The GDB monitor watches the internals of the services and detects faults such as access violations and exceptions. Again, the debug monitor is located on the same machine as the service.

.. Collect data surrounding each fault as it happens.
+
When a fault occurs, the packets involved with the fault are interesting. Peach captures the packets using a network capture monitor. This monitor resides on the local machine with Peach Fuzzer.
+
Peach collects log files generated by the debugger located on the remote machine where the service resides. A monitor that saves files sends files from a specified folder on the remote system to the Peach logging repository on the local machine. The monitor to save the log files is located on the remote machine.

4. Revert to the VM snapshot.
+
This step uses the VM monitor and VM snapshot from step 1 to refresh the test environment, and the debug monitor from step 3 to start the network service in the refreshed environment. No additional monitors are needed for this step.

5. Resume fuzzing.
+
Loop to step 3.

===== Identifying Agents

Peach offers two types of agents to manage monitors and I/O publishers: local and remote.

* Local agents reside inside Peach. +
The local agent in this recipe addresses automation involving the VM and data collection
that captures network packets. The local agent houses the xref:Monitors_Vmware[VMware]
 and the xref:Monitors_NetworkCapture[NetworkCapture] monitors.
+
The VMware monitor starts a snapshot VM environment at the beginning of the fuzzing job,
as well as restarting the same VM snapshot after a fault occurs.

* Remote agents reside in separate processes on remote machines with the test targets. +
In this case, the remote agent and the Linux service reside on the same machine.
+
The remote agent houses the xref:Monitors_Gdb[Gdb] debug monitor that starts the
Linux service client at the beginning of the fuzzing job and restarts the service in the
refreshed environment after a fault. The Gdb debug monitor detects faults that occur in
the client.
+
In addition, a data collection monitor collects log files after a fault occurs in the network client. The xref:Monitors_SaveFile[Save File] monitor forwards the log files to the logging repository.

The result is that we end up with the following configuration:

image::{images}/UserGuide/Recipes/VM_Remote_Agent.png[scale="50"]

Peach is located on one machine with a local agent that houses the VM monitor and the Network capture monitor. A second agent resides on the remote machine with the service. The remote agent houses the Gdb debug monitor and the SaveFile monitor.

The local agent is simple to implement. All that's needed is to define the agent, then specify the appropriate monitors and monitor settings used with the local agent.

The remote monitor is a little more involved. Like the local agent, the remote agent needs to be defined, then specify the appropriate monitors and monitor settings used with the remote agent. Second, the remote agent needs to run on the same OS as the test target. This step can be done separately from specifying the configuration details. In this recipe, a VM snapshot is used. See xref:VM_Setup[Using Virtual Machines], for information on setting up the VM snapshot.

==== Sample Network Client Configuration

This section shows the recipe implemented for a network service client and consists of the following items:

* Setup on the Target VM Image
* Pit variables
* Peach agents
* Peach monitors
* Debug monitor "No Cpu Kill" parameter
* Configuration test

[NOTE]
=======
The configurations for the network client and the network service are very similar. Two significant differences exist:

* The network client configuration uses a client application instead of the network service.
* In the network client configuration, the test target initiates the action instead of
responding to a request. The client contacts Peach, acting as the network service, then waits for Peach to provide a response to the query. The debug monitor has additional configuration options that are set to drive this configuration.
=======


===== Setup on the Target VM Image

Perform the following task on the VM before taking a snapshot of the VM.

* Run the Peach agent from a shell with root access. +
Within the shell, navigate to the peach folder and execute the following command: +
`./peach -a tcp` +
When Peach starts the VM, the Peach agent is running in a root shell.

===== Pit Variables

The following UI display identifies data values typically needed by a network
protocol Pit. The variables and values are independent of the monitors used in
the configuration. Pit variables are unique to the Pit and might differ with those
in the example illustration.

image::{images}/UserGuide/Recipes/LinuxNetClient_PitVariables.png[scale="50"]

The Pit User Guides describe the Pit-specific variables.

Community String (Authentication):: Community string used for authentication. Peach and the network client must use the same community string. Check the server documentation for consistency of this value. If needed, change the value here to coincide with the value expected by the test target.

Source Port:: Port number of the local machine that sends packets to the server. Several services use well-known ports that usually can be left unedited.

Target IPv4 Address:: IPv4 address of the target machine (client). For information on obtaining the IPv4 address, see Retrieving Machine Information section of the Pit User Guide.

Target Port:: SNMP port number of the remote machine that sends and receives packets. Several services use well-known ports that usually can be left unedited.

Timeout:: Duration, in milliseconds, to wait for incoming data. During fuzzing, a timeout failure causes the fuzzer to skip to the next test case.

===== Agents

The following UI diagram acts as an overview, showing the Peach agents and the monitors within each agent. Peach uses the ordering within the agent to determine the order in which to load and run monitors.

image::{images}/UserGuide/Recipes/LinuxNetClient_Agents.png[scale="50"]

The local agent is defined first and lists the default information for both name and location. This definition for a local agent is typical and, otherwise, unremarkable. The NetworkCapture and Vmware monitors are independent of one another, allowing either monitor to top the list.

The remote agent, named "Remote Client Manager", has quite a different location specification. The location consists of concatenated pieces of information:

* Channel. The channel for a remote agent is `tcp`. A colon and two forward slashes separate the channel from the IPv4 address of the hardware interface.
* Target IPv4 address of the remote machine. The IPv4 address of the agent is the second component of the location.  For more information, see the Retrieving Machine Information section of the Peach Pit User Guide.

The monitor list within each agent is significant, as the monitors are launched in order from top to bottom within an agent.

===== Monitors

This recipe uses four monitors, two on the machine with Peach and two on the remote machine. The recipe shows each monitor and describes its roles: fault detection, data collection, and automation.

====== Vmware (Remote Client Manager)

The xref:Monitors_Vmware[Vmware] monitor controls setting up and starting the virtual machine.

image::{images}/UserGuide/Recipes/LinuxNetClient_Vmware.png[scale="50"]

The most significant parameters for the VMware monitor follow:

Vmx:: Identifies the full path of the virtual machine image. Peach loads the
snapshot of the VM image at the start of the fuzzing job and after a fault occurs.

Headless:: Identifies whether the VM has a window associated with it. When
developing a configuration, set this parameter to false. When the configuration is
complete, change Headless to true.

Host Type:: Specifies the VMware product used in the configuration.

Snapshot Name:: Identifies the snapshot to use for the specific image.

===== Network Capture (InterestingPackets)

The xref:Monitors_NetworkCapture[Network Capture Monitor] captures
network packets sent and received from the test target. When a fault occurs,
Peach stores the packets immediately surrounding the fault in the log of the test case.

image::{images}/UserGuide/Recipes/LinuxNetClient_NetworkCapture.png[scale="50"]

The most significant parameters for the network capture monitor follow:

Device:: Specifies the name of the interface on the local machine (the machine
with Peach) used to communicate with the test target. Use `ifconfig` to identify
the interface(s) available for use.

[NOTE]
=======
You can find the appropriate host interface that communicates with the VM using the following steps:

1. Collect a list of interfaces (and their IPv4 addresses) by running `ipconfig` or `ifconfig`.
2. Test each interface in the list. Manually run a capture session with Wireshark using an interface from the list.
3. On the host machine, Ping the target IPv4 (of the VM).
4. If the correct interface of the host is used, you'll see the Ping request and reply packet exchanges through Wireshark,
5. Loop to step 2 and repeat, using another interface.

=======

Filter:: Helps capture only those packets associated with the fuzzing session.
The filter adheres to the syntax and requirements of the Pcap filter specification.

TIP: WireShark refers to the Libpcap filters as capture filters. Use the capture
filters. Wireshark also defines its own display filters that it uses to filter entries in its session files. The display filters are not compatible with Libpcap.

===== GDB (Debugger)

The xref:Monitors_Gdb[GDB] debugger monitor performs two main functions in this recipe:

* Starts the network client at the start of a fuzzing job and restarts the client when the VM snapshot refreshes.
* Detects faults internal to the client.

The Gdb monitor uses the settings in the following illustration:

image::{images}/UserGuide/Recipes/LinuxNetClient_Gdb.png[scale="50"]

The most significant parameters follow:

Executable:: Identifies the full path to the Linux service client. The client
resides on the remote machine; so, the full path is for the Linux file system.

Arguments:: Arguments for the executable.

No Cpu Kill:: Controls whether the process stays alive if its CPU usage drops to zero. Specify `true` to keep the process running and to allow the process to release or close its resources before exiting. For more information, see the following section _Closing the Client Process_.

Start On Call:: Controls when the test target launches, and in turn, initiates contact with the service (Peach). Specify `StartIterationEvent` to launch the client at the start of the test case.

===== SaveFile (CollectLogs)

The xref:Monitors_SaveFile[SaveFile] monitor collects log files from the remote
test target and copies them to the Peach Logging folder. The monitor is housed by
the remote agent.

image::{images}/UserGuide/Recipes/LinuxNetClient_SaveFile.png[scale="50"]

The most significant parameter follows:

Filename:: Specifies the full path to the Linux logging system used by GDB.

==== Closing the Client Process

In this recipe, the Peach debug monitor launches the network service client using the "Start On Call" parameter so that the client initiates contact with the server. Then, at the end of the test case after execution complete, the "No Cpu Kill" parameter provides control of how the client closes:

* If "No Cpu Kill" is `true`, Peach waits for the process to exit OR for a time to elapse specified by the "Wait For Exit Timeout" parameter.
* If "No Cpu Kill" is `false`, Peach waits for the CPU usage of the process to reach zero percent OR for the process to exit OR for a time to elapse specified by the "Wait For Exit Timeout" parameter. The "No Cpu Kill" parameter default setting is `false`.

NOTE: If the waiting period ends, peach kills the target process if it is still running and starts the next iteration.

So, when do you need to let a process with zero CPU activity continue to execute?

Set “No Cpu Kill” to `true` when you're fuzzing a network service client. In this scenario, Peach Fuzzer starts the network client using the “Start on Call” parameter to initiate contact with the service. When the client receives and processes the reply, Peach waits for the client to run to completion and watches for any faults that occur before the client exits.

Scenarios exempt from the "No Cpu Kill" option include the following:

* Fuzzing network service servers typically do not use the “Start On Call” option, so the “No Cpu Kill” option isn't needed.
* Fuzzing file formats require “Start on Call” to start the fuzzing target once the fuzzed data file is generated. The “No Cpu Kill” parameter can be used here; however, Peach can save time that will be replicated in each test case by letting the process terminate if the CPU usage falls to zero. In this case, not using “No Cpu Kill” is a performance optimization.
* Embedded devices. Fuzzing configurations for these devices do not use the Peach debugging monitors: GDB, WindowsDebugger, or CrashWrangler. So, the “No Cpu Kill” option isn't needed.
* Kernel-mode debugging. Kernel-mode debugging has its own set of requirements. “No Cpu Kill” is not used here.

===== Configuration Test

Once the monitors and associated parameters are part of the configuration, you can test the configuration. From the Configuration menu along the left edge of the window, click on `Test` to run a single iteration (test case) on the configuration. Note that the test checks the connections and communications. It does NOT do any fuzzing.

For more information on testing a configuration, see xref:Test_PitConfiguration[Test Pit Configuration].
