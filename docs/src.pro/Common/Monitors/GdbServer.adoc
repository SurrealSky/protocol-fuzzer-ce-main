<<<
[[Monitors_GdbServer]]
== GdbServer Monitor (Linux, OS X)

*Monitor Categories*: *Automation*, *Data collection*, *Fault detection*

The _GdbServer_ monitor uses GDB to access a remote debugger that implements the gdb server protocol. This can be +gdbserver+ or any other implementation.
This monitor also supportes the multi mode of the extended +gdbserver+ protocol via the _RemoteExecutable_ parameter.

When a configured signal/exception is handled,
_GdbServer_ collects and logs information about the crash including frame information, registers and backtrace.

_GdbServer_ supports bucketing of crashes and basic risk ranking that is based on the exploitability of the fault. Bucketing uses categories for major and minor issues.
The exploitability evaluation is similar to the !exploitable debugging extension for .NET.

For normal GDB support see the xref:Monitors_Gdb[Gdb] monitor.

NOTE: The _GdbServer_ monitor requires a recent version of GDB.

=== Parameters

_Required:_

Target::
+
GDB target command arguments. 
Example: +remote 192.168.1.2:6000+.
+
When possible use the extended-remote version: +extended-remote IP:PORT+.

LocalExecutable::
Local copy of executable remote target is running.

_Optional:_

RemoteExecutable::
Enables multi-process capabilities in the extended gdb server protocol. Provides the remote executable name to load and run. This is the remote exec file-name.

FaultOnEarlyExit::
Trigger a fault if the process exits prematurely, defaults to `false`.

GdbPath::
Path to `gdb`, defaults to `/usr/bin/gdb`.

HandleSignals::
+
Signals to consider faults.
Space separated list of signals/exceptions to handle as fautls. 
Defaults to: SIGSEGV SIGFPE SIGABRT SIGILL SIGPIPE SIGBUS SIGSYS SIGXCPU SIGXFSZ EXC_BAD_ACCESS EXC_BAD_INSTRUCTION EXC_ARITHMETIC

NoCpuKill::
Disable process killing when the CPU usage nears zero, defaults to `false`.

RestartAfterFault::
If `true`, restarts the debugger when any monitor detects a fault.
If `false`, restarts the debugger only if the process exits or crashes.
This argument defaults to `true`.

RestartOnEachTest::
Restarts the process for each iteration, defaults to `false`.

Script::
+
Script file used to drive GDB and perform crash analysis.
This script sets up GDB to run the target application, report back information such as child pid, and handle any signals.
This script also performs crash anlysis and bucketing.
An example script is provided in the examples section.
+
The script is a Mushtache style template with the following available parameters:
+
exploitableScript;; Default crash analysis and bucketing script
faultOnEarlyExit;; Maps to the FaultOnEarlyExit parameter
gdbLog;; Log file used to record information that will be logged with any fault
gdbCmd;; This script file after being processed by Mushtache
gdbPath;; Maps to the GdbPath parameter
gdbPid;; Pid file generated by script at start of executable
gdbTempDir;; Temporary directory to hold generated data
handleSignals;; Maps to the HandleSignals parameter
localExecutable;; Maps to the LocalExecutableParameter
noCpuKill;; Maps to the NoCpuKill parameter
remoteExecutable;; Maps to the RemoteExecutable parameter
restartOnEachTest;; Maps to the RestartOnEachTest parameter
restartAfterFault;; Maps to the RestartAfterFault parameter
startOnCall;; Maps to the StartOnCall parameter
target;; Maps to the Target parameter
waitForExitOnCall;; Maps to the WaitForExitOnCall parameter
waitFOrExitTimeout;; Maps to the WaitForExitTimeout parameter

StartOnCall::
Start the executable on a state model call.

WaitForExitOnCall::
Wait for the process to exit on a state model call and fault if a timeout is reached.

WaitForExitTimeout::
WaitForExitOnCall timeout value, expressed in milliseconds. `-1` is infinite, defaults to `10000`.

=== Gdb Installation

Installing `gdb` on Linux consists of using the package manager to download and install the `gdb` debugger and the needed support files and libraries.

* For Ubuntu systems, run the following command install `gdb`:
+
----
sudo apt-get install gdb
----

* For CentOS and RedHat Enterprise Linux installations, run the following command to install `gdb`:
+
----
sudo yum install gdb
----

* For SUSE Enterprise Linux installations, run the following command to install `gdb`:
+
----
sudo zypper install gdb
----

You can also install `gdb` on OS X using a package manager. See the http://ntraft.com/installing-gdb-on-os-x-mavericks/[Installing GDB on OS X Mavericks] article for more information.

=== Examples

.Script Example
====================

This is an example +Script+ for driving GDB.

The _GdbServer_ monitor expects specific output that the included exploit analysis to generate the fault title, risk and bucket hashes.

The following regular expressions are used to extract information from log.  If replacing the crash analysis portion of the script make sure to output to allow the first three regexes to pass.

  "^Hash: (\w+)\.(\w+)$"  -- Major and Minor bucket
  "^Exploitability Classification: (.*)$" -- Risk
  "^Short description: (.*)$" -- Title
  "^Other tags: (.*)$" -- If found, added to Title

Script:
----
define log_if_crash
 if ($_thread != 0x00)
  printf "Crash detected, running exploitable.\n"
  set logging overwrite on
  set logging redirect on
  set logging on {{gdbLog}}                 <2>
  exploitable -v                            <4>
  printf "\n--- Info Frame ---\n\n"
  info frame
  printf "\n--- Info Registers ---\n\n"
  info registers
  printf "\n--- Backtrace ---\n\n"
  thread apply all bt full
  set logging off
 end
end

handle all nostop noprint
handle {{handleSignals}} stop print

file {{executable}}
source {{exploitableScript}}

python

import sys

def on_start(evt):
    import tempfile, os
    h,tmp = tempfile.mkstemp()
    os.close(h)
    with open(tmp, 'w') as f:
        f.write(str(gdb.inferiors()[0].pid))
    os.renames(tmp, '{{gdbPid}}')           <1>
    gdb.events.cont.disconnect(on_start)

gdb.events.cont.connect(on_start)

print("starting inferior: '{{target}} {{remoteExecutable}}'")

try:
  if len('{{remoteExecutable}}') > 1:
    print('starting in extended-remote, multi-process mode')
    gdb.execute('set remote exec-file {{remoteExecutable}}')
    gdb.execute('target {{target}}')
    gdb.execute('run')
  else:
    gdb.execute('target {{target}}')
    gdb.execute('continue')
	
except:
  e = sys.exc_info()[1]
  print('Exception starting target: ' + str(e))
  import tempfile, os
  h,tmp = tempfile.mkstemp()
  os.close(h)
  with open(tmp, 'w') as f:
    f.write(str(e))
  os.renames(tmp, '{{gdbConnectError}}')  <3>
  gdb.execute('quit')

end

log_if_crash
quit
----
<1> Must generate _gdbPid_ when target has been started
<2> Must generate _gdbLog_ when a fault has been handled
<3> On remote connection error, output the error message to _gdbConnectError_
<4> Generates output compatable with regexes
====================

/////////
ifdef::peachug[]

.Base Usage Example+
====================

This parameter example is from a typical setup where a state model call triggers launching of the executable.

[cols="2,4" options="header",halign="center"]
|==========================================================
|Parameter    |Value
|Executable   |`/usr/bin/curl`
|Arguments    |`http://localhost`
|StartOnCall  |`ScoobySnacks`
|==========================================================
====================

endif::peachug[]

ifndef::peachug[]

.Basic Usage Example
======================
[source,xml]
----
include::Gdb_Example.xml[]
----
======================

endif::peachug[]
/////////


